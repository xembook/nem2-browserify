<!doctype html>
<html lang="ja">
<head>
    <meta charset="utf-8">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jasmine/3.3.0/jasmine.min.css">
</head>
<body>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jasmine/3.3.0/jasmine.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jasmine/3.3.0/jasmine-html.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jasmine/3.3.0/boot.min.js"></script>
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://xembook.github.io/nem2-browserify/symbol-sdk-0.23.1.js"></script>
<script>

jasmine.DEFAULT_TIMEOUT_INTERVAL = 60000;
describe('symbol-sdk.0.23.1',() => {

	let networkType;
	let minFeeMultiplier;
	let medianFeeMultiplier;
	let clog;
	let  createCompleteAggregateTx;
	let  createTx;
	let getRandMessage;
	let getSinedTx;
	let bob;

	beforeEach(()=>{
		bob = nem.Account.generateNewAccount(networkType);
	});

	beforeAll(async()=>{
		NODE = "https://sym-test-01.opening-line.jp:3001";
		nem = require("/node_modules/symbol-sdk");

		repo = new nem.RepositoryFactoryHttp(NODE);
		nsRepo = repo.createNamespaceRepository();
		txRepo = repo.createTransactionRepository();
		nwRepo = repo.createNetworkRepository();
		blockRepo = repo.createBlockRepository();
		receiptRepo = repo.createReceiptRepository();
		accountRepo = repo.createAccountRepository();
		nodeRepo = repo.createNodeRepository();
		tsRepo = repo.createTransactionStatusRepository();
		chainRepo = repo.createChainRepository();
		finRepo = repo.createFinalizationRepository();
		hlRepo = repo.createHashLockRepository();
		metaRepo = repo.createMetadataRepository();
		mosaicRepo = repo.createMosaicRepository();
		msigRepo = repo.createMultisigRepository();
		resAccountRepo = repo.createRestrictionAccountRepository();
		resMosaicRepo = repo.createRestrictionMosaicRepository();
		slRepo = repo.createSecretLockRepository();

		transactionService = new nem.TransactionService(txRepo, receiptRepo);
		stateProofService = new nem.StateProofService(repo);
		metaService = new nem.MetadataTransactionService(metaRepo);
		mosaicResService = new nem.MosaicRestrictionTransactionService(resMosaicRepo,nsRepo)

		//listener
		wsEndpoint = NODE.replace('http', 'ws') + "/ws";
		listener = new nem.Listener(wsEndpoint,nsRepo,WebSocket);
		listener.open();

		//parameter
		epochAdjustment = await repo.getEpochAdjustment().toPromise();
		generationHash = await repo.getGenerationHash().toPromise();
		networkType = await repo.getNetworkType().toPromise();
		transactionFees = await nwRepo.getTransactionFees().toPromise();
		medianFeeMultiplier = transactionFees.medianFeeMultiplier;
		minFeeMultiplier = transactionFees.minFeeMultiplier;

		console.log(medianFeeMultiplier);
		console.log(minFeeMultiplier);
		networkCurrency = (await repo.getCurrencies().toPromise()).currency;

		alice = nem.Account.createFromPrivateKey("803F16C54119EA888C2E7DDB1F5B9672ED93D44801D08DE68374A1125625B486",networkType);

		clog = function(signedTx){
		    console.log(NODE + "/transactionStatus/" + signedTx.hash);
		    console.log(NODE + "/transactions/confirmed/" + signedTx.hash);
		    console.log("http://explorer.testnet.symboldev.network/transactions/" + signedTx.hash);
		}

		createTx = function(publicAccount,amount){
			return nem.TransferTransaction.create(
				nem.Deadline.create(epochAdjustment),
				publicAccount.address,
				[networkCurrency.createRelative(amount)],
				nem.PlainMessage.create(""),
				networkType
			);
		}

		createAggregateTx = function(alice,aliceAmount,bob,bobAmount){

			const aggregateArray =
			[createTx(bob.publicAccount,aliceAmount).toAggregate(alice.publicAccount)]
			.concat([createTx(alice.publicAccount,bobAmount).toAggregate(bob.publicAccount)]);

			return nem.AggregateTransaction.createComplete(
			  nem.Deadline.create(epochAdjustment),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(minFeeMultiplier,1);
		}

		getSignedTx = function(aggregateArray,cosigners){
			return nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),
				aggregateArray,
				networkType,[]
			)
			.setMaxFeeForAggregate(medianFeeMultiplier + minFeeMultiplier + 100,cosigners.length)
			.signTransactionWithCosignatories(alice,cosigners,generationHash);
		}

		getRandMessage = function(N){
		  S="abcdefghijklmnopqrstuvwxyz"
		  return Array.from(Array(N)).map(()=>S[Math.floor(Math.random()*S.length)]).join('')
		}

	});

	describe('network properties', () => {

		it('resolves to epochAdjustment', async () => {
			expect(await repo.getEpochAdjustment().toPromise())
			.toBe(1573430400)
		})

		it('resolves to networkType', async () => {
			expect(await repo.getNetworkType().toPromise())
			.toBe(152)
		})

		it('resolves to generationHash', async () => {
			expect(await repo.getGenerationHash().toPromise())
			.toBe("45FBCF2F0EA36EFA7923C9BC923D6503169651F7FA4EFC46A8EAF5AE09057EBD")
		})
 	});

	describe('Transaction',() => {

		let  createCompleteAggregateTx;
		let  createTx;
		beforeAll(async()=>{

			createTx = function(publicAccount,amount){
				return nem.TransferTransaction.create(
					nem.Deadline.create(epochAdjustment),
					publicAccount.address,
					[networkCurrency.createRelative(amount)],
					nem.PlainMessage.create(""),
					networkType
				);
			}

			createAggregateTx = function(alice,aliceAmount,bob,bobAmount){

				const aggregateArray =
				[createTx(bob.publicAccount,aliceAmount).toAggregate(alice.publicAccount)]
				.concat([createTx(alice.publicAccount,bobAmount).toAggregate(bob.publicAccount)]);

				return nem.AggregateTransaction.createComplete(
		          nem.Deadline.create(epochAdjustment),aggregateArray,networkType,[]
			  	).setMaxFeeForAggregate(minFeeMultiplier,1);
			}
		})

		beforeEach(()=>{
			bob = nem.Account.generateNewAccount(networkType);
		});

		it('catches Failure_Core_Insufficient_Balance', async () => {

	        const signedTx = createAggregateTx(alice,1,bob,2)
			.signTransactionWithCosignatories(alice,[bob],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Core_Insufficient_Balance'))
		});

		it('catches Failure_Aggregate_Missing_Cosignatures', async () => {

			const signedTx = createAggregateTx(alice,2,bob,1)
	        .signTransactionWithCosignatories(alice,[],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Aggregate_Missing_Cosignatures'))
		});

		it('catches Failure_Aggregate_Redundant_Cosignatures', async () => {

			const signedTx = createAggregateTx(alice,2,bob,1)
	        .signTransactionWithCosignatories(alice,[bob,bob],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Aggregate_Redundant_Cosignatures'))
		});



		it('catches Failure_Core_Invalid_Address', async () => {

			carol = nem.Account.generateNewAccount(networkType + 1);
			const signedTx = createAggregateTx(alice,2,carol,1)
	        .signTransactionWithCosignatories(alice,[carol],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Core_Invalid_Address'));
		});

		it('catches Failure_Core_Future_Deadline', async () => {

			const aggregateArray =
			[createTx(bob.publicAccount,2).toAggregate(alice.publicAccount)]
			.concat([createTx(alice.publicAccount,1).toAggregate(bob.publicAccount)]);

			const aggregateTx = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(0),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(minFeeMultiplier,1);

			const signedTx = aggregateTx.signTransactionWithCosignatories(alice,[bob],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Core_Future_Deadline'))
		});

		it('catches Failure_Core_Past_Deadline', async () => {

			const aggregateArray =
			[createTx(bob.publicAccount,2).toAggregate(alice.publicAccount)]
			.concat([createTx(alice.publicAccount,1).toAggregate(bob.publicAccount)]);

			const aggregateTx = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment + 7200),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(minFeeMultiplier,1);

			const signedTx = aggregateTx.signTransactionWithCosignatories(alice,[bob],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Core_Past_Deadline'))
		});


		it('catches Failure_Core_Wrong_Network', async () => {

			const aggregateArray =
			[createTx(bob.publicAccount,2).toAggregate(alice.publicAccount)]
			.concat(createTx(alice.publicAccount,1).toAggregate(bob.publicAccount));

			const aggregateTx = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),aggregateArray,networkType + 1,[]
			).setMaxFeeForAggregate(minFeeMultiplier,1);

			const signedTx = aggregateTx.signTransactionWithCosignatories(alice,[bob],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Core_Wrong_Network'));
		});

		it('catches Failure_Aggregate_Too_Many_Transactions', async () => {

			let aggregateArray = Array();
			for(let i=0;i<=100;i++){
				aggregateArray.push(createTx(bob.publicAccount,0).toAggregate(alice.publicAccount));
			}

			const aggregateTx = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(minFeeMultiplier,0);

			const signedTx = aggregateTx.signTransactionWithCosignatories(alice,[],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Aggregate_Too_Many_Transactions'));
		});

		it('catches Failure_Transfer_Message_Too_Large', async () => {

			const signedTx = nem.TransferTransaction.create(
				nem.Deadline.create(epochAdjustment),
				alice.address,
				[networkCurrency.createRelative(0)],
				nem.PlainMessage.create(getRandMessage(1024)),
				networkType
			).setMaxFee(minFeeMultiplier)
			.signWith(alice,generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Transfer_Message_Too_Large'));
		});


		it('catches Failure_Aggregate_Too_Many_Cosignatures', async () => {

			carols = Array();
			carolAddresses = Array();
			for(let i=0;i<=25;i++){
				carol = nem.Account.generateNewAccount(networkType)
				carolAddresses.push(carol.address);
				carols.push(carol);

			}

			msigTx = nem.MultisigAccountModificationTransaction.create(
			    nem.Deadline.create(epochAdjustment),
			    1,1,carolAddresses,[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,2,epochAdjustment).toAggregate(alice.publicAccount)]
			.concat(msigTx.toAggregate(bob.publicAccount));

			const aggregateTx = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(medianFeeMultiplier + minFeeMultiplier,carolAddresses.length + 1);

			cosigns = [bob].concat(carols);
			const signedTx = aggregateTx.signTransactionWithCosignatories(alice,cosigns,generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Aggregate_Too_Many_Cosignatures'));
		});


 	});

	xdescribe('Multisig',() => {

		beforeAll(async()=>{
			getCarolAccounts = function(cnt){

				carols = Array();
				carolAddresses = Array();
				for(let i = 0; i <= cnt; i++){
					carol = nem.Account.generateNewAccount(networkType)
					carolAddresses.push(carol.address);
					carols.push(carol);
				}
				return {accounts:carols,addresses:carolAddresses}
			}
			getCarolAggregate = function(account,cnt){

				carols = Array();
				carolMultisigs = Array();
				for(let i = 0; i <= cnt; i++){

					carol = nem.Account.generateNewAccount(networkType)
					msigTx = nem.MultisigAccountModificationTransaction.create(
					    nem.Deadline.create(epochAdjustment),
					    1,1,[account.address],[],nem.NetworkType.TEST_NET
					);

					carols.push(carol);
					carolMultisigs.push(msigTx.toAggregate(carol.publicAccount));
				}
				return {aggTx:carolMultisigs,cosigs:carols};
			}

		})


		it('catches Failure_Multisig_Max_Cosigned_Accounts', async () => {

			carolsAggTxs = getCarolAggregate(bob,20);
			const aggregateArray =
			[createTx(bob.publicAccount,6).toAggregate(alice.publicAccount)]
			.concat(carolsAggTxs.aggTx)
			signedTx = getSignedTx(aggregateArray,[bob].concat(carolsAggTxs.cosigs));

			res = await transactionService.announce(
				signedTx
			,listener).toPromise()
			console.log(res);

			carolsAggTxs2 = getCarolAggregate(bob,20);
			const aggregateArray2 =
			[createTx(bob.publicAccount,6).toAggregate(alice.publicAccount)]
			.concat(carolsAggTxs2.aggTx)
			signedTx2 = getSignedTx(aggregateArray2,[bob].concat(carolsAggTxs2.cosigs));

			await expectAsync( transactionService.announce(signedTx2,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Max_Cosigned_Accounts'));
		});

		it('catches Failure_Multisig_Max_Cosignatories', async () => {

			dave = nem.Account.generateNewAccount(networkType);
			carols = getCarolAccounts(20);

			msigTx = nem.MultisigAccountModificationTransaction.create(
			    nem.Deadline.create(epochAdjustment),
			    1,1,[dave.address].concat(carols.addresses),[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,6).toAggregate(alice.publicAccount)]
			.concat(createTx(dave.publicAccount,3).toAggregate(alice.publicAccount))
			.concat(msigTx.toAggregate(bob.publicAccount));
			signedTx = getSignedTx(aggregateArray,[bob].concat(carols.accounts).concat(dave));
			res = await transactionService.announce(
				signedTx
			,listener).toPromise()
			console.log(res);

			carols2 = getCarolAccounts(20);
			const signedTx2 = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),
				[
					nem.MultisigAccountModificationTransaction.create(
				    nem.Deadline.create(epochAdjustment),
				    1,1,carols2.addresses,[],nem.NetworkType.TEST_NET)
					.toAggregate(bob.publicAccount)
				],
				networkType,[]
			).setMaxFeeForAggregate(minFeeMultiplier,carols2.addresses.length)
			.signTransactionWithCosignatories(dave,carols2.accounts,generationHash);

			await expectAsync( transactionService.announce(signedTx2,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Max_Cosignatories'));
		});

		it('catches Failure_Multisig_Multiple_Deletes', async () => {

			carols = getCarolAccounts(20);
			msigTx = nem.MultisigAccountModificationTransaction.create(
			    nem.Deadline.create(epochAdjustment),
			    1,1,[],carols.addresses,nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(msigTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob].concat(carols.accounts))
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Multiple_Deletes'));
		});


		it('catches Failure_Multisig_Already_A_Cosignatory', async () => {

			dave = nem.Account.generateNewAccount(networkType);
			carols = getCarolAccounts(5);

			msigTx = nem.MultisigAccountModificationTransaction.create(
			    nem.Deadline.create(epochAdjustment),
			    1,1,[dave.address].concat(carols.addresses),[],nem.NetworkType.TEST_NET
			);

			msigTx2 = nem.MultisigAccountModificationTransaction.create(
			    nem.Deadline.create(epochAdjustment),
			    1,1,carols.addresses,[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(createTx(dave.publicAccount,0).toAggregate(alice.publicAccount))
			.concat(msigTx.toAggregate(bob.publicAccount))
			.concat(msigTx2.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob].concat(carols.accounts).concat(dave))
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Already_A_Cosignatory'));
		});

		it('catches Failure_Multisig_Operation_Prohibited_By_Account', async () => {

			carols = getCarolAccounts(1);
			msigTx = nem.MultisigAccountModificationTransaction.create(
			    nem.Deadline.create(epochAdjustment),
			    1,1,carols.addresses,[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,4).toAggregate(alice.publicAccount)]
			.concat(msigTx.toAggregate(bob.publicAccount))

			res = await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob].concat(carols.accounts))
			,listener).toPromise())

			await expectAsync( transactionService.announce(
				createTx(alice.publicAccount,0,epochAdjustment)
				.setMaxFee(minFeeMultiplier).signWith(bob,generationHash)
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Operation_Prohibited_By_Account'));
		});
	});

	xdescribe('Metadata',() => {

		beforeAll(async()=>{
			getCarolAccounts = function(cnt){

				carols = Array();
				carolAddresses = Array();
				for(let i = 0; i <= cnt; i++){
					carol = nem.Account.generateNewAccount(networkType)
					carolAddresses.push(carol.address);
					carols.push(carol);
				}
				return {accounts:carols,addresses:carolAddresses}
			}
		})




		it('catches Failure_Metadata_Value_Too_Large', async () => {

			accountKey = nem.KeyGenerator.generateUInt64Key("key_account");
	        createAccountMetaTx = await metaService.createAccountMetadataTransaction(
	            nem.Deadline.create(epochAdjustment),
	            networkType,
	            bob.address,//target
	            accountKey,
	            getRandMessage(1025),
	            bob.address // sender
	        ).toPromise();

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(createAccountMetaTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Metadata_Value_Too_Large'));
		});

		it('catches Failure_Metadata_Value_Too_Large', async () => {

			randomId = getRandMessage(56).toLowerCase();
			mosaicId = new nem.NamespaceId( "mosaic__" + randomId);

			mosaicKey = nem.KeyGenerator.generateUInt64Key("key_mosaic");
	        createMosaicMetaTx = await metaService.createMosaicMetadataTransaction(
	            nem.Deadline.create(epochAdjustment),
	            networkType,
	            bob.address,
	            mosaicId,
	            mosaicKey,
	            getRandMessage(1025),
	            bob.address
	        ).toPromise();

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(createMosaicMetaTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Metadata_Value_Too_Large'));
		});

		it('catches Failure_Mosaic_Expired', async () => {

			randomId = getRandMessage(56).toLowerCase();
			mosaicId = new nem.NamespaceId( "mosaic__" + randomId);

			mosaicKey = nem.KeyGenerator.generateUInt64Key("key_mosaic");
	        createMosaicMetaTx = await metaService.createMosaicMetadataTransaction(
	            nem.Deadline.create(epochAdjustment),
	            networkType,
	            bob.address,
	            mosaicId,
	            mosaicKey,
	            getRandMessage(1024),
	            bob.address
	        ).toPromise();

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(createMosaicMetaTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Expired'));
		});

		it('catches Failure_Metadata_Value_Too_Large', async () => {

			randomId = getRandMessage(56).toLowerCase();
			accountId = new nem.NamespaceId("account_" + randomId);

			namespaceKey = nem.KeyGenerator.generateUInt64Key("key_namespace");
	        createNamespaceMetaTx = await metaService.createNamespaceMetadataTransaction(
	            nem.Deadline.create(epochAdjustment),
	            networkType,
	            bob.address,
	            accountId,
	            namespaceKey,
	            getRandMessage(1025),
	            bob.address
	        ).toPromise();

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(createNamespaceMetaTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Metadata_Value_Too_Large'));
		});

		it('catches Failure_Namespace_Unknown', async () => {

			randomId = getRandMessage(56).toLowerCase();
			accountId = new nem.NamespaceId("account_" + randomId);

			namespaceKey = nem.KeyGenerator.generateUInt64Key("key_namespace");
	        createNamespaceMetaTx = await metaService.createNamespaceMetadataTransaction(
	            nem.Deadline.create(epochAdjustment),
	            networkType,
	            bob.address,
	            accountId,
	            namespaceKey,
	            getRandMessage(1024),
	            bob.address
	        ).toPromise();

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(createNamespaceMetaTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Unknown'));


		});
	});

	xdescribe('Restriction',() => {

		beforeAll(async()=>{

			mosaicAddressResTx = function(account,mosaicId,value){

		      resKey = nem.KeyGenerator.generateUInt64Key("KYC".toLowerCase());
		      return nem.MosaicAddressRestrictionTransaction.create(
		        nem.Deadline.create(epochAdjustment),
		        mosaicId, // mosaicId
		        resKey, // restrictionKey
		        account.address, // address
		        nem.UInt64.fromUint(value), // newRestrictionValue
		        networkType,
		      );
		    }
		})



		it('catches Failure_RestrictionMosaic_Account_Unauthorized', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(true, true, true),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			//モザイク変更
			mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicDefTx.mosaicId,
				nem.MosaicSupplyChangeAction.Increase,
				nem.UInt64.fromUint(1000000),
				networkType
			);

			resKey = nem.KeyGenerator.generateUInt64Key("KYC".toLowerCase());
			creatreMosaicGlobalResTx = nem.MosaicGlobalRestrictionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicId, // mosaicId
				resKey, // restrictionKey
				nem.UInt64.fromUint(0), // previousRestrictionValue
				nem.MosaicRestrictionType.NONE, // previousRestrictionType
				nem.UInt64.fromUint(1), // newRestrictionValue
				nem.MosaicRestrictionType.EQ, // newRestrictionType
				networkType,
				undefined
			);

			distMosaicTx = function(publicAccount,mosaicId){
		      message = getRandMessage(1023);

		      return     nem.TransferTransaction.create(
		          nem.Deadline.create(epochAdjustment),
		          publicAccount.address,
		          [new nem.Mosaic(mosaicId, nem.UInt64.fromUint(1))],
		          nem.PlainMessage.create(message),
		          networkType
		        );
		    }

			const aggregateArray =
			[createTx(bob.publicAccount,100).toAggregate(alice.publicAccount)]
            .concat(mosaicDefTx.toAggregate(bob.publicAccount))
            .concat(mosaicChangeTx.toAggregate(bob.publicAccount))
            .concat(creatreMosaicGlobalResTx.toAggregate(bob.publicAccount))
			.concat(mosaicAddressResTx(bob,mosaicId,1).toAggregate(bob.publicAccount))
	        .concat(mosaicAddressResTx(carol1,mosaicId,0).toAggregate(bob.publicAccount))
			.concat(distMosaicTx(carol1.publicAccount,mosaicId).toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionMosaic_Account_Unauthorized'));
		});


		it('catches Failure_RestrictionAccount_Address_Interaction_Prohibited AllowIncomingAddress', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			addressResTx = nem.AccountRestrictionTransaction.createAddressRestrictionModificationTransaction(
		      nem.Deadline.create(epochAdjustment),
		      nem.AddressRestrictionFlag.AllowIncomingAddress,
		      [carol1.address],
		      [],
		      networkType
		    );

			const aggregateArray =
			[addressResTx.toAggregate(bob.publicAccount)]
			.concat(createTx(bob.publicAccount,1).toAggregate(alice.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionAccount_Address_Interaction_Prohibited'));
		});

		it('catches Failure_RestrictionAccount_Address_Interaction_Prohibited BlockIncomingAddress', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			addressResTx = nem.AccountRestrictionTransaction.createAddressRestrictionModificationTransaction(
		      nem.Deadline.create(epochAdjustment),
		      nem.AddressRestrictionFlag.BlockIncomingAddress,
		      [alice.address],
		      [],
		      networkType
		    );

			const aggregateArray =
			[addressResTx.toAggregate(bob.publicAccount)]
			.concat(createTx(bob.publicAccount,1).toAggregate(alice.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionAccount_Address_Interaction_Prohibited'));
		});


		it('catches Failure_RestrictionAccount_Address_Interaction_Prohibited AllowOutgoingAddress', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			addressResTx = nem.AccountRestrictionTransaction.createAddressRestrictionModificationTransaction(
		      nem.Deadline.create(epochAdjustment),
		      nem.AddressRestrictionFlag.AllowOutgoingAddress,
		      [alice.address],
		      [],
		      networkType
		    );

			const aggregateArray =
			[addressResTx.toAggregate(bob.publicAccount)]
			.concat(createTx(bob.publicAccount,2).toAggregate(alice.publicAccount))
			.concat(createTx(carol1.publicAccount,1).toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionAccount_Address_Interaction_Prohibited'));
		});

		it('catches Failure_RestrictionAccount_Address_Interaction_Prohibited BlockOutgoingAddress', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			addressResTx = nem.AccountRestrictionTransaction.createAddressRestrictionModificationTransaction(
		      nem.Deadline.create(epochAdjustment),
		      nem.AddressRestrictionFlag.BlockOutgoingAddress,
		      [alice.address],
		      [],
		      networkType
		    );

			const aggregateArray =
			[addressResTx.toAggregate(bob.publicAccount)]
			.concat(createTx(bob.publicAccount,2).toAggregate(alice.publicAccount))
			.concat(createTx(alice.publicAccount,1).toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionAccount_Address_Interaction_Prohibited'));
		});

		it('catches Failure_RestrictionAccount_Mosaic_Transfer_Prohibited AllowMosaic', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(true, true, true),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			//モザイク変更
			mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicDefTx.mosaicId,
				nem.MosaicSupplyChangeAction.Increase,
				nem.UInt64.fromUint(1000000),
				networkType
			);

			distMosaicTx = function(publicAccount,mosaicId){
		      message = getRandMessage(1023);

		      return     nem.TransferTransaction.create(
		          nem.Deadline.create(epochAdjustment),
		          publicAccount.address,
		          [new nem.Mosaic(mosaicId, nem.UInt64.fromUint(1))],
		          nem.PlainMessage.create(message),
		          networkType
		        );
		    }

			mosaicRexTx = nem.AccountRestrictionTransaction.createMosaicRestrictionModificationTransaction(
		      nem.Deadline.create(epochAdjustment),
		      nem.MosaicRestrictionFlag.AllowMosaic,
		      [mosaicDefTx.mosaicId],
		      [],
		      networkType
		    );


			const aggregateArray =
			[createTx(bob.publicAccount,50).toAggregate(alice.publicAccount)]
            .concat(mosaicDefTx.toAggregate(bob.publicAccount))
            .concat(mosaicChangeTx.toAggregate(bob.publicAccount))
			.concat(mosaicRexTx.toAggregate(bob.publicAccount))
			.concat(createTx(bob.publicAccount,1).toAggregate(alice.publicAccount))



			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionAccount_Mosaic_Transfer_Prohibited'));
		});

		it('catches Failure_RestrictionAccount_Mosaic_Transfer_Prohibited BlockMosaic', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(true, true, true),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			//モザイク変更
			mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicDefTx.mosaicId,
				nem.MosaicSupplyChangeAction.Increase,
				nem.UInt64.fromUint(1000000),
				networkType
			);

			distMosaicTx = function(publicAccount,mosaicId){
		      message = getRandMessage(1023);

		      return     nem.TransferTransaction.create(
		          nem.Deadline.create(epochAdjustment),
		          publicAccount.address,
		          [new nem.Mosaic(mosaicId, nem.UInt64.fromUint(1))],
		          nem.PlainMessage.create(message),
		          networkType
		        );
		    }

			mosaicRexTx = nem.AccountRestrictionTransaction.createMosaicRestrictionModificationTransaction(
		      nem.Deadline.create(epochAdjustment),
		      nem.MosaicRestrictionFlag.BlockMosaic,
		      [mosaicDefTx.mosaicId],
		      [],
		      networkType
		    );


			const aggregateArray =
			[createTx(bob.publicAccount,50).toAggregate(alice.publicAccount)]
            .concat(mosaicDefTx.toAggregate(bob.publicAccount))
            .concat(mosaicChangeTx.toAggregate(bob.publicAccount))
			.concat(mosaicRexTx.toAggregate(carol1.publicAccount))
			.concat(distMosaicTx(carol1.publicAccount,mosaicId).toAggregate(bob.publicAccount));



			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob,carol1])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionAccount_Mosaic_Transfer_Prohibited'));
		});







	});
	xdescribe('Namespace',() => {

		beforeEach(()=>{
			bob = nem.Account.generateNewAccount(networkType);
		});

		it('catches Failure_Namespace_Invalid_Name', async () => {

			randomId = getRandMessage(57).toLowerCase();
	        mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			accountId = new nem.NamespaceId("account_" + randomId);

			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
				nem.Deadline.create(epochAdjustment),
				mosaicId.fullName,
				nem.UInt64.fromUint(86400),
				networkType
			).setMaxFee(minFeeMultiplier);

			await expectAsync( transactionService.announce(
				namespaceTx.signWith(bob,generationHash)
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Name'));
		});

		it('catches Failure_Namespace_Invalid_Duration TOO SHORT', async () => {

			randomId = getRandMessage(56).toLowerCase();
	        mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			accountId = new nem.NamespaceId("account_" + randomId);

			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
				nem.Deadline.create(epochAdjustment),
				mosaicId.fullName,
				nem.UInt64.fromUint(86399),
				networkType
			).setMaxFee(minFeeMultiplier);

			await expectAsync( transactionService.announce(
				namespaceTx.signWith(bob,generationHash)
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Duration'));
		});

		it('catches Failure_Namespace_Invalid_Duration TOO LONG', async () => {

			randomId = getRandMessage(56).toLowerCase();
	        mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			accountId = new nem.NamespaceId("account_" + randomId);

			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
				nem.Deadline.create(epochAdjustment),
				mosaicId.fullName,
				nem.UInt64.fromUint(5256001),
				networkType
			).setMaxFee(minFeeMultiplier);

			await expectAsync( transactionService.announce(
				namespaceTx.signWith(bob,generationHash)
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Duration'));
		});

		it('catches Failure_Namespace_Invalid_Duration Reserved', async () => {

	        mosaicId = new nem.NamespaceId( "symbol");

			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
		        nem.Deadline.create(epochAdjustment),
		        mosaicId.fullName,
		        nem.UInt64.fromUint(90000),
		        networkType
		    );

			const aggregateArray =
			[createTx(bob.publicAccount,300).toAggregate(alice.publicAccount)]
			.concat(namespaceTx.toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Duration'));
		});

		it('catches Failure_Namespace_Invalid_Name parent is reserved', async () => {

			subMosaicId = new nem.NamespaceId(getRandMessage(65).toLowerCase());

	        subNamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
	          nem.Deadline.create(epochAdjustment),
	          subMosaicId.fullName,
	          "symbol",
	          networkType,
	        );

			const aggregateArray =
			[createTx(bob.publicAccount,1).toAggregate(alice.publicAccount)]
			.concat(subNamespaceTx.toAggregate(bob.publicAccount))

			signedTx = getSignedTx(aggregateArray,[bob]);
			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Name'));
		});


		it('catches Failure_Namespace_Invalid_Name SUB', async () => {

			randomId = getRandMessage(56).toLowerCase();
	        mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			subMosaicId = new nem.NamespaceId(getRandMessage(65).toLowerCase());


			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
		        nem.Deadline.create(epochAdjustment),
		        mosaicId.fullName,
		        nem.UInt64.fromUint(86400),
		        networkType
		    );

	        subNamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
	          nem.Deadline.create(epochAdjustment),
	          subMosaicId.fullName,
	          mosaicId.fullName,
	          networkType,
	        );

			const aggregateArray =
			[createTx(bob.publicAccount,1).toAggregate(alice.publicAccount)]
			.concat(namespaceTx.toAggregate(bob.publicAccount))
			.concat(subNamespaceTx.toAggregate(bob.publicAccount))

			signedTx = getSignedTx(aggregateArray,[bob]);
			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Name'));
		});


		it('catches Failure_Namespace_Owner_Conflict', async () => {

			bob2 = nem.Account.generateNewAccount(networkType);

			randomId = getRandMessage(56).toLowerCase();
	        mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
		        nem.Deadline.create(epochAdjustment),
		        mosaicId.fullName,
		        nem.UInt64.fromUint(86400),
		        networkType
		    );

			namespaceTx2 = nem.NamespaceRegistrationTransaction.createRootNamespace(
		        nem.Deadline.create(epochAdjustment),
		        mosaicId.fullName,
		        nem.UInt64.fromUint(86400),
		        networkType
		    );

			const aggregateArray =
			[createTx(bob.publicAccount,200).toAggregate(alice.publicAccount)]
			.concat(createTx(bob2.publicAccount,200).toAggregate(alice.publicAccount))
			.concat(namespaceTx.toAggregate(bob.publicAccount))
			.concat(namespaceTx2.toAggregate(bob2.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob,bob2])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Owner_Conflict'));
		});

		it('catches Failure_Namespace_Invalid_Name SUB2', async () => {

			randomId = getRandMessage(56).toLowerCase();
	        mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			subMosaicId = new nem.NamespaceId(getRandMessage(65).toLowerCase());
			sub2MosaicId = new nem.NamespaceId(getRandMessage(12).toLowerCase());


			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
		        nem.Deadline.create(epochAdjustment),
		        mosaicId.fullName,
		        nem.UInt64.fromUint(86400),
		        networkType
		    );

	        subNamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
	          nem.Deadline.create(epochAdjustment),
	          subMosaicId.fullName,
	          mosaicId,
	          networkType,
	        );

			sub2NamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
	          nem.Deadline.create(epochAdjustment),
	          sub2MosaicId.fullName,
	          subMosaicId,
	          networkType,
	        );

			const aggregateArray =
			[createTx(bob.publicAccount,200).toAggregate(alice.publicAccount)]
			.concat(namespaceTx.toAggregate(bob.publicAccount))
			.concat(subNamespaceTx.toAggregate(bob.publicAccount))
			.concat(sub2NamespaceTx.toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Name'));
		});

		it('catches Failure_Namespace_Name_Id_Mismatch', async () => {

			randomId = getRandMessage(56).toLowerCase();
	        mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			subMosaicId = new nem.NamespaceId(getRandMessage(12).toLowerCase());
			sub2MosaicId = new nem.NamespaceId(getRandMessage(12).toLowerCase());
			sub3MosaicId = new nem.NamespaceId(getRandMessage(12).toLowerCase());

			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
		        nem.Deadline.create(epochAdjustment),
		        mosaicId.fullName,
		        nem.UInt64.fromUint(86400),
		        networkType
		    );

	        subNamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
	          nem.Deadline.create(epochAdjustment),
	          subMosaicId.fullName,
	          mosaicId,
	          networkType,
	        );

			sub2NamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
	          nem.Deadline.create(epochAdjustment),
	          sub2MosaicId.fullName,
	          subMosaicId,
	          networkType,
	        );

			sub3NamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
	          nem.Deadline.create(epochAdjustment),
	          sub3MosaicId.fullName,
	          sub2MosaicId,
	          networkType,
	        );

			const aggregateArray =
			[createTx(bob.publicAccount,200).toAggregate(alice.publicAccount)]
			.concat(namespaceTx.toAggregate(bob.publicAccount))
			.concat(subNamespaceTx.toAggregate(bob.publicAccount))
			.concat(sub2NamespaceTx.toAggregate(bob.publicAccount))
			.concat(sub3NamespaceTx.toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Name_Id_Mismatch'));
		});
	});
	xdescribe('Mosaic',() => {

		it('catches Failure_Mosaic_Supply_Exceeded', async () => {

			//モザイク作成
	        nonce = nem.MosaicNonce.createRandom();
	        mosaicDefTx = nem.MosaicDefinitionTransaction.create(
	            nem.Deadline.create(epochAdjustment),
	            nonce,
	            nem.MosaicId.createFromNonce(nonce, bob.address),
	            nem.MosaicFlags.create(true, true, true),
	            0,
	            nem.UInt64.fromUint(1),
	            networkType
	        );
			//モザイク変更
	        mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
	            nem.Deadline.create(epochAdjustment),
	            mosaicDefTx.mosaicId,
	            nem.MosaicSupplyChangeAction.Increase,
	            nem.UInt64.fromUint(9000000000000001),
	            networkType
	        );





			const aggregateArray =
			[createTx(bob.publicAccount,50).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Supply_Exceeded'));
		});

		it('catches Failure_Mosaic_Id_Mismatch', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);

			//モザイク作成
	        nonce = nem.MosaicNonce.createRandom();
	        mosaicDefTx = nem.MosaicDefinitionTransaction.create(
	            nem.Deadline.create(epochAdjustment),
	            nonce,
	            nem.MosaicId.createFromNonce(nonce, carol1.address),
	            nem.MosaicFlags.create(true, true, true),
	            0,
	            nem.UInt64.fromUint(3650*24*60*2 + 1),
	            networkType
	        );

			const aggregateArray =
			[createTx(bob.publicAccount,50).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Id_Mismatch'));
		});


		it('catches Failure_Mosaic_Invalid_Duration', async () => {

			//モザイク作成
	        nonce = nem.MosaicNonce.createRandom();
	        mosaicDefTx = nem.MosaicDefinitionTransaction.create(
	            nem.Deadline.create(epochAdjustment),
	            nonce,
	            nem.MosaicId.createFromNonce(nonce, bob.address),
	            nem.MosaicFlags.create(true, true, true),
	            0,
	            nem.UInt64.fromUint(3650*24*60*2 + 1),
	            networkType
	        );

			const aggregateArray =
			[createTx(bob.publicAccount,50).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Invalid_Duration'));
		});

		it('catches Failure_Mosaic_Invalid_Divisibility', async () => {

			//モザイク作成
	        nonce = nem.MosaicNonce.createRandom();
	        mosaicDefTx = nem.MosaicDefinitionTransaction.create(
	            nem.Deadline.create(epochAdjustment),
	            nonce,
	            nem.MosaicId.createFromNonce(nonce, bob.address),
	            nem.MosaicFlags.create(true, true, true),
	            7,
	            nem.UInt64.fromUint(0),
	            networkType
	        );

			const aggregateArray =
			[createTx(bob.publicAccount,50).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Invalid_Divisibility'));
		});

		it('catches Failure_Mosaic_Required_Property_Flag_Unset', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(true, true, false),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			resKey = nem.KeyGenerator.generateUInt64Key("KYC".toLowerCase());
			creatreMosaicGlobalResTx = nem.MosaicGlobalRestrictionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicId, // mosaicId
				resKey, // restrictionKey
				nem.UInt64.fromUint(0), // previousRestrictionValue
				nem.MosaicRestrictionType.NONE, // previousRestrictionType
				nem.UInt64.fromUint(1), // newRestrictionValue
				nem.MosaicRestrictionType.EQ, // newRestrictionType
				networkType,
				undefined
			);

			const aggregateArray =
			[createTx(bob.publicAccount,100).toAggregate(alice.publicAccount)]
            .concat(mosaicDefTx.toAggregate(bob.publicAccount))
            .concat(creatreMosaicGlobalResTx.toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Required_Property_Flag_Unset'));

		});

		it('catches Failure_Mosaic_Supply_Immutable', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			distMosaicTx = function(publicAccount,mosaicId){
		      message = getRandMessage(1023);

		      return     nem.TransferTransaction.create(
		          nem.Deadline.create(epochAdjustment),
		          publicAccount.address,
		          [new nem.Mosaic(mosaicId, nem.UInt64.fromUint(1))],
		          nem.PlainMessage.create(message),
		          networkType
		        );
		    }


			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(false, true, true),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			//モザイク変更
	        mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
	            nem.Deadline.create(epochAdjustment),
	            mosaicDefTx.mosaicId,
	            nem.MosaicSupplyChangeAction.Increase,
	            nem.UInt64.fromUint(1000000),
	            networkType
	        );

			const aggregateArray =
			[createTx(bob.publicAccount,100).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx.toAggregate(bob.publicAccount))
			.concat(distMosaicTx(carol1.publicAccount,mosaicDefTx.mosaicId).toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx.toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Supply_Immutable'));

		});

		it('catches Failure_Mosaic_Non_Transferable', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			carol2 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			distMosaicTx = function(publicAccount,mosaicId){
		      message = getRandMessage(1023);

		      return     nem.TransferTransaction.create(
		          nem.Deadline.create(epochAdjustment),
		          publicAccount.address,
		          [new nem.Mosaic(mosaicId, nem.UInt64.fromUint(1))],
		          nem.PlainMessage.create(message),
		          networkType
		        );
		    }

			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(true, false, true),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			//モザイク変更
	        mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
	            nem.Deadline.create(epochAdjustment),
	            mosaicDefTx.mosaicId,
	            nem.MosaicSupplyChangeAction.Increase,
	            nem.UInt64.fromUint(1000000),
	            networkType
	        );

			const aggregateArray =
			[createTx(bob.publicAccount,100).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx.toAggregate(bob.publicAccount))
			.concat(distMosaicTx(carol1.publicAccount,mosaicDefTx.mosaicId).toAggregate(bob.publicAccount))
			.concat(distMosaicTx(carol2.publicAccount,mosaicDefTx.mosaicId).toAggregate(carol1.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob,carol1])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Non_Transferable'));

		});


	});





});//symbol-sdk
</script>

</body>
</html>
