<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">

</head>
<body>
<div class="container">

<script src="symbol-token-standards-0.5.2.js"></script>
<!-- script src="symbol-sdk-0.20.7.js"></script -->
<script>

	nem	= require("/node_modules/symbol-sdk");
	hd	= require("/node_modules/symbol-hd-wallets");
	sts	= require("/node_modules/symbol-token-standards");
	console.log(sts);



const transactionParams = new sts.TransactionParameters(
  nem.Deadline.create(),
  750000, // maxFee
)

// :warning: You should create separate backups of
// authorities and security token pass phrases.
const authKeys = hd.MnemonicPassPhrase.createRandom() // backup the resulting 24-words safely!
const tokenKeys = hd.MnemonicPassPhrase.createRandom() // backup the resulting 24-words safely!

// :warning: It is recommended to create operator
// keys offline and using a separate device.
const operators = [
  new nem.PublicAccount('PUBLIC_KEY_OPERATOR_1', 'ADDRESS_OPERATOR_1'),
  new nem.PublicAccount('PUBLIC_KEY_OPERATOR_2', 'ADDRESS_OPERATOR_2'),
  // ...
]


/*
// initialize NIP13 library
const network = new NetworkConfig(...)
const tokenAuthority = new NIP13.TokenAuthority(network, authKeys)
const securityToken = new NIP13.Token(network, tokenKeys)

// offline creation of the `CreateToken` security token contract
const metadata = new SecuritiesMetadata(
  'MIC',
  'ISIN',
  'ISO_10962',
  'Website',
  'Sector',
  'Industry',
  {
    'customKey1': 'metadata',
    // ...
  },
)
const tokenId = securityToken.create(
  'My Awesome Security Token', // security token name
  securityToken.getTarget().publicAccount, // actor
  tokenAuthority.getAuthority().publicAccount, // token authority
  operators,
  123456789, // total outstanding shares
  metadata,
  transactionParams,
)

// get the transaction URI for `CreateToken` execution
const resultURI: TransactionURI = securityToken.result

// :warning: It is recommended to sign the resulting transactions
// using a hardware wallet rather than any type of software generated
// wallets.
const transaction: AggregateTransaction = resultURI.toTransaction()
const signedTransaction: SignedTransaction = securityToken.getTarget().sign(transaction, 'networkGenerationHash')

// `signedTransaction` can now be broadcast to the Symbol network of choice.

// It is important to denote that given the **aggregate** nature of security
// token contracts, multiple parties MAY be involved in the transaction and
// it is therefor required to issue a HashLockTransaction before announcing
// the aggregate bonded transaction that represents the contract.

*/
</script>
</body>
</html>
