<!doctype html>
<html lang="ja">
<head>
		<meta charset="utf-8">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jasmine/3.3.0/jasmine.min.css">
</head>
<body>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jasmine/3.3.0/jasmine.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jasmine/3.3.0/jasmine-html.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jasmine/3.3.0/boot.min.js"></script>
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://xembook.github.io/nem2-browserify/symbol-sdk-1.0.1.js"></script>
<script>

jasmine.DEFAULT_TIMEOUT_INTERVAL =240000;
describe('symbol-sdk.1.0.1',() => {

	let networkType;
	let minFeeMultiplier;
	let medianFeeMultiplier;
	let clog;
	let createCompleteAggregateTx;
	let createTx;
	let getRandMessage;
	let getSinedTx;
	let bob;
	let getCarolAccounts;
	let getCarolAggregate;

	beforeEach(async()=>{
		await listener.open();
		bob = nem.Account.generateNewAccount(networkType);
	});

	beforeAll(async()=>{
		NODE = "https://sym-test-01.opening-line.jp:3001";
		nem = require("/node_modules/symbol-sdk");
		sha3_256 = require('/node_modules/js-sha3').sha3_256;

		repo = new nem.RepositoryFactoryHttp(NODE);
		nsRepo = repo.createNamespaceRepository();
		txRepo = repo.createTransactionRepository();
		nwRepo = repo.createNetworkRepository();
		blockRepo = repo.createBlockRepository();
		receiptRepo = repo.createReceiptRepository();
		accountRepo = repo.createAccountRepository();
		nodeRepo = repo.createNodeRepository();
		tsRepo = repo.createTransactionStatusRepository();
		chainRepo = repo.createChainRepository();
		finRepo = repo.createFinalizationRepository();
		hlRepo = repo.createHashLockRepository();
		metaRepo = repo.createMetadataRepository();
		mosaicRepo = repo.createMosaicRepository();
		msigRepo = repo.createMultisigRepository();
		resAccountRepo = repo.createRestrictionAccountRepository();
		resMosaicRepo = repo.createRestrictionMosaicRepository();
		slRepo = repo.createSecretLockRepository();

		transactionService = new nem.TransactionService(txRepo, receiptRepo);
		stateProofService = new nem.StateProofService(repo);
		metaService = new nem.MetadataTransactionService(metaRepo);
		mosaicResService = new nem.MosaicRestrictionTransactionService(resMosaicRepo,nsRepo)

		//listener
		wsEndpoint = NODE.replace('http', 'ws') + "/ws";
		listener = new nem.Listener(wsEndpoint,nsRepo,WebSocket);
		listener.open();

		//parameter
		epochAdjustment = await repo.getEpochAdjustment().toPromise();
		generationHash = await repo.getGenerationHash().toPromise();
		networkType = await repo.getNetworkType().toPromise();
		transactionFees = await nwRepo.getTransactionFees().toPromise();
		medianFeeMultiplier = transactionFees.medianFeeMultiplier;
		minFeeMultiplier = transactionFees.minFeeMultiplier;
//		feeAdjustment = minFeeMultiplier * 2 + medianFeeMultiplier * 2;
		feeAdjustment = 100;
		console.log(medianFeeMultiplier);
		console.log(minFeeMultiplier);
		networkCurrency = (await repo.getCurrencies().toPromise()).currency;

		alice = nem.Account.createFromPrivateKey("803F16C54119EA888C2E7DDB1F5B9672ED93D44801D08DE68374A1125625B486",networkType);

		clog = function(signedTx){
			console.log(NODE + "/transactionStatus/" + signedTx.hash);
			console.log(NODE + "/transactions/confirmed/" + signedTx.hash);
			console.log("http://explorer.testnet.symboldev.network/transactions/" + signedTx.hash);
		}

		createTx = function(publicAccount,amount){
			return nem.TransferTransaction.create(
				nem.Deadline.create(epochAdjustment),
				publicAccount.address,
				[networkCurrency.createRelative(amount)],
				nem.PlainMessage.create(""),
				networkType
			);
		}

		createTxByNamespace = function(publicAccount,amount){
			const mosaicId = new nem.NamespaceId('symbol.xym');
			return nem.TransferTransaction.create(
				nem.Deadline.create(epochAdjustment),
				publicAccount.address,
				[new nem.Mosaic(mosaicId, nem.UInt64.fromUint(amount * 1000000))],
				nem.PlainMessage.create(""),
				networkType
			);
		}

		createAggregateTx = function(alice,aliceAmount,bob,bobAmount){

			const aggregateArray =
			[createTx(bob.publicAccount,aliceAmount).toAggregate(alice.publicAccount)]
			.concat([createTx(alice.publicAccount,bobAmount).toAggregate(bob.publicAccount)]);

			return nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(feeAdjustment,1);
		}

		getSignedTx = function(aggregateArray,cosigners){
			compTx = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),
				aggregateArray,
				networkType,[]
			)
			.setMaxFeeForAggregate(feeAdjustment,cosigners.length)
			//console.log(compTx);
			return compTx.signTransactionWithCosignatories(alice,cosigners,generationHash);
		}

		getRandMessage = function(N){
			S="abcdefghijklmnopqrstuvwxyz"
			return Array.from(Array(N)).map(()=>S[Math.floor(Math.random()*S.length)]).join('')
		}
		getCarolAccounts = function(cnt){

			carols = Array();
			carolAddresses = Array();
			for(let i = 0; i <= cnt; i++){
				carol = nem.Account.generateNewAccount(networkType)
				carolAddresses.push(carol.address);
				carols.push(carol);
			}
			return {accounts:carols,addresses:carolAddresses}
		}
		getCarolAggregate = function(account,cnt){

			carols = Array();
			carolMultisigs = Array();
			for(let i = 0; i <= cnt; i++){

				carol = nem.Account.generateNewAccount(networkType)
				msigTx = nem.MultisigAccountModificationTransaction.create(
					nem.Deadline.create(epochAdjustment),
					1,1,[account.address],[],nem.NetworkType.TEST_NET
				);

				carols.push(carol);
				carolMultisigs.push(msigTx.toAggregate(carol.publicAccount));
			}
			return {aggTx:carolMultisigs,cosigs:carols};
		}

	});

	describe('network properties', () => {

		it('resolves to epochAdjustment', async () => {
			expect(await repo.getEpochAdjustment().toPromise())
			.toBe(1616694977)
		})

		it('resolves to networkType', async () => {
			expect(await repo.getNetworkType().toPromise())
			.toBe(152)
		})

		it('resolves to generationHash', async () => {
			expect(await repo.getGenerationHash().toPromise())
			.toBe("3B5E1FA6445653C971A50687E75E6D09FB30481055E3990C84B25E9222DC1155")
		})
	});
	describe('Lock',() => {

		it('catches Failure_LockHash_Invalid_Mosaic_Id', async () => {});
		it('catches Failure_LockHash_Hash_Already_Exists', async () => {});
		it('catches Failure_LockHash_Unknown_Hash', async () => {});
		it('catches Failure_LockHash_Inactive_Hash', async () => {});
		it('catches Failure_LockSecret_Invalid_Hash_Algorithm', async () => {});
		it('catches Failure_LockSecret_Hash_Already_Exists', async () => {});
		it('catches Failure_LockSecret_Proof_Size_Out_Of_Bounds', async () => {});
		it('catches Failure_LockSecret_Secret_Mismatch', async () => {});
		it('catches Failure_LockSecret_Unknown_Composite_Key', async () => {});
		it('catches Failure_LockSecret_Inactive_Secret', async () => {});
		it('catches Failure_LockSecret_Hash_Algorithm_Mismatch', async () => {});

		it('catches Failure_LockHash_Invalid_Mosaic_Amount', async () => {

			aggregateArray =
			[createTx(bob.publicAccount,2).toAggregate(alice.publicAccount)]
			.concat([createTx(alice.publicAccount,1).toAggregate(bob.publicAccount)]);

			aggTx = nem.AggregateTransaction.createBonded(
				nem.Deadline.create(epochAdjustment),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(feeAdjustment,1);

			signedTx = alice.sign(aggTx, generationHash);

			hashLockTx = nem.HashLockTransaction.create(
				nem.Deadline.create(epochAdjustment),
				networkCurrency.createRelative(9),
				nem.UInt64.fromUint(480),
				signedTx,
				networkType,
				nem.UInt64.fromUint(1000000)
			);

			signedLockTx = alice.sign(hashLockTx, generationHash);

			await expectAsync( transactionService.announce(signedLockTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_LockHash_Invalid_Mosaic_Amount'))
		});
		it('catches Failure_LockHash_Invalid_Duration', async () => {

			aggregateArray =
			[createTx(bob.publicAccount,2).toAggregate(alice.publicAccount)]
			.concat([createTx(alice.publicAccount,1).toAggregate(bob.publicAccount)]);

			aggTx = nem.AggregateTransaction.createBonded(
				nem.Deadline.create(epochAdjustment),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(feeAdjustment,1);

			signedTx = alice.sign(aggTx, generationHash);

			hashLockTx = nem.HashLockTransaction.create(
				nem.Deadline.create(epochAdjustment),
				networkCurrency.createRelative(10),
				nem.UInt64.fromUint(2 * 24 * 60 * 60 / 30 + 1),
				signedTx,
				networkType,
				nem.UInt64.fromUint(1000000)
			);

			signedLockTx = alice.sign(hashLockTx, generationHash);

			await expectAsync( transactionService.announce(signedLockTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_LockHash_Invalid_Duration'))
		});
		it('catches Failure_LockSecret_Invalid_Duration', async () => {

			carol = nem.Account.generateNewAccount(networkType);

			random = nem.Crypto.randomBytes(20);
		    proof = random.toString('hex'); //秘密の合言葉
		    hash = sha3_256.create();
		    secret = hash.update(random).hex().toUpperCase();//ダイジェスト

		    tx = nem.SecretLockTransaction.create(
		        nem.Deadline.create(epochAdjustment),
		        networkCurrency.createRelative(1),
		        nem.UInt64.fromUint(365 * 24 * 3600 / 30 + 1),
		        nem.LockHashAlgorithm.Op_Sha3_256,
		        secret,
		        carol.address,
		        networkType
		    );

			const aggregateArray =
			[createTx(bob.publicAccount,2).toAggregate(alice.publicAccount)]
			.concat([tx.toAggregate(bob.publicAccount)]);

			const signedTx = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(feeAdjustment,1)
			.signTransactionWithCosignatories(alice,[bob],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_LockSecret_Invalid_Duration'))
		});

	});
	describe('Transaction',() => {

		it('catches Failure_Core_Nemesis_Account_Signed_After_Nemesis_Block', async () => {});
		it('catches Failure_Core_Invalid_Version', async () => {});
		it('catches Failure_Core_Invalid_Transaction_Fee', async () => {});
		it('catches Failure_Core_Block_Harvester_Ineligible', async () => {});
		it('catches Failure_Core_Zero_Address', async () => {});
		it('catches Failure_Core_Zero_Public_Key', async () => {});
		it('catches Failure_Core_Nonzero_Internal_Padding', async () => {});
		it('catches Failure_Core_Address_Collision', async () => {});
		it('catches Failure_Core_Invalid_Link_Action', async () => {});
		it('catches Failure_Core_Link_Already_Exists', async () => {});
		it('catches Failure_Core_Inconsistent_Unlink_Data', async () => {});
		it('catches Failure_Core_Invalid_Link_Range', async () => {});
		it('catches Failure_Core_Too_Many_Links', async () => {});
		it('catches Failure_Aggregate_No_Transactions', async () => {});
		it('catches Failure_Aggregate_Transactions_Hash_Mismatch', async () => {});


		it('catches Failure_Core_Insufficient_Balance', async () => {

			const signedTx = createAggregateTx(alice,1,bob,2)
			.signTransactionWithCosignatories(alice,[bob],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Core_Insufficient_Balance'))
		});
		it('catches Failure_Aggregate_Missing_Cosignatures', async () => {

			const signedTx = createAggregateTx(alice,2,bob,1)
			.signTransactionWithCosignatories(alice,[],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Aggregate_Missing_Cosignatures'))
		});
		it('catches Failure_Aggregate_Redundant_Cosignatures', async () => {

			const signedTx = createAggregateTx(alice,2,bob,1)
			.signTransactionWithCosignatories(alice,[bob,bob],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Aggregate_Redundant_Cosignatures'))
		});
		it('catches Failure_Core_Invalid_Address', async () => {

			carol = nem.Account.generateNewAccount(networkType + 1);
			const signedTx = createAggregateTx(alice,2,carol,1)
			.signTransactionWithCosignatories(alice,[carol],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Core_Invalid_Address'));
		});
		it('catches Failure_Core_Future_Deadline', async () => {

			const aggregateArray =
			[createTx(bob.publicAccount,2).toAggregate(alice.publicAccount)]
			.concat([createTx(alice.publicAccount,1).toAggregate(bob.publicAccount)]);

			const aggregateTx = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(0),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(feeAdjustment,1);

			const signedTx = aggregateTx.signTransactionWithCosignatories(alice,[bob],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Core_Future_Deadline'))
		});
		it('catches Failure_Core_Past_Deadline', async () => {

			const aggregateArray =
			[createTx(bob.publicAccount,2).toAggregate(alice.publicAccount)]
			.concat([createTx(alice.publicAccount,1).toAggregate(bob.publicAccount)]);

			const aggregateTx = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment + 7200),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(feeAdjustment,1);

			const signedTx = aggregateTx.signTransactionWithCosignatories(alice,[bob],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Core_Past_Deadline'))
		});
		it('catches Failure_Core_Wrong_Network', async () => {

			const aggregateArray =
			[createTx(bob.publicAccount,2).toAggregate(alice.publicAccount)]
			.concat(createTx(alice.publicAccount,1).toAggregate(bob.publicAccount));

			const aggregateTx = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),aggregateArray,networkType + 1,[]
			).setMaxFeeForAggregate(feeAdjustment,1);

			const signedTx = aggregateTx.signTransactionWithCosignatories(alice,[bob],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Core_Wrong_Network'));
		});
		it('catches Failure_Aggregate_Too_Many_Transactions', async () => {

			let aggregateArray = Array();
			for(let i=0;i<=100;i++){
				aggregateArray.push(createTx(bob.publicAccount,0).toAggregate(alice.publicAccount));
			}

			const aggregateTx = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(feeAdjustment,0);

			const signedTx = aggregateTx.signTransactionWithCosignatories(alice,[],generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Aggregate_Too_Many_Transactions'));
		});

		it('catches Failure_Aggregate_Too_Many_Cosignatures', async () => {

			carols = Array();
			carolAddresses = Array();
			for(let i=0;i<=25;i++){
				carol = nem.Account.generateNewAccount(networkType)
				carolAddresses.push(carol.address);
				carols.push(carol);

			}

			msigTx = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,carolAddresses,[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,2,epochAdjustment).toAggregate(alice.publicAccount)]
			.concat(msigTx.toAggregate(bob.publicAccount));

			const aggregateTx = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(feeAdjustment,carolAddresses.length + 1);

			cosigns = [bob].concat(carols);
			const signedTx = aggregateTx.signTransactionWithCosignatories(alice,cosigns,generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Aggregate_Too_Many_Cosignatures'));
		});
		it('catches Failure_Aggregate_Ineligible_Cosignatories', async () => {

			carol = nem.Account.generateNewAccount(networkType)
			carol1 = nem.Account.generateNewAccount(networkType)

			msigTx = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,[carol.address],[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,6).toAggregate(alice.publicAccount)]
			.concat(msigTx.toAggregate(bob.publicAccount))
			signedTx = getSignedTx(aggregateArray,[bob,carol1].concat(carol));

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Aggregate_Ineligible_Cosignatories'));
		});

		it('catches Failure_Transfer_Message_Too_Large', async () => {

			const signedTx = nem.TransferTransaction.create(
				nem.Deadline.create(epochAdjustment),
				alice.address,
				[networkCurrency.createRelative(0)],
				nem.PlainMessage.create(getRandMessage(1024)),
				networkType
			).setMaxFee(feeAdjustment)
			.signWith(alice,generationHash);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Transfer_Message_Too_Large'));
		});
		it('catches Failure_Transfer_Out_Of_Order_Mosaics', async () => {

			tx = nem.TransferTransaction.create(
				nem.Deadline.create(epochAdjustment),
				bob.address,
				[
					networkCurrency.createRelative(1),
					networkCurrency.createRelative(1)
				],
				nem.PlainMessage.create(""),
				networkType
			).setMaxFee(feeAdjustment);


			const signedTx = tx.signWith(alice,generationHash);
			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Transfer_Out_Of_Order_Mosaics'))
		});

	});
	describe('Multisig',() => {


		it('catches Failure_Multisig_Redundant_Modification', async () => {});
		it('catches Failure_Multisig_Unknown_Multisig_Account', async () => {});
		it('catches Failure_Multisig_Not_A_Cosignatory', async () => {});
		it('catches Failure_Multisig_Max_Multisig_Depth', async () => {

			carol = nem.Account.generateNewAccount(networkType)
			carol1 = nem.Account.generateNewAccount(networkType)
			carol2 = nem.Account.generateNewAccount(networkType)
			carol3 = nem.Account.generateNewAccount(networkType)

			msigTx = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,[carol.address],[],networkType
			);

			msigTx1 = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,[carol1.address],[],networkType
			);

			msigTx2 = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,[carol2.address],[],networkType
			);

			msigTx3 = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,[carol3.address],[],networkType
			);

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(msigTx.toAggregate(bob.publicAccount))
			.concat(msigTx1.toAggregate(carol.publicAccount))
			.concat(msigTx2.toAggregate(carol1.publicAccount))
			.concat(msigTx3.toAggregate(carol2.publicAccount))
			signedTx = getSignedTx(aggregateArray,[bob,carol,carol1,carol2,carol3]);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Max_Multisig_Depth'));

		});

		it('catches Failure_Multisig_Min_Setting_Out_Of_Range', async () => {
			carol = nem.Account.generateNewAccount(networkType)

			msigTx = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				200,1,[carol.address],[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(msigTx.toAggregate(bob.publicAccount))
			signedTx = getSignedTx(aggregateArray,[bob,carol]);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Min_Setting_Out_Of_Range'));


		});

		it('catches Failure_Multisig_Min_Setting_Out_Of_Range minus', async () => {
			carol = nem.Account.generateNewAccount(networkType)

			msigTx = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				-1,1,[carol.address],[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(msigTx.toAggregate(bob.publicAccount))
			signedTx = getSignedTx(aggregateArray,[bob,carol]);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Min_Setting_Out_Of_Range'));


		});

		it('catches Failure_Multisig_Min_Setting_Larger_Than_Num_Cosignatories', async () => {

			carol = nem.Account.generateNewAccount(networkType)
			msigTx = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				2,1,[carol.address],[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(msigTx.toAggregate(bob.publicAccount))
			signedTx = getSignedTx(aggregateArray,[bob,carol]);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Min_Setting_Larger_Than_Num_Cosignatories'));
		});

		it('catches Failure_Multisig_Max_Cosigned_Accounts', async () => {

			carolsAggTxs = getCarolAggregate(bob,20);
			const aggregateArray =
			[createTx(bob.publicAccount,10).toAggregate(alice.publicAccount)]
			.concat(carolsAggTxs.aggTx)
			signedTx = getSignedTx(aggregateArray,[bob].concat(carolsAggTxs.cosigs));

			res = await transactionService.announce(
				signedTx
			,listener).toPromise()
			console.log(res);

			carolsAggTxs2 = getCarolAggregate(bob,20);
			const aggregateArray2 =
			[createTx(bob.publicAccount,10).toAggregate(alice.publicAccount)]
			.concat(carolsAggTxs2.aggTx)
			signedTx2 = getSignedTx(aggregateArray2,[bob].concat(carolsAggTxs2.cosigs));

			await expectAsync( transactionService.announce(signedTx2,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Max_Cosigned_Accounts'));
		});
		it('catches Failure_Multisig_Max_Cosignatories', async () => {

			dave = nem.Account.generateNewAccount(networkType);
			carols = getCarolAccounts(20);

			msigTx = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,[dave.address].concat(carols.addresses),[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,10).toAggregate(alice.publicAccount)]
			.concat(createTx(dave.publicAccount,5).toAggregate(alice.publicAccount))
			.concat(msigTx.toAggregate(bob.publicAccount));
			signedTx = getSignedTx(aggregateArray,[bob].concat(carols.accounts).concat(dave));
			res = await transactionService.announce(
				signedTx
			,listener).toPromise()
			console.log(res);

			carols2 = getCarolAccounts(20);
			const signedTx2 = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),
				[
					nem.MultisigAccountModificationTransaction.create(
					nem.Deadline.create(epochAdjustment),
					1,1,carols2.addresses,[],nem.NetworkType.TEST_NET)
					.toAggregate(bob.publicAccount)
				],
				networkType,[]
			).setMaxFeeForAggregate(feeAdjustment,carols2.addresses.length)
			.signTransactionWithCosignatories(dave,carols2.accounts,generationHash);

			await expectAsync( transactionService.announce(signedTx2,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Max_Cosignatories'));
		});
		it('catches Failure_Multisig_Multiple_Deletes', async () => {

			carols = getCarolAccounts(20);
			msigTx = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,[],carols.addresses,nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(msigTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob].concat(carols.accounts))
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Multiple_Deletes'));
		});
		it('catches Failure_Multisig_Already_A_Cosignatory', async () => {

			dave = nem.Account.generateNewAccount(networkType);
			carols = getCarolAccounts(5);

			msigTx = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,[dave.address].concat(carols.addresses),[],nem.NetworkType.TEST_NET
			);

			msigTx2 = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,carols.addresses,[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(createTx(dave.publicAccount,0).toAggregate(alice.publicAccount))
			.concat(msigTx.toAggregate(bob.publicAccount))
			.concat(msigTx2.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob].concat(carols.accounts).concat(dave))
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Already_A_Cosignatory'));
		});
		it('catches Failure_Multisig_Operation_Prohibited_By_Account', async () => {

			carols = getCarolAccounts(1);
			msigTx = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,carols.addresses,[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,4).toAggregate(alice.publicAccount)]
			.concat(msigTx.toAggregate(bob.publicAccount))
			.concat(createTx(alice.publicAccount,0).toAggregate(bob.publicAccount))

			res = await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob].concat(carols.accounts))
			,listener).toPromise())
			await expectAsync( transactionService.announce(
				createTx(alice.publicAccount,0)
				.setMaxFee(feeAdjustment).signWith(bob,generationHash)
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Operation_Prohibited_By_Account'));
		});
		it('catches Failure_Multisig_Loop', async () => {

			carol = nem.Account.generateNewAccount(networkType)
			carol1 = nem.Account.generateNewAccount(networkType)

			msigTx = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,[carol.address],[],nem.NetworkType.TEST_NET
			);

			msigTx1 = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,[carol1.address],[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,6).toAggregate(alice.publicAccount)]
			.concat(msigTx.toAggregate(carol.publicAccount))
			.concat(msigTx1.toAggregate(bob.publicAccount))
			signedTx = getSignedTx(aggregateArray,[bob,carol]);

			await listener.open();
			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Loop'));
		});
		it('catches Failure_Multisig_Account_In_Both_Sets', async () => {

			carol = nem.Account.generateNewAccount(networkType)

			msigTx = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,[carol.address],[carol.address],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(msigTx.toAggregate(carol.publicAccount))
			signedTx = getSignedTx(aggregateArray,[bob,carol]);

			await expectAsync( transactionService.announce(signedTx,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Multisig_Account_In_Both_Sets'));
		});

	});
	describe('Metadata',() => {

		it('catches Failure_Metadata_Value_Too_Small', async () => {});
		it('catches Failure_Metadata_Value_Size_Delta_Too_Large', async () => {});
		it('catches Failure_Metadata_Value_Size_Delta_Mismatch', async () => {});
		it('catches Failure_Metadata_Value_Change_Irreversible', async () => {});
		it('catches Failure_Metadata_Value_Too_Large', async () => {

			accountKey = nem.KeyGenerator.generateUInt64Key("key_account");
			createAccountMetaTx = await metaService.createAccountMetadataTransaction(
				nem.Deadline.create(epochAdjustment),
				networkType,
				bob.address,//target
				accountKey,
				getRandMessage(1025),
				bob.address // sender
			).toPromise();

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(createAccountMetaTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Metadata_Value_Too_Large'));
		});
		it('catches Failure_Metadata_Value_Too_Large', async () => {

			randomId = getRandMessage(56).toLowerCase();
			mosaicId = new nem.NamespaceId( "mosaic__" + randomId);

			mosaicKey = nem.KeyGenerator.generateUInt64Key("key_mosaic");
			createMosaicMetaTx = await metaService.createMosaicMetadataTransaction(
				nem.Deadline.create(epochAdjustment),
				networkType,
				bob.address,
				mosaicId,
				mosaicKey,
				getRandMessage(1025),
				bob.address
			).toPromise();

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(createMosaicMetaTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Metadata_Value_Too_Large'));
		});
		it('catches Failure_Metadata_Value_Too_Large', async () => {

			randomId = getRandMessage(56).toLowerCase();
			accountId = new nem.NamespaceId("account_" + randomId);

			namespaceKey = nem.KeyGenerator.generateUInt64Key("key_namespace");
			createNamespaceMetaTx = await metaService.createNamespaceMetadataTransaction(
				nem.Deadline.create(epochAdjustment),
				networkType,
				bob.address,
				accountId,
				namespaceKey,
				getRandMessage(1025),
				bob.address
			).toPromise();

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(createNamespaceMetaTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Metadata_Value_Too_Large'));
		});
	});
	describe('Restriction',() => {

		beforeAll(async()=>{

			mosaicAddressResTx = function(account,mosaicId,value){

				resKey = nem.KeyGenerator.generateUInt64Key("KYC".toLowerCase());
				return nem.MosaicAddressRestrictionTransaction.create(
					nem.Deadline.create(epochAdjustment),
					mosaicId, // mosaicId
					resKey, // restrictionKey
					account.address, // address
					nem.UInt64.fromUint(value), // newRestrictionValue
					networkType,
				);
			}
		})

		it('catches Failure_RestrictionAccount_Invalid_Restriction_Flags', async () => {});
//		it('catches Failure_RestrictionAccount_Invalid_Modification_Action', async () => {});
		it('catches Failure_RestrictionAccount_Invalid_Modification_Address', async () => {});
//		it('catches Failure_RestrictionAccount_Modification_Operation_Type_Incompatible', async () => {});
		it('catches Failure_RestrictionAccount_Redundant_Modification', async () => {});
		it('catches Failure_RestrictionAccount_Invalid_Modification', async () => {});
		it('catches Failure_RestrictionAccount_Modification_Count_Exceeded', async () => {});
		it('catches Failure_RestrictionAccount_No_Modifications', async () => {});
		it('catches Failure_RestrictionAccount_Values_Count_Exceeded', async () => {});
		it('catches Failure_RestrictionAccount_Invalid_Value', async () => {});
		it('catches Failure_RestrictionAccount_Operation_Type_Prohibited', async () => {});
		it('catches Failure_RestrictionMosaic_Invalid_Restriction_Type', async () => {});
		it('catches Failure_RestrictionMosaic_Previous_Value_Mismatch', async () => {});
		it('catches Failure_RestrictionMosaic_Previous_Value_Must_Be_Zero', async () => {});
		it('catches Failure_RestrictionMosaic_Max_Restrictions_Exceeded', async () => {});
		it('catches Failure_RestrictionMosaic_Cannot_Delete_Nonexistent_Restriction', async () => {});
		it('catches Failure_RestrictionMosaic_Unknown_Global_Restriction', async () => {});
		it('catches Failure_RestrictionMosaic_Invalid_Global_Restriction', async () => {});

		it('catches Failure_RestrictionMosaic_Account_Unauthorized', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(true, true, true),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			//モザイク変更
			mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicDefTx.mosaicId,
				nem.MosaicSupplyChangeAction.Increase,
				nem.UInt64.fromUint(1000000),
				networkType
			);

			resKey = nem.KeyGenerator.generateUInt64Key("KYC".toLowerCase());
			creatreMosaicGlobalResTx = nem.MosaicGlobalRestrictionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicId, // mosaicId
				resKey, // restrictionKey
				nem.UInt64.fromUint(0), // previousRestrictionValue
				nem.MosaicRestrictionType.NONE, // previousRestrictionType
				nem.UInt64.fromUint(1), // newRestrictionValue
				nem.MosaicRestrictionType.EQ, // newRestrictionType
				networkType,
				undefined
			);

			distMosaicTx = function(publicAccount,mosaicId){
				message = getRandMessage(1023);

				return	 nem.TransferTransaction.create(
					nem.Deadline.create(epochAdjustment),
					publicAccount.address,
					[new nem.Mosaic(mosaicId, nem.UInt64.fromUint(1))],
					nem.PlainMessage.create(message),
					networkType
				);
			}

			const aggregateArray =
			[createTx(bob.publicAccount,100).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx.toAggregate(bob.publicAccount))
			.concat(creatreMosaicGlobalResTx.toAggregate(bob.publicAccount))
			.concat(mosaicAddressResTx(bob,mosaicId,1).toAggregate(bob.publicAccount))
			.concat(mosaicAddressResTx(carol1,mosaicId,0).toAggregate(bob.publicAccount))
			.concat(distMosaicTx(carol1.publicAccount,mosaicId).toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionMosaic_Account_Unauthorized'));
		});
		it('catches Failure_RestrictionAccount_Address_Interaction_Prohibited AllowIncomingAddress', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			addressResTx = nem.AccountRestrictionTransaction.createAddressRestrictionModificationTransaction(
				nem.Deadline.create(epochAdjustment),
				nem.AddressRestrictionFlag.AllowIncomingAddress,
				[carol1.address],
				[],
				networkType
			);

			const aggregateArray =
			[addressResTx.toAggregate(bob.publicAccount)]
			.concat(createTx(bob.publicAccount,1).toAggregate(alice.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionAccount_Address_Interaction_Prohibited'));
		});
		it('catches Failure_RestrictionAccount_Address_Interaction_Prohibited BlockIncomingAddress', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			addressResTx = nem.AccountRestrictionTransaction.createAddressRestrictionModificationTransaction(
				nem.Deadline.create(epochAdjustment),
				nem.AddressRestrictionFlag.BlockIncomingAddress,
				[alice.address],
				[],
				networkType
			);

			const aggregateArray =
			[addressResTx.toAggregate(bob.publicAccount)]
			.concat(createTx(bob.publicAccount,1).toAggregate(alice.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionAccount_Address_Interaction_Prohibited'));
		});
		it('catches Failure_RestrictionAccount_Address_Interaction_Prohibited AllowOutgoingAddress', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			addressResTx = nem.AccountRestrictionTransaction.createAddressRestrictionModificationTransaction(
				nem.Deadline.create(epochAdjustment),
				nem.AddressRestrictionFlag.AllowOutgoingAddress,
				[alice.address],
				[],
				networkType
			);

			const aggregateArray =
			[addressResTx.toAggregate(bob.publicAccount)]
			.concat(createTx(bob.publicAccount,2).toAggregate(alice.publicAccount))
			.concat(createTx(carol1.publicAccount,1).toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionAccount_Address_Interaction_Prohibited'));
		});
		it('catches Failure_RestrictionAccount_Address_Interaction_Prohibited BlockOutgoingAddress', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			addressResTx = nem.AccountRestrictionTransaction.createAddressRestrictionModificationTransaction(
				nem.Deadline.create(epochAdjustment),
				nem.AddressRestrictionFlag.BlockOutgoingAddress,
				[alice.address],
				[],
				networkType
			);

			const aggregateArray =
			[addressResTx.toAggregate(bob.publicAccount)]
			.concat(createTx(bob.publicAccount,2).toAggregate(alice.publicAccount))
			.concat(createTx(alice.publicAccount,1).toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionAccount_Address_Interaction_Prohibited'));
		});
		it('catches Failure_RestrictionAccount_Mosaic_Transfer_Prohibited AllowMosaic', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(true, true, true),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			//モザイク変更
			mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicDefTx.mosaicId,
				nem.MosaicSupplyChangeAction.Increase,
				nem.UInt64.fromUint(1000000),
				networkType
			);

			distMosaicTx = function(publicAccount,mosaicId){
				message = getRandMessage(1023);

				return	 nem.TransferTransaction.create(
					nem.Deadline.create(epochAdjustment),
					publicAccount.address,
					[new nem.Mosaic(mosaicId, nem.UInt64.fromUint(1))],
					nem.PlainMessage.create(message),
					networkType
				);
			}

			mosaicRexTx = nem.AccountRestrictionTransaction.createMosaicRestrictionModificationTransaction(
				nem.Deadline.create(epochAdjustment),
				nem.MosaicRestrictionFlag.AllowMosaic,
				[mosaicDefTx.mosaicId],
				[],
				networkType
			);


			const aggregateArray =
			[createTx(bob.publicAccount,50).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx.toAggregate(bob.publicAccount))
			.concat(mosaicRexTx.toAggregate(bob.publicAccount))
			.concat(createTx(bob.publicAccount,1).toAggregate(alice.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionAccount_Mosaic_Transfer_Prohibited'));
		});
		it('catches Failure_RestrictionAccount_Mosaic_Transfer_Prohibited BlockMosaic', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(true, true, true),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			//モザイク変更
			mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicDefTx.mosaicId,
				nem.MosaicSupplyChangeAction.Increase,
				nem.UInt64.fromUint(1000000),
				networkType
			);

			distMosaicTx = function(publicAccount,mosaicId){
				message = getRandMessage(1023);

				return	 nem.TransferTransaction.create(
					nem.Deadline.create(epochAdjustment),
					publicAccount.address,
					[new nem.Mosaic(mosaicId, nem.UInt64.fromUint(1))],
					nem.PlainMessage.create(message),
					networkType
				);
			}

			mosaicRexTx = nem.AccountRestrictionTransaction.createMosaicRestrictionModificationTransaction(
				nem.Deadline.create(epochAdjustment),
				nem.MosaicRestrictionFlag.BlockMosaic,
				[mosaicDefTx.mosaicId],
				[],
				networkType
			);

			const aggregateArray =
			[createTx(bob.publicAccount,50).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx.toAggregate(bob.publicAccount))
			.concat(mosaicRexTx.toAggregate(carol1.publicAccount))
			.concat(distMosaicTx(carol1.publicAccount,mosaicId).toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob,carol1])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_RestrictionAccount_Mosaic_Transfer_Prohibited'));
		});

	});
	describe('Namespace',() => {

		beforeEach(()=>{
			bob = nem.Account.generateNewAccount(networkType);
		});

		beforeAll(async()=>{

			getNamespaceSignedTx = function(account,name){

				namespaceId = new nem.NamespaceId( name);
				namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
					nem.Deadline.create(epochAdjustment),
					namespaceId.fullName,
					nem.UInt64.fromUint(90000),
					networkType
				);

				const aggregateArray =
				[createTx(account.publicAccount,300).toAggregate(alice.publicAccount)]
				.concat(namespaceTx.toAggregate(account.publicAccount))

				return getSignedTx(aggregateArray,[account]);
			}

			getSubNamespaceSignedTx = function(account,name){

				subMosaicId = new nem.NamespaceId(getRandMessage(64).toLowerCase());
				subNamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
					nem.Deadline.create(epochAdjustment),
					subMosaicId.fullName,
					name,
					networkType,
				);

				const aggregateArray =
				[createTx(account.publicAccount,1).toAggregate(alice.publicAccount)]
				.concat(subNamespaceTx.toAggregate(account.publicAccount))

				return getSignedTx(aggregateArray,[account]);
			}
		})


		it('catches Failure_Namespace_Name_Id_Mismatch', async () => {});
		it('catches Failure_Namespace_Expired', async () => {});
//		it('catches Failure_Namespace_Id_Mismatch', async () => {});
		it('catches Failure_Namespace_Invalid_Registration_Type', async () => {});
		it('catches Failure_Namespace_Too_Deep', async () => {});
		it('catches Failure_Namespace_Already_Exists', async () => {});
//		it('catches Failure_Namespace_Already_Active', async () => {});
		it('catches Failure_Namespace_Eternal_After_Nemesis_Block', async () => {});
		it('catches Failure_Namespace_Max_Children_Exceeded', async () => {});
		it('catches Failure_Namespace_Alias_Invalid_Action', async () => {});
		it('catches Failure_Namespace_Alias_Already_Exists', async () => {});
		it('catches Failure_Namespace_Unknown_Alias', async () => {});
		it('catches Failure_Namespace_Alias_Inconsistent_Unlink_Type', async () => {});
		it('catches Failure_Namespace_Alias_Inconsistent_Unlink_Data', async () => {});
		it('catches Failure_Namespace_Alias_Invalid_Address', async () => {});

		it('catches Failure_Namespace_Invalid_Name', async () => {

			randomId = getRandMessage(57).toLowerCase();
			mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			accountId = new nem.NamespaceId("account_" + randomId);

			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
				nem.Deadline.create(epochAdjustment),
				mosaicId.fullName,
				nem.UInt64.fromUint(86400),
				networkType
			).setMaxFee(feeAdjustment);

			await expectAsync( transactionService.announce(
				namespaceTx.signWith(bob,generationHash)
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Name'));
		});
		it('catches Failure_Namespace_Invalid_Duration TOO SHORT', async () => {

			randomId = getRandMessage(56).toLowerCase();
			mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			accountId = new nem.NamespaceId("account_" + randomId);

			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
				nem.Deadline.create(epochAdjustment),
				mosaicId.fullName,
				nem.UInt64.fromUint(86399),
				networkType
			).setMaxFee(feeAdjustment);

			await expectAsync( transactionService.announce(
				namespaceTx.signWith(bob,generationHash)
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Duration'));
		});
		it('catches Failure_Namespace_Invalid_Duration TOO LONG', async () => {

			randomId = getRandMessage(56).toLowerCase();
			mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			accountId = new nem.NamespaceId("account_" + randomId);

			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
				nem.Deadline.create(epochAdjustment),
				mosaicId.fullName,
				nem.UInt64.fromUint(5256001),
				networkType
			).setMaxFee(feeAdjustment);

			await expectAsync( transactionService.announce(
				namespaceTx.signWith(bob,generationHash)
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Duration'));
		});
		it('catches Failure_Namespace_Invalid_Duration Reserved', async () => {

			mosaicId = new nem.NamespaceId( "symbol");

			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
				nem.Deadline.create(epochAdjustment),
				mosaicId.fullName,
				nem.UInt64.fromUint(90000),
				networkType
			);

			const aggregateArray =
			[createTx(bob.publicAccount,300).toAggregate(alice.publicAccount)]
			.concat(namespaceTx.toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Duration'));
		});
		it('catches Failure_Namespace_Invalid_Duration Reserved "symbol"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"symbol")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Duration'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "symbl"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"symbl")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "xym"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"xym")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "xem"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"xem")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "nem"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"nem")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "user"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"user")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "account"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"account")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "org"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"org")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "com"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"com")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "biz"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"biz")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "net"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"net")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "edu"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"edu")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "mil"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"mil")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "gov"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"gov")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		it('catches Failure_Namespace_Root_Name_Reserved "info"', async () => {

			await expectAsync( transactionService.announce(
				getNamespaceSignedTx(bob,"info")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Root_Name_Reserved'));
		});
		xit('catches Failure_Namespace_Owner_Conflict "symbol"', async () => {

			await expectAsync( transactionService.announce(
				getSubNamespaceSignedTx(bob,"symbol")
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Owner_Conflict'));
		});
		xit('catches Failure_Namespace_Unknown_Parent', async () => {

			await expectAsync( transactionService.announce(
				getSubNamespaceSignedTx(bob,getRandMessage(64).toLowerCase())
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Unknown_Parent'));
		});
		it('catches Failure_Namespace_Invalid_Name SUB', async () => {

			randomId = getRandMessage(56).toLowerCase();
			mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			subMosaicId = new nem.NamespaceId(getRandMessage(65).toLowerCase());


			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
				nem.Deadline.create(epochAdjustment),
				mosaicId.fullName,
				nem.UInt64.fromUint(86400),
				networkType
			);

			subNamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
				nem.Deadline.create(epochAdjustment),
				subMosaicId.fullName,
				mosaicId.fullName,
				networkType,
			);

			const aggregateArray =
			[createTx(bob.publicAccount,1).toAggregate(alice.publicAccount)]
			.concat(namespaceTx.toAggregate(bob.publicAccount))
			.concat(subNamespaceTx.toAggregate(bob.publicAccount))

			signedTx = getSignedTx(aggregateArray,[bob]);
			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Name'));
		});
		it('catches Failure_Namespace_Owner_Conflict', async () => {

			bob2 = nem.Account.generateNewAccount(networkType);

			randomId = getRandMessage(56).toLowerCase();
			mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
				nem.Deadline.create(epochAdjustment),
				mosaicId.fullName,
				nem.UInt64.fromUint(86400),
				networkType
			);

			namespaceTx2 = nem.NamespaceRegistrationTransaction.createRootNamespace(
				nem.Deadline.create(epochAdjustment),
				mosaicId.fullName,
				nem.UInt64.fromUint(86400),
				networkType
			);

			const aggregateArray =
			[createTx(bob.publicAccount,200).toAggregate(alice.publicAccount)]
			.concat(createTx(bob2.publicAccount,200).toAggregate(alice.publicAccount))
			.concat(namespaceTx.toAggregate(bob.publicAccount))
			.concat(namespaceTx2.toAggregate(bob2.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob,bob2])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Owner_Conflict'));
		});
		it('catches Failure_Namespace_Invalid_Name SUB2', async () => {

			randomId = getRandMessage(56).toLowerCase();
			mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			subMosaicId = new nem.NamespaceId(getRandMessage(65).toLowerCase());
			sub2MosaicId = new nem.NamespaceId(getRandMessage(12).toLowerCase());


			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
				nem.Deadline.create(epochAdjustment),
				mosaicId.fullName,
				nem.UInt64.fromUint(86400),
				networkType
			);

			subNamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
				nem.Deadline.create(epochAdjustment),
				subMosaicId.fullName,
				mosaicId,
				networkType,
			);

			sub2NamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
				nem.Deadline.create(epochAdjustment),
				sub2MosaicId.fullName,
				subMosaicId,
				networkType,
			);

			const aggregateArray =
			[createTx(bob.publicAccount,200).toAggregate(alice.publicAccount)]
			.concat(namespaceTx.toAggregate(bob.publicAccount))
			.concat(subNamespaceTx.toAggregate(bob.publicAccount))
			.concat(sub2NamespaceTx.toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Invalid_Name'));
		});
		it('catches Failure_Namespace_Unknown_Parent', async () => {

			randomId = getRandMessage(56).toLowerCase();
			mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			subMosaicId = new nem.NamespaceId(getRandMessage(12).toLowerCase());
			sub2MosaicId = new nem.NamespaceId(getRandMessage(12).toLowerCase());
			sub3MosaicId = new nem.NamespaceId(getRandMessage(12).toLowerCase());

			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
				nem.Deadline.create(epochAdjustment),
				mosaicId.fullName,
				nem.UInt64.fromUint(86400),
				networkType
			);

			subNamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
				nem.Deadline.create(epochAdjustment),
				subMosaicId.fullName,
				mosaicId,
				networkType,
			);

			sub2NamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
				nem.Deadline.create(epochAdjustment),
				sub2MosaicId.fullName,
				subMosaicId,
				networkType,
			);

			sub3NamespaceTx = nem.NamespaceRegistrationTransaction.createSubNamespace(
				nem.Deadline.create(epochAdjustment),
				sub3MosaicId.fullName,
				sub2MosaicId,
				networkType,
			);

			const aggregateArray =
			[createTx(bob.publicAccount,200).toAggregate(alice.publicAccount)]
			.concat(namespaceTx.toAggregate(bob.publicAccount))
			.concat(subNamespaceTx.toAggregate(bob.publicAccount))
			.concat(sub2NamespaceTx.toAggregate(bob.publicAccount))
			.concat(sub3NamespaceTx.toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Unknown_Parent'));
		});
		it('catches Failure_Namespace_Unknown', async () => {

			randomId = getRandMessage(56).toLowerCase();
			accountId = new nem.NamespaceId("account_" + randomId);

			namespaceKey = nem.KeyGenerator.generateUInt64Key("key_namespace");
			createNamespaceMetaTx = await metaService.createNamespaceMetadataTransaction(
				nem.Deadline.create(epochAdjustment),
				networkType,
				bob.address,
				accountId,
				namespaceKey,
				getRandMessage(1024),
				bob.address
			).toPromise();

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(createNamespaceMetaTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Namespace_Unknown'));


		});

	});
	describe('Mosaic',() => {

		it('catches Failure_Mosaic_Invalid_Name', async () => {});
//		it('catches Failure_Mosaic_Name_Id_Mismatch', async () => {});
		it('catches Failure_Mosaic_Owner_Conflict', async () => {
		});
//		it('catches Failure_Mosaic_Parent_Id_Conflict', async () => {});
//		it('catches Failure_Mosaic_Invalid_Property', async () => {});
		it('catches Failure_Mosaic_Invalid_Flags', async () => {});
		it('catches Failure_Mosaic_Invalid_Supply_Change_Action', async () => {

			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			distMosaicTx = function(publicAccount,mosaicId){
				return	 nem.TransferTransaction.create(
					nem.Deadline.create(epochAdjustment),
					publicAccount.address,
					[new nem.Mosaic(mosaicId, nem.UInt64.fromUint(1))],
					nem.PlainMessage.create(""),
					networkType
				);
			}

			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(true, false, true),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			//モザイク変更
			mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicDefTx.mosaicId,
				2,
				nem.UInt64.fromUint(1000000),
				networkType
			);


			const aggregateArray =
			[createTx(bob.publicAccount,100).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx.toAggregate(bob.publicAccount))

			await expectAsync(
				transactionService.announce(
					getSignedTx(aggregateArray,[bob]),
					listener
				).toPromise()
			)
			.toBeRejectedWith(new Error('Failure_Mosaic_Invalid_Supply_Change_Action'));



		});
		it('catches Failure_Mosaic_Invalid_Supply_Change_Amount', async () => {

			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			distMosaicTx = function(publicAccount,mosaicId){
				return	 nem.TransferTransaction.create(
					nem.Deadline.create(epochAdjustment),
					publicAccount.address,
					[new nem.Mosaic(mosaicId, nem.UInt64.fromUint(1))],
					nem.PlainMessage.create(""),
					networkType
				);
			}

			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(true, false, true),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			//モザイク変更
			mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicDefTx.mosaicId,
				nem.MosaicSupplyChangeAction.Increase,
				nem.UInt64.fromUint(1000000),
				networkType
			);

			mosaicChangeTx2 = nem.MosaicSupplyChangeTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicDefTx.mosaicId,
				nem.MosaicSupplyChangeAction.Increase,
				nem.UInt64.fromUint(0),
				networkType
			);

			const aggregateArray =
			[createTx(bob.publicAccount,100).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx.toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx2.toAggregate(bob.publicAccount))

			await expectAsync(
				transactionService.announce(
					getSignedTx(aggregateArray,[bob]),
					listener
				).toPromise()
			)
			.toBeRejectedWith(new Error('Failure_Mosaic_Invalid_Supply_Change_Amount'));




		});
		it('catches Failure_Mosaic_Invalid_Id', async () => {});
		it('catches Failure_Mosaic_Modification_Disallowed', async () => {});
		it('catches Failure_Mosaic_Modification_No_Changes', async () => {


		});
		it('catches Failure_Mosaic_Supply_Negative', async () => {});
		it('catches Failure_Mosaic_Max_Mosaics_Exceeded', async () => {});


		it('catches Failure_Mosaic_Supply_Exceeded', async () => {

			//モザイク作成
			nonce = nem.MosaicNonce.createRandom();
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				nem.MosaicId.createFromNonce(nonce, bob.address),
				nem.MosaicFlags.create(true, true, true),
				0,
				nem.UInt64.fromUint(1),
				networkType
			);
			//モザイク変更
			mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicDefTx.mosaicId,
				nem.MosaicSupplyChangeAction.Increase,
				nem.UInt64.fromUint(9000000000000001),
				networkType
			);

			const aggregateArray =
			[createTx(bob.publicAccount,50).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Supply_Exceeded'));
		});
		it('catches Failure_Mosaic_Id_Mismatch', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);

			//モザイク作成
			nonce = nem.MosaicNonce.createRandom();
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				nem.MosaicId.createFromNonce(nonce, carol1.address),
				nem.MosaicFlags.create(true, true, true),
				0,
				nem.UInt64.fromUint(3650*24*60*2 + 1),
				networkType
			);

			const aggregateArray =
			[createTx(bob.publicAccount,50).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Id_Mismatch'));
		});
		it('catches Failure_Mosaic_Invalid_Duration', async () => {

			//モザイク作成
			nonce = nem.MosaicNonce.createRandom();
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				nem.MosaicId.createFromNonce(nonce, bob.address),
				nem.MosaicFlags.create(true, true, true),
				0,
				nem.UInt64.fromUint(3650*24*60*2 + 1),
				networkType
			);

			const aggregateArray =
			[createTx(bob.publicAccount,50).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Invalid_Duration'));
		});
		it('catches Failure_Mosaic_Invalid_Divisibility', async () => {

			//モザイク作成
			nonce = nem.MosaicNonce.createRandom();
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				nem.MosaicId.createFromNonce(nonce, bob.address),
				nem.MosaicFlags.create(true, true, true),
				7,
				nem.UInt64.fromUint(0),
				networkType
			);

			const aggregateArray =
			[createTx(bob.publicAccount,50).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Invalid_Divisibility'));
		});
		it('catches Failure_Mosaic_Required_Property_Flag_Unset', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(true, true, false),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			resKey = nem.KeyGenerator.generateUInt64Key("KYC".toLowerCase());
			creatreMosaicGlobalResTx = nem.MosaicGlobalRestrictionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicId, // mosaicId
				resKey, // restrictionKey
				nem.UInt64.fromUint(0), // previousRestrictionValue
				nem.MosaicRestrictionType.NONE, // previousRestrictionType
				nem.UInt64.fromUint(1), // newRestrictionValue
				nem.MosaicRestrictionType.EQ, // newRestrictionType
				networkType,
				undefined
			);

			const aggregateArray =
			[createTx(bob.publicAccount,100).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount))
			.concat(creatreMosaicGlobalResTx.toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Required_Property_Flag_Unset'));

		});
		it('catches Failure_Mosaic_Supply_Immutable', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			distMosaicTx = function(publicAccount,mosaicId){
				message = getRandMessage(1023);

				return	 nem.TransferTransaction.create(
					nem.Deadline.create(epochAdjustment),
					publicAccount.address,
					[new nem.Mosaic(mosaicId, nem.UInt64.fromUint(1))],
					nem.PlainMessage.create(message),
					networkType
				);
			}


			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(false, true, true),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			//モザイク変更
			mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicDefTx.mosaicId,
				nem.MosaicSupplyChangeAction.Increase,
				nem.UInt64.fromUint(1000000),
				networkType
			);

			const aggregateArray =
			[createTx(bob.publicAccount,100).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx.toAggregate(bob.publicAccount))
			.concat(distMosaicTx(carol1.publicAccount,mosaicDefTx.mosaicId).toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx.toAggregate(bob.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Supply_Immutable'));

		});
		it('catches Failure_Mosaic_Non_Transferable', async () => {

			carol1 = nem.Account.generateNewAccount(networkType);
			carol2 = nem.Account.generateNewAccount(networkType);
			nonce = nem.MosaicNonce.createRandom();
			mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

			distMosaicTx = function(publicAccount,mosaicId){
				message = getRandMessage(1023);

				return	 nem.TransferTransaction.create(
					nem.Deadline.create(epochAdjustment),
					publicAccount.address,
					[new nem.Mosaic(mosaicId, nem.UInt64.fromUint(1))],
					nem.PlainMessage.create(message),
					networkType
				);
			}

			//モザイク作成
			mosaicDefTx = nem.MosaicDefinitionTransaction.create(
				nem.Deadline.create(epochAdjustment),
				nonce,
				mosaicId,
				nem.MosaicFlags.create(true, false, true),
				0,
				nem.UInt64.fromUint(0),
				networkType
			);

			//モザイク変更
			mosaicChangeTx = nem.MosaicSupplyChangeTransaction.create(
				nem.Deadline.create(epochAdjustment),
				mosaicDefTx.mosaicId,
				nem.MosaicSupplyChangeAction.Increase,
				nem.UInt64.fromUint(1000000),
				networkType
			);

			const aggregateArray =
			[createTx(bob.publicAccount,100).toAggregate(alice.publicAccount)]
			.concat(mosaicDefTx.toAggregate(bob.publicAccount))
			.concat(mosaicChangeTx.toAggregate(bob.publicAccount))
			.concat(distMosaicTx(carol1.publicAccount,mosaicDefTx.mosaicId).toAggregate(bob.publicAccount))
			.concat(distMosaicTx(carol2.publicAccount,mosaicDefTx.mosaicId).toAggregate(carol1.publicAccount))

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob,carol1])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Non_Transferable'));

		});
		it('catches Failure_Mosaic_Expired', async () => {

			randomId = getRandMessage(56).toLowerCase();
			mosaicId = new nem.NamespaceId( "mosaic__" + randomId);

			mosaicKey = nem.KeyGenerator.generateUInt64Key("key_mosaic");
			createMosaicMetaTx = await metaService.createMosaicMetadataTransaction(
				nem.Deadline.create(epochAdjustment),
				networkType,
				bob.address,
				mosaicId,
				mosaicKey,
				getRandMessage(1024),
				bob.address
			).toPromise();

			const aggregateArray =
			[createTx(bob.publicAccount,0).toAggregate(alice.publicAccount)]
			.concat(createMosaicMetaTx.toAggregate(bob.publicAccount));

			await expectAsync( transactionService.announce(
				getSignedTx(aggregateArray,[bob])
			,listener).toPromise())
			.toBeRejectedWith(new Error('Failure_Mosaic_Expired'));
		});

	});
	describe('AccountLink',() => {
		it('catches Failure_Hash_Already_Exists', async () => {});
		it('catches Failure_Signature_Not_Verifiable', async () => {});
		it('catches Failure_AccountLink_Link_Already_Exists', async () => {});
		it('catches Failure_AccountLink_Inconsistent_Unlink_Data', async () => {});
		it('catches Failure_AccountLink_Unknown_Link', async () => {});
		it('catches Failure_AccountLink_Remote_Account_Ineligible', async () => {});
		it('catches Failure_AccountLink_Remote_Account_Signer_Prohibited', async () => {});
		it('catches Failure_AccountLink_Remote_Account_Participant_Prohibited', async () => {});

	});

	describe('SUCCESS',()=>{
		it('resolves Max Message Transaction', async () => {

			const signedTx = nem.TransferTransaction.create(
				nem.Deadline.create(epochAdjustment),
				alice.address,
				[],
				nem.PlainMessage.create(getRandMessage(1023)),
				networkType
			).setMaxFee(feeAdjustment)
			.signWith(alice,generationHash);

			res = await  transactionService.announce(signedTx,listener).toPromise();
			console.log(res);
			expect(res.transactionInfo.hash)
			.toBe(signedTx.hash)
		});

		it('resolves Max Aggregate Transaction', async () => {

			let aggregateArray = Array();
			for(let i=0;i<=99;i++){
				aggregateArray.push(createTx(bob.publicAccount,0).toAggregate(alice.publicAccount));
			}

			const aggregateTx = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),aggregateArray,networkType,[]
			).setMaxFeeForAggregate(feeAdjustment,0);

			const signedTx = aggregateTx.signTransactionWithCosignatories(alice,[],generationHash);

			res = await transactionService.announce(signedTx,listener).toPromise();
			expect(res.transactionInfo.hash).toBe(signedTx.hash)
		});
		it('resolves Max Multisig Modification Transaction', async () => {

			dave = nem.Account.generateNewAccount(networkType);
			carols = getCarolAccounts(11);

			msigTx = nem.MultisigAccountModificationTransaction.create(
				nem.Deadline.create(epochAdjustment),
				1,1,[dave.address].concat(carols.addresses),[],nem.NetworkType.TEST_NET
			);

			const aggregateArray =
			[createTx(bob.publicAccount,15).toAggregate(alice.publicAccount)]
			.concat(createTx(dave.publicAccount,7).toAggregate(alice.publicAccount))
			.concat(msigTx.toAggregate(bob.publicAccount));
			signedTx = getSignedTx(aggregateArray,[bob].concat(carols.accounts).concat(dave));
			res = await transactionService.announce(
				signedTx
			,listener).toPromise()
			console.log(res);

			carols2 = getCarolAccounts(11);
			const signedTx2 = nem.AggregateTransaction.createComplete(
				nem.Deadline.create(epochAdjustment),
				[
					nem.MultisigAccountModificationTransaction.create(
					nem.Deadline.create(epochAdjustment),
					1,1,carols2.addresses,[],nem.NetworkType.TEST_NET)
					.toAggregate(bob.publicAccount)
				],
				networkType,[]
			).setMaxFeeForAggregate(feeAdjustment,carols2.addresses.length)
			.signTransactionWithCosignatories(dave,carols2.accounts,generationHash);
			console.log(signedTx2.hash)
			clog(signedTx2);
			res2 = await transactionService.announce(signedTx2,listener).toPromise()
			expect(res2.transactionInfo.hash).toBe(signedTx2.hash)

		});
		xit('resolves Max Mosaic Transaction', async () => {

			console.log(alice);

			carol1 = nem.Account.generateNewAccount(networkType);

			distMosaicTx = function(publicAccount,mosaics){
				message = getRandMessage(1023);

				return	 nem.TransferTransaction.create(
					nem.Deadline.create(epochAdjustment),
					publicAccount.address,
					mosaics,
					nem.PlainMessage.create(message),
					networkType
				);
			}

			async function announceCreateMosaicTxs(mosaics,count){

				mosaicDefTxs = Array();
				for(i=0; i < count; i++){

					nonce = nem.MosaicNonce.createRandom();
					mosaicId = nem.MosaicId.createFromNonce(nonce, bob.address)

					//モザイク作成
					mosaicDefTx = nem.MosaicDefinitionTransaction.create(
						nem.Deadline.create(epochAdjustment),
						nonce,
						mosaicId,
						nem.MosaicFlags.create(true, true, true),
						0,
						nem.UInt64.fromUint(60*2),
						networkType
					);

					mosaics.push(new nem.Mosaic(mosaicId, nem.UInt64.fromUint(0)));
					mosaicDefTxs.push(mosaicDefTx.toAggregate(bob.publicAccount));
				}
				console.log(mosaics);

				const aggregateArray =
				[createTx(bob.publicAccount,160).toAggregate(alice.publicAccount)]
				.concat(mosaicDefTxs)

				signedTx = getSignedTx(aggregateArray,[bob]);
				clog(signedTx);
				await listener.open();
				res = await transactionService.announce(signedTx,listener).toPromise()
				console.log(res);
				return mosaics;
			}

			console.log(bob);

			mosaics = Array();
			mosaics = await announceCreateMosaicTxs(mosaics,85);
			mosaics = await announceCreateMosaicTxs(mosaics,85);
			mosaics = await announceCreateMosaicTxs(mosaics,85);

			console.log(mosaics);

			const aggregateArray3 =
			[createTx(bob.publicAccount,5).toAggregate(alice.publicAccount)]
			.concat(distMosaicTx(carol1.publicAccount,mosaics).toAggregate(bob.publicAccount));

			signedTx3 = getSignedTx(aggregateArray3,[bob]);
			console.log(signedTx3.hash);
			clog(signedTx3);

			await listener.open();
			res3 = await transactionService.announce(signedTx3,listener).toPromise();
			expect(res3.transactionInfo.hash).toBe(signedTx3.hash);

		});

		it('resolves TEMP TEST', async () => {


			const aggregateArray3 =
			[createTx(bob.publicAccount,5).toAggregate(alice.publicAccount)]
			.concat(createTxByNamespace(alice.publicAccount,1).toAggregate(bob.publicAccount));

			signedTx3 = getSignedTx(aggregateArray3,[bob]);
			console.log(signedTx3.hash);
			clog(signedTx3);

			await listener.open();
			res3 = await transactionService.announce(signedTx3,listener).toPromise();
			expect(res3.transactionInfo.hash).toBe(signedTx3.hash);
		});

		it('resolves TEMP TEST', async () => {

			console.log(bob);
			randomId = getRandMessage(56).toLowerCase();
			mosaicId = new nem.NamespaceId( "mosaic__" + randomId);
			accountId = new nem.NamespaceId("account_" + randomId);

			namespaceTx = nem.NamespaceRegistrationTransaction.createRootNamespace(
				nem.Deadline.create(epochAdjustment),
				mosaicId.fullName,
				nem.UInt64.fromUint(86400),
				networkType
			);

			const aggregateArray3 =
			[createTx(bob.publicAccount,50).toAggregate(alice.publicAccount)]
			.concat(namespaceTx.toAggregate(bob.publicAccount));

			signedTx3 = getSignedTx(aggregateArray3,[bob]);
			console.log(signedTx3.hash);
			clog(signedTx3);

			await listener.open();
			res3 = await transactionService.announce(signedTx3,listener).toPromise();
			expect(res3.transactionInfo.hash).toBe(signedTx3.hash);

		});
	});


});//symbol-sdk
</script>

</body>
</html>
