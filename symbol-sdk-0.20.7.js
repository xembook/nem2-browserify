require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var asn1 = exports;

asn1.bignum = require('bn.js');

asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

},{"./asn1/api":2,"./asn1/base":4,"./asn1/constants":8,"./asn1/decoders":10,"./asn1/encoders":13,"bn.js":16}],2:[function(require,module,exports){
var asn1 = require('../asn1');
var inherits = require('inherits');

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = require('vm').runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"../asn1":1,"inherits":99,"vm":155}],3:[function(require,module,exports){
var inherits = require('inherits');
var Reporter = require('../base').Reporter;
var Buffer = require('buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"../base":4,"buffer":47,"inherits":99}],4:[function(require,module,exports){
var base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":3,"./node":5,"./reporter":6}],5:[function(require,module,exports){
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
var DecoderBuffer = require('../base').DecoderBuffer;
var assert = require('minimalistic-assert');

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};

},{"../base":4,"minimalistic-assert":104}],6:[function(require,module,exports){
var inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};

},{"inherits":99}],7:[function(require,module,exports){
var constants = require('../constants');

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":8}],8:[function(require,module,exports){
var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":7}],9:[function(require,module,exports){
var inherits = require('inherits');

var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                    options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../../asn1":1,"inherits":99}],10:[function(require,module,exports){
var decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":9,"./pem":11}],11:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"./der":9,"buffer":47,"inherits":99}],12:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

},{"../../asn1":1,"buffer":47,"inherits":99}],13:[function(require,module,exports){
var encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":12,"./pem":14}],14:[function(require,module,exports){
var inherits = require('inherits');

var DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"./der":12,"inherits":99}],15:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],16:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = require('buffer').Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":18}],17:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}

},{"crypto":18}],18:[function(require,module,exports){

},{}],19:[function(require,module,exports){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = require('safe-buffer').Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES

},{"safe-buffer":142}],20:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
var incr32 = require('./incr32')

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher

},{"./aes":19,"./ghash":24,"./incr32":25,"buffer-xor":46,"cipher-base":48,"inherits":99,"safe-buffer":142}],21:[function(require,module,exports){
var ciphers = require('./encrypter')
var deciphers = require('./decrypter')
var modes = require('./modes/list.json')

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"./decrypter":22,"./encrypter":23,"./modes/list.json":33}],22:[function(require,module,exports){
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var MODES = require('./modes')
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

},{"./aes":19,"./authCipher":20,"./modes":32,"./streamCipher":35,"cipher-base":48,"evp_bytestokey":83,"inherits":99,"safe-buffer":142}],23:[function(require,module,exports){
var MODES = require('./modes')
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

},{"./aes":19,"./authCipher":20,"./modes":32,"./streamCipher":35,"cipher-base":48,"evp_bytestokey":83,"inherits":99,"safe-buffer":142}],24:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH

},{"safe-buffer":142}],25:[function(require,module,exports){
function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32

},{}],26:[function(require,module,exports){
var xor = require('buffer-xor')

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}

},{"buffer-xor":46}],27:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var xor = require('buffer-xor')

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}

},{"buffer-xor":46,"safe-buffer":142}],28:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":142}],29:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":142}],30:[function(require,module,exports){
var xor = require('buffer-xor')
var Buffer = require('safe-buffer').Buffer
var incr32 = require('../incr32')

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

},{"../incr32":25,"buffer-xor":46,"safe-buffer":142}],31:[function(require,module,exports){
exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}

},{}],32:[function(require,module,exports){
var modeModules = {
  ECB: require('./ecb'),
  CBC: require('./cbc'),
  CFB: require('./cfb'),
  CFB8: require('./cfb8'),
  CFB1: require('./cfb1'),
  OFB: require('./ofb'),
  CTR: require('./ctr'),
  GCM: require('./ctr')
}

var modes = require('./list.json')

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes

},{"./cbc":26,"./cfb":27,"./cfb1":28,"./cfb8":29,"./ctr":30,"./ecb":31,"./list.json":33,"./ofb":34}],33:[function(require,module,exports){
module.exports={
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
}

},{}],34:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)
},{"buffer":47,"buffer-xor":46}],35:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher

},{"./aes":19,"cipher-base":48,"inherits":99,"safe-buffer":142}],36:[function(require,module,exports){
var DES = require('browserify-des')
var aes = require('browserify-aes/browser')
var aesModes = require('browserify-aes/modes')
var desModes = require('browserify-des/modes')
var ebtk = require('evp_bytestokey')

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"browserify-aes/browser":21,"browserify-aes/modes":32,"browserify-des":37,"browserify-des/modes":38,"evp_bytestokey":83}],37:[function(require,module,exports){
var CipherBase = require('cipher-base')
var des = require('des.js')
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}

},{"cipher-base":48,"des.js":56,"inherits":99,"safe-buffer":142}],38:[function(require,module,exports){
exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}

},{}],39:[function(require,module,exports){
(function (Buffer){
var bn = require('bn.js');
var randomBytes = require('randombytes');
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

}).call(this,require("buffer").Buffer)
},{"bn.js":16,"buffer":47,"randombytes":124}],40:[function(require,module,exports){
module.exports = require('./browser/algorithms.json')

},{"./browser/algorithms.json":41}],41:[function(require,module,exports){
module.exports={
  "sha224WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    "sign": "ecdsa/rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "sha256WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    "sign": "ecdsa/rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "sha384WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    "sign": "ecdsa/rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "sha512WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    "sign": "ecdsa/rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    "sign": "rsa",
    "hash": "sha1",
    "id": "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    "sign": "ecdsa",
    "hash": "sha1",
    "id": ""
  },
  "sha256": {
    "sign": "ecdsa",
    "hash": "sha256",
    "id": ""
  },
  "sha224": {
    "sign": "ecdsa",
    "hash": "sha224",
    "id": ""
  },
  "sha384": {
    "sign": "ecdsa",
    "hash": "sha384",
    "id": ""
  },
  "sha512": {
    "sign": "ecdsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-SHA1": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-WITH-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-WITH-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-WITH-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-WITH-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-RIPEMD160": {
    "sign": "dsa",
    "hash": "rmd160",
    "id": ""
  },
  "ripemd160WithRSA": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "md5WithRSAEncryption": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  }
}

},{}],42:[function(require,module,exports){
module.exports={
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
}

},{}],43:[function(require,module,exports){
(function (Buffer){
var createHash = require('create-hash')
var stream = require('stream')
var inherits = require('inherits')
var sign = require('./sign')
var verify = require('./verify')

var algorithms = require('./algorithms.json')
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = new Buffer(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = new Buffer(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

}).call(this,require("buffer").Buffer)
},{"./algorithms.json":41,"./sign":44,"./verify":45,"buffer":47,"create-hash":51,"inherits":99,"stream":151}],44:[function(require,module,exports){
(function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var createHmac = require('create-hmac')
var crt = require('browserify-rsa')
var EC = require('elliptic').ec
var BN = require('bn.js')
var parseKeys = require('parse-asn1')
var curves = require('./curves.json')

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [ 0, 1 ]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return new Buffer(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [ 0 ].concat(r)
  if (s[0] & 0x80) s = [ 0 ].concat(s)

  var total = r.length + s.length + 4
  var res = [ 0x30, total, 0x02, r.length ]
  res = res.concat(r, [ 0x02, s.length ], s)
  return new Buffer(res)
}

function getKey (x, q, hash, algo) {
  x = new Buffer(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length)
    zeros.fill(0)
    x = Buffer.concat([ zeros, x ])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = new Buffer(hlen)
  v.fill(1)
  var k = new Buffer(hlen)
  k.fill(0)
  k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = new Buffer(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length)
    zeros.fill(0)
    out = Buffer.concat([ zeros, out ])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = new Buffer(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([ t, kv.v ])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

}).call(this,require("buffer").Buffer)
},{"./curves.json":42,"bn.js":16,"browserify-rsa":39,"buffer":47,"create-hmac":53,"elliptic":66,"parse-asn1":110}],45:[function(require,module,exports){
(function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var BN = require('bn.js')
var EC = require('elliptic').ec
var parseKeys = require('parse-asn1')
var curves = require('./curves.json')

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [ 1 ]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = new Buffer(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = new Buffer(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify

}).call(this,require("buffer").Buffer)
},{"./curves.json":42,"bn.js":16,"buffer":47,"elliptic":66,"parse-asn1":110}],46:[function(require,module,exports){
(function (Buffer){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this,require("buffer").Buffer)
},{"buffer":47}],47:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)
},{"base64-js":15,"buffer":47,"ieee754":98}],48:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var StringDecoder = require('string_decoder').StringDecoder
var inherits = require('inherits')

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase

},{"inherits":99,"safe-buffer":142,"stream":151,"string_decoder":152}],49:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":100}],50:[function(require,module,exports){
(function (Buffer){
var elliptic = require('elliptic')
var BN = require('bn.js')

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

}).call(this,require("buffer").Buffer)
},{"bn.js":16,"buffer":47,"elliptic":66}],51:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var MD5 = require('md5.js')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Base = require('cipher-base')

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}

},{"cipher-base":48,"inherits":99,"md5.js":102,"ripemd160":141,"sha.js":144}],52:[function(require,module,exports){
var MD5 = require('md5.js')

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}

},{"md5.js":102}],53:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Legacy = require('./legacy')
var Base = require('cipher-base')
var Buffer = require('safe-buffer').Buffer
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')

var sha = require('sha.js')

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}

},{"./legacy":54,"cipher-base":48,"create-hash/md5":52,"inherits":99,"ripemd160":141,"safe-buffer":142,"sha.js":144}],54:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var Base = require('cipher-base')

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac

},{"cipher-base":48,"inherits":99,"safe-buffer":142}],55:[function(require,module,exports){
'use strict'

exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')
exports.createHash = exports.Hash = require('create-hash')
exports.createHmac = exports.Hmac = require('create-hmac')

var algos = require('browserify-sign/algos')
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = require('pbkdf2')
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = require('browserify-cipher')

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = require('diffie-hellman')

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = require('browserify-sign')

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = require('create-ecdh')

var publicEncrypt = require('public-encrypt')

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = require('randomfill')

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}

},{"browserify-cipher":36,"browserify-sign":43,"browserify-sign/algos":40,"create-ecdh":50,"create-hash":51,"create-hmac":53,"diffie-hellman":62,"pbkdf2":111,"public-encrypt":118,"randombytes":124,"randomfill":125}],56:[function(require,module,exports){
'use strict';

exports.utils = require('./des/utils');
exports.Cipher = require('./des/cipher');
exports.DES = require('./des/des');
exports.CBC = require('./des/cbc');
exports.EDE = require('./des/ede');

},{"./des/cbc":57,"./des/cipher":58,"./des/des":59,"./des/ede":60,"./des/utils":61}],57:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};

},{"inherits":99,"minimalistic-assert":104}],58:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};

},{"minimalistic-assert":104}],59:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var utils = require('./utils');
var Cipher = require('./cipher');

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};

},{"./cipher":58,"./utils":61,"inherits":99,"minimalistic-assert":104}],60:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var Cipher = require('./cipher');
var DES = require('./des');

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

},{"./cipher":58,"./des":59,"inherits":99,"minimalistic-assert":104}],61:[function(require,module,exports){
'use strict';

exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};

},{}],62:[function(require,module,exports){
(function (Buffer){
var generatePrime = require('./lib/generatePrime')
var primes = require('./lib/primes.json')

var DH = require('./lib/dh')

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

}).call(this,require("buffer").Buffer)
},{"./lib/dh":63,"./lib/generatePrime":64,"./lib/primes.json":65,"buffer":47}],63:[function(require,module,exports){
(function (Buffer){
var BN = require('bn.js');
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require('./generatePrime');
var randomBytes = require('randombytes');
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

}).call(this,require("buffer").Buffer)
},{"./generatePrime":64,"bn.js":16,"buffer":47,"miller-rabin":103,"randombytes":124}],64:[function(require,module,exports){
var randomBytes = require('randombytes');
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require('bn.js');
var TWENTYFOUR = new BN(24);
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}

},{"bn.js":16,"miller-rabin":103,"randombytes":124}],65:[function(require,module,exports){
module.exports={
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}
},{}],66:[function(require,module,exports){
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":81,"./elliptic/curve":69,"./elliptic/curves":72,"./elliptic/ec":73,"./elliptic/eddsa":76,"./elliptic/utils":80,"brorand":17}],67:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
                          bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../utils":80,"bn.js":16}],68:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../utils":80,"./base":67,"bn.js":16,"inherits":99}],69:[function(require,module,exports){
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":67,"./edwards":68,"./mont":70,"./short":71}],70:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var utils = require('../utils');

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../utils":80,"./base":67,"bn.js":16,"inherits":99}],71:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../utils":80,"./base":67,"bn.js":16,"inherits":99}],72:[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');
var curve = require('./curve');
var utils = require('./utils');

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});

},{"./curve":69,"./precomputed/secp256k1":79,"./utils":80,"hash.js":85}],73:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var HmacDRBG = require('hmac-drbg');
var utils = require('../utils');
var curves = require('../curves');
var rand = require('brorand');
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ?
        options.k(iter) :
        new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../curves":72,"../utils":80,"./key":74,"./signature":75,"bn.js":16,"brorand":17,"hmac-drbg":97}],74:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"../utils":80,"bn.js":16}],75:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var utils = require('../utils');
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../utils":80,"bn.js":16}],76:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var curves = require('../curves');
var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../curves":72,"../utils":80,"./key":77,"./signature":78,"hash.js":85}],77:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../utils":80}],78:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"../utils":80,"bn.js":16}],79:[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};

},{}],80:[function(require,module,exports){
'use strict';

var utils = exports;
var BN = require('bn.js');
var minAssert = require('minimalistic-assert');
var minUtils = require('minimalistic-crypto-utils');

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":16,"minimalistic-assert":104,"minimalistic-crypto-utils":105}],81:[function(require,module,exports){
module.exports={
  "_from": "elliptic@^6.0.0",
  "_id": "elliptic@6.5.2",
  "_inBundle": false,
  "_integrity": "sha512-f4x70okzZbIQl/NSRLkI/+tteV/9WqL98zx+SQ69KbXxmVrmjwsNUPn/gYJJ0sHvEak24cZgHIPegRePAtA/xw==",
  "_location": "/browserify/elliptic",
  "_phantomChildren": {},
  "_requested": {
    "type": "range",
    "registry": true,
    "raw": "elliptic@^6.0.0",
    "name": "elliptic",
    "escapedName": "elliptic",
    "rawSpec": "^6.0.0",
    "saveSpec": null,
    "fetchSpec": "^6.0.0"
  },
  "_requiredBy": [
    "/browserify/browserify-sign",
    "/browserify/create-ecdh"
  ],
  "_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.5.2.tgz",
  "_shasum": "05c5678d7173c049d8ca433552224a495d0e3762",
  "_spec": "elliptic@^6.0.0",
  "_where": "/home/ec2-user/.nvm/versions/node/v12.16.2/lib/node_modules/browserify/node_modules/browserify-sign",
  "author": {
    "name": "Fedor Indutny",
    "email": "fedor@indutny.com"
  },
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "bn.js": "^4.4.0",
    "brorand": "^1.0.1",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.0",
    "inherits": "^2.0.1",
    "minimalistic-assert": "^1.0.0",
    "minimalistic-crypto-utils": "^1.0.0"
  },
  "deprecated": false,
  "description": "EC cryptography",
  "devDependencies": {
    "brfs": "^1.4.3",
    "coveralls": "^3.0.8",
    "grunt": "^1.0.4",
    "grunt-browserify": "^5.0.0",
    "grunt-cli": "^1.2.0",
    "grunt-contrib-connect": "^1.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^1.0.1",
    "grunt-mocha-istanbul": "^3.0.1",
    "grunt-saucelabs": "^9.0.1",
    "istanbul": "^0.4.2",
    "jscs": "^3.0.7",
    "jshint": "^2.10.3",
    "mocha": "^6.2.2"
  },
  "files": [
    "lib"
  ],
  "homepage": "https://github.com/indutny/elliptic",
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "license": "MIT",
  "main": "lib/elliptic.js",
  "name": "elliptic",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/indutny/elliptic.git"
  },
  "scripts": {
    "jscs": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
    "jshint": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
    "lint": "npm run jscs && npm run jshint",
    "test": "npm run lint && npm run unit",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "version": "grunt dist && git add dist/"
  },
  "version": "6.5.2"
}

},{}],82:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],83:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var MD5 = require('md5.js')

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey

},{"md5.js":102,"safe-buffer":142}],84:[function(require,module,exports){
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var inherits = require('inherits')

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

},{"inherits":99,"safe-buffer":142,"stream":151}],85:[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":86,"./hash/hmac":87,"./hash/ripemd":88,"./hash/sha":89,"./hash/utils":96}],86:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"./utils":96,"minimalistic-assert":104}],87:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"./utils":96,"minimalistic-assert":104}],88:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var common = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"./common":86,"./utils":96}],89:[function(require,module,exports){
'use strict';

exports.sha1 = require('./sha/1');
exports.sha224 = require('./sha/224');
exports.sha256 = require('./sha/256');
exports.sha384 = require('./sha/384');
exports.sha512 = require('./sha/512');

},{"./sha/1":90,"./sha/224":91,"./sha/256":92,"./sha/384":93,"./sha/512":94}],90:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":86,"../utils":96,"./common":95}],91:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var SHA256 = require('./256');

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};


},{"../utils":96,"./256":92}],92:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var assert = require('minimalistic-assert');

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":86,"../utils":96,"./common":95,"minimalistic-assert":104}],93:[function(require,module,exports){
'use strict';

var utils = require('../utils');

var SHA512 = require('./512');

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

},{"../utils":96,"./512":94}],94:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var assert = require('minimalistic-assert');

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../common":86,"../utils":96,"minimalistic-assert":104}],95:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;

},{"../utils":96}],96:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"inherits":99,"minimalistic-assert":104}],97:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var utils = require('minimalistic-crypto-utils');
var assert = require('minimalistic-assert');

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};

},{"hash.js":85,"minimalistic-assert":104,"minimalistic-crypto-utils":105}],98:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],99:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],100:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],101:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],102:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var HashBase = require('hash-base')
var Buffer = require('safe-buffer').Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5

},{"hash-base":84,"inherits":99,"safe-buffer":142}],103:[function(require,module,exports){
var bn = require('bn.js');
var brorand = require('brorand');

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};

},{"bn.js":16,"brorand":17}],104:[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],105:[function(require,module,exports){
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

},{}],106:[function(require,module,exports){
module.exports={"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}
},{}],107:[function(require,module,exports){
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.
'use strict'

var asn1 = require('asn1.js')

exports.certificate = require('./certificate')

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})

},{"./certificate":108,"asn1.js":1}],108:[function(require,module,exports){
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen

'use strict'

var asn = require('asn1.js')

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional(),
    this.key('curve').objid().optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int().optional(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate

},{"asn1.js":1}],109:[function(require,module,exports){
// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m
var evp = require('evp_bytestokey')
var ciphers = require('browserify-aes')
var Buffer = require('safe-buffer').Buffer
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/[\r\n]/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = Buffer.from(match[2], 'hex')
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}

},{"browserify-aes":21,"evp_bytestokey":83,"safe-buffer":142}],110:[function(require,module,exports){
var asn1 = require('./asn1')
var aesid = require('./aesid.json')
var fixProc = require('./fixProc')
var ciphers = require('browserify-aes')
var compat = require('pbkdf2')
var Buffer = require('safe-buffer').Buffer
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}

},{"./aesid.json":106,"./asn1":107,"./fixProc":109,"browserify-aes":21,"pbkdf2":111,"safe-buffer":142}],111:[function(require,module,exports){
exports.pbkdf2 = require('./lib/async')
exports.pbkdf2Sync = require('./lib/sync')

},{"./lib/async":112,"./lib/sync":115}],112:[function(require,module,exports){
(function (process,global){
var checkParameters = require('./precondition')
var defaultEncoding = require('./default-encoding')
var sync = require('./sync')
var Buffer = require('safe-buffer').Buffer

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  'sha': 'SHA-1',
  'sha-1': 'SHA-1',
  'sha1': 'SHA-1',
  'sha256': 'SHA-256',
  'sha-256': 'SHA-256',
  'sha384': 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  'sha512': 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}

function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    process.nextTick(function () {
      callback(null, out)
    })
  }, function (e) {
    process.nextTick(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof global.Promise !== 'function') {
    return process.nextTick(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
  }

  checkParameters(password, salt, iterations, keylen)
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./default-encoding":113,"./precondition":114,"./sync":115,"_process":117,"safe-buffer":142}],113:[function(require,module,exports){
(function (process){
var defaultEncoding
/* istanbul ignore next */
if (process.browser) {
  defaultEncoding = 'utf-8'
} else {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
}
module.exports = defaultEncoding

}).call(this,require('_process'))
},{"_process":117}],114:[function(require,module,exports){
(function (Buffer){
var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

function checkBuffer (buf, name) {
  if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
    throw new TypeError(name + ' must be a buffer or string')
  }
}

module.exports = function (password, salt, iterations, keylen) {
  checkBuffer(password, 'Password')
  checkBuffer(salt, 'Salt')

  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":100}],115:[function(require,module,exports){
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')

var checkParameters = require('./precondition')
var defaultEncoding = require('./default-encoding')
var Buffer = require('safe-buffer').Buffer
var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(password, salt, iterations, keylen)

  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2

},{"./default-encoding":113,"./precondition":114,"create-hash/md5":52,"ripemd160":141,"safe-buffer":142,"sha.js":144}],116:[function(require,module,exports){
(function (process){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))
},{"_process":117}],117:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],118:[function(require,module,exports){
exports.publicEncrypt = require('./publicEncrypt')
exports.privateDecrypt = require('./privateDecrypt')

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}

},{"./privateDecrypt":120,"./publicEncrypt":121}],119:[function(require,module,exports){
var createHash = require('create-hash')
var Buffer = require('safe-buffer').Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}

},{"create-hash":51,"safe-buffer":142}],120:[function(require,module,exports){
var parseKeys = require('parse-asn1')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var crt = require('browserify-rsa')
var createHash = require('create-hash')
var withPublic = require('./withPublic')
var Buffer = require('safe-buffer').Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}

},{"./mgf":119,"./withPublic":122,"./xor":123,"bn.js":16,"browserify-rsa":39,"create-hash":51,"parse-asn1":110,"safe-buffer":142}],121:[function(require,module,exports){
var parseKeys = require('parse-asn1')
var randomBytes = require('randombytes')
var createHash = require('create-hash')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var withPublic = require('./withPublic')
var crt = require('browserify-rsa')
var Buffer = require('safe-buffer').Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}

},{"./mgf":119,"./withPublic":122,"./xor":123,"bn.js":16,"browserify-rsa":39,"create-hash":51,"parse-asn1":110,"randombytes":124,"safe-buffer":142}],122:[function(require,module,exports){
var BN = require('bn.js')
var Buffer = require('safe-buffer').Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic

},{"bn.js":16,"safe-buffer":142}],123:[function(require,module,exports){
module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}

},{}],124:[function(require,module,exports){
(function (process,global){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":117,"safe-buffer":142}],125:[function(require,module,exports){
(function (process,global){
'use strict'

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = require('safe-buffer')
var randombytes = require('randombytes')
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = global.crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":117,"randombytes":124,"safe-buffer":142}],126:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":127}],127:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":129,"./_stream_writable":131,"core-util-is":49,"inherits":99,"process-nextick-args":116}],128:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":130,"core-util-is":49,"inherits":99}],129:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":127,"./internal/streams/BufferList":132,"./internal/streams/destroy":133,"./internal/streams/stream":134,"_process":117,"core-util-is":49,"events":82,"inherits":99,"isarray":101,"process-nextick-args":116,"safe-buffer":135,"string_decoder/":136,"util":18}],130:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":127,"core-util-is":49,"inherits":99}],131:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":127,"./internal/streams/destroy":133,"./internal/streams/stream":134,"_process":117,"core-util-is":49,"inherits":99,"process-nextick-args":116,"safe-buffer":135,"timers":153,"util-deprecate":154}],132:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":135,"util":18}],133:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":116}],134:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":82}],135:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":47}],136:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":135}],137:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":138}],138:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":127,"./lib/_stream_passthrough.js":128,"./lib/_stream_readable.js":129,"./lib/_stream_transform.js":130,"./lib/_stream_writable.js":131}],139:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":138}],140:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":131}],141:[function(require,module,exports){
'use strict'
var Buffer = require('buffer').Buffer
var inherits = require('inherits')
var HashBase = require('hash-base')

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

},{"buffer":47,"hash-base":84,"inherits":99}],142:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":47}],143:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

},{"safe-buffer":142}],144:[function(require,module,exports){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":145,"./sha1":146,"./sha224":147,"./sha256":148,"./sha384":149,"./sha512":150}],145:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

},{"./hash":143,"inherits":99,"safe-buffer":142}],146:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

},{"./hash":143,"inherits":99,"safe-buffer":142}],147:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

},{"./hash":143,"./sha256":148,"inherits":99,"safe-buffer":142}],148:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

},{"./hash":143,"inherits":99,"safe-buffer":142}],149:[function(require,module,exports){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

},{"./hash":143,"./sha512":150,"inherits":99,"safe-buffer":142}],150:[function(require,module,exports){
var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

},{"./hash":143,"inherits":99,"safe-buffer":142}],151:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":82,"inherits":99,"readable-stream/duplex.js":126,"readable-stream/passthrough.js":137,"readable-stream/readable.js":138,"readable-stream/transform.js":139,"readable-stream/writable.js":140}],152:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"dup":136,"safe-buffer":142}],153:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":117,"timers":153}],154:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],155:[function(require,module,exports){
var indexOf = function (xs, item) {
    if (xs.indexOf) return xs.indexOf(item);
    else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
    }
    return -1;
};
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    if (context) {
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    }

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.isContext = function (context) {
    return context instanceof Context;
};

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{}],156:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"dup":15}],157:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountAddressRestrictionTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const UnresolvedAddressDto_1 = require("./UnresolvedAddressDto");
class AccountAddressRestrictionTransactionBodyBuilder {
    constructor(restrictionFlags, restrictionAdditions, restrictionDeletions) {
        this.restrictionFlags = restrictionFlags;
        this.accountRestrictionTransactionBody_Reserved1 = 0;
        this.restrictionAdditions = restrictionAdditions;
        this.restrictionDeletions = restrictionDeletions;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const restrictionFlags = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const restrictionAdditionsCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const restrictionDeletionsCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const accountRestrictionTransactionBody_Reserved1 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const restrictionAdditions = [];
        for (let i = 0; i < (Array.isArray(restrictionAdditionsCount) ? GeneratorUtils_1.GeneratorUtils.compact(restrictionAdditionsCount) : restrictionAdditionsCount); i++) {
            const item = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
            restrictionAdditions.push(item);
            byteArray.splice(0, item.getSize());
        }
        const restrictionDeletions = [];
        for (let i = 0; i < (Array.isArray(restrictionDeletionsCount) ? GeneratorUtils_1.GeneratorUtils.compact(restrictionDeletionsCount) : restrictionDeletionsCount); i++) {
            const item = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
            restrictionDeletions.push(item);
            byteArray.splice(0, item.getSize());
        }
        return new AccountAddressRestrictionTransactionBodyBuilder(restrictionFlags, restrictionAdditions, restrictionDeletions);
    }
    getRestrictionFlags() {
        return this.restrictionFlags;
    }
    getAccountRestrictionTransactionBody_Reserved1() {
        return this.accountRestrictionTransactionBody_Reserved1;
    }
    getRestrictionAdditions() {
        return this.restrictionAdditions;
    }
    getRestrictionDeletions() {
        return this.restrictionDeletions;
    }
    getSize() {
        let size = 0;
        size += 2;
        size += 1;
        size += 1;
        size += 4;
        this.restrictionAdditions.forEach((o) => size += o.getSize());
        this.restrictionDeletions.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const restrictionFlagsBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getRestrictionFlags(), 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionFlagsBytes);
        const restrictionAdditionsCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.restrictionAdditions.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionAdditionsCountBytes);
        const restrictionDeletionsCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.restrictionDeletions.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionDeletionsCountBytes);
        const accountRestrictionTransactionBody_Reserved1Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getAccountRestrictionTransactionBody_Reserved1(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountRestrictionTransactionBody_Reserved1Bytes);
        this.restrictionAdditions.forEach((item) => {
            const restrictionAdditionsBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionAdditionsBytes);
        });
        this.restrictionDeletions.forEach((item) => {
            const restrictionDeletionsBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionDeletionsBytes);
        });
        return newArray;
    }
}
exports.AccountAddressRestrictionTransactionBodyBuilder = AccountAddressRestrictionTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./UnresolvedAddressDto":299}],158:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountAddressRestrictionTransactionBuilder = void 0;
const AccountAddressRestrictionTransactionBodyBuilder_1 = require("./AccountAddressRestrictionTransactionBodyBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const TransactionBuilder_1 = require("./TransactionBuilder");
class AccountAddressRestrictionTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, restrictionFlags, restrictionAdditions, restrictionDeletions) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.accountAddressRestrictionTransactionBody = new AccountAddressRestrictionTransactionBodyBuilder_1.AccountAddressRestrictionTransactionBodyBuilder(restrictionFlags, restrictionAdditions, restrictionDeletions);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const accountAddressRestrictionTransactionBody = AccountAddressRestrictionTransactionBodyBuilder_1.AccountAddressRestrictionTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, accountAddressRestrictionTransactionBody.getSize());
        return new AccountAddressRestrictionTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, accountAddressRestrictionTransactionBody.restrictionFlags, accountAddressRestrictionTransactionBody.restrictionAdditions, accountAddressRestrictionTransactionBody.restrictionDeletions);
    }
    getRestrictionFlags() {
        return this.accountAddressRestrictionTransactionBody.getRestrictionFlags();
    }
    getAccountRestrictionTransactionBody_Reserved1() {
        return this.accountAddressRestrictionTransactionBody.getAccountRestrictionTransactionBody_Reserved1();
    }
    getRestrictionAdditions() {
        return this.accountAddressRestrictionTransactionBody.getRestrictionAdditions();
    }
    getRestrictionDeletions() {
        return this.accountAddressRestrictionTransactionBody.getRestrictionDeletions();
    }
    getSize() {
        let size = super.getSize();
        size += this.accountAddressRestrictionTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const accountAddressRestrictionTransactionBodyBytes = this.accountAddressRestrictionTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountAddressRestrictionTransactionBodyBytes);
        return newArray;
    }
}
exports.AccountAddressRestrictionTransactionBuilder = AccountAddressRestrictionTransactionBuilder;

},{"./AccountAddressRestrictionTransactionBodyBuilder":157,"./GeneratorUtils":220,"./TransactionBuilder":295}],159:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountKeyFlagsDto = void 0;
var AccountKeyFlagsDto;
(function (AccountKeyFlagsDto) {
    AccountKeyFlagsDto[AccountKeyFlagsDto["UNSET"] = 0] = "UNSET";
    AccountKeyFlagsDto[AccountKeyFlagsDto["LINKED"] = 1] = "LINKED";
    AccountKeyFlagsDto[AccountKeyFlagsDto["VRF"] = 2] = "VRF";
    AccountKeyFlagsDto[AccountKeyFlagsDto["VOTING"] = 4] = "VOTING";
    AccountKeyFlagsDto[AccountKeyFlagsDto["NODE"] = 8] = "NODE";
})(AccountKeyFlagsDto = exports.AccountKeyFlagsDto || (exports.AccountKeyFlagsDto = {}));

},{}],160:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountKeyLinkTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const KeyDto_1 = require("./KeyDto");
class AccountKeyLinkTransactionBodyBuilder {
    constructor(linkedPublicKey, linkAction) {
        this.linkedPublicKey = linkedPublicKey;
        this.linkAction = linkAction;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const linkedPublicKey = KeyDto_1.KeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, linkedPublicKey.getSize());
        const linkAction = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        return new AccountKeyLinkTransactionBodyBuilder(linkedPublicKey, linkAction);
    }
    getLinkedPublicKey() {
        return this.linkedPublicKey;
    }
    getLinkAction() {
        return this.linkAction;
    }
    getSize() {
        let size = 0;
        size += this.linkedPublicKey.getSize();
        size += 1;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const linkedPublicKeyBytes = this.linkedPublicKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, linkedPublicKeyBytes);
        const linkActionBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.linkAction, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, linkActionBytes);
        return newArray;
    }
}
exports.AccountKeyLinkTransactionBodyBuilder = AccountKeyLinkTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./KeyDto":235}],161:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountKeyLinkTransactionBuilder = void 0;
const AccountKeyLinkTransactionBodyBuilder_1 = require("./AccountKeyLinkTransactionBodyBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const TransactionBuilder_1 = require("./TransactionBuilder");
class AccountKeyLinkTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, linkedPublicKey, linkAction) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.accountKeyLinkTransactionBody = new AccountKeyLinkTransactionBodyBuilder_1.AccountKeyLinkTransactionBodyBuilder(linkedPublicKey, linkAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const accountKeyLinkTransactionBody = AccountKeyLinkTransactionBodyBuilder_1.AccountKeyLinkTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, accountKeyLinkTransactionBody.getSize());
        return new AccountKeyLinkTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, accountKeyLinkTransactionBody.linkedPublicKey, accountKeyLinkTransactionBody.linkAction);
    }
    getLinkedPublicKey() {
        return this.accountKeyLinkTransactionBody.getLinkedPublicKey();
    }
    getLinkAction() {
        return this.accountKeyLinkTransactionBody.getLinkAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.accountKeyLinkTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const accountKeyLinkTransactionBodyBytes = this.accountKeyLinkTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountKeyLinkTransactionBodyBytes);
        return newArray;
    }
}
exports.AccountKeyLinkTransactionBuilder = AccountKeyLinkTransactionBuilder;

},{"./AccountKeyLinkTransactionBodyBuilder":160,"./GeneratorUtils":220,"./TransactionBuilder":295}],162:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountMetadataTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const UnresolvedAddressDto_1 = require("./UnresolvedAddressDto");
class AccountMetadataTransactionBodyBuilder {
    constructor(targetAddress, scopedMetadataKey, valueSizeDelta, value) {
        this.targetAddress = targetAddress;
        this.scopedMetadataKey = scopedMetadataKey;
        this.valueSizeDelta = valueSizeDelta;
        this.value = value;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const targetAddress = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, targetAddress.getSize());
        const scopedMetadataKey = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const valueSizeDelta = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const valueSize = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const value = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), valueSize);
        byteArray.splice(0, valueSize);
        return new AccountMetadataTransactionBodyBuilder(targetAddress, scopedMetadataKey, valueSizeDelta, value);
    }
    getTargetAddress() {
        return this.targetAddress;
    }
    getScopedMetadataKey() {
        return this.scopedMetadataKey;
    }
    getValueSizeDelta() {
        return this.valueSizeDelta;
    }
    getValue() {
        return this.value;
    }
    getSize() {
        let size = 0;
        size += this.targetAddress.getSize();
        size += 8;
        size += 2;
        size += 2;
        size += this.value.length;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const targetAddressBytes = this.targetAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, targetAddressBytes);
        const scopedMetadataKeyBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getScopedMetadataKey());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, scopedMetadataKeyBytes);
        const valueSizeDeltaBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getValueSizeDelta(), 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, valueSizeDeltaBytes);
        const valueSizeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.value.length, 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, valueSizeBytes);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.value);
        return newArray;
    }
}
exports.AccountMetadataTransactionBodyBuilder = AccountMetadataTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./UnresolvedAddressDto":299}],163:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountMetadataTransactionBuilder = void 0;
const AccountMetadataTransactionBodyBuilder_1 = require("./AccountMetadataTransactionBodyBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const TransactionBuilder_1 = require("./TransactionBuilder");
class AccountMetadataTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, targetAddress, scopedMetadataKey, valueSizeDelta, value) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.accountMetadataTransactionBody = new AccountMetadataTransactionBodyBuilder_1.AccountMetadataTransactionBodyBuilder(targetAddress, scopedMetadataKey, valueSizeDelta, value);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const accountMetadataTransactionBody = AccountMetadataTransactionBodyBuilder_1.AccountMetadataTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, accountMetadataTransactionBody.getSize());
        return new AccountMetadataTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, accountMetadataTransactionBody.targetAddress, accountMetadataTransactionBody.scopedMetadataKey, accountMetadataTransactionBody.valueSizeDelta, accountMetadataTransactionBody.value);
    }
    getTargetAddress() {
        return this.accountMetadataTransactionBody.getTargetAddress();
    }
    getScopedMetadataKey() {
        return this.accountMetadataTransactionBody.getScopedMetadataKey();
    }
    getValueSizeDelta() {
        return this.accountMetadataTransactionBody.getValueSizeDelta();
    }
    getValue() {
        return this.accountMetadataTransactionBody.getValue();
    }
    getSize() {
        let size = super.getSize();
        size += this.accountMetadataTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const accountMetadataTransactionBodyBytes = this.accountMetadataTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountMetadataTransactionBodyBytes);
        return newArray;
    }
}
exports.AccountMetadataTransactionBuilder = AccountMetadataTransactionBuilder;

},{"./AccountMetadataTransactionBodyBuilder":162,"./GeneratorUtils":220,"./TransactionBuilder":295}],164:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountMosaicRestrictionTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const UnresolvedMosaicIdDto_1 = require("./UnresolvedMosaicIdDto");
class AccountMosaicRestrictionTransactionBodyBuilder {
    constructor(restrictionFlags, restrictionAdditions, restrictionDeletions) {
        this.restrictionFlags = restrictionFlags;
        this.accountRestrictionTransactionBody_Reserved1 = 0;
        this.restrictionAdditions = restrictionAdditions;
        this.restrictionDeletions = restrictionDeletions;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const restrictionFlags = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const restrictionAdditionsCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const restrictionDeletionsCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const accountRestrictionTransactionBody_Reserved1 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const restrictionAdditions = [];
        for (let i = 0; i < (Array.isArray(restrictionAdditionsCount) ? GeneratorUtils_1.GeneratorUtils.compact(restrictionAdditionsCount) : restrictionAdditionsCount); i++) {
            const item = UnresolvedMosaicIdDto_1.UnresolvedMosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
            restrictionAdditions.push(item);
            byteArray.splice(0, item.getSize());
        }
        const restrictionDeletions = [];
        for (let i = 0; i < (Array.isArray(restrictionDeletionsCount) ? GeneratorUtils_1.GeneratorUtils.compact(restrictionDeletionsCount) : restrictionDeletionsCount); i++) {
            const item = UnresolvedMosaicIdDto_1.UnresolvedMosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
            restrictionDeletions.push(item);
            byteArray.splice(0, item.getSize());
        }
        return new AccountMosaicRestrictionTransactionBodyBuilder(restrictionFlags, restrictionAdditions, restrictionDeletions);
    }
    getRestrictionFlags() {
        return this.restrictionFlags;
    }
    getAccountRestrictionTransactionBody_Reserved1() {
        return this.accountRestrictionTransactionBody_Reserved1;
    }
    getRestrictionAdditions() {
        return this.restrictionAdditions;
    }
    getRestrictionDeletions() {
        return this.restrictionDeletions;
    }
    getSize() {
        let size = 0;
        size += 2;
        size += 1;
        size += 1;
        size += 4;
        this.restrictionAdditions.forEach((o) => size += o.getSize());
        this.restrictionDeletions.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const restrictionFlagsBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getRestrictionFlags(), 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionFlagsBytes);
        const restrictionAdditionsCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.restrictionAdditions.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionAdditionsCountBytes);
        const restrictionDeletionsCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.restrictionDeletions.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionDeletionsCountBytes);
        const accountRestrictionTransactionBody_Reserved1Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getAccountRestrictionTransactionBody_Reserved1(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountRestrictionTransactionBody_Reserved1Bytes);
        this.restrictionAdditions.forEach((item) => {
            const restrictionAdditionsBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionAdditionsBytes);
        });
        this.restrictionDeletions.forEach((item) => {
            const restrictionDeletionsBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionDeletionsBytes);
        });
        return newArray;
    }
}
exports.AccountMosaicRestrictionTransactionBodyBuilder = AccountMosaicRestrictionTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./UnresolvedMosaicIdDto":301}],165:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountMosaicRestrictionTransactionBuilder = void 0;
const AccountMosaicRestrictionTransactionBodyBuilder_1 = require("./AccountMosaicRestrictionTransactionBodyBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const TransactionBuilder_1 = require("./TransactionBuilder");
class AccountMosaicRestrictionTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, restrictionFlags, restrictionAdditions, restrictionDeletions) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.accountMosaicRestrictionTransactionBody = new AccountMosaicRestrictionTransactionBodyBuilder_1.AccountMosaicRestrictionTransactionBodyBuilder(restrictionFlags, restrictionAdditions, restrictionDeletions);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const accountMosaicRestrictionTransactionBody = AccountMosaicRestrictionTransactionBodyBuilder_1.AccountMosaicRestrictionTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, accountMosaicRestrictionTransactionBody.getSize());
        return new AccountMosaicRestrictionTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, accountMosaicRestrictionTransactionBody.restrictionFlags, accountMosaicRestrictionTransactionBody.restrictionAdditions, accountMosaicRestrictionTransactionBody.restrictionDeletions);
    }
    getRestrictionFlags() {
        return this.accountMosaicRestrictionTransactionBody.getRestrictionFlags();
    }
    getAccountRestrictionTransactionBody_Reserved1() {
        return this.accountMosaicRestrictionTransactionBody.getAccountRestrictionTransactionBody_Reserved1();
    }
    getRestrictionAdditions() {
        return this.accountMosaicRestrictionTransactionBody.getRestrictionAdditions();
    }
    getRestrictionDeletions() {
        return this.accountMosaicRestrictionTransactionBody.getRestrictionDeletions();
    }
    getSize() {
        let size = super.getSize();
        size += this.accountMosaicRestrictionTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const accountMosaicRestrictionTransactionBodyBytes = this.accountMosaicRestrictionTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountMosaicRestrictionTransactionBodyBytes);
        return newArray;
    }
}
exports.AccountMosaicRestrictionTransactionBuilder = AccountMosaicRestrictionTransactionBuilder;

},{"./AccountMosaicRestrictionTransactionBodyBuilder":164,"./GeneratorUtils":220,"./TransactionBuilder":295}],166:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountOperationRestrictionTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class AccountOperationRestrictionTransactionBodyBuilder {
    constructor(restrictionFlags, restrictionAdditions, restrictionDeletions) {
        this.restrictionFlags = restrictionFlags;
        this.accountRestrictionTransactionBody_Reserved1 = 0;
        this.restrictionAdditions = restrictionAdditions;
        this.restrictionDeletions = restrictionDeletions;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const restrictionFlags = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const restrictionAdditionsCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const restrictionDeletionsCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const accountRestrictionTransactionBody_Reserved1 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const restrictionAdditions = [];
        for (let i = 0; i < (Array.isArray(restrictionAdditionsCount) ? GeneratorUtils_1.GeneratorUtils.compact(restrictionAdditionsCount) : restrictionAdditionsCount); i++) {
            const item = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
            restrictionAdditions.push(item);
            byteArray.splice(0, 2);
        }
        const restrictionDeletions = [];
        for (let i = 0; i < (Array.isArray(restrictionDeletionsCount) ? GeneratorUtils_1.GeneratorUtils.compact(restrictionDeletionsCount) : restrictionDeletionsCount); i++) {
            const item = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
            restrictionDeletions.push(item);
            byteArray.splice(0, 2);
        }
        return new AccountOperationRestrictionTransactionBodyBuilder(restrictionFlags, restrictionAdditions, restrictionDeletions);
    }
    getRestrictionFlags() {
        return this.restrictionFlags;
    }
    getAccountRestrictionTransactionBody_Reserved1() {
        return this.accountRestrictionTransactionBody_Reserved1;
    }
    getRestrictionAdditions() {
        return this.restrictionAdditions;
    }
    getRestrictionDeletions() {
        return this.restrictionDeletions;
    }
    getSize() {
        let size = 0;
        size += 2;
        size += 1;
        size += 1;
        size += 4;
        this.restrictionAdditions.forEach(() => size += 2);
        this.restrictionDeletions.forEach(() => size += 2);
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const restrictionFlagsBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getRestrictionFlags(), 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionFlagsBytes);
        const restrictionAdditionsCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.restrictionAdditions.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionAdditionsCountBytes);
        const restrictionDeletionsCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.restrictionDeletions.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionDeletionsCountBytes);
        const accountRestrictionTransactionBody_Reserved1Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getAccountRestrictionTransactionBody_Reserved1(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountRestrictionTransactionBody_Reserved1Bytes);
        this.restrictionAdditions.forEach((item) => {
            const restrictionAdditionsBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(item, 2);
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionAdditionsBytes);
        });
        this.restrictionDeletions.forEach((item) => {
            const restrictionDeletionsBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(item, 2);
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionDeletionsBytes);
        });
        return newArray;
    }
}
exports.AccountOperationRestrictionTransactionBodyBuilder = AccountOperationRestrictionTransactionBodyBuilder;

},{"./GeneratorUtils":220}],167:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountOperationRestrictionTransactionBuilder = void 0;
const AccountOperationRestrictionTransactionBodyBuilder_1 = require("./AccountOperationRestrictionTransactionBodyBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const TransactionBuilder_1 = require("./TransactionBuilder");
class AccountOperationRestrictionTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, restrictionFlags, restrictionAdditions, restrictionDeletions) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.accountOperationRestrictionTransactionBody = new AccountOperationRestrictionTransactionBodyBuilder_1.AccountOperationRestrictionTransactionBodyBuilder(restrictionFlags, restrictionAdditions, restrictionDeletions);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const accountOperationRestrictionTransactionBody = AccountOperationRestrictionTransactionBodyBuilder_1.AccountOperationRestrictionTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, accountOperationRestrictionTransactionBody.getSize());
        return new AccountOperationRestrictionTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, accountOperationRestrictionTransactionBody.restrictionFlags, accountOperationRestrictionTransactionBody.restrictionAdditions, accountOperationRestrictionTransactionBody.restrictionDeletions);
    }
    getRestrictionFlags() {
        return this.accountOperationRestrictionTransactionBody.getRestrictionFlags();
    }
    getAccountRestrictionTransactionBody_Reserved1() {
        return this.accountOperationRestrictionTransactionBody.getAccountRestrictionTransactionBody_Reserved1();
    }
    getRestrictionAdditions() {
        return this.accountOperationRestrictionTransactionBody.getRestrictionAdditions();
    }
    getRestrictionDeletions() {
        return this.accountOperationRestrictionTransactionBody.getRestrictionDeletions();
    }
    getSize() {
        let size = super.getSize();
        size += this.accountOperationRestrictionTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const accountOperationRestrictionTransactionBodyBytes = this.accountOperationRestrictionTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountOperationRestrictionTransactionBodyBytes);
        return newArray;
    }
}
exports.AccountOperationRestrictionTransactionBuilder = AccountOperationRestrictionTransactionBuilder;

},{"./AccountOperationRestrictionTransactionBodyBuilder":166,"./GeneratorUtils":220,"./TransactionBuilder":295}],168:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountRestrictionAddressValueBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
class AccountRestrictionAddressValueBuilder {
    constructor(restrictionValues) {
        this.restrictionValues = restrictionValues;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const restrictionValuesCount = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const restrictionValues = [];
        for (let i = 0; i < (Array.isArray(restrictionValuesCount) ? GeneratorUtils_1.GeneratorUtils.compact(restrictionValuesCount) : restrictionValuesCount); i++) {
            const item = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
            restrictionValues.push(item);
            byteArray.splice(0, item.getSize());
        }
        return new AccountRestrictionAddressValueBuilder(restrictionValues);
    }
    getRestrictionValues() {
        return this.restrictionValues;
    }
    getSize() {
        let size = 0;
        size += 8;
        this.restrictionValues.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const restrictionValuesCountBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(GeneratorUtils_1.GeneratorUtils.fromUint(this.restrictionValues.length));
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionValuesCountBytes);
        this.restrictionValues.forEach((item) => {
            const restrictionValuesBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionValuesBytes);
        });
        return newArray;
    }
}
exports.AccountRestrictionAddressValueBuilder = AccountRestrictionAddressValueBuilder;

},{"./AddressDto":178,"./GeneratorUtils":220}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountRestrictionFlagsDto = void 0;
var AccountRestrictionFlagsDto;
(function (AccountRestrictionFlagsDto) {
    AccountRestrictionFlagsDto[AccountRestrictionFlagsDto["ADDRESS"] = 1] = "ADDRESS";
    AccountRestrictionFlagsDto[AccountRestrictionFlagsDto["MOSAIC_ID"] = 2] = "MOSAIC_ID";
    AccountRestrictionFlagsDto[AccountRestrictionFlagsDto["TRANSACTION_TYPE"] = 4] = "TRANSACTION_TYPE";
    AccountRestrictionFlagsDto[AccountRestrictionFlagsDto["OUTGOING"] = 16384] = "OUTGOING";
    AccountRestrictionFlagsDto[AccountRestrictionFlagsDto["BLOCK"] = 32768] = "BLOCK";
})(AccountRestrictionFlagsDto = exports.AccountRestrictionFlagsDto || (exports.AccountRestrictionFlagsDto = {}));

},{}],170:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountRestrictionMosaicValueBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicIdDto_1 = require("./MosaicIdDto");
class AccountRestrictionMosaicValueBuilder {
    constructor(restrictionValues) {
        this.restrictionValues = restrictionValues;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const restrictionValuesCount = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const restrictionValues = [];
        for (let i = 0; i < (Array.isArray(restrictionValuesCount) ? GeneratorUtils_1.GeneratorUtils.compact(restrictionValuesCount) : restrictionValuesCount); i++) {
            const item = MosaicIdDto_1.MosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
            restrictionValues.push(item);
            byteArray.splice(0, item.getSize());
        }
        return new AccountRestrictionMosaicValueBuilder(restrictionValues);
    }
    getRestrictionValues() {
        return this.restrictionValues;
    }
    getSize() {
        let size = 0;
        size += 8;
        this.restrictionValues.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const restrictionValuesCountBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(GeneratorUtils_1.GeneratorUtils.fromUint(this.restrictionValues.length));
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionValuesCountBytes);
        this.restrictionValues.forEach((item) => {
            const restrictionValuesBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionValuesBytes);
        });
        return newArray;
    }
}
exports.AccountRestrictionMosaicValueBuilder = AccountRestrictionMosaicValueBuilder;

},{"./GeneratorUtils":220,"./MosaicIdDto":252}],171:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountRestrictionTransactionTypeValueBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class AccountRestrictionTransactionTypeValueBuilder {
    constructor(restrictionValues) {
        this.restrictionValues = restrictionValues;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const restrictionValuesCount = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const restrictionValues = [];
        for (let i = 0; i < (Array.isArray(restrictionValuesCount) ? GeneratorUtils_1.GeneratorUtils.compact(restrictionValuesCount) : restrictionValuesCount); i++) {
            const item = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
            restrictionValues.push(item);
            byteArray.splice(0, 2);
        }
        return new AccountRestrictionTransactionTypeValueBuilder(restrictionValues);
    }
    getRestrictionValues() {
        return this.restrictionValues;
    }
    getSize() {
        let size = 0;
        size += 8;
        this.restrictionValues.forEach(() => size += 2);
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const restrictionValuesCountBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(GeneratorUtils_1.GeneratorUtils.fromUint(this.restrictionValues.length));
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionValuesCountBytes);
        this.restrictionValues.forEach((item) => {
            const restrictionValuesBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(item, 2);
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionValuesBytes);
        });
        return newArray;
    }
}
exports.AccountRestrictionTransactionTypeValueBuilder = AccountRestrictionTransactionTypeValueBuilder;

},{"./GeneratorUtils":220}],172:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountRestrictionsBuilder = void 0;
const AccountRestrictionsInfoBuilder_1 = require("./AccountRestrictionsInfoBuilder");
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
class AccountRestrictionsBuilder {
    constructor(address, restrictions) {
        this.address = address;
        this.restrictions = restrictions;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const address = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, address.getSize());
        const restrictionsCount = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const restrictions = [];
        for (let i = 0; i < (Array.isArray(restrictionsCount) ? GeneratorUtils_1.GeneratorUtils.compact(restrictionsCount) : restrictionsCount); i++) {
            const item = AccountRestrictionsInfoBuilder_1.AccountRestrictionsInfoBuilder.loadFromBinary(Uint8Array.from(byteArray));
            restrictions.push(item);
            byteArray.splice(0, item.getSize());
        }
        return new AccountRestrictionsBuilder(address, restrictions);
    }
    getAddress() {
        return this.address;
    }
    getRestrictions() {
        return this.restrictions;
    }
    getSize() {
        let size = 0;
        size += this.address.getSize();
        size += 8;
        this.restrictions.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const addressBytes = this.address.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressBytes);
        const restrictionsCountBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(GeneratorUtils_1.GeneratorUtils.fromUint(this.restrictions.length));
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionsCountBytes);
        this.restrictions.forEach((item) => {
            const restrictionsBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionsBytes);
        });
        return newArray;
    }
}
exports.AccountRestrictionsBuilder = AccountRestrictionsBuilder;

},{"./AccountRestrictionsInfoBuilder":173,"./AddressDto":178,"./GeneratorUtils":220}],173:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountRestrictionsInfoBuilder = void 0;
const AccountRestrictionAddressValueBuilder_1 = require("./AccountRestrictionAddressValueBuilder");
const AccountRestrictionFlagsDto_1 = require("./AccountRestrictionFlagsDto");
const AccountRestrictionMosaicValueBuilder_1 = require("./AccountRestrictionMosaicValueBuilder");
const AccountRestrictionTransactionTypeValueBuilder_1 = require("./AccountRestrictionTransactionTypeValueBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
class AccountRestrictionsInfoBuilder {
    constructor(restrictionFlags, addressRestrictions, mosaicIdRestrictions, transactionTypeRestrictions) {
        this.restrictionFlags = restrictionFlags;
        this.addressRestrictions = addressRestrictions;
        this.mosaicIdRestrictions = mosaicIdRestrictions;
        this.transactionTypeRestrictions = transactionTypeRestrictions;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const restrictionFlags = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const restrictionFlagsConditionBytes = Uint8Array.from(byteArray.slice(0, 1));
        byteArray.splice(0, 1);
        let addressRestrictions;
        if (restrictionFlags & AccountRestrictionFlagsDto_1.AccountRestrictionFlagsDto.ADDRESS) {
            addressRestrictions = AccountRestrictionAddressValueBuilder_1.AccountRestrictionAddressValueBuilder.loadFromBinary(restrictionFlagsConditionBytes);
        }
        let mosaicIdRestrictions;
        if (restrictionFlags & AccountRestrictionFlagsDto_1.AccountRestrictionFlagsDto.MOSAIC_ID) {
            mosaicIdRestrictions = AccountRestrictionMosaicValueBuilder_1.AccountRestrictionMosaicValueBuilder.loadFromBinary(restrictionFlagsConditionBytes);
        }
        let transactionTypeRestrictions;
        if (restrictionFlags & AccountRestrictionFlagsDto_1.AccountRestrictionFlagsDto.TRANSACTION_TYPE) {
            transactionTypeRestrictions = AccountRestrictionTransactionTypeValueBuilder_1.AccountRestrictionTransactionTypeValueBuilder.loadFromBinary(restrictionFlagsConditionBytes);
        }
        return new AccountRestrictionsInfoBuilder(restrictionFlags, addressRestrictions, mosaicIdRestrictions, transactionTypeRestrictions);
    }
    getRestrictionFlags() {
        return this.restrictionFlags;
    }
    getAddressRestrictions() {
        if (this.restrictionFlags & AccountRestrictionFlagsDto_1.AccountRestrictionFlagsDto.ADDRESS) {
            throw new Error('restrictionFlags is not set to ADDRESS.');
        }
        return this.addressRestrictions;
    }
    getMosaicIdRestrictions() {
        if (this.restrictionFlags & AccountRestrictionFlagsDto_1.AccountRestrictionFlagsDto.MOSAIC_ID) {
            throw new Error('restrictionFlags is not set to MOSAIC_ID.');
        }
        return this.mosaicIdRestrictions;
    }
    getTransactionTypeRestrictions() {
        if (this.restrictionFlags & AccountRestrictionFlagsDto_1.AccountRestrictionFlagsDto.TRANSACTION_TYPE) {
            throw new Error('restrictionFlags is not set to TRANSACTION_TYPE.');
        }
        return this.transactionTypeRestrictions;
    }
    getSize() {
        let size = 0;
        size += 2;
        if (this.restrictionFlags & AccountRestrictionFlagsDto_1.AccountRestrictionFlagsDto.ADDRESS) {
            size += this.addressRestrictions.getSize();
        }
        if (this.restrictionFlags & AccountRestrictionFlagsDto_1.AccountRestrictionFlagsDto.MOSAIC_ID) {
            size += this.mosaicIdRestrictions.getSize();
        }
        if (this.restrictionFlags & AccountRestrictionFlagsDto_1.AccountRestrictionFlagsDto.TRANSACTION_TYPE) {
            size += this.transactionTypeRestrictions.getSize();
        }
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const restrictionFlagsBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getRestrictionFlags(), 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionFlagsBytes);
        if (this.restrictionFlags & AccountRestrictionFlagsDto_1.AccountRestrictionFlagsDto.ADDRESS) {
            const addressRestrictionsBytes = this.addressRestrictions.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressRestrictionsBytes);
        }
        if (this.restrictionFlags & AccountRestrictionFlagsDto_1.AccountRestrictionFlagsDto.MOSAIC_ID) {
            const mosaicIdRestrictionsBytes = this.mosaicIdRestrictions.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicIdRestrictionsBytes);
        }
        if (this.restrictionFlags & AccountRestrictionFlagsDto_1.AccountRestrictionFlagsDto.TRANSACTION_TYPE) {
            const transactionTypeRestrictionsBytes = this.transactionTypeRestrictions.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, transactionTypeRestrictionsBytes);
        }
        return newArray;
    }
}
exports.AccountRestrictionsInfoBuilder = AccountRestrictionsInfoBuilder;

},{"./AccountRestrictionAddressValueBuilder":168,"./AccountRestrictionFlagsDto":169,"./AccountRestrictionMosaicValueBuilder":170,"./AccountRestrictionTransactionTypeValueBuilder":171,"./GeneratorUtils":220}],174:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountStateBuilder = void 0;
const AccountKeyFlagsDto_1 = require("./AccountKeyFlagsDto");
const AccountStateFormatDto_1 = require("./AccountStateFormatDto");
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const HeightActivityBucketsBuilder_1 = require("./HeightActivityBucketsBuilder");
const HeightDto_1 = require("./HeightDto");
const ImportanceSnapshotBuilder_1 = require("./ImportanceSnapshotBuilder");
const KeyDto_1 = require("./KeyDto");
const MosaicBuilder_1 = require("./MosaicBuilder");
const VotingKeyDto_1 = require("./VotingKeyDto");
class AccountStateBuilder {
    constructor(address, addressHeight, publicKey, publicKeyHeight, accountType, supplementalAccountKeysMask, balances, linkedPublicKey, vrfPublicKey, votingPublicKey, nodePublicKey, importanceSnapshots, activityBuckets) {
        this.address = address;
        this.addressHeight = addressHeight;
        this.publicKey = publicKey;
        this.publicKeyHeight = publicKeyHeight;
        this.accountType = accountType;
        this.supplementalAccountKeysMask = supplementalAccountKeysMask;
        this.linkedPublicKey = linkedPublicKey;
        this.vrfPublicKey = vrfPublicKey;
        this.votingPublicKey = votingPublicKey;
        this.nodePublicKey = nodePublicKey;
        this.importanceSnapshots = importanceSnapshots;
        this.activityBuckets = activityBuckets;
        this.balances = balances;
        if (importanceSnapshots) {
            this.format = AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE;
        }
        else {
            this.format = AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE;
        }
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const address = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, address.getSize());
        const addressHeight = HeightDto_1.HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, addressHeight.getSize());
        const publicKey = KeyDto_1.KeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, publicKey.getSize());
        const publicKeyHeight = HeightDto_1.HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, publicKeyHeight.getSize());
        const accountType = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const format = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const supplementalAccountKeysMask = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const supplementalAccountKeysMaskConditionBytes = Uint8Array.from(byteArray.slice(0, 32));
        byteArray.splice(0, 32);
        const formatConditionBytes = Uint8Array.from(byteArray.slice(0, 1));
        byteArray.splice(0, 1);
        const balancesCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const balances = [];
        for (let i = 0; i < (Array.isArray(balancesCount) ? GeneratorUtils_1.GeneratorUtils.compact(balancesCount) : balancesCount); i++) {
            const item = MosaicBuilder_1.MosaicBuilder.loadFromBinary(Uint8Array.from(byteArray));
            balances.push(item);
            byteArray.splice(0, item.getSize());
        }
        let linkedPublicKey;
        if (supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.LINKED) {
            linkedPublicKey = KeyDto_1.KeyDto.loadFromBinary(supplementalAccountKeysMaskConditionBytes);
        }
        let vrfPublicKey;
        if (supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.VRF) {
            vrfPublicKey = KeyDto_1.KeyDto.loadFromBinary(supplementalAccountKeysMaskConditionBytes);
        }
        let votingPublicKey;
        if (supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.VOTING) {
            votingPublicKey = VotingKeyDto_1.VotingKeyDto.loadFromBinary(supplementalAccountKeysMaskConditionBytes);
        }
        let nodePublicKey;
        if (supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.NODE) {
            nodePublicKey = KeyDto_1.KeyDto.loadFromBinary(supplementalAccountKeysMaskConditionBytes);
        }
        let importanceSnapshots;
        if (format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            importanceSnapshots = ImportanceSnapshotBuilder_1.ImportanceSnapshotBuilder.loadFromBinary(formatConditionBytes);
        }
        let activityBuckets;
        if (format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            activityBuckets = HeightActivityBucketsBuilder_1.HeightActivityBucketsBuilder.loadFromBinary(formatConditionBytes);
        }
        return new AccountStateBuilder(address, addressHeight, publicKey, publicKeyHeight, accountType, supplementalAccountKeysMask, balances, linkedPublicKey, vrfPublicKey, votingPublicKey, nodePublicKey, importanceSnapshots, activityBuckets);
    }
    getAddress() {
        return this.address;
    }
    getAddressHeight() {
        return this.addressHeight;
    }
    getPublicKey() {
        return this.publicKey;
    }
    getPublicKeyHeight() {
        return this.publicKeyHeight;
    }
    getAccountType() {
        return this.accountType;
    }
    getFormat() {
        return this.format;
    }
    getSupplementalAccountKeysMask() {
        return this.supplementalAccountKeysMask;
    }
    getLinkedPublicKey() {
        if (this.supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.LINKED) {
            throw new Error('supplementalAccountKeysMask is not set to LINKED.');
        }
        return this.linkedPublicKey;
    }
    getVrfPublicKey() {
        if (this.supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.VRF) {
            throw new Error('supplementalAccountKeysMask is not set to VRF.');
        }
        return this.vrfPublicKey;
    }
    getVotingPublicKey() {
        if (this.supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.VOTING) {
            throw new Error('supplementalAccountKeysMask is not set to VOTING.');
        }
        return this.votingPublicKey;
    }
    getNodePublicKey() {
        if (this.supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.NODE) {
            throw new Error('supplementalAccountKeysMask is not set to NODE.');
        }
        return this.nodePublicKey;
    }
    getImportanceSnapshots() {
        if (this.format !== AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            throw new Error('format is not set to HIGH_VALUE.');
        }
        return this.importanceSnapshots;
    }
    getActivityBuckets() {
        if (this.format !== AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            throw new Error('format is not set to HIGH_VALUE.');
        }
        return this.activityBuckets;
    }
    getBalances() {
        return this.balances;
    }
    getSize() {
        let size = 0;
        size += this.address.getSize();
        size += this.addressHeight.getSize();
        size += this.publicKey.getSize();
        size += this.publicKeyHeight.getSize();
        size += 1;
        size += 1;
        size += 1;
        if (this.supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.LINKED) {
            size += this.linkedPublicKey.getSize();
        }
        if (this.supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.VRF) {
            size += this.vrfPublicKey.getSize();
        }
        if (this.supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.VOTING) {
            size += this.votingPublicKey.getSize();
        }
        if (this.supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.NODE) {
            size += this.nodePublicKey.getSize();
        }
        if (this.format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            size += this.importanceSnapshots.getSize();
        }
        if (this.format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            size += this.activityBuckets.getSize();
        }
        size += 2;
        this.balances.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const addressBytes = this.address.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressBytes);
        const addressHeightBytes = this.addressHeight.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressHeightBytes);
        const publicKeyBytes = this.publicKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, publicKeyBytes);
        const publicKeyHeightBytes = this.publicKeyHeight.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, publicKeyHeightBytes);
        const accountTypeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.accountType, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountTypeBytes);
        const formatBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.format, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, formatBytes);
        const supplementalAccountKeysMaskBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getSupplementalAccountKeysMask(), 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, supplementalAccountKeysMaskBytes);
        if (this.supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.LINKED) {
            const linkedPublicKeyBytes = this.linkedPublicKey.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, linkedPublicKeyBytes);
        }
        if (this.supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.VRF) {
            const vrfPublicKeyBytes = this.vrfPublicKey.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, vrfPublicKeyBytes);
        }
        if (this.supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.VOTING) {
            const votingPublicKeyBytes = this.votingPublicKey.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, votingPublicKeyBytes);
        }
        if (this.supplementalAccountKeysMask & AccountKeyFlagsDto_1.AccountKeyFlagsDto.NODE) {
            const nodePublicKeyBytes = this.nodePublicKey.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, nodePublicKeyBytes);
        }
        if (this.format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            const importanceSnapshotsBytes = this.importanceSnapshots.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, importanceSnapshotsBytes);
        }
        if (this.format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            const activityBucketsBytes = this.activityBuckets.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, activityBucketsBytes);
        }
        const balancesCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.balances.length, 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, balancesCountBytes);
        this.balances.forEach((item) => {
            const balancesBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, balancesBytes);
        });
        return newArray;
    }
}
exports.AccountStateBuilder = AccountStateBuilder;

},{"./AccountKeyFlagsDto":159,"./AccountStateFormatDto":175,"./AddressDto":178,"./GeneratorUtils":220,"./HeightActivityBucketsBuilder":229,"./HeightDto":230,"./ImportanceSnapshotBuilder":233,"./KeyDto":235,"./MosaicBuilder":243,"./VotingKeyDto":302}],175:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountStateFormatDto = void 0;
var AccountStateFormatDto;
(function (AccountStateFormatDto) {
    AccountStateFormatDto[AccountStateFormatDto["REGULAR"] = 0] = "REGULAR";
    AccountStateFormatDto[AccountStateFormatDto["HIGH_VALUE"] = 1] = "HIGH_VALUE";
})(AccountStateFormatDto = exports.AccountStateFormatDto || (exports.AccountStateFormatDto = {}));

},{}],176:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressAliasTransactionBodyBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const NamespaceIdDto_1 = require("./NamespaceIdDto");
class AddressAliasTransactionBodyBuilder {
    constructor(namespaceId, address, aliasAction) {
        this.namespaceId = namespaceId;
        this.address = address;
        this.aliasAction = aliasAction;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const namespaceId = NamespaceIdDto_1.NamespaceIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, namespaceId.getSize());
        const address = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, address.getSize());
        const aliasAction = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        return new AddressAliasTransactionBodyBuilder(namespaceId, address, aliasAction);
    }
    getNamespaceId() {
        return this.namespaceId;
    }
    getAddress() {
        return this.address;
    }
    getAliasAction() {
        return this.aliasAction;
    }
    getSize() {
        let size = 0;
        size += this.namespaceId.getSize();
        size += this.address.getSize();
        size += 1;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const namespaceIdBytes = this.namespaceId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, namespaceIdBytes);
        const addressBytes = this.address.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressBytes);
        const aliasActionBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.aliasAction, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, aliasActionBytes);
        return newArray;
    }
}
exports.AddressAliasTransactionBodyBuilder = AddressAliasTransactionBodyBuilder;

},{"./AddressDto":178,"./GeneratorUtils":220,"./NamespaceIdDto":270}],177:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressAliasTransactionBuilder = void 0;
const AddressAliasTransactionBodyBuilder_1 = require("./AddressAliasTransactionBodyBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const TransactionBuilder_1 = require("./TransactionBuilder");
class AddressAliasTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, namespaceId, address, aliasAction) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.addressAliasTransactionBody = new AddressAliasTransactionBodyBuilder_1.AddressAliasTransactionBodyBuilder(namespaceId, address, aliasAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const addressAliasTransactionBody = AddressAliasTransactionBodyBuilder_1.AddressAliasTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, addressAliasTransactionBody.getSize());
        return new AddressAliasTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, addressAliasTransactionBody.namespaceId, addressAliasTransactionBody.address, addressAliasTransactionBody.aliasAction);
    }
    getNamespaceId() {
        return this.addressAliasTransactionBody.getNamespaceId();
    }
    getAddress() {
        return this.addressAliasTransactionBody.getAddress();
    }
    getAliasAction() {
        return this.addressAliasTransactionBody.getAliasAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.addressAliasTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const addressAliasTransactionBodyBytes = this.addressAliasTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressAliasTransactionBodyBytes);
        return newArray;
    }
}
exports.AddressAliasTransactionBuilder = AddressAliasTransactionBuilder;

},{"./AddressAliasTransactionBodyBuilder":176,"./GeneratorUtils":220,"./TransactionBuilder":295}],178:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class AddressDto {
    constructor(address) {
        this.address = address;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const address = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 24);
        byteArray.splice(0, 24);
        return new AddressDto(address);
    }
    getAddress() {
        return this.address;
    }
    getSize() {
        return 24;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.address);
        return newArray;
    }
}
exports.AddressDto = AddressDto;

},{"./GeneratorUtils":220}],179:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressKeyValueBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicRestrictionKeyDto_1 = require("./MosaicRestrictionKeyDto");
class AddressKeyValueBuilder {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const key = MosaicRestrictionKeyDto_1.MosaicRestrictionKeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, key.getSize());
        const value = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new AddressKeyValueBuilder(key, value);
    }
    getKey() {
        return this.key;
    }
    getValue() {
        return this.value;
    }
    getSize() {
        let size = 0;
        size += this.key.getSize();
        size += 8;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const keyBytes = this.key.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, keyBytes);
        const valueBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getValue());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, valueBytes);
        return newArray;
    }
}
exports.AddressKeyValueBuilder = AddressKeyValueBuilder;

},{"./GeneratorUtils":220,"./MosaicRestrictionKeyDto":261}],180:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressKeyValueSetBuilder = void 0;
const AddressKeyValueBuilder_1 = require("./AddressKeyValueBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
class AddressKeyValueSetBuilder {
    constructor(keys) {
        this.keys = keys;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const keyValueCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const keys = [];
        for (let i = 0; i < (Array.isArray(keyValueCount) ? GeneratorUtils_1.GeneratorUtils.compact(keyValueCount) : keyValueCount); i++) {
            const item = AddressKeyValueBuilder_1.AddressKeyValueBuilder.loadFromBinary(Uint8Array.from(byteArray));
            keys.push(item);
            byteArray.splice(0, item.getSize());
        }
        return new AddressKeyValueSetBuilder(keys);
    }
    getKeys() {
        return this.keys;
    }
    getSize() {
        let size = 0;
        size += 1;
        this.keys.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const keyValueCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.keys.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, keyValueCountBytes);
        this.keys.forEach((item) => {
            const keysBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, keysBytes);
        });
        return newArray;
    }
}
exports.AddressKeyValueSetBuilder = AddressKeyValueSetBuilder;

},{"./AddressKeyValueBuilder":179,"./GeneratorUtils":220}],181:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressResolutionEntryBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const ReceiptSourceBuilder_1 = require("./ReceiptSourceBuilder");
class AddressResolutionEntryBuilder {
    constructor(source, resolved) {
        this.source = source;
        this.resolved = resolved;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const source = ReceiptSourceBuilder_1.ReceiptSourceBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, source.getSize());
        const resolved = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, resolved.getSize());
        return new AddressResolutionEntryBuilder(source, resolved);
    }
    getSource() {
        return this.source;
    }
    getResolved() {
        return this.resolved;
    }
    getSize() {
        let size = 0;
        size += this.source.getSize();
        size += this.resolved.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const sourceBytes = this.source.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, sourceBytes);
        const resolvedBytes = this.resolved.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, resolvedBytes);
        return newArray;
    }
}
exports.AddressResolutionEntryBuilder = AddressResolutionEntryBuilder;

},{"./AddressDto":178,"./GeneratorUtils":220,"./ReceiptSourceBuilder":284}],182:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressResolutionStatementBuilder = void 0;
const AddressResolutionEntryBuilder_1 = require("./AddressResolutionEntryBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const ReceiptBuilder_1 = require("./ReceiptBuilder");
const UnresolvedAddressDto_1 = require("./UnresolvedAddressDto");
class AddressResolutionStatementBuilder extends ReceiptBuilder_1.ReceiptBuilder {
    constructor(version, type, unresolved, resolutionEntries) {
        super(version, type);
        this.unresolved = unresolved;
        this.resolutionEntries = resolutionEntries;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = ReceiptBuilder_1.ReceiptBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const unresolved = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, unresolved.getSize());
        let resolutionEntriesByteSize = byteArray.length;
        const resolutionEntries = [];
        while (resolutionEntriesByteSize > 0) {
            const item = AddressResolutionEntryBuilder_1.AddressResolutionEntryBuilder.loadFromBinary(Uint8Array.from(byteArray));
            resolutionEntries.push(item);
            const itemSize = item.getSize();
            resolutionEntriesByteSize -= itemSize;
            byteArray.splice(0, itemSize);
        }
        return new AddressResolutionStatementBuilder(superObject.version, superObject.type, unresolved, resolutionEntries);
    }
    getUnresolved() {
        return this.unresolved;
    }
    getResolutionEntries() {
        return this.resolutionEntries;
    }
    getSize() {
        let size = super.getSize();
        size += this.unresolved.getSize();
        this.resolutionEntries.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const unresolvedBytes = this.unresolved.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, unresolvedBytes);
        this.resolutionEntries.forEach((item) => {
            const resolutionEntriesBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, resolutionEntriesBytes);
        });
        return newArray;
    }
}
exports.AddressResolutionStatementBuilder = AddressResolutionStatementBuilder;

},{"./AddressResolutionEntryBuilder":181,"./GeneratorUtils":220,"./ReceiptBuilder":283,"./UnresolvedAddressDto":299}],183:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregateBondedTransactionBuilder = void 0;
const AggregateTransactionBodyBuilder_1 = require("./AggregateTransactionBodyBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const TransactionBuilder_1 = require("./TransactionBuilder");
class AggregateBondedTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, transactionsHash, transactions, cosignatures) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.aggregateTransactionBody = new AggregateTransactionBodyBuilder_1.AggregateTransactionBodyBuilder(transactionsHash, transactions, cosignatures);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const aggregateTransactionBody = AggregateTransactionBodyBuilder_1.AggregateTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, aggregateTransactionBody.getSize());
        return new AggregateBondedTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, aggregateTransactionBody.transactionsHash, aggregateTransactionBody.transactions, aggregateTransactionBody.cosignatures);
    }
    getTransactionsHash() {
        return this.aggregateTransactionBody.getTransactionsHash();
    }
    getAggregateTransactionHeader_Reserved1() {
        return this.aggregateTransactionBody.getAggregateTransactionHeader_Reserved1();
    }
    getTransactions() {
        return this.aggregateTransactionBody.getTransactions();
    }
    getCosignatures() {
        return this.aggregateTransactionBody.getCosignatures();
    }
    getSize() {
        let size = super.getSize();
        size += this.aggregateTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const aggregateTransactionBodyBytes = this.aggregateTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, aggregateTransactionBodyBytes);
        return newArray;
    }
}
exports.AggregateBondedTransactionBuilder = AggregateBondedTransactionBuilder;

},{"./AggregateTransactionBodyBuilder":185,"./GeneratorUtils":220,"./TransactionBuilder":295}],184:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregateCompleteTransactionBuilder = void 0;
const AggregateTransactionBodyBuilder_1 = require("./AggregateTransactionBodyBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const TransactionBuilder_1 = require("./TransactionBuilder");
class AggregateCompleteTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, transactionsHash, transactions, cosignatures) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.aggregateTransactionBody = new AggregateTransactionBodyBuilder_1.AggregateTransactionBodyBuilder(transactionsHash, transactions, cosignatures);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const aggregateTransactionBody = AggregateTransactionBodyBuilder_1.AggregateTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, aggregateTransactionBody.getSize());
        return new AggregateCompleteTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, aggregateTransactionBody.transactionsHash, aggregateTransactionBody.transactions, aggregateTransactionBody.cosignatures);
    }
    getTransactionsHash() {
        return this.aggregateTransactionBody.getTransactionsHash();
    }
    getAggregateTransactionHeader_Reserved1() {
        return this.aggregateTransactionBody.getAggregateTransactionHeader_Reserved1();
    }
    getTransactions() {
        return this.aggregateTransactionBody.getTransactions();
    }
    getCosignatures() {
        return this.aggregateTransactionBody.getCosignatures();
    }
    getSize() {
        let size = super.getSize();
        size += this.aggregateTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const aggregateTransactionBodyBytes = this.aggregateTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, aggregateTransactionBodyBytes);
        return newArray;
    }
}
exports.AggregateCompleteTransactionBuilder = AggregateCompleteTransactionBuilder;

},{"./AggregateTransactionBodyBuilder":185,"./GeneratorUtils":220,"./TransactionBuilder":295}],185:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregateTransactionBodyBuilder = void 0;
const CosignatureBuilder_1 = require("./CosignatureBuilder");
const EmbeddedTransactionHelper_1 = require("./EmbeddedTransactionHelper");
const GeneratorUtils_1 = require("./GeneratorUtils");
const Hash256Dto_1 = require("./Hash256Dto");
class AggregateTransactionBodyBuilder {
    constructor(transactionsHash, transactions, cosignatures) {
        this.transactionsHash = transactionsHash;
        this.aggregateTransactionHeader_Reserved1 = 0;
        this.transactions = transactions;
        this.cosignatures = cosignatures;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const transactionsHash = Hash256Dto_1.Hash256Dto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, transactionsHash.getSize());
        const payloadSize = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const aggregateTransactionHeader_Reserved1 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        let transactionsByteSize = payloadSize;
        const transactions = [];
        while (transactionsByteSize > 0) {
            const item = EmbeddedTransactionHelper_1.EmbeddedTransactionHelper.loadFromBinary(Uint8Array.from(byteArray));
            transactions.push(item);
            const itemSize = item.getSize() + GeneratorUtils_1.GeneratorUtils.getTransactionPaddingSize(item.getSize(), 8);
            transactionsByteSize -= itemSize;
            byteArray.splice(0, itemSize);
        }
        let cosignaturesByteSize = byteArray.length;
        const cosignatures = [];
        while (cosignaturesByteSize > 0) {
            const item = CosignatureBuilder_1.CosignatureBuilder.loadFromBinary(Uint8Array.from(byteArray));
            cosignatures.push(item);
            const itemSize = item.getSize();
            cosignaturesByteSize -= itemSize;
            byteArray.splice(0, itemSize);
        }
        return new AggregateTransactionBodyBuilder(transactionsHash, transactions, cosignatures);
    }
    getTransactionsHash() {
        return this.transactionsHash;
    }
    getAggregateTransactionHeader_Reserved1() {
        return this.aggregateTransactionHeader_Reserved1;
    }
    getTransactions() {
        return this.transactions;
    }
    getCosignatures() {
        return this.cosignatures;
    }
    getSize() {
        let size = 0;
        size += this.transactionsHash.getSize();
        size += 4;
        size += 4;
        this.transactions.forEach((o) => size += EmbeddedTransactionHelper_1.EmbeddedTransactionHelper.serialize(o).length);
        this.cosignatures.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const transactionsHashBytes = this.transactionsHash.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, transactionsHashBytes);
        const payloadSizeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(EmbeddedTransactionHelper_1.EmbeddedTransactionHelper.getEmbeddedTransactionSize(this.transactions), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, payloadSizeBytes);
        const aggregateTransactionHeader_Reserved1Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getAggregateTransactionHeader_Reserved1(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, aggregateTransactionHeader_Reserved1Bytes);
        this.transactions.forEach((item) => {
            const transactionsBytes = EmbeddedTransactionHelper_1.EmbeddedTransactionHelper.serialize(item);
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, transactionsBytes);
        });
        this.cosignatures.forEach((item) => {
            const cosignaturesBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, cosignaturesBytes);
        });
        return newArray;
    }
}
exports.AggregateTransactionBodyBuilder = AggregateTransactionBodyBuilder;

},{"./CosignatureBuilder":192,"./EmbeddedTransactionHelper":215,"./GeneratorUtils":220,"./Hash256Dto":223}],186:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmountDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class AmountDto {
    constructor(amount) {
        this.amount = amount;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const amount = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new AmountDto(amount);
    }
    getAmount() {
        return this.amount;
    }
    getSize() {
        return 8;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const amountBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getAmount());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, amountBytes);
        return newArray;
    }
}
exports.AmountDto = AmountDto;

},{"./GeneratorUtils":220}],187:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BalanceChangeReceiptBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicBuilder_1 = require("./MosaicBuilder");
const ReceiptBuilder_1 = require("./ReceiptBuilder");
class BalanceChangeReceiptBuilder extends ReceiptBuilder_1.ReceiptBuilder {
    constructor(version, type, mosaic, targetAddress) {
        super(version, type);
        this.mosaic = mosaic;
        this.targetAddress = targetAddress;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = ReceiptBuilder_1.ReceiptBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaic = MosaicBuilder_1.MosaicBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaic.getSize());
        const targetAddress = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, targetAddress.getSize());
        return new BalanceChangeReceiptBuilder(superObject.version, superObject.type, mosaic, targetAddress);
    }
    getMosaic() {
        return this.mosaic;
    }
    getTargetAddress() {
        return this.targetAddress;
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaic.getSize();
        size += this.targetAddress.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicBytes = this.mosaic.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicBytes);
        const targetAddressBytes = this.targetAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, targetAddressBytes);
        return newArray;
    }
}
exports.BalanceChangeReceiptBuilder = BalanceChangeReceiptBuilder;

},{"./AddressDto":178,"./GeneratorUtils":220,"./MosaicBuilder":243,"./ReceiptBuilder":283}],188:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BalanceTransferReceiptBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicBuilder_1 = require("./MosaicBuilder");
const ReceiptBuilder_1 = require("./ReceiptBuilder");
class BalanceTransferReceiptBuilder extends ReceiptBuilder_1.ReceiptBuilder {
    constructor(version, type, mosaic, senderAddress, recipientAddress) {
        super(version, type);
        this.mosaic = mosaic;
        this.senderAddress = senderAddress;
        this.recipientAddress = recipientAddress;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = ReceiptBuilder_1.ReceiptBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaic = MosaicBuilder_1.MosaicBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaic.getSize());
        const senderAddress = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, senderAddress.getSize());
        const recipientAddress = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, recipientAddress.getSize());
        return new BalanceTransferReceiptBuilder(superObject.version, superObject.type, mosaic, senderAddress, recipientAddress);
    }
    getMosaic() {
        return this.mosaic;
    }
    getSenderAddress() {
        return this.senderAddress;
    }
    getRecipientAddress() {
        return this.recipientAddress;
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaic.getSize();
        size += this.senderAddress.getSize();
        size += this.recipientAddress.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicBytes = this.mosaic.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicBytes);
        const senderAddressBytes = this.senderAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, senderAddressBytes);
        const recipientAddressBytes = this.recipientAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, recipientAddressBytes);
        return newArray;
    }
}
exports.BalanceTransferReceiptBuilder = BalanceTransferReceiptBuilder;

},{"./AddressDto":178,"./GeneratorUtils":220,"./MosaicBuilder":243,"./ReceiptBuilder":283}],189:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockDurationDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class BlockDurationDto {
    constructor(blockDuration) {
        this.blockDuration = blockDuration;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const blockDuration = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new BlockDurationDto(blockDuration);
    }
    getBlockDuration() {
        return this.blockDuration;
    }
    getSize() {
        return 8;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const blockDurationBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getBlockDuration());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, blockDurationBytes);
        return newArray;
    }
}
exports.BlockDurationDto = BlockDurationDto;

},{"./GeneratorUtils":220}],190:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockFeeMultiplierDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class BlockFeeMultiplierDto {
    constructor(blockFeeMultiplier) {
        this.blockFeeMultiplier = blockFeeMultiplier;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const blockFeeMultiplier = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        return new BlockFeeMultiplierDto(blockFeeMultiplier);
    }
    getBlockFeeMultiplier() {
        return this.blockFeeMultiplier;
    }
    getSize() {
        return 4;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const blockFeeMultiplierBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getBlockFeeMultiplier(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, blockFeeMultiplierBytes);
        return newArray;
    }
}
exports.BlockFeeMultiplierDto = BlockFeeMultiplierDto;

},{"./GeneratorUtils":220}],191:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockHeaderBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const BlockFeeMultiplierDto_1 = require("./BlockFeeMultiplierDto");
const DifficultyDto_1 = require("./DifficultyDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const Hash256Dto_1 = require("./Hash256Dto");
const HeightDto_1 = require("./HeightDto");
const KeyDto_1 = require("./KeyDto");
const SignatureDto_1 = require("./SignatureDto");
const TimestampDto_1 = require("./TimestampDto");
const VrfProofBuilder_1 = require("./VrfProofBuilder");
class BlockHeaderBuilder {
    constructor(signature, signerPublicKey, version, network, type, height, timestamp, difficulty, generationHashProof, previousBlockHash, transactionsHash, receiptsHash, stateHash, beneficiaryAddress, feeMultiplier) {
        this.size = 0;
        this.verifiableEntityHeader_Reserved1 = 0;
        this.signature = signature;
        this.signerPublicKey = signerPublicKey;
        this.entityBody_Reserved1 = 0;
        this.version = version;
        this.network = network;
        this.type = type;
        this.height = height;
        this.timestamp = timestamp;
        this.difficulty = difficulty;
        this.generationHashProof = generationHashProof;
        this.previousBlockHash = previousBlockHash;
        this.transactionsHash = transactionsHash;
        this.receiptsHash = receiptsHash;
        this.stateHash = stateHash;
        this.beneficiaryAddress = beneficiaryAddress;
        this.feeMultiplier = feeMultiplier;
        this.blockHeader_Reserved1 = 0;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const size = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const verifiableEntityHeader_Reserved1 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const signature = SignatureDto_1.SignatureDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, signature.getSize());
        const signerPublicKey = KeyDto_1.KeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, signerPublicKey.getSize());
        const entityBody_Reserved1 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const version = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const network = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const type = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const height = HeightDto_1.HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, height.getSize());
        const timestamp = TimestampDto_1.TimestampDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, timestamp.getSize());
        const difficulty = DifficultyDto_1.DifficultyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, difficulty.getSize());
        const generationHashProof = VrfProofBuilder_1.VrfProofBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, generationHashProof.getSize());
        const previousBlockHash = Hash256Dto_1.Hash256Dto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, previousBlockHash.getSize());
        const transactionsHash = Hash256Dto_1.Hash256Dto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, transactionsHash.getSize());
        const receiptsHash = Hash256Dto_1.Hash256Dto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, receiptsHash.getSize());
        const stateHash = Hash256Dto_1.Hash256Dto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, stateHash.getSize());
        const beneficiaryAddress = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, beneficiaryAddress.getSize());
        const feeMultiplier = BlockFeeMultiplierDto_1.BlockFeeMultiplierDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, feeMultiplier.getSize());
        const blockHeader_Reserved1 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        return new BlockHeaderBuilder(signature, signerPublicKey, version, network, type, height, timestamp, difficulty, generationHashProof, previousBlockHash, transactionsHash, receiptsHash, stateHash, beneficiaryAddress, feeMultiplier);
    }
    getVerifiableEntityHeader_Reserved1() {
        return this.verifiableEntityHeader_Reserved1;
    }
    getSignature() {
        return this.signature;
    }
    getSignerPublicKey() {
        return this.signerPublicKey;
    }
    getEntityBody_Reserved1() {
        return this.entityBody_Reserved1;
    }
    getVersion() {
        return this.version;
    }
    getNetwork() {
        return this.network;
    }
    getType() {
        return this.type;
    }
    getHeight() {
        return this.height;
    }
    getTimestamp() {
        return this.timestamp;
    }
    getDifficulty() {
        return this.difficulty;
    }
    getGenerationHashProof() {
        return this.generationHashProof;
    }
    getPreviousBlockHash() {
        return this.previousBlockHash;
    }
    getTransactionsHash() {
        return this.transactionsHash;
    }
    getReceiptsHash() {
        return this.receiptsHash;
    }
    getStateHash() {
        return this.stateHash;
    }
    getBeneficiaryAddress() {
        return this.beneficiaryAddress;
    }
    getFeeMultiplier() {
        return this.feeMultiplier;
    }
    getBlockHeader_Reserved1() {
        return this.blockHeader_Reserved1;
    }
    getSize() {
        let size = 0;
        size += 4;
        size += 4;
        size += this.signature.getSize();
        size += this.signerPublicKey.getSize();
        size += 4;
        size += 1;
        size += 1;
        size += 2;
        size += this.height.getSize();
        size += this.timestamp.getSize();
        size += this.difficulty.getSize();
        size += this.generationHashProof.getSize();
        size += this.previousBlockHash.getSize();
        size += this.transactionsHash.getSize();
        size += this.receiptsHash.getSize();
        size += this.stateHash.getSize();
        size += this.beneficiaryAddress.getSize();
        size += this.feeMultiplier.getSize();
        size += 4;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const sizeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getSize(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, sizeBytes);
        const verifiableEntityHeader_Reserved1Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getVerifiableEntityHeader_Reserved1(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, verifiableEntityHeader_Reserved1Bytes);
        const signatureBytes = this.signature.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, signatureBytes);
        const signerPublicKeyBytes = this.signerPublicKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, signerPublicKeyBytes);
        const entityBody_Reserved1Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getEntityBody_Reserved1(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, entityBody_Reserved1Bytes);
        const versionBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getVersion(), 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, versionBytes);
        const networkBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.network, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, networkBytes);
        const typeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.type, 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, typeBytes);
        const heightBytes = this.height.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, heightBytes);
        const timestampBytes = this.timestamp.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, timestampBytes);
        const difficultyBytes = this.difficulty.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, difficultyBytes);
        const generationHashProofBytes = this.generationHashProof.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, generationHashProofBytes);
        const previousBlockHashBytes = this.previousBlockHash.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, previousBlockHashBytes);
        const transactionsHashBytes = this.transactionsHash.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, transactionsHashBytes);
        const receiptsHashBytes = this.receiptsHash.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, receiptsHashBytes);
        const stateHashBytes = this.stateHash.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, stateHashBytes);
        const beneficiaryAddressBytes = this.beneficiaryAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, beneficiaryAddressBytes);
        const feeMultiplierBytes = this.feeMultiplier.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, feeMultiplierBytes);
        const blockHeader_Reserved1Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getBlockHeader_Reserved1(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, blockHeader_Reserved1Bytes);
        return newArray;
    }
}
exports.BlockHeaderBuilder = BlockHeaderBuilder;

},{"./AddressDto":178,"./BlockFeeMultiplierDto":190,"./DifficultyDto":194,"./GeneratorUtils":220,"./Hash256Dto":223,"./HeightDto":230,"./KeyDto":235,"./SignatureDto":293,"./TimestampDto":294,"./VrfProofBuilder":307}],192:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosignatureBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const KeyDto_1 = require("./KeyDto");
const SignatureDto_1 = require("./SignatureDto");
class CosignatureBuilder {
    constructor(version, signerPublicKey, signature) {
        this.version = version;
        this.signerPublicKey = signerPublicKey;
        this.signature = signature;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const version = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const signerPublicKey = KeyDto_1.KeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, signerPublicKey.getSize());
        const signature = SignatureDto_1.SignatureDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, signature.getSize());
        return new CosignatureBuilder(version, signerPublicKey, signature);
    }
    getVersion() {
        return this.version;
    }
    getSignerPublicKey() {
        return this.signerPublicKey;
    }
    getSignature() {
        return this.signature;
    }
    getSize() {
        let size = 0;
        size += 8;
        size += this.signerPublicKey.getSize();
        size += this.signature.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const versionBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getVersion());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, versionBytes);
        const signerPublicKeyBytes = this.signerPublicKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, signerPublicKeyBytes);
        const signatureBytes = this.signature.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, signatureBytes);
        return newArray;
    }
}
exports.CosignatureBuilder = CosignatureBuilder;

},{"./GeneratorUtils":220,"./KeyDto":235,"./SignatureDto":293}],193:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DetachedCosignatureBuilder = void 0;
const CosignatureBuilder_1 = require("./CosignatureBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const Hash256Dto_1 = require("./Hash256Dto");
class DetachedCosignatureBuilder extends CosignatureBuilder_1.CosignatureBuilder {
    constructor(version, signerPublicKey, signature, parentHash) {
        super(version, signerPublicKey, signature);
        this.parentHash = parentHash;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = CosignatureBuilder_1.CosignatureBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const parentHash = Hash256Dto_1.Hash256Dto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, parentHash.getSize());
        return new DetachedCosignatureBuilder(superObject.version, superObject.signerPublicKey, superObject.signature, parentHash);
    }
    getParentHash() {
        return this.parentHash;
    }
    getSize() {
        let size = super.getSize();
        size += this.parentHash.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const parentHashBytes = this.parentHash.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, parentHashBytes);
        return newArray;
    }
}
exports.DetachedCosignatureBuilder = DetachedCosignatureBuilder;

},{"./CosignatureBuilder":192,"./GeneratorUtils":220,"./Hash256Dto":223}],194:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DifficultyDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class DifficultyDto {
    constructor(difficulty) {
        this.difficulty = difficulty;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const difficulty = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new DifficultyDto(difficulty);
    }
    getDifficulty() {
        return this.difficulty;
    }
    getSize() {
        return 8;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const difficultyBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getDifficulty());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, difficultyBytes);
        return newArray;
    }
}
exports.DifficultyDto = DifficultyDto;

},{"./GeneratorUtils":220}],195:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedAccountAddressRestrictionTransactionBuilder = void 0;
const AccountAddressRestrictionTransactionBodyBuilder_1 = require("./AccountAddressRestrictionTransactionBodyBuilder");
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
class EmbeddedAccountAddressRestrictionTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, restrictionFlags, restrictionAdditions, restrictionDeletions) {
        super(signerPublicKey, version, network, type);
        this.accountAddressRestrictionTransactionBody = new AccountAddressRestrictionTransactionBodyBuilder_1.AccountAddressRestrictionTransactionBodyBuilder(restrictionFlags, restrictionAdditions, restrictionDeletions);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const accountAddressRestrictionTransactionBody = AccountAddressRestrictionTransactionBodyBuilder_1.AccountAddressRestrictionTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, accountAddressRestrictionTransactionBody.getSize());
        return new EmbeddedAccountAddressRestrictionTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, accountAddressRestrictionTransactionBody.restrictionFlags, accountAddressRestrictionTransactionBody.restrictionAdditions, accountAddressRestrictionTransactionBody.restrictionDeletions);
    }
    getRestrictionFlags() {
        return this.accountAddressRestrictionTransactionBody.getRestrictionFlags();
    }
    getAccountRestrictionTransactionBody_Reserved1() {
        return this.accountAddressRestrictionTransactionBody.getAccountRestrictionTransactionBody_Reserved1();
    }
    getRestrictionAdditions() {
        return this.accountAddressRestrictionTransactionBody.getRestrictionAdditions();
    }
    getRestrictionDeletions() {
        return this.accountAddressRestrictionTransactionBody.getRestrictionDeletions();
    }
    getSize() {
        let size = super.getSize();
        size += this.accountAddressRestrictionTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const accountAddressRestrictionTransactionBodyBytes = this.accountAddressRestrictionTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountAddressRestrictionTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedAccountAddressRestrictionTransactionBuilder = EmbeddedAccountAddressRestrictionTransactionBuilder;

},{"./AccountAddressRestrictionTransactionBodyBuilder":157,"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220}],196:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedAccountKeyLinkTransactionBuilder = void 0;
const AccountKeyLinkTransactionBodyBuilder_1 = require("./AccountKeyLinkTransactionBodyBuilder");
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
class EmbeddedAccountKeyLinkTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, linkedPublicKey, linkAction) {
        super(signerPublicKey, version, network, type);
        this.accountKeyLinkTransactionBody = new AccountKeyLinkTransactionBodyBuilder_1.AccountKeyLinkTransactionBodyBuilder(linkedPublicKey, linkAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const accountKeyLinkTransactionBody = AccountKeyLinkTransactionBodyBuilder_1.AccountKeyLinkTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, accountKeyLinkTransactionBody.getSize());
        return new EmbeddedAccountKeyLinkTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, accountKeyLinkTransactionBody.linkedPublicKey, accountKeyLinkTransactionBody.linkAction);
    }
    getLinkedPublicKey() {
        return this.accountKeyLinkTransactionBody.getLinkedPublicKey();
    }
    getLinkAction() {
        return this.accountKeyLinkTransactionBody.getLinkAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.accountKeyLinkTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const accountKeyLinkTransactionBodyBytes = this.accountKeyLinkTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountKeyLinkTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedAccountKeyLinkTransactionBuilder = EmbeddedAccountKeyLinkTransactionBuilder;

},{"./AccountKeyLinkTransactionBodyBuilder":160,"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220}],197:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedAccountMetadataTransactionBuilder = void 0;
const AccountMetadataTransactionBodyBuilder_1 = require("./AccountMetadataTransactionBodyBuilder");
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
class EmbeddedAccountMetadataTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, targetAddress, scopedMetadataKey, valueSizeDelta, value) {
        super(signerPublicKey, version, network, type);
        this.accountMetadataTransactionBody = new AccountMetadataTransactionBodyBuilder_1.AccountMetadataTransactionBodyBuilder(targetAddress, scopedMetadataKey, valueSizeDelta, value);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const accountMetadataTransactionBody = AccountMetadataTransactionBodyBuilder_1.AccountMetadataTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, accountMetadataTransactionBody.getSize());
        return new EmbeddedAccountMetadataTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, accountMetadataTransactionBody.targetAddress, accountMetadataTransactionBody.scopedMetadataKey, accountMetadataTransactionBody.valueSizeDelta, accountMetadataTransactionBody.value);
    }
    getTargetAddress() {
        return this.accountMetadataTransactionBody.getTargetAddress();
    }
    getScopedMetadataKey() {
        return this.accountMetadataTransactionBody.getScopedMetadataKey();
    }
    getValueSizeDelta() {
        return this.accountMetadataTransactionBody.getValueSizeDelta();
    }
    getValue() {
        return this.accountMetadataTransactionBody.getValue();
    }
    getSize() {
        let size = super.getSize();
        size += this.accountMetadataTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const accountMetadataTransactionBodyBytes = this.accountMetadataTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountMetadataTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedAccountMetadataTransactionBuilder = EmbeddedAccountMetadataTransactionBuilder;

},{"./AccountMetadataTransactionBodyBuilder":162,"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220}],198:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedAccountMosaicRestrictionTransactionBuilder = void 0;
const AccountMosaicRestrictionTransactionBodyBuilder_1 = require("./AccountMosaicRestrictionTransactionBodyBuilder");
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
class EmbeddedAccountMosaicRestrictionTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, restrictionFlags, restrictionAdditions, restrictionDeletions) {
        super(signerPublicKey, version, network, type);
        this.accountMosaicRestrictionTransactionBody = new AccountMosaicRestrictionTransactionBodyBuilder_1.AccountMosaicRestrictionTransactionBodyBuilder(restrictionFlags, restrictionAdditions, restrictionDeletions);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const accountMosaicRestrictionTransactionBody = AccountMosaicRestrictionTransactionBodyBuilder_1.AccountMosaicRestrictionTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, accountMosaicRestrictionTransactionBody.getSize());
        return new EmbeddedAccountMosaicRestrictionTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, accountMosaicRestrictionTransactionBody.restrictionFlags, accountMosaicRestrictionTransactionBody.restrictionAdditions, accountMosaicRestrictionTransactionBody.restrictionDeletions);
    }
    getRestrictionFlags() {
        return this.accountMosaicRestrictionTransactionBody.getRestrictionFlags();
    }
    getAccountRestrictionTransactionBody_Reserved1() {
        return this.accountMosaicRestrictionTransactionBody.getAccountRestrictionTransactionBody_Reserved1();
    }
    getRestrictionAdditions() {
        return this.accountMosaicRestrictionTransactionBody.getRestrictionAdditions();
    }
    getRestrictionDeletions() {
        return this.accountMosaicRestrictionTransactionBody.getRestrictionDeletions();
    }
    getSize() {
        let size = super.getSize();
        size += this.accountMosaicRestrictionTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const accountMosaicRestrictionTransactionBodyBytes = this.accountMosaicRestrictionTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountMosaicRestrictionTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedAccountMosaicRestrictionTransactionBuilder = EmbeddedAccountMosaicRestrictionTransactionBuilder;

},{"./AccountMosaicRestrictionTransactionBodyBuilder":164,"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220}],199:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedAccountOperationRestrictionTransactionBuilder = void 0;
const AccountOperationRestrictionTransactionBodyBuilder_1 = require("./AccountOperationRestrictionTransactionBodyBuilder");
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
class EmbeddedAccountOperationRestrictionTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, restrictionFlags, restrictionAdditions, restrictionDeletions) {
        super(signerPublicKey, version, network, type);
        this.accountOperationRestrictionTransactionBody = new AccountOperationRestrictionTransactionBodyBuilder_1.AccountOperationRestrictionTransactionBodyBuilder(restrictionFlags, restrictionAdditions, restrictionDeletions);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const accountOperationRestrictionTransactionBody = AccountOperationRestrictionTransactionBodyBuilder_1.AccountOperationRestrictionTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, accountOperationRestrictionTransactionBody.getSize());
        return new EmbeddedAccountOperationRestrictionTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, accountOperationRestrictionTransactionBody.restrictionFlags, accountOperationRestrictionTransactionBody.restrictionAdditions, accountOperationRestrictionTransactionBody.restrictionDeletions);
    }
    getRestrictionFlags() {
        return this.accountOperationRestrictionTransactionBody.getRestrictionFlags();
    }
    getAccountRestrictionTransactionBody_Reserved1() {
        return this.accountOperationRestrictionTransactionBody.getAccountRestrictionTransactionBody_Reserved1();
    }
    getRestrictionAdditions() {
        return this.accountOperationRestrictionTransactionBody.getRestrictionAdditions();
    }
    getRestrictionDeletions() {
        return this.accountOperationRestrictionTransactionBody.getRestrictionDeletions();
    }
    getSize() {
        let size = super.getSize();
        size += this.accountOperationRestrictionTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const accountOperationRestrictionTransactionBodyBytes = this.accountOperationRestrictionTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountOperationRestrictionTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedAccountOperationRestrictionTransactionBuilder = EmbeddedAccountOperationRestrictionTransactionBuilder;

},{"./AccountOperationRestrictionTransactionBodyBuilder":166,"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220}],200:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedAddressAliasTransactionBuilder = void 0;
const AddressAliasTransactionBodyBuilder_1 = require("./AddressAliasTransactionBodyBuilder");
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
class EmbeddedAddressAliasTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, namespaceId, address, aliasAction) {
        super(signerPublicKey, version, network, type);
        this.addressAliasTransactionBody = new AddressAliasTransactionBodyBuilder_1.AddressAliasTransactionBodyBuilder(namespaceId, address, aliasAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const addressAliasTransactionBody = AddressAliasTransactionBodyBuilder_1.AddressAliasTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, addressAliasTransactionBody.getSize());
        return new EmbeddedAddressAliasTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, addressAliasTransactionBody.namespaceId, addressAliasTransactionBody.address, addressAliasTransactionBody.aliasAction);
    }
    getNamespaceId() {
        return this.addressAliasTransactionBody.getNamespaceId();
    }
    getAddress() {
        return this.addressAliasTransactionBody.getAddress();
    }
    getAliasAction() {
        return this.addressAliasTransactionBody.getAliasAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.addressAliasTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const addressAliasTransactionBodyBytes = this.addressAliasTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressAliasTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedAddressAliasTransactionBuilder = EmbeddedAddressAliasTransactionBuilder;

},{"./AddressAliasTransactionBodyBuilder":176,"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220}],201:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedHashLockTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const HashLockTransactionBodyBuilder_1 = require("./HashLockTransactionBodyBuilder");
class EmbeddedHashLockTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, mosaic, duration, hash) {
        super(signerPublicKey, version, network, type);
        this.hashLockTransactionBody = new HashLockTransactionBodyBuilder_1.HashLockTransactionBodyBuilder(mosaic, duration, hash);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const hashLockTransactionBody = HashLockTransactionBodyBuilder_1.HashLockTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, hashLockTransactionBody.getSize());
        return new EmbeddedHashLockTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, hashLockTransactionBody.mosaic, hashLockTransactionBody.duration, hashLockTransactionBody.hash);
    }
    getMosaic() {
        return this.hashLockTransactionBody.getMosaic();
    }
    getDuration() {
        return this.hashLockTransactionBody.getDuration();
    }
    getHash() {
        return this.hashLockTransactionBody.getHash();
    }
    getSize() {
        let size = super.getSize();
        size += this.hashLockTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const hashLockTransactionBodyBytes = this.hashLockTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, hashLockTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedHashLockTransactionBuilder = EmbeddedHashLockTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./HashLockTransactionBodyBuilder":226}],202:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMosaicAddressRestrictionTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicAddressRestrictionTransactionBodyBuilder_1 = require("./MosaicAddressRestrictionTransactionBodyBuilder");
class EmbeddedMosaicAddressRestrictionTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, mosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, targetAddress) {
        super(signerPublicKey, version, network, type);
        this.mosaicAddressRestrictionTransactionBody = new MosaicAddressRestrictionTransactionBodyBuilder_1.MosaicAddressRestrictionTransactionBodyBuilder(mosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, targetAddress);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaicAddressRestrictionTransactionBody = MosaicAddressRestrictionTransactionBodyBuilder_1.MosaicAddressRestrictionTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicAddressRestrictionTransactionBody.getSize());
        return new EmbeddedMosaicAddressRestrictionTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, mosaicAddressRestrictionTransactionBody.mosaicId, mosaicAddressRestrictionTransactionBody.restrictionKey, mosaicAddressRestrictionTransactionBody.previousRestrictionValue, mosaicAddressRestrictionTransactionBody.newRestrictionValue, mosaicAddressRestrictionTransactionBody.targetAddress);
    }
    getMosaicId() {
        return this.mosaicAddressRestrictionTransactionBody.getMosaicId();
    }
    getRestrictionKey() {
        return this.mosaicAddressRestrictionTransactionBody.getRestrictionKey();
    }
    getPreviousRestrictionValue() {
        return this.mosaicAddressRestrictionTransactionBody.getPreviousRestrictionValue();
    }
    getNewRestrictionValue() {
        return this.mosaicAddressRestrictionTransactionBody.getNewRestrictionValue();
    }
    getTargetAddress() {
        return this.mosaicAddressRestrictionTransactionBody.getTargetAddress();
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaicAddressRestrictionTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicAddressRestrictionTransactionBodyBytes = this.mosaicAddressRestrictionTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicAddressRestrictionTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedMosaicAddressRestrictionTransactionBuilder = EmbeddedMosaicAddressRestrictionTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./MosaicAddressRestrictionTransactionBodyBuilder":239}],203:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMosaicAliasTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicAliasTransactionBodyBuilder_1 = require("./MosaicAliasTransactionBodyBuilder");
class EmbeddedMosaicAliasTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, namespaceId, mosaicId, aliasAction) {
        super(signerPublicKey, version, network, type);
        this.mosaicAliasTransactionBody = new MosaicAliasTransactionBodyBuilder_1.MosaicAliasTransactionBodyBuilder(namespaceId, mosaicId, aliasAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaicAliasTransactionBody = MosaicAliasTransactionBodyBuilder_1.MosaicAliasTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicAliasTransactionBody.getSize());
        return new EmbeddedMosaicAliasTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, mosaicAliasTransactionBody.namespaceId, mosaicAliasTransactionBody.mosaicId, mosaicAliasTransactionBody.aliasAction);
    }
    getNamespaceId() {
        return this.mosaicAliasTransactionBody.getNamespaceId();
    }
    getMosaicId() {
        return this.mosaicAliasTransactionBody.getMosaicId();
    }
    getAliasAction() {
        return this.mosaicAliasTransactionBody.getAliasAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaicAliasTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicAliasTransactionBodyBytes = this.mosaicAliasTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicAliasTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedMosaicAliasTransactionBuilder = EmbeddedMosaicAliasTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./MosaicAliasTransactionBodyBuilder":241}],204:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMosaicDefinitionTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicDefinitionTransactionBodyBuilder_1 = require("./MosaicDefinitionTransactionBodyBuilder");
class EmbeddedMosaicDefinitionTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, id, duration, nonce, flags, divisibility) {
        super(signerPublicKey, version, network, type);
        this.mosaicDefinitionTransactionBody = new MosaicDefinitionTransactionBodyBuilder_1.MosaicDefinitionTransactionBodyBuilder(id, duration, nonce, flags, divisibility);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaicDefinitionTransactionBody = MosaicDefinitionTransactionBodyBuilder_1.MosaicDefinitionTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicDefinitionTransactionBody.getSize());
        return new EmbeddedMosaicDefinitionTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, mosaicDefinitionTransactionBody.id, mosaicDefinitionTransactionBody.duration, mosaicDefinitionTransactionBody.nonce, mosaicDefinitionTransactionBody.flags, mosaicDefinitionTransactionBody.divisibility);
    }
    getId() {
        return this.mosaicDefinitionTransactionBody.getId();
    }
    getDuration() {
        return this.mosaicDefinitionTransactionBody.getDuration();
    }
    getNonce() {
        return this.mosaicDefinitionTransactionBody.getNonce();
    }
    getFlags() {
        return this.mosaicDefinitionTransactionBody.getFlags();
    }
    getDivisibility() {
        return this.mosaicDefinitionTransactionBody.getDivisibility();
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaicDefinitionTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicDefinitionTransactionBodyBytes = this.mosaicDefinitionTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicDefinitionTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedMosaicDefinitionTransactionBuilder = EmbeddedMosaicDefinitionTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./MosaicDefinitionTransactionBodyBuilder":245}],205:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMosaicGlobalRestrictionTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicGlobalRestrictionTransactionBodyBuilder_1 = require("./MosaicGlobalRestrictionTransactionBodyBuilder");
class EmbeddedMosaicGlobalRestrictionTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, mosaicId, referenceMosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, previousRestrictionType, newRestrictionType) {
        super(signerPublicKey, version, network, type);
        this.mosaicGlobalRestrictionTransactionBody = new MosaicGlobalRestrictionTransactionBodyBuilder_1.MosaicGlobalRestrictionTransactionBodyBuilder(mosaicId, referenceMosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, previousRestrictionType, newRestrictionType);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaicGlobalRestrictionTransactionBody = MosaicGlobalRestrictionTransactionBodyBuilder_1.MosaicGlobalRestrictionTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicGlobalRestrictionTransactionBody.getSize());
        return new EmbeddedMosaicGlobalRestrictionTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, mosaicGlobalRestrictionTransactionBody.mosaicId, mosaicGlobalRestrictionTransactionBody.referenceMosaicId, mosaicGlobalRestrictionTransactionBody.restrictionKey, mosaicGlobalRestrictionTransactionBody.previousRestrictionValue, mosaicGlobalRestrictionTransactionBody.newRestrictionValue, mosaicGlobalRestrictionTransactionBody.previousRestrictionType, mosaicGlobalRestrictionTransactionBody.newRestrictionType);
    }
    getMosaicId() {
        return this.mosaicGlobalRestrictionTransactionBody.getMosaicId();
    }
    getReferenceMosaicId() {
        return this.mosaicGlobalRestrictionTransactionBody.getReferenceMosaicId();
    }
    getRestrictionKey() {
        return this.mosaicGlobalRestrictionTransactionBody.getRestrictionKey();
    }
    getPreviousRestrictionValue() {
        return this.mosaicGlobalRestrictionTransactionBody.getPreviousRestrictionValue();
    }
    getNewRestrictionValue() {
        return this.mosaicGlobalRestrictionTransactionBody.getNewRestrictionValue();
    }
    getPreviousRestrictionType() {
        return this.mosaicGlobalRestrictionTransactionBody.getPreviousRestrictionType();
    }
    getNewRestrictionType() {
        return this.mosaicGlobalRestrictionTransactionBody.getNewRestrictionType();
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaicGlobalRestrictionTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicGlobalRestrictionTransactionBodyBytes = this.mosaicGlobalRestrictionTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicGlobalRestrictionTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedMosaicGlobalRestrictionTransactionBuilder = EmbeddedMosaicGlobalRestrictionTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./MosaicGlobalRestrictionTransactionBodyBuilder":250}],206:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMosaicMetadataTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicMetadataTransactionBodyBuilder_1 = require("./MosaicMetadataTransactionBodyBuilder");
class EmbeddedMosaicMetadataTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, targetAddress, scopedMetadataKey, targetMosaicId, valueSizeDelta, value) {
        super(signerPublicKey, version, network, type);
        this.mosaicMetadataTransactionBody = new MosaicMetadataTransactionBodyBuilder_1.MosaicMetadataTransactionBodyBuilder(targetAddress, scopedMetadataKey, targetMosaicId, valueSizeDelta, value);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaicMetadataTransactionBody = MosaicMetadataTransactionBodyBuilder_1.MosaicMetadataTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicMetadataTransactionBody.getSize());
        return new EmbeddedMosaicMetadataTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, mosaicMetadataTransactionBody.targetAddress, mosaicMetadataTransactionBody.scopedMetadataKey, mosaicMetadataTransactionBody.targetMosaicId, mosaicMetadataTransactionBody.valueSizeDelta, mosaicMetadataTransactionBody.value);
    }
    getTargetAddress() {
        return this.mosaicMetadataTransactionBody.getTargetAddress();
    }
    getScopedMetadataKey() {
        return this.mosaicMetadataTransactionBody.getScopedMetadataKey();
    }
    getTargetMosaicId() {
        return this.mosaicMetadataTransactionBody.getTargetMosaicId();
    }
    getValueSizeDelta() {
        return this.mosaicMetadataTransactionBody.getValueSizeDelta();
    }
    getValue() {
        return this.mosaicMetadataTransactionBody.getValue();
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaicMetadataTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicMetadataTransactionBodyBytes = this.mosaicMetadataTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicMetadataTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedMosaicMetadataTransactionBuilder = EmbeddedMosaicMetadataTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./MosaicMetadataTransactionBodyBuilder":253}],207:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMosaicSupplyChangeTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicSupplyChangeTransactionBodyBuilder_1 = require("./MosaicSupplyChangeTransactionBodyBuilder");
class EmbeddedMosaicSupplyChangeTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, mosaicId, delta, action) {
        super(signerPublicKey, version, network, type);
        this.mosaicSupplyChangeTransactionBody = new MosaicSupplyChangeTransactionBodyBuilder_1.MosaicSupplyChangeTransactionBodyBuilder(mosaicId, delta, action);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaicSupplyChangeTransactionBody = MosaicSupplyChangeTransactionBodyBuilder_1.MosaicSupplyChangeTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicSupplyChangeTransactionBody.getSize());
        return new EmbeddedMosaicSupplyChangeTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, mosaicSupplyChangeTransactionBody.mosaicId, mosaicSupplyChangeTransactionBody.delta, mosaicSupplyChangeTransactionBody.action);
    }
    getMosaicId() {
        return this.mosaicSupplyChangeTransactionBody.getMosaicId();
    }
    getDelta() {
        return this.mosaicSupplyChangeTransactionBody.getDelta();
    }
    getAction() {
        return this.mosaicSupplyChangeTransactionBody.getAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaicSupplyChangeTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicSupplyChangeTransactionBodyBytes = this.mosaicSupplyChangeTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicSupplyChangeTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedMosaicSupplyChangeTransactionBuilder = EmbeddedMosaicSupplyChangeTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./MosaicSupplyChangeTransactionBodyBuilder":262}],208:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMultisigAccountModificationTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MultisigAccountModificationTransactionBodyBuilder_1 = require("./MultisigAccountModificationTransactionBodyBuilder");
class EmbeddedMultisigAccountModificationTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, minRemovalDelta, minApprovalDelta, addressAdditions, addressDeletions) {
        super(signerPublicKey, version, network, type);
        this.multisigAccountModificationTransactionBody = new MultisigAccountModificationTransactionBodyBuilder_1.MultisigAccountModificationTransactionBodyBuilder(minRemovalDelta, minApprovalDelta, addressAdditions, addressDeletions);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const multisigAccountModificationTransactionBody = MultisigAccountModificationTransactionBodyBuilder_1.MultisigAccountModificationTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, multisigAccountModificationTransactionBody.getSize());
        return new EmbeddedMultisigAccountModificationTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, multisigAccountModificationTransactionBody.minRemovalDelta, multisigAccountModificationTransactionBody.minApprovalDelta, multisigAccountModificationTransactionBody.addressAdditions, multisigAccountModificationTransactionBody.addressDeletions);
    }
    getMinRemovalDelta() {
        return this.multisigAccountModificationTransactionBody.getMinRemovalDelta();
    }
    getMinApprovalDelta() {
        return this.multisigAccountModificationTransactionBody.getMinApprovalDelta();
    }
    getMultisigAccountModificationTransactionBody_Reserved1() {
        return this.multisigAccountModificationTransactionBody.getMultisigAccountModificationTransactionBody_Reserved1();
    }
    getAddressAdditions() {
        return this.multisigAccountModificationTransactionBody.getAddressAdditions();
    }
    getAddressDeletions() {
        return this.multisigAccountModificationTransactionBody.getAddressDeletions();
    }
    getSize() {
        let size = super.getSize();
        size += this.multisigAccountModificationTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const multisigAccountModificationTransactionBodyBytes = this.multisigAccountModificationTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, multisigAccountModificationTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedMultisigAccountModificationTransactionBuilder = EmbeddedMultisigAccountModificationTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./MultisigAccountModificationTransactionBodyBuilder":264}],209:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedNamespaceMetadataTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const NamespaceMetadataTransactionBodyBuilder_1 = require("./NamespaceMetadataTransactionBodyBuilder");
class EmbeddedNamespaceMetadataTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, targetAddress, scopedMetadataKey, targetNamespaceId, valueSizeDelta, value) {
        super(signerPublicKey, version, network, type);
        this.namespaceMetadataTransactionBody = new NamespaceMetadataTransactionBodyBuilder_1.NamespaceMetadataTransactionBodyBuilder(targetAddress, scopedMetadataKey, targetNamespaceId, valueSizeDelta, value);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const namespaceMetadataTransactionBody = NamespaceMetadataTransactionBodyBuilder_1.NamespaceMetadataTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, namespaceMetadataTransactionBody.getSize());
        return new EmbeddedNamespaceMetadataTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, namespaceMetadataTransactionBody.targetAddress, namespaceMetadataTransactionBody.scopedMetadataKey, namespaceMetadataTransactionBody.targetNamespaceId, namespaceMetadataTransactionBody.valueSizeDelta, namespaceMetadataTransactionBody.value);
    }
    getTargetAddress() {
        return this.namespaceMetadataTransactionBody.getTargetAddress();
    }
    getScopedMetadataKey() {
        return this.namespaceMetadataTransactionBody.getScopedMetadataKey();
    }
    getTargetNamespaceId() {
        return this.namespaceMetadataTransactionBody.getTargetNamespaceId();
    }
    getValueSizeDelta() {
        return this.namespaceMetadataTransactionBody.getValueSizeDelta();
    }
    getValue() {
        return this.namespaceMetadataTransactionBody.getValue();
    }
    getSize() {
        let size = super.getSize();
        size += this.namespaceMetadataTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const namespaceMetadataTransactionBodyBytes = this.namespaceMetadataTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, namespaceMetadataTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedNamespaceMetadataTransactionBuilder = EmbeddedNamespaceMetadataTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./NamespaceMetadataTransactionBodyBuilder":272}],210:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedNamespaceRegistrationTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const NamespaceRegistrationTransactionBodyBuilder_1 = require("./NamespaceRegistrationTransactionBodyBuilder");
class EmbeddedNamespaceRegistrationTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, id, name, duration, parentId) {
        super(signerPublicKey, version, network, type);
        this.namespaceRegistrationTransactionBody = new NamespaceRegistrationTransactionBodyBuilder_1.NamespaceRegistrationTransactionBodyBuilder(id, name, duration, parentId);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const namespaceRegistrationTransactionBody = NamespaceRegistrationTransactionBodyBuilder_1.NamespaceRegistrationTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, namespaceRegistrationTransactionBody.getSize());
        return new EmbeddedNamespaceRegistrationTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, namespaceRegistrationTransactionBody.id, namespaceRegistrationTransactionBody.name, namespaceRegistrationTransactionBody.duration, namespaceRegistrationTransactionBody.parentId);
    }
    getDuration() {
        return this.namespaceRegistrationTransactionBody.getDuration();
    }
    getParentId() {
        return this.namespaceRegistrationTransactionBody.getParentId();
    }
    getId() {
        return this.namespaceRegistrationTransactionBody.getId();
    }
    getRegistrationType() {
        return this.namespaceRegistrationTransactionBody.getRegistrationType();
    }
    getName() {
        return this.namespaceRegistrationTransactionBody.getName();
    }
    getSize() {
        let size = super.getSize();
        size += this.namespaceRegistrationTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const namespaceRegistrationTransactionBodyBytes = this.namespaceRegistrationTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, namespaceRegistrationTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedNamespaceRegistrationTransactionBuilder = EmbeddedNamespaceRegistrationTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./NamespaceRegistrationTransactionBodyBuilder":275}],211:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedNodeKeyLinkTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const NodeKeyLinkTransactionBodyBuilder_1 = require("./NodeKeyLinkTransactionBodyBuilder");
class EmbeddedNodeKeyLinkTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, linkedPublicKey, linkAction) {
        super(signerPublicKey, version, network, type);
        this.nodeKeyLinkTransactionBody = new NodeKeyLinkTransactionBodyBuilder_1.NodeKeyLinkTransactionBodyBuilder(linkedPublicKey, linkAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const nodeKeyLinkTransactionBody = NodeKeyLinkTransactionBodyBuilder_1.NodeKeyLinkTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, nodeKeyLinkTransactionBody.getSize());
        return new EmbeddedNodeKeyLinkTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, nodeKeyLinkTransactionBody.linkedPublicKey, nodeKeyLinkTransactionBody.linkAction);
    }
    getLinkedPublicKey() {
        return this.nodeKeyLinkTransactionBody.getLinkedPublicKey();
    }
    getLinkAction() {
        return this.nodeKeyLinkTransactionBody.getLinkAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.nodeKeyLinkTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const nodeKeyLinkTransactionBodyBytes = this.nodeKeyLinkTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, nodeKeyLinkTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedNodeKeyLinkTransactionBuilder = EmbeddedNodeKeyLinkTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./NodeKeyLinkTransactionBodyBuilder":278}],212:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedSecretLockTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const SecretLockTransactionBodyBuilder_1 = require("./SecretLockTransactionBodyBuilder");
class EmbeddedSecretLockTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, secret, mosaic, duration, hashAlgorithm, recipientAddress) {
        super(signerPublicKey, version, network, type);
        this.secretLockTransactionBody = new SecretLockTransactionBodyBuilder_1.SecretLockTransactionBodyBuilder(secret, mosaic, duration, hashAlgorithm, recipientAddress);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const secretLockTransactionBody = SecretLockTransactionBodyBuilder_1.SecretLockTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, secretLockTransactionBody.getSize());
        return new EmbeddedSecretLockTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, secretLockTransactionBody.secret, secretLockTransactionBody.mosaic, secretLockTransactionBody.duration, secretLockTransactionBody.hashAlgorithm, secretLockTransactionBody.recipientAddress);
    }
    getSecret() {
        return this.secretLockTransactionBody.getSecret();
    }
    getMosaic() {
        return this.secretLockTransactionBody.getMosaic();
    }
    getDuration() {
        return this.secretLockTransactionBody.getDuration();
    }
    getHashAlgorithm() {
        return this.secretLockTransactionBody.getHashAlgorithm();
    }
    getRecipientAddress() {
        return this.secretLockTransactionBody.getRecipientAddress();
    }
    getSize() {
        let size = super.getSize();
        size += this.secretLockTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const secretLockTransactionBodyBytes = this.secretLockTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secretLockTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedSecretLockTransactionBuilder = EmbeddedSecretLockTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./SecretLockTransactionBodyBuilder":289}],213:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedSecretProofTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const SecretProofTransactionBodyBuilder_1 = require("./SecretProofTransactionBodyBuilder");
class EmbeddedSecretProofTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, secret, hashAlgorithm, recipientAddress, proof) {
        super(signerPublicKey, version, network, type);
        this.secretProofTransactionBody = new SecretProofTransactionBodyBuilder_1.SecretProofTransactionBodyBuilder(secret, hashAlgorithm, recipientAddress, proof);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const secretProofTransactionBody = SecretProofTransactionBodyBuilder_1.SecretProofTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, secretProofTransactionBody.getSize());
        return new EmbeddedSecretProofTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, secretProofTransactionBody.secret, secretProofTransactionBody.hashAlgorithm, secretProofTransactionBody.recipientAddress, secretProofTransactionBody.proof);
    }
    getSecret() {
        return this.secretProofTransactionBody.getSecret();
    }
    getHashAlgorithm() {
        return this.secretProofTransactionBody.getHashAlgorithm();
    }
    getRecipientAddress() {
        return this.secretProofTransactionBody.getRecipientAddress();
    }
    getProof() {
        return this.secretProofTransactionBody.getProof();
    }
    getSize() {
        let size = super.getSize();
        size += this.secretProofTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const secretProofTransactionBodyBytes = this.secretProofTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secretProofTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedSecretProofTransactionBuilder = EmbeddedSecretProofTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./SecretProofTransactionBodyBuilder":291}],214:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const KeyDto_1 = require("./KeyDto");
class EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type) {
        this.size = 0;
        this.embeddedTransactionHeader_Reserved1 = 0;
        this.signerPublicKey = signerPublicKey;
        this.entityBody_Reserved1 = 0;
        this.version = version;
        this.network = network;
        this.type = type;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const size = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const embeddedTransactionHeader_Reserved1 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const signerPublicKey = KeyDto_1.KeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, signerPublicKey.getSize());
        const entityBody_Reserved1 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const version = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const network = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const type = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        return new EmbeddedTransactionBuilder(signerPublicKey, version, network, type);
    }
    getEmbeddedTransactionHeader_Reserved1() {
        return this.embeddedTransactionHeader_Reserved1;
    }
    getSignerPublicKey() {
        return this.signerPublicKey;
    }
    getEntityBody_Reserved1() {
        return this.entityBody_Reserved1;
    }
    getVersion() {
        return this.version;
    }
    getNetwork() {
        return this.network;
    }
    getType() {
        return this.type;
    }
    getSize() {
        let size = 0;
        size += 4;
        size += 4;
        size += this.signerPublicKey.getSize();
        size += 4;
        size += 1;
        size += 1;
        size += 2;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const sizeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getSize(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, sizeBytes);
        const embeddedTransactionHeader_Reserved1Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getEmbeddedTransactionHeader_Reserved1(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, embeddedTransactionHeader_Reserved1Bytes);
        const signerPublicKeyBytes = this.signerPublicKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, signerPublicKeyBytes);
        const entityBody_Reserved1Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getEntityBody_Reserved1(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, entityBody_Reserved1Bytes);
        const versionBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getVersion(), 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, versionBytes);
        const networkBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.network, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, networkBytes);
        const typeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.type, 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, typeBytes);
        return newArray;
    }
}
exports.EmbeddedTransactionBuilder = EmbeddedTransactionBuilder;

},{"./GeneratorUtils":220,"./KeyDto":235}],215:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedTransactionHelper = void 0;
const EmbeddedAccountAddressRestrictionTransactionBuilder_1 = require("./EmbeddedAccountAddressRestrictionTransactionBuilder");
const EmbeddedAccountKeyLinkTransactionBuilder_1 = require("./EmbeddedAccountKeyLinkTransactionBuilder");
const EmbeddedAccountMetadataTransactionBuilder_1 = require("./EmbeddedAccountMetadataTransactionBuilder");
const EmbeddedAccountMosaicRestrictionTransactionBuilder_1 = require("./EmbeddedAccountMosaicRestrictionTransactionBuilder");
const EmbeddedAccountOperationRestrictionTransactionBuilder_1 = require("./EmbeddedAccountOperationRestrictionTransactionBuilder");
const EmbeddedAddressAliasTransactionBuilder_1 = require("./EmbeddedAddressAliasTransactionBuilder");
const EmbeddedHashLockTransactionBuilder_1 = require("./EmbeddedHashLockTransactionBuilder");
const EmbeddedMosaicAddressRestrictionTransactionBuilder_1 = require("./EmbeddedMosaicAddressRestrictionTransactionBuilder");
const EmbeddedMosaicAliasTransactionBuilder_1 = require("./EmbeddedMosaicAliasTransactionBuilder");
const EmbeddedMosaicDefinitionTransactionBuilder_1 = require("./EmbeddedMosaicDefinitionTransactionBuilder");
const EmbeddedMosaicGlobalRestrictionTransactionBuilder_1 = require("./EmbeddedMosaicGlobalRestrictionTransactionBuilder");
const EmbeddedMosaicMetadataTransactionBuilder_1 = require("./EmbeddedMosaicMetadataTransactionBuilder");
const EmbeddedMosaicSupplyChangeTransactionBuilder_1 = require("./EmbeddedMosaicSupplyChangeTransactionBuilder");
const EmbeddedMultisigAccountModificationTransactionBuilder_1 = require("./EmbeddedMultisigAccountModificationTransactionBuilder");
const EmbeddedNamespaceMetadataTransactionBuilder_1 = require("./EmbeddedNamespaceMetadataTransactionBuilder");
const EmbeddedNamespaceRegistrationTransactionBuilder_1 = require("./EmbeddedNamespaceRegistrationTransactionBuilder");
const EmbeddedNodeKeyLinkTransactionBuilder_1 = require("./EmbeddedNodeKeyLinkTransactionBuilder");
const EmbeddedSecretLockTransactionBuilder_1 = require("./EmbeddedSecretLockTransactionBuilder");
const EmbeddedSecretProofTransactionBuilder_1 = require("./EmbeddedSecretProofTransactionBuilder");
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const EmbeddedTransferTransactionBuilder_1 = require("./EmbeddedTransferTransactionBuilder");
const EmbeddedVotingKeyLinkTransactionBuilder_1 = require("./EmbeddedVotingKeyLinkTransactionBuilder");
const EmbeddedVrfKeyLinkTransactionBuilder_1 = require("./EmbeddedVrfKeyLinkTransactionBuilder");
const EntityTypeDto_1 = require("./EntityTypeDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
class EmbeddedTransactionHelper {
    static serialize(transaction) {
        const byte = transaction.serialize();
        const padding = new Uint8Array(GeneratorUtils_1.GeneratorUtils.getTransactionPaddingSize(byte.length, 8));
        return GeneratorUtils_1.GeneratorUtils.concatTypedArrays(byte, padding);
    }
    static loadFromBinary(bytes) {
        const header = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(bytes);
        switch (header.getType()) {
            case EntityTypeDto_1.EntityTypeDto.MOSAIC_DEFINITION_TRANSACTION_BUILDER:
                return EmbeddedMosaicDefinitionTransactionBuilder_1.EmbeddedMosaicDefinitionTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.ACCOUNT_KEY_LINK_TRANSACTION_BUILDER:
                return EmbeddedAccountKeyLinkTransactionBuilder_1.EmbeddedAccountKeyLinkTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.NODE_KEY_LINK_TRANSACTION_BUILDER:
                return EmbeddedNodeKeyLinkTransactionBuilder_1.EmbeddedNodeKeyLinkTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.VOTING_KEY_LINK_TRANSACTION_BUILDER:
                return EmbeddedVotingKeyLinkTransactionBuilder_1.EmbeddedVotingKeyLinkTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.VRF_KEY_LINK_TRANSACTION_BUILDER:
                return EmbeddedVrfKeyLinkTransactionBuilder_1.EmbeddedVrfKeyLinkTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.HASH_LOCK_TRANSACTION_BUILDER:
                return EmbeddedHashLockTransactionBuilder_1.EmbeddedHashLockTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.SECRET_LOCK_TRANSACTION_BUILDER:
                return EmbeddedSecretLockTransactionBuilder_1.EmbeddedSecretLockTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.SECRET_PROOF_TRANSACTION_BUILDER:
                return EmbeddedSecretProofTransactionBuilder_1.EmbeddedSecretProofTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.ACCOUNT_METADATA_TRANSACTION_BUILDER:
                return EmbeddedAccountMetadataTransactionBuilder_1.EmbeddedAccountMetadataTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.MOSAIC_METADATA_TRANSACTION_BUILDER:
                return EmbeddedMosaicMetadataTransactionBuilder_1.EmbeddedMosaicMetadataTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.NAMESPACE_METADATA_TRANSACTION_BUILDER:
                return EmbeddedNamespaceMetadataTransactionBuilder_1.EmbeddedNamespaceMetadataTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.MOSAIC_SUPPLY_CHANGE_TRANSACTION_BUILDER:
                return EmbeddedMosaicSupplyChangeTransactionBuilder_1.EmbeddedMosaicSupplyChangeTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.MULTISIG_ACCOUNT_MODIFICATION_TRANSACTION_BUILDER:
                return EmbeddedMultisigAccountModificationTransactionBuilder_1.EmbeddedMultisigAccountModificationTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.ADDRESS_ALIAS_TRANSACTION_BUILDER:
                return EmbeddedAddressAliasTransactionBuilder_1.EmbeddedAddressAliasTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.MOSAIC_ALIAS_TRANSACTION_BUILDER:
                return EmbeddedMosaicAliasTransactionBuilder_1.EmbeddedMosaicAliasTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.NAMESPACE_REGISTRATION_TRANSACTION_BUILDER:
                return EmbeddedNamespaceRegistrationTransactionBuilder_1.EmbeddedNamespaceRegistrationTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.ACCOUNT_ADDRESS_RESTRICTION_TRANSACTION_BUILDER:
                return EmbeddedAccountAddressRestrictionTransactionBuilder_1.EmbeddedAccountAddressRestrictionTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.ACCOUNT_MOSAIC_RESTRICTION_TRANSACTION_BUILDER:
                return EmbeddedAccountMosaicRestrictionTransactionBuilder_1.EmbeddedAccountMosaicRestrictionTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.ACCOUNT_OPERATION_RESTRICTION_TRANSACTION_BUILDER:
                return EmbeddedAccountOperationRestrictionTransactionBuilder_1.EmbeddedAccountOperationRestrictionTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.MOSAIC_ADDRESS_RESTRICTION_TRANSACTION_BUILDER:
                return EmbeddedMosaicAddressRestrictionTransactionBuilder_1.EmbeddedMosaicAddressRestrictionTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.MOSAIC_GLOBAL_RESTRICTION_TRANSACTION_BUILDER:
                return EmbeddedMosaicGlobalRestrictionTransactionBuilder_1.EmbeddedMosaicGlobalRestrictionTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.TRANSFER_TRANSACTION_BUILDER:
                return EmbeddedTransferTransactionBuilder_1.EmbeddedTransferTransactionBuilder.loadFromBinary(bytes);
            default:
                throw new Error(`Transaction type: ${header.getType()} not recognized.`);
        }
    }
    static getEmbeddedTransactionSize(transactions) {
        return transactions.map((o) => EmbeddedTransactionHelper.serialize(o).length).reduce((a, b) => a + b, 0);
    }
}
exports.EmbeddedTransactionHelper = EmbeddedTransactionHelper;

},{"./EmbeddedAccountAddressRestrictionTransactionBuilder":195,"./EmbeddedAccountKeyLinkTransactionBuilder":196,"./EmbeddedAccountMetadataTransactionBuilder":197,"./EmbeddedAccountMosaicRestrictionTransactionBuilder":198,"./EmbeddedAccountOperationRestrictionTransactionBuilder":199,"./EmbeddedAddressAliasTransactionBuilder":200,"./EmbeddedHashLockTransactionBuilder":201,"./EmbeddedMosaicAddressRestrictionTransactionBuilder":202,"./EmbeddedMosaicAliasTransactionBuilder":203,"./EmbeddedMosaicDefinitionTransactionBuilder":204,"./EmbeddedMosaicGlobalRestrictionTransactionBuilder":205,"./EmbeddedMosaicMetadataTransactionBuilder":206,"./EmbeddedMosaicSupplyChangeTransactionBuilder":207,"./EmbeddedMultisigAccountModificationTransactionBuilder":208,"./EmbeddedNamespaceMetadataTransactionBuilder":209,"./EmbeddedNamespaceRegistrationTransactionBuilder":210,"./EmbeddedNodeKeyLinkTransactionBuilder":211,"./EmbeddedSecretLockTransactionBuilder":212,"./EmbeddedSecretProofTransactionBuilder":213,"./EmbeddedTransactionBuilder":214,"./EmbeddedTransferTransactionBuilder":216,"./EmbeddedVotingKeyLinkTransactionBuilder":217,"./EmbeddedVrfKeyLinkTransactionBuilder":218,"./EntityTypeDto":219,"./GeneratorUtils":220}],216:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedTransferTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const TransferTransactionBodyBuilder_1 = require("./TransferTransactionBodyBuilder");
class EmbeddedTransferTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, recipientAddress, mosaics, message) {
        super(signerPublicKey, version, network, type);
        this.transferTransactionBody = new TransferTransactionBodyBuilder_1.TransferTransactionBodyBuilder(recipientAddress, mosaics, message);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const transferTransactionBody = TransferTransactionBodyBuilder_1.TransferTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, transferTransactionBody.getSize());
        return new EmbeddedTransferTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, transferTransactionBody.recipientAddress, transferTransactionBody.mosaics, transferTransactionBody.message);
    }
    getRecipientAddress() {
        return this.transferTransactionBody.getRecipientAddress();
    }
    getTransferTransactionBody_Reserved1() {
        return this.transferTransactionBody.getTransferTransactionBody_Reserved1();
    }
    getTransferTransactionBody_Reserved2() {
        return this.transferTransactionBody.getTransferTransactionBody_Reserved2();
    }
    getMosaics() {
        return this.transferTransactionBody.getMosaics();
    }
    getMessage() {
        return this.transferTransactionBody.getMessage();
    }
    getSize() {
        let size = super.getSize();
        size += this.transferTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const transferTransactionBodyBytes = this.transferTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, transferTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedTransferTransactionBuilder = EmbeddedTransferTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./TransferTransactionBodyBuilder":297}],217:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedVotingKeyLinkTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const VotingKeyLinkTransactionBodyBuilder_1 = require("./VotingKeyLinkTransactionBodyBuilder");
class EmbeddedVotingKeyLinkTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, linkedPublicKey, linkAction) {
        super(signerPublicKey, version, network, type);
        this.votingKeyLinkTransactionBody = new VotingKeyLinkTransactionBodyBuilder_1.VotingKeyLinkTransactionBodyBuilder(linkedPublicKey, linkAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const votingKeyLinkTransactionBody = VotingKeyLinkTransactionBodyBuilder_1.VotingKeyLinkTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, votingKeyLinkTransactionBody.getSize());
        return new EmbeddedVotingKeyLinkTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, votingKeyLinkTransactionBody.linkedPublicKey, votingKeyLinkTransactionBody.linkAction);
    }
    getLinkedPublicKey() {
        return this.votingKeyLinkTransactionBody.getLinkedPublicKey();
    }
    getLinkAction() {
        return this.votingKeyLinkTransactionBody.getLinkAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.votingKeyLinkTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const votingKeyLinkTransactionBodyBytes = this.votingKeyLinkTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, votingKeyLinkTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedVotingKeyLinkTransactionBuilder = EmbeddedVotingKeyLinkTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./VotingKeyLinkTransactionBodyBuilder":303}],218:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedVrfKeyLinkTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const VrfKeyLinkTransactionBodyBuilder_1 = require("./VrfKeyLinkTransactionBodyBuilder");
class EmbeddedVrfKeyLinkTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, linkedPublicKey, linkAction) {
        super(signerPublicKey, version, network, type);
        this.vrfKeyLinkTransactionBody = new VrfKeyLinkTransactionBodyBuilder_1.VrfKeyLinkTransactionBodyBuilder(linkedPublicKey, linkAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const vrfKeyLinkTransactionBody = VrfKeyLinkTransactionBodyBuilder_1.VrfKeyLinkTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, vrfKeyLinkTransactionBody.getSize());
        return new EmbeddedVrfKeyLinkTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, vrfKeyLinkTransactionBody.linkedPublicKey, vrfKeyLinkTransactionBody.linkAction);
    }
    getLinkedPublicKey() {
        return this.vrfKeyLinkTransactionBody.getLinkedPublicKey();
    }
    getLinkAction() {
        return this.vrfKeyLinkTransactionBody.getLinkAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.vrfKeyLinkTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const vrfKeyLinkTransactionBodyBytes = this.vrfKeyLinkTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, vrfKeyLinkTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedVrfKeyLinkTransactionBuilder = EmbeddedVrfKeyLinkTransactionBuilder;

},{"./EmbeddedTransactionBuilder":214,"./GeneratorUtils":220,"./VrfKeyLinkTransactionBodyBuilder":305}],219:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityTypeDto = void 0;
var EntityTypeDto;
(function (EntityTypeDto) {
    EntityTypeDto[EntityTypeDto["RESERVED"] = 0] = "RESERVED";
    EntityTypeDto[EntityTypeDto["BLOCK_HEADER_BUILDER"] = 33091] = "BLOCK_HEADER_BUILDER";
    EntityTypeDto[EntityTypeDto["MOSAIC_DEFINITION_TRANSACTION_BUILDER"] = 16717] = "MOSAIC_DEFINITION_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["ACCOUNT_KEY_LINK_TRANSACTION_BUILDER"] = 16716] = "ACCOUNT_KEY_LINK_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["NODE_KEY_LINK_TRANSACTION_BUILDER"] = 16972] = "NODE_KEY_LINK_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["AGGREGATE_COMPLETE_TRANSACTION_BUILDER"] = 16705] = "AGGREGATE_COMPLETE_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["AGGREGATE_BONDED_TRANSACTION_BUILDER"] = 16961] = "AGGREGATE_BONDED_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["VOTING_KEY_LINK_TRANSACTION_BUILDER"] = 16707] = "VOTING_KEY_LINK_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["VRF_KEY_LINK_TRANSACTION_BUILDER"] = 16963] = "VRF_KEY_LINK_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["HASH_LOCK_TRANSACTION_BUILDER"] = 16712] = "HASH_LOCK_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["SECRET_LOCK_TRANSACTION_BUILDER"] = 16722] = "SECRET_LOCK_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["SECRET_PROOF_TRANSACTION_BUILDER"] = 16978] = "SECRET_PROOF_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["ACCOUNT_METADATA_TRANSACTION_BUILDER"] = 16708] = "ACCOUNT_METADATA_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["MOSAIC_METADATA_TRANSACTION_BUILDER"] = 16964] = "MOSAIC_METADATA_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["NAMESPACE_METADATA_TRANSACTION_BUILDER"] = 17220] = "NAMESPACE_METADATA_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["MOSAIC_SUPPLY_CHANGE_TRANSACTION_BUILDER"] = 16973] = "MOSAIC_SUPPLY_CHANGE_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["MULTISIG_ACCOUNT_MODIFICATION_TRANSACTION_BUILDER"] = 16725] = "MULTISIG_ACCOUNT_MODIFICATION_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["ADDRESS_ALIAS_TRANSACTION_BUILDER"] = 16974] = "ADDRESS_ALIAS_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["MOSAIC_ALIAS_TRANSACTION_BUILDER"] = 17230] = "MOSAIC_ALIAS_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["NAMESPACE_REGISTRATION_TRANSACTION_BUILDER"] = 16718] = "NAMESPACE_REGISTRATION_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["ACCOUNT_ADDRESS_RESTRICTION_TRANSACTION_BUILDER"] = 16720] = "ACCOUNT_ADDRESS_RESTRICTION_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["ACCOUNT_MOSAIC_RESTRICTION_TRANSACTION_BUILDER"] = 16976] = "ACCOUNT_MOSAIC_RESTRICTION_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["ACCOUNT_OPERATION_RESTRICTION_TRANSACTION_BUILDER"] = 17232] = "ACCOUNT_OPERATION_RESTRICTION_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["MOSAIC_ADDRESS_RESTRICTION_TRANSACTION_BUILDER"] = 16977] = "MOSAIC_ADDRESS_RESTRICTION_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["MOSAIC_GLOBAL_RESTRICTION_TRANSACTION_BUILDER"] = 16721] = "MOSAIC_GLOBAL_RESTRICTION_TRANSACTION_BUILDER";
    EntityTypeDto[EntityTypeDto["TRANSFER_TRANSACTION_BUILDER"] = 16724] = "TRANSFER_TRANSACTION_BUILDER";
})(EntityTypeDto = exports.EntityTypeDto || (exports.EntityTypeDto = {}));

},{}],220:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorUtils = void 0;
class GeneratorUtils {
    static bufferToUint64(input) {
        if (8 !== input.length) {
            throw Error(`byte array has unexpected size '${input.length}'`);
        }
        input = input.reverse();
        const view = new DataView(input.buffer);
        return [view.getUint32(4), view.getUint32(0)];
    }
    static readUint32At(bytes, index) {
        return ((bytes[index] +
            (bytes[index + 1] << 8) +
            (bytes[index + 2] << 16) +
            (bytes[index + 3] << 24)) >>>
            0);
    }
    static uintToBuffer(uintValue, bufferSize) {
        const buffer = new ArrayBuffer(bufferSize);
        const dataView = new DataView(buffer);
        try {
            if (1 === bufferSize) {
                dataView.setUint8(0, uintValue);
            }
            else if (2 === bufferSize) {
                dataView.setUint16(0, uintValue, true);
            }
            else if (4 === bufferSize) {
                dataView.setUint32(0, uintValue, true);
            }
            else {
                throw new Error("Unexpected bufferSize");
            }
            return new Uint8Array(buffer);
        }
        catch (e) {
            throw new Error(`Converting uint value ${uintValue} into buffer with error: ${e}`);
        }
    }
    static bufferToUint(buffer) {
        const dataView = new DataView(buffer.buffer);
        try {
            if (1 === buffer.byteLength) {
                return dataView.getUint8(0);
            }
            else if (2 === buffer.byteLength) {
                return dataView.getUint16(0, true);
            }
            else if (4 === buffer.byteLength) {
                return dataView.getUint32(0, true);
            }
            throw new Error("Unexpected buffer size");
        }
        catch (e) {
            throw new Error(`Converting buffer into number with error: ${e}`);
        }
    }
    static uint64ToBuffer(uintValue) {
        const uint32Array = new Uint32Array(uintValue);
        return new Uint8Array(uint32Array.buffer);
    }
    static concatTypedArrays(array1, array2) {
        const newArray = new Uint8Array(array1.length + array2.length);
        newArray.set(array1);
        newArray.set(array2, array1.length);
        return newArray;
    }
    static getBytes(binary, size) {
        if (size > binary.length) {
            throw new RangeError();
        }
        const bytes = binary.slice(0, size);
        return bytes;
    }
    static getTransactionPaddingSize(size, alignment) {
        return 0 === size % alignment ? 0 : alignment - (size % alignment);
    }
    static compact(uint64) {
        const low = uint64[0];
        const high = uint64[1];
        if (0x00200000 <= high) {
            return uint64;
        }
        return high * 0x100000000 + low;
    }
    static fromUint(number) {
        const value = [(number & 0xffffffff) >>> 0, (number / 0x100000000) >>> 0];
        return value;
    }
}
exports.GeneratorUtils = GeneratorUtils;
GeneratorUtils.uint8ToInt8 = (input) => {
    if (0xff < input) {
        throw Error(`input '${input}' is out of range`);
    }
    return (input << 24) >> 24;
};

},{}],221:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalKeyValueBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicRestrictionKeyDto_1 = require("./MosaicRestrictionKeyDto");
const RestrictionRuleBuilder_1 = require("./RestrictionRuleBuilder");
class GlobalKeyValueBuilder {
    constructor(key, restrictionRule) {
        this.key = key;
        this.restrictionRule = restrictionRule;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const key = MosaicRestrictionKeyDto_1.MosaicRestrictionKeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, key.getSize());
        const restrictionRule = RestrictionRuleBuilder_1.RestrictionRuleBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, restrictionRule.getSize());
        return new GlobalKeyValueBuilder(key, restrictionRule);
    }
    getKey() {
        return this.key;
    }
    getRestrictionRule() {
        return this.restrictionRule;
    }
    getSize() {
        let size = 0;
        size += this.key.getSize();
        size += this.restrictionRule.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const keyBytes = this.key.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, keyBytes);
        const restrictionRuleBytes = this.restrictionRule.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionRuleBytes);
        return newArray;
    }
}
exports.GlobalKeyValueBuilder = GlobalKeyValueBuilder;

},{"./GeneratorUtils":220,"./MosaicRestrictionKeyDto":261,"./RestrictionRuleBuilder":285}],222:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalKeyValueSetBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const GlobalKeyValueBuilder_1 = require("./GlobalKeyValueBuilder");
class GlobalKeyValueSetBuilder {
    constructor(keys) {
        this.keys = keys;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const keyValueCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const keys = [];
        for (let i = 0; i < (Array.isArray(keyValueCount) ? GeneratorUtils_1.GeneratorUtils.compact(keyValueCount) : keyValueCount); i++) {
            const item = GlobalKeyValueBuilder_1.GlobalKeyValueBuilder.loadFromBinary(Uint8Array.from(byteArray));
            keys.push(item);
            byteArray.splice(0, item.getSize());
        }
        return new GlobalKeyValueSetBuilder(keys);
    }
    getKeys() {
        return this.keys;
    }
    getSize() {
        let size = 0;
        size += 1;
        this.keys.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const keyValueCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.keys.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, keyValueCountBytes);
        this.keys.forEach((item) => {
            const keysBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, keysBytes);
        });
        return newArray;
    }
}
exports.GlobalKeyValueSetBuilder = GlobalKeyValueSetBuilder;

},{"./GeneratorUtils":220,"./GlobalKeyValueBuilder":221}],223:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hash256Dto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class Hash256Dto {
    constructor(hash256) {
        this.hash256 = hash256;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const hash256 = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 32);
        byteArray.splice(0, 32);
        return new Hash256Dto(hash256);
    }
    getHash256() {
        return this.hash256;
    }
    getSize() {
        return 32;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.hash256);
        return newArray;
    }
}
exports.Hash256Dto = Hash256Dto;

},{"./GeneratorUtils":220}],224:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hash512Dto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class Hash512Dto {
    constructor(hash512) {
        this.hash512 = hash512;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const hash512 = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 64);
        byteArray.splice(0, 64);
        return new Hash512Dto(hash512);
    }
    getHash512() {
        return this.hash512;
    }
    getSize() {
        return 64;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.hash512);
        return newArray;
    }
}
exports.Hash512Dto = Hash512Dto;

},{"./GeneratorUtils":220}],225:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HashLockInfoBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const Hash256Dto_1 = require("./Hash256Dto");
const HeightDto_1 = require("./HeightDto");
const MosaicBuilder_1 = require("./MosaicBuilder");
class HashLockInfoBuilder {
    constructor(ownerAddress, mosaic, endHeight, status, hash) {
        this.ownerAddress = ownerAddress;
        this.mosaic = mosaic;
        this.endHeight = endHeight;
        this.status = status;
        this.hash = hash;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const ownerAddress = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, ownerAddress.getSize());
        const mosaic = MosaicBuilder_1.MosaicBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaic.getSize());
        const endHeight = HeightDto_1.HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, endHeight.getSize());
        const status = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const hash = Hash256Dto_1.Hash256Dto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, hash.getSize());
        return new HashLockInfoBuilder(ownerAddress, mosaic, endHeight, status, hash);
    }
    getOwnerAddress() {
        return this.ownerAddress;
    }
    getMosaic() {
        return this.mosaic;
    }
    getEndHeight() {
        return this.endHeight;
    }
    getStatus() {
        return this.status;
    }
    getHash() {
        return this.hash;
    }
    getSize() {
        let size = 0;
        size += this.ownerAddress.getSize();
        size += this.mosaic.getSize();
        size += this.endHeight.getSize();
        size += 1;
        size += this.hash.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const ownerAddressBytes = this.ownerAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, ownerAddressBytes);
        const mosaicBytes = this.mosaic.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicBytes);
        const endHeightBytes = this.endHeight.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, endHeightBytes);
        const statusBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.status, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, statusBytes);
        const hashBytes = this.hash.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, hashBytes);
        return newArray;
    }
}
exports.HashLockInfoBuilder = HashLockInfoBuilder;

},{"./AddressDto":178,"./GeneratorUtils":220,"./Hash256Dto":223,"./HeightDto":230,"./MosaicBuilder":243}],226:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HashLockTransactionBodyBuilder = void 0;
const BlockDurationDto_1 = require("./BlockDurationDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const Hash256Dto_1 = require("./Hash256Dto");
const UnresolvedMosaicBuilder_1 = require("./UnresolvedMosaicBuilder");
class HashLockTransactionBodyBuilder {
    constructor(mosaic, duration, hash) {
        this.mosaic = mosaic;
        this.duration = duration;
        this.hash = hash;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const mosaic = UnresolvedMosaicBuilder_1.UnresolvedMosaicBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaic.getSize());
        const duration = BlockDurationDto_1.BlockDurationDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, duration.getSize());
        const hash = Hash256Dto_1.Hash256Dto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, hash.getSize());
        return new HashLockTransactionBodyBuilder(mosaic, duration, hash);
    }
    getMosaic() {
        return this.mosaic;
    }
    getDuration() {
        return this.duration;
    }
    getHash() {
        return this.hash;
    }
    getSize() {
        let size = 0;
        size += this.mosaic.getSize();
        size += this.duration.getSize();
        size += this.hash.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const mosaicBytes = this.mosaic.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicBytes);
        const durationBytes = this.duration.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, durationBytes);
        const hashBytes = this.hash.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, hashBytes);
        return newArray;
    }
}
exports.HashLockTransactionBodyBuilder = HashLockTransactionBodyBuilder;

},{"./BlockDurationDto":189,"./GeneratorUtils":220,"./Hash256Dto":223,"./UnresolvedMosaicBuilder":300}],227:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HashLockTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const HashLockTransactionBodyBuilder_1 = require("./HashLockTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class HashLockTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, mosaic, duration, hash) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.hashLockTransactionBody = new HashLockTransactionBodyBuilder_1.HashLockTransactionBodyBuilder(mosaic, duration, hash);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const hashLockTransactionBody = HashLockTransactionBodyBuilder_1.HashLockTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, hashLockTransactionBody.getSize());
        return new HashLockTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, hashLockTransactionBody.mosaic, hashLockTransactionBody.duration, hashLockTransactionBody.hash);
    }
    getMosaic() {
        return this.hashLockTransactionBody.getMosaic();
    }
    getDuration() {
        return this.hashLockTransactionBody.getDuration();
    }
    getHash() {
        return this.hashLockTransactionBody.getHash();
    }
    getSize() {
        let size = super.getSize();
        size += this.hashLockTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const hashLockTransactionBodyBytes = this.hashLockTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, hashLockTransactionBodyBytes);
        return newArray;
    }
}
exports.HashLockTransactionBuilder = HashLockTransactionBuilder;

},{"./GeneratorUtils":220,"./HashLockTransactionBodyBuilder":226,"./TransactionBuilder":295}],228:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HeightActivityBucketBuilder = void 0;
const AmountDto_1 = require("./AmountDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const ImportanceHeightDto_1 = require("./ImportanceHeightDto");
class HeightActivityBucketBuilder {
    constructor(startHeight, totalFeesPaid, beneficiaryCount, rawScore) {
        this.startHeight = startHeight;
        this.totalFeesPaid = totalFeesPaid;
        this.beneficiaryCount = beneficiaryCount;
        this.rawScore = rawScore;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const startHeight = ImportanceHeightDto_1.ImportanceHeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, startHeight.getSize());
        const totalFeesPaid = AmountDto_1.AmountDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, totalFeesPaid.getSize());
        const beneficiaryCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const rawScore = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new HeightActivityBucketBuilder(startHeight, totalFeesPaid, beneficiaryCount, rawScore);
    }
    getStartHeight() {
        return this.startHeight;
    }
    getTotalFeesPaid() {
        return this.totalFeesPaid;
    }
    getBeneficiaryCount() {
        return this.beneficiaryCount;
    }
    getRawScore() {
        return this.rawScore;
    }
    getSize() {
        let size = 0;
        size += this.startHeight.getSize();
        size += this.totalFeesPaid.getSize();
        size += 4;
        size += 8;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const startHeightBytes = this.startHeight.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, startHeightBytes);
        const totalFeesPaidBytes = this.totalFeesPaid.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, totalFeesPaidBytes);
        const beneficiaryCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getBeneficiaryCount(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, beneficiaryCountBytes);
        const rawScoreBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getRawScore());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, rawScoreBytes);
        return newArray;
    }
}
exports.HeightActivityBucketBuilder = HeightActivityBucketBuilder;

},{"./AmountDto":186,"./GeneratorUtils":220,"./ImportanceHeightDto":232}],229:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HeightActivityBucketsBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class HeightActivityBucketsBuilder {
    constructor(buckets) {
        this.buckets = buckets;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const buckets = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 5);
        byteArray.splice(0, 5);
        return new HeightActivityBucketsBuilder(buckets);
    }
    getBuckets() {
        return this.buckets;
    }
    getSize() {
        let size = 0;
        size += this.buckets.length;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.buckets);
        return newArray;
    }
}
exports.HeightActivityBucketsBuilder = HeightActivityBucketsBuilder;

},{"./GeneratorUtils":220}],230:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HeightDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class HeightDto {
    constructor(height) {
        this.height = height;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const height = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new HeightDto(height);
    }
    getHeight() {
        return this.height;
    }
    getSize() {
        return 8;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const heightBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getHeight());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, heightBytes);
        return newArray;
    }
}
exports.HeightDto = HeightDto;

},{"./GeneratorUtils":220}],231:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportanceDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class ImportanceDto {
    constructor(importance) {
        this.importance = importance;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const importance = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new ImportanceDto(importance);
    }
    getImportance() {
        return this.importance;
    }
    getSize() {
        return 8;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const importanceBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getImportance());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, importanceBytes);
        return newArray;
    }
}
exports.ImportanceDto = ImportanceDto;

},{"./GeneratorUtils":220}],232:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportanceHeightDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class ImportanceHeightDto {
    constructor(importanceHeight) {
        this.importanceHeight = importanceHeight;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const importanceHeight = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new ImportanceHeightDto(importanceHeight);
    }
    getImportanceHeight() {
        return this.importanceHeight;
    }
    getSize() {
        return 8;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const importanceHeightBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getImportanceHeight());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, importanceHeightBytes);
        return newArray;
    }
}
exports.ImportanceHeightDto = ImportanceHeightDto;

},{"./GeneratorUtils":220}],233:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportanceSnapshotBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const ImportanceDto_1 = require("./ImportanceDto");
const ImportanceHeightDto_1 = require("./ImportanceHeightDto");
class ImportanceSnapshotBuilder {
    constructor(importance, height) {
        this.importance = importance;
        this.height = height;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const importance = ImportanceDto_1.ImportanceDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, importance.getSize());
        const height = ImportanceHeightDto_1.ImportanceHeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, height.getSize());
        return new ImportanceSnapshotBuilder(importance, height);
    }
    getImportance() {
        return this.importance;
    }
    getHeight() {
        return this.height;
    }
    getSize() {
        let size = 0;
        size += this.importance.getSize();
        size += this.height.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const importanceBytes = this.importance.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, importanceBytes);
        const heightBytes = this.height.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, heightBytes);
        return newArray;
    }
}
exports.ImportanceSnapshotBuilder = ImportanceSnapshotBuilder;

},{"./GeneratorUtils":220,"./ImportanceDto":231,"./ImportanceHeightDto":232}],234:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InflationReceiptBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicBuilder_1 = require("./MosaicBuilder");
const ReceiptBuilder_1 = require("./ReceiptBuilder");
class InflationReceiptBuilder extends ReceiptBuilder_1.ReceiptBuilder {
    constructor(version, type, mosaic) {
        super(version, type);
        this.mosaic = mosaic;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = ReceiptBuilder_1.ReceiptBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaic = MosaicBuilder_1.MosaicBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaic.getSize());
        return new InflationReceiptBuilder(superObject.version, superObject.type, mosaic);
    }
    getMosaic() {
        return this.mosaic;
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaic.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicBytes = this.mosaic.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicBytes);
        return newArray;
    }
}
exports.InflationReceiptBuilder = InflationReceiptBuilder;

},{"./GeneratorUtils":220,"./MosaicBuilder":243,"./ReceiptBuilder":283}],235:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class KeyDto {
    constructor(key) {
        this.key = key;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const key = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 32);
        byteArray.splice(0, 32);
        return new KeyDto(key);
    }
    getKey() {
        return this.key;
    }
    getSize() {
        return 32;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.key);
        return newArray;
    }
}
exports.KeyDto = KeyDto;

},{"./GeneratorUtils":220}],236:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataEntryBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MetadataValueBuilder_1 = require("./MetadataValueBuilder");
const ScopedMetadataKeyDto_1 = require("./ScopedMetadataKeyDto");
class MetadataEntryBuilder {
    constructor(sourceAddress, targetAddress, scopedMetadataKey, targetId, metadataType, value) {
        this.sourceAddress = sourceAddress;
        this.targetAddress = targetAddress;
        this.scopedMetadataKey = scopedMetadataKey;
        this.targetId = targetId;
        this.metadataType = metadataType;
        this.value = value;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const sourceAddress = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, sourceAddress.getSize());
        const targetAddress = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, targetAddress.getSize());
        const scopedMetadataKey = ScopedMetadataKeyDto_1.ScopedMetadataKeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, scopedMetadataKey.getSize());
        const targetId = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const metadataType = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const value = MetadataValueBuilder_1.MetadataValueBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, value.getSize());
        return new MetadataEntryBuilder(sourceAddress, targetAddress, scopedMetadataKey, targetId, metadataType, value);
    }
    getSourceAddress() {
        return this.sourceAddress;
    }
    getTargetAddress() {
        return this.targetAddress;
    }
    getScopedMetadataKey() {
        return this.scopedMetadataKey;
    }
    getTargetId() {
        return this.targetId;
    }
    getMetadataType() {
        return this.metadataType;
    }
    getValue() {
        return this.value;
    }
    getSize() {
        let size = 0;
        size += this.sourceAddress.getSize();
        size += this.targetAddress.getSize();
        size += this.scopedMetadataKey.getSize();
        size += 8;
        size += 1;
        size += this.value.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const sourceAddressBytes = this.sourceAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, sourceAddressBytes);
        const targetAddressBytes = this.targetAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, targetAddressBytes);
        const scopedMetadataKeyBytes = this.scopedMetadataKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, scopedMetadataKeyBytes);
        const targetIdBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getTargetId());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, targetIdBytes);
        const metadataTypeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.metadataType, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, metadataTypeBytes);
        const valueBytes = this.value.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, valueBytes);
        return newArray;
    }
}
exports.MetadataEntryBuilder = MetadataEntryBuilder;

},{"./AddressDto":178,"./GeneratorUtils":220,"./MetadataValueBuilder":237,"./ScopedMetadataKeyDto":287}],237:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataValueBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class MetadataValueBuilder {
    constructor(data) {
        this.size = 0;
        this.data = data;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const size = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const data = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), size);
        byteArray.splice(0, size);
        return new MetadataValueBuilder(data);
    }
    getData() {
        return this.data;
    }
    getSize() {
        let size = 0;
        size += 2;
        size += this.data.length;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const sizeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getSize(), 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, sizeBytes);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.data);
        return newArray;
    }
}
exports.MetadataValueBuilder = MetadataValueBuilder;

},{"./GeneratorUtils":220}],238:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicAddressRestrictionEntryBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const AddressKeyValueSetBuilder_1 = require("./AddressKeyValueSetBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicIdDto_1 = require("./MosaicIdDto");
class MosaicAddressRestrictionEntryBuilder {
    constructor(mosaicId, address, keyPairs) {
        this.mosaicId = mosaicId;
        this.address = address;
        this.keyPairs = keyPairs;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const mosaicId = MosaicIdDto_1.MosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicId.getSize());
        const address = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, address.getSize());
        const keyPairs = AddressKeyValueSetBuilder_1.AddressKeyValueSetBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, keyPairs.getSize());
        return new MosaicAddressRestrictionEntryBuilder(mosaicId, address, keyPairs);
    }
    getMosaicId() {
        return this.mosaicId;
    }
    getAddress() {
        return this.address;
    }
    getKeyPairs() {
        return this.keyPairs;
    }
    getSize() {
        let size = 0;
        size += this.mosaicId.getSize();
        size += this.address.getSize();
        size += this.keyPairs.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const mosaicIdBytes = this.mosaicId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicIdBytes);
        const addressBytes = this.address.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressBytes);
        const keyPairsBytes = this.keyPairs.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, keyPairsBytes);
        return newArray;
    }
}
exports.MosaicAddressRestrictionEntryBuilder = MosaicAddressRestrictionEntryBuilder;

},{"./AddressDto":178,"./AddressKeyValueSetBuilder":180,"./GeneratorUtils":220,"./MosaicIdDto":252}],239:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicAddressRestrictionTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const UnresolvedAddressDto_1 = require("./UnresolvedAddressDto");
const UnresolvedMosaicIdDto_1 = require("./UnresolvedMosaicIdDto");
class MosaicAddressRestrictionTransactionBodyBuilder {
    constructor(mosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, targetAddress) {
        this.mosaicId = mosaicId;
        this.restrictionKey = restrictionKey;
        this.previousRestrictionValue = previousRestrictionValue;
        this.newRestrictionValue = newRestrictionValue;
        this.targetAddress = targetAddress;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const mosaicId = UnresolvedMosaicIdDto_1.UnresolvedMosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicId.getSize());
        const restrictionKey = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const previousRestrictionValue = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const newRestrictionValue = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const targetAddress = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, targetAddress.getSize());
        return new MosaicAddressRestrictionTransactionBodyBuilder(mosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, targetAddress);
    }
    getMosaicId() {
        return this.mosaicId;
    }
    getRestrictionKey() {
        return this.restrictionKey;
    }
    getPreviousRestrictionValue() {
        return this.previousRestrictionValue;
    }
    getNewRestrictionValue() {
        return this.newRestrictionValue;
    }
    getTargetAddress() {
        return this.targetAddress;
    }
    getSize() {
        let size = 0;
        size += this.mosaicId.getSize();
        size += 8;
        size += 8;
        size += 8;
        size += this.targetAddress.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const mosaicIdBytes = this.mosaicId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicIdBytes);
        const restrictionKeyBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getRestrictionKey());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionKeyBytes);
        const previousRestrictionValueBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getPreviousRestrictionValue());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, previousRestrictionValueBytes);
        const newRestrictionValueBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getNewRestrictionValue());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, newRestrictionValueBytes);
        const targetAddressBytes = this.targetAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, targetAddressBytes);
        return newArray;
    }
}
exports.MosaicAddressRestrictionTransactionBodyBuilder = MosaicAddressRestrictionTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./UnresolvedAddressDto":299,"./UnresolvedMosaicIdDto":301}],240:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicAddressRestrictionTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicAddressRestrictionTransactionBodyBuilder_1 = require("./MosaicAddressRestrictionTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class MosaicAddressRestrictionTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, mosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, targetAddress) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.mosaicAddressRestrictionTransactionBody = new MosaicAddressRestrictionTransactionBodyBuilder_1.MosaicAddressRestrictionTransactionBodyBuilder(mosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, targetAddress);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaicAddressRestrictionTransactionBody = MosaicAddressRestrictionTransactionBodyBuilder_1.MosaicAddressRestrictionTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicAddressRestrictionTransactionBody.getSize());
        return new MosaicAddressRestrictionTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, mosaicAddressRestrictionTransactionBody.mosaicId, mosaicAddressRestrictionTransactionBody.restrictionKey, mosaicAddressRestrictionTransactionBody.previousRestrictionValue, mosaicAddressRestrictionTransactionBody.newRestrictionValue, mosaicAddressRestrictionTransactionBody.targetAddress);
    }
    getMosaicId() {
        return this.mosaicAddressRestrictionTransactionBody.getMosaicId();
    }
    getRestrictionKey() {
        return this.mosaicAddressRestrictionTransactionBody.getRestrictionKey();
    }
    getPreviousRestrictionValue() {
        return this.mosaicAddressRestrictionTransactionBody.getPreviousRestrictionValue();
    }
    getNewRestrictionValue() {
        return this.mosaicAddressRestrictionTransactionBody.getNewRestrictionValue();
    }
    getTargetAddress() {
        return this.mosaicAddressRestrictionTransactionBody.getTargetAddress();
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaicAddressRestrictionTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicAddressRestrictionTransactionBodyBytes = this.mosaicAddressRestrictionTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicAddressRestrictionTransactionBodyBytes);
        return newArray;
    }
}
exports.MosaicAddressRestrictionTransactionBuilder = MosaicAddressRestrictionTransactionBuilder;

},{"./GeneratorUtils":220,"./MosaicAddressRestrictionTransactionBodyBuilder":239,"./TransactionBuilder":295}],241:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicAliasTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicIdDto_1 = require("./MosaicIdDto");
const NamespaceIdDto_1 = require("./NamespaceIdDto");
class MosaicAliasTransactionBodyBuilder {
    constructor(namespaceId, mosaicId, aliasAction) {
        this.namespaceId = namespaceId;
        this.mosaicId = mosaicId;
        this.aliasAction = aliasAction;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const namespaceId = NamespaceIdDto_1.NamespaceIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, namespaceId.getSize());
        const mosaicId = MosaicIdDto_1.MosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicId.getSize());
        const aliasAction = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        return new MosaicAliasTransactionBodyBuilder(namespaceId, mosaicId, aliasAction);
    }
    getNamespaceId() {
        return this.namespaceId;
    }
    getMosaicId() {
        return this.mosaicId;
    }
    getAliasAction() {
        return this.aliasAction;
    }
    getSize() {
        let size = 0;
        size += this.namespaceId.getSize();
        size += this.mosaicId.getSize();
        size += 1;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const namespaceIdBytes = this.namespaceId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, namespaceIdBytes);
        const mosaicIdBytes = this.mosaicId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicIdBytes);
        const aliasActionBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.aliasAction, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, aliasActionBytes);
        return newArray;
    }
}
exports.MosaicAliasTransactionBodyBuilder = MosaicAliasTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./MosaicIdDto":252,"./NamespaceIdDto":270}],242:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicAliasTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicAliasTransactionBodyBuilder_1 = require("./MosaicAliasTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class MosaicAliasTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, namespaceId, mosaicId, aliasAction) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.mosaicAliasTransactionBody = new MosaicAliasTransactionBodyBuilder_1.MosaicAliasTransactionBodyBuilder(namespaceId, mosaicId, aliasAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaicAliasTransactionBody = MosaicAliasTransactionBodyBuilder_1.MosaicAliasTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicAliasTransactionBody.getSize());
        return new MosaicAliasTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, mosaicAliasTransactionBody.namespaceId, mosaicAliasTransactionBody.mosaicId, mosaicAliasTransactionBody.aliasAction);
    }
    getNamespaceId() {
        return this.mosaicAliasTransactionBody.getNamespaceId();
    }
    getMosaicId() {
        return this.mosaicAliasTransactionBody.getMosaicId();
    }
    getAliasAction() {
        return this.mosaicAliasTransactionBody.getAliasAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaicAliasTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicAliasTransactionBodyBytes = this.mosaicAliasTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicAliasTransactionBodyBytes);
        return newArray;
    }
}
exports.MosaicAliasTransactionBuilder = MosaicAliasTransactionBuilder;

},{"./GeneratorUtils":220,"./MosaicAliasTransactionBodyBuilder":241,"./TransactionBuilder":295}],243:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicBuilder = void 0;
const AmountDto_1 = require("./AmountDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicIdDto_1 = require("./MosaicIdDto");
class MosaicBuilder {
    constructor(mosaicId, amount) {
        this.mosaicId = mosaicId;
        this.amount = amount;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const mosaicId = MosaicIdDto_1.MosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicId.getSize());
        const amount = AmountDto_1.AmountDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, amount.getSize());
        return new MosaicBuilder(mosaicId, amount);
    }
    getMosaicId() {
        return this.mosaicId;
    }
    getAmount() {
        return this.amount;
    }
    getSize() {
        let size = 0;
        size += this.mosaicId.getSize();
        size += this.amount.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const mosaicIdBytes = this.mosaicId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicIdBytes);
        const amountBytes = this.amount.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, amountBytes);
        return newArray;
    }
}
exports.MosaicBuilder = MosaicBuilder;

},{"./AmountDto":186,"./GeneratorUtils":220,"./MosaicIdDto":252}],244:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicDefinitionBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const HeightDto_1 = require("./HeightDto");
const MosaicPropertiesBuilder_1 = require("./MosaicPropertiesBuilder");
class MosaicDefinitionBuilder {
    constructor(startHeight, ownerAddress, revision, properties) {
        this.startHeight = startHeight;
        this.ownerAddress = ownerAddress;
        this.revision = revision;
        this.properties = properties;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const startHeight = HeightDto_1.HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, startHeight.getSize());
        const ownerAddress = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, ownerAddress.getSize());
        const revision = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const properties = MosaicPropertiesBuilder_1.MosaicPropertiesBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, properties.getSize());
        return new MosaicDefinitionBuilder(startHeight, ownerAddress, revision, properties);
    }
    getStartHeight() {
        return this.startHeight;
    }
    getOwnerAddress() {
        return this.ownerAddress;
    }
    getRevision() {
        return this.revision;
    }
    getProperties() {
        return this.properties;
    }
    getSize() {
        let size = 0;
        size += this.startHeight.getSize();
        size += this.ownerAddress.getSize();
        size += 4;
        size += this.properties.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const startHeightBytes = this.startHeight.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, startHeightBytes);
        const ownerAddressBytes = this.ownerAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, ownerAddressBytes);
        const revisionBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getRevision(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, revisionBytes);
        const propertiesBytes = this.properties.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, propertiesBytes);
        return newArray;
    }
}
exports.MosaicDefinitionBuilder = MosaicDefinitionBuilder;

},{"./AddressDto":178,"./GeneratorUtils":220,"./HeightDto":230,"./MosaicPropertiesBuilder":256}],245:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicDefinitionTransactionBodyBuilder = void 0;
const BlockDurationDto_1 = require("./BlockDurationDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicIdDto_1 = require("./MosaicIdDto");
const MosaicNonceDto_1 = require("./MosaicNonceDto");
class MosaicDefinitionTransactionBodyBuilder {
    constructor(id, duration, nonce, flags, divisibility) {
        this.id = id;
        this.duration = duration;
        this.nonce = nonce;
        this.flags = flags;
        this.divisibility = divisibility;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const id = MosaicIdDto_1.MosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, id.getSize());
        const duration = BlockDurationDto_1.BlockDurationDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, duration.getSize());
        const nonce = MosaicNonceDto_1.MosaicNonceDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, nonce.getSize());
        const flags = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const divisibility = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        return new MosaicDefinitionTransactionBodyBuilder(id, duration, nonce, flags, divisibility);
    }
    getId() {
        return this.id;
    }
    getDuration() {
        return this.duration;
    }
    getNonce() {
        return this.nonce;
    }
    getFlags() {
        return this.flags;
    }
    getDivisibility() {
        return this.divisibility;
    }
    getSize() {
        let size = 0;
        size += this.id.getSize();
        size += this.duration.getSize();
        size += this.nonce.getSize();
        size += 1;
        size += 1;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const idBytes = this.id.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, idBytes);
        const durationBytes = this.duration.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, durationBytes);
        const nonceBytes = this.nonce.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, nonceBytes);
        const flagsBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getFlags(), 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, flagsBytes);
        const divisibilityBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getDivisibility(), 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, divisibilityBytes);
        return newArray;
    }
}
exports.MosaicDefinitionTransactionBodyBuilder = MosaicDefinitionTransactionBodyBuilder;

},{"./BlockDurationDto":189,"./GeneratorUtils":220,"./MosaicIdDto":252,"./MosaicNonceDto":255}],246:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicDefinitionTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicDefinitionTransactionBodyBuilder_1 = require("./MosaicDefinitionTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class MosaicDefinitionTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, id, duration, nonce, flags, divisibility) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.mosaicDefinitionTransactionBody = new MosaicDefinitionTransactionBodyBuilder_1.MosaicDefinitionTransactionBodyBuilder(id, duration, nonce, flags, divisibility);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaicDefinitionTransactionBody = MosaicDefinitionTransactionBodyBuilder_1.MosaicDefinitionTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicDefinitionTransactionBody.getSize());
        return new MosaicDefinitionTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, mosaicDefinitionTransactionBody.id, mosaicDefinitionTransactionBody.duration, mosaicDefinitionTransactionBody.nonce, mosaicDefinitionTransactionBody.flags, mosaicDefinitionTransactionBody.divisibility);
    }
    getId() {
        return this.mosaicDefinitionTransactionBody.getId();
    }
    getDuration() {
        return this.mosaicDefinitionTransactionBody.getDuration();
    }
    getNonce() {
        return this.mosaicDefinitionTransactionBody.getNonce();
    }
    getFlags() {
        return this.mosaicDefinitionTransactionBody.getFlags();
    }
    getDivisibility() {
        return this.mosaicDefinitionTransactionBody.getDivisibility();
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaicDefinitionTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicDefinitionTransactionBodyBytes = this.mosaicDefinitionTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicDefinitionTransactionBodyBytes);
        return newArray;
    }
}
exports.MosaicDefinitionTransactionBuilder = MosaicDefinitionTransactionBuilder;

},{"./GeneratorUtils":220,"./MosaicDefinitionTransactionBodyBuilder":245,"./TransactionBuilder":295}],247:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicEntryBuilder = void 0;
const AmountDto_1 = require("./AmountDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicDefinitionBuilder_1 = require("./MosaicDefinitionBuilder");
const MosaicIdDto_1 = require("./MosaicIdDto");
class MosaicEntryBuilder {
    constructor(mosaicId, supply, definition) {
        this.mosaicId = mosaicId;
        this.supply = supply;
        this.definition = definition;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const mosaicId = MosaicIdDto_1.MosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicId.getSize());
        const supply = AmountDto_1.AmountDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, supply.getSize());
        const definition = MosaicDefinitionBuilder_1.MosaicDefinitionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, definition.getSize());
        return new MosaicEntryBuilder(mosaicId, supply, definition);
    }
    getMosaicId() {
        return this.mosaicId;
    }
    getSupply() {
        return this.supply;
    }
    getDefinition() {
        return this.definition;
    }
    getSize() {
        let size = 0;
        size += this.mosaicId.getSize();
        size += this.supply.getSize();
        size += this.definition.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const mosaicIdBytes = this.mosaicId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicIdBytes);
        const supplyBytes = this.supply.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, supplyBytes);
        const definitionBytes = this.definition.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, definitionBytes);
        return newArray;
    }
}
exports.MosaicEntryBuilder = MosaicEntryBuilder;

},{"./AmountDto":186,"./GeneratorUtils":220,"./MosaicDefinitionBuilder":244,"./MosaicIdDto":252}],248:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicExpiryReceiptBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicIdDto_1 = require("./MosaicIdDto");
const ReceiptBuilder_1 = require("./ReceiptBuilder");
class MosaicExpiryReceiptBuilder extends ReceiptBuilder_1.ReceiptBuilder {
    constructor(version, type, artifactId) {
        super(version, type);
        this.artifactId = artifactId;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = ReceiptBuilder_1.ReceiptBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const artifactId = MosaicIdDto_1.MosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, artifactId.getSize());
        return new MosaicExpiryReceiptBuilder(superObject.version, superObject.type, artifactId);
    }
    getArtifactId() {
        return this.artifactId;
    }
    getSize() {
        let size = super.getSize();
        size += this.artifactId.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const artifactIdBytes = this.artifactId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, artifactIdBytes);
        return newArray;
    }
}
exports.MosaicExpiryReceiptBuilder = MosaicExpiryReceiptBuilder;

},{"./GeneratorUtils":220,"./MosaicIdDto":252,"./ReceiptBuilder":283}],249:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicGlobalRestrictionEntryBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const GlobalKeyValueSetBuilder_1 = require("./GlobalKeyValueSetBuilder");
const MosaicIdDto_1 = require("./MosaicIdDto");
class MosaicGlobalRestrictionEntryBuilder {
    constructor(mosaicId, keyPairs) {
        this.mosaicId = mosaicId;
        this.keyPairs = keyPairs;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const mosaicId = MosaicIdDto_1.MosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicId.getSize());
        const keyPairs = GlobalKeyValueSetBuilder_1.GlobalKeyValueSetBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, keyPairs.getSize());
        return new MosaicGlobalRestrictionEntryBuilder(mosaicId, keyPairs);
    }
    getMosaicId() {
        return this.mosaicId;
    }
    getKeyPairs() {
        return this.keyPairs;
    }
    getSize() {
        let size = 0;
        size += this.mosaicId.getSize();
        size += this.keyPairs.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const mosaicIdBytes = this.mosaicId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicIdBytes);
        const keyPairsBytes = this.keyPairs.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, keyPairsBytes);
        return newArray;
    }
}
exports.MosaicGlobalRestrictionEntryBuilder = MosaicGlobalRestrictionEntryBuilder;

},{"./GeneratorUtils":220,"./GlobalKeyValueSetBuilder":222,"./MosaicIdDto":252}],250:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicGlobalRestrictionTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const UnresolvedMosaicIdDto_1 = require("./UnresolvedMosaicIdDto");
class MosaicGlobalRestrictionTransactionBodyBuilder {
    constructor(mosaicId, referenceMosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, previousRestrictionType, newRestrictionType) {
        this.mosaicId = mosaicId;
        this.referenceMosaicId = referenceMosaicId;
        this.restrictionKey = restrictionKey;
        this.previousRestrictionValue = previousRestrictionValue;
        this.newRestrictionValue = newRestrictionValue;
        this.previousRestrictionType = previousRestrictionType;
        this.newRestrictionType = newRestrictionType;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const mosaicId = UnresolvedMosaicIdDto_1.UnresolvedMosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicId.getSize());
        const referenceMosaicId = UnresolvedMosaicIdDto_1.UnresolvedMosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, referenceMosaicId.getSize());
        const restrictionKey = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const previousRestrictionValue = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const newRestrictionValue = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const previousRestrictionType = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const newRestrictionType = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        return new MosaicGlobalRestrictionTransactionBodyBuilder(mosaicId, referenceMosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, previousRestrictionType, newRestrictionType);
    }
    getMosaicId() {
        return this.mosaicId;
    }
    getReferenceMosaicId() {
        return this.referenceMosaicId;
    }
    getRestrictionKey() {
        return this.restrictionKey;
    }
    getPreviousRestrictionValue() {
        return this.previousRestrictionValue;
    }
    getNewRestrictionValue() {
        return this.newRestrictionValue;
    }
    getPreviousRestrictionType() {
        return this.previousRestrictionType;
    }
    getNewRestrictionType() {
        return this.newRestrictionType;
    }
    getSize() {
        let size = 0;
        size += this.mosaicId.getSize();
        size += this.referenceMosaicId.getSize();
        size += 8;
        size += 8;
        size += 8;
        size += 1;
        size += 1;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const mosaicIdBytes = this.mosaicId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicIdBytes);
        const referenceMosaicIdBytes = this.referenceMosaicId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, referenceMosaicIdBytes);
        const restrictionKeyBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getRestrictionKey());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionKeyBytes);
        const previousRestrictionValueBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getPreviousRestrictionValue());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, previousRestrictionValueBytes);
        const newRestrictionValueBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getNewRestrictionValue());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, newRestrictionValueBytes);
        const previousRestrictionTypeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.previousRestrictionType, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, previousRestrictionTypeBytes);
        const newRestrictionTypeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.newRestrictionType, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, newRestrictionTypeBytes);
        return newArray;
    }
}
exports.MosaicGlobalRestrictionTransactionBodyBuilder = MosaicGlobalRestrictionTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./UnresolvedMosaicIdDto":301}],251:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicGlobalRestrictionTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicGlobalRestrictionTransactionBodyBuilder_1 = require("./MosaicGlobalRestrictionTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class MosaicGlobalRestrictionTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, mosaicId, referenceMosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, previousRestrictionType, newRestrictionType) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.mosaicGlobalRestrictionTransactionBody = new MosaicGlobalRestrictionTransactionBodyBuilder_1.MosaicGlobalRestrictionTransactionBodyBuilder(mosaicId, referenceMosaicId, restrictionKey, previousRestrictionValue, newRestrictionValue, previousRestrictionType, newRestrictionType);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaicGlobalRestrictionTransactionBody = MosaicGlobalRestrictionTransactionBodyBuilder_1.MosaicGlobalRestrictionTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicGlobalRestrictionTransactionBody.getSize());
        return new MosaicGlobalRestrictionTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, mosaicGlobalRestrictionTransactionBody.mosaicId, mosaicGlobalRestrictionTransactionBody.referenceMosaicId, mosaicGlobalRestrictionTransactionBody.restrictionKey, mosaicGlobalRestrictionTransactionBody.previousRestrictionValue, mosaicGlobalRestrictionTransactionBody.newRestrictionValue, mosaicGlobalRestrictionTransactionBody.previousRestrictionType, mosaicGlobalRestrictionTransactionBody.newRestrictionType);
    }
    getMosaicId() {
        return this.mosaicGlobalRestrictionTransactionBody.getMosaicId();
    }
    getReferenceMosaicId() {
        return this.mosaicGlobalRestrictionTransactionBody.getReferenceMosaicId();
    }
    getRestrictionKey() {
        return this.mosaicGlobalRestrictionTransactionBody.getRestrictionKey();
    }
    getPreviousRestrictionValue() {
        return this.mosaicGlobalRestrictionTransactionBody.getPreviousRestrictionValue();
    }
    getNewRestrictionValue() {
        return this.mosaicGlobalRestrictionTransactionBody.getNewRestrictionValue();
    }
    getPreviousRestrictionType() {
        return this.mosaicGlobalRestrictionTransactionBody.getPreviousRestrictionType();
    }
    getNewRestrictionType() {
        return this.mosaicGlobalRestrictionTransactionBody.getNewRestrictionType();
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaicGlobalRestrictionTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicGlobalRestrictionTransactionBodyBytes = this.mosaicGlobalRestrictionTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicGlobalRestrictionTransactionBodyBytes);
        return newArray;
    }
}
exports.MosaicGlobalRestrictionTransactionBuilder = MosaicGlobalRestrictionTransactionBuilder;

},{"./GeneratorUtils":220,"./MosaicGlobalRestrictionTransactionBodyBuilder":250,"./TransactionBuilder":295}],252:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicIdDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class MosaicIdDto {
    constructor(mosaicId) {
        this.mosaicId = mosaicId;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const mosaicId = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new MosaicIdDto(mosaicId);
    }
    getMosaicId() {
        return this.mosaicId;
    }
    getSize() {
        return 8;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const mosaicIdBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getMosaicId());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicIdBytes);
        return newArray;
    }
}
exports.MosaicIdDto = MosaicIdDto;

},{"./GeneratorUtils":220}],253:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicMetadataTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const UnresolvedAddressDto_1 = require("./UnresolvedAddressDto");
const UnresolvedMosaicIdDto_1 = require("./UnresolvedMosaicIdDto");
class MosaicMetadataTransactionBodyBuilder {
    constructor(targetAddress, scopedMetadataKey, targetMosaicId, valueSizeDelta, value) {
        this.targetAddress = targetAddress;
        this.scopedMetadataKey = scopedMetadataKey;
        this.targetMosaicId = targetMosaicId;
        this.valueSizeDelta = valueSizeDelta;
        this.value = value;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const targetAddress = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, targetAddress.getSize());
        const scopedMetadataKey = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const targetMosaicId = UnresolvedMosaicIdDto_1.UnresolvedMosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, targetMosaicId.getSize());
        const valueSizeDelta = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const valueSize = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const value = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), valueSize);
        byteArray.splice(0, valueSize);
        return new MosaicMetadataTransactionBodyBuilder(targetAddress, scopedMetadataKey, targetMosaicId, valueSizeDelta, value);
    }
    getTargetAddress() {
        return this.targetAddress;
    }
    getScopedMetadataKey() {
        return this.scopedMetadataKey;
    }
    getTargetMosaicId() {
        return this.targetMosaicId;
    }
    getValueSizeDelta() {
        return this.valueSizeDelta;
    }
    getValue() {
        return this.value;
    }
    getSize() {
        let size = 0;
        size += this.targetAddress.getSize();
        size += 8;
        size += this.targetMosaicId.getSize();
        size += 2;
        size += 2;
        size += this.value.length;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const targetAddressBytes = this.targetAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, targetAddressBytes);
        const scopedMetadataKeyBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getScopedMetadataKey());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, scopedMetadataKeyBytes);
        const targetMosaicIdBytes = this.targetMosaicId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, targetMosaicIdBytes);
        const valueSizeDeltaBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getValueSizeDelta(), 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, valueSizeDeltaBytes);
        const valueSizeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.value.length, 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, valueSizeBytes);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.value);
        return newArray;
    }
}
exports.MosaicMetadataTransactionBodyBuilder = MosaicMetadataTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./UnresolvedAddressDto":299,"./UnresolvedMosaicIdDto":301}],254:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicMetadataTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicMetadataTransactionBodyBuilder_1 = require("./MosaicMetadataTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class MosaicMetadataTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, targetAddress, scopedMetadataKey, targetMosaicId, valueSizeDelta, value) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.mosaicMetadataTransactionBody = new MosaicMetadataTransactionBodyBuilder_1.MosaicMetadataTransactionBodyBuilder(targetAddress, scopedMetadataKey, targetMosaicId, valueSizeDelta, value);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaicMetadataTransactionBody = MosaicMetadataTransactionBodyBuilder_1.MosaicMetadataTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicMetadataTransactionBody.getSize());
        return new MosaicMetadataTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, mosaicMetadataTransactionBody.targetAddress, mosaicMetadataTransactionBody.scopedMetadataKey, mosaicMetadataTransactionBody.targetMosaicId, mosaicMetadataTransactionBody.valueSizeDelta, mosaicMetadataTransactionBody.value);
    }
    getTargetAddress() {
        return this.mosaicMetadataTransactionBody.getTargetAddress();
    }
    getScopedMetadataKey() {
        return this.mosaicMetadataTransactionBody.getScopedMetadataKey();
    }
    getTargetMosaicId() {
        return this.mosaicMetadataTransactionBody.getTargetMosaicId();
    }
    getValueSizeDelta() {
        return this.mosaicMetadataTransactionBody.getValueSizeDelta();
    }
    getValue() {
        return this.mosaicMetadataTransactionBody.getValue();
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaicMetadataTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicMetadataTransactionBodyBytes = this.mosaicMetadataTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicMetadataTransactionBodyBytes);
        return newArray;
    }
}
exports.MosaicMetadataTransactionBuilder = MosaicMetadataTransactionBuilder;

},{"./GeneratorUtils":220,"./MosaicMetadataTransactionBodyBuilder":253,"./TransactionBuilder":295}],255:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicNonceDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class MosaicNonceDto {
    constructor(mosaicNonce) {
        this.mosaicNonce = mosaicNonce;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const mosaicNonce = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        return new MosaicNonceDto(mosaicNonce);
    }
    getMosaicNonce() {
        return this.mosaicNonce;
    }
    getSize() {
        return 4;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const mosaicNonceBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getMosaicNonce(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicNonceBytes);
        return newArray;
    }
}
exports.MosaicNonceDto = MosaicNonceDto;

},{"./GeneratorUtils":220}],256:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicPropertiesBuilder = void 0;
const BlockDurationDto_1 = require("./BlockDurationDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
class MosaicPropertiesBuilder {
    constructor(flags, divisibility, duration) {
        this.flags = flags;
        this.divisibility = divisibility;
        this.duration = duration;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const flags = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const divisibility = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const duration = BlockDurationDto_1.BlockDurationDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, duration.getSize());
        return new MosaicPropertiesBuilder(flags, divisibility, duration);
    }
    getFlags() {
        return this.flags;
    }
    getDivisibility() {
        return this.divisibility;
    }
    getDuration() {
        return this.duration;
    }
    getSize() {
        let size = 0;
        size += 1;
        size += 1;
        size += this.duration.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const flagsBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getFlags(), 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, flagsBytes);
        const divisibilityBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getDivisibility(), 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, divisibilityBytes);
        const durationBytes = this.duration.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, durationBytes);
        return newArray;
    }
}
exports.MosaicPropertiesBuilder = MosaicPropertiesBuilder;

},{"./BlockDurationDto":189,"./GeneratorUtils":220}],257:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicResolutionEntryBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicIdDto_1 = require("./MosaicIdDto");
const ReceiptSourceBuilder_1 = require("./ReceiptSourceBuilder");
class MosaicResolutionEntryBuilder {
    constructor(source, resolved) {
        this.source = source;
        this.resolved = resolved;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const source = ReceiptSourceBuilder_1.ReceiptSourceBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, source.getSize());
        const resolved = MosaicIdDto_1.MosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, resolved.getSize());
        return new MosaicResolutionEntryBuilder(source, resolved);
    }
    getSource() {
        return this.source;
    }
    getResolved() {
        return this.resolved;
    }
    getSize() {
        let size = 0;
        size += this.source.getSize();
        size += this.resolved.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const sourceBytes = this.source.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, sourceBytes);
        const resolvedBytes = this.resolved.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, resolvedBytes);
        return newArray;
    }
}
exports.MosaicResolutionEntryBuilder = MosaicResolutionEntryBuilder;

},{"./GeneratorUtils":220,"./MosaicIdDto":252,"./ReceiptSourceBuilder":284}],258:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicResolutionStatementBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicResolutionEntryBuilder_1 = require("./MosaicResolutionEntryBuilder");
const ReceiptBuilder_1 = require("./ReceiptBuilder");
const UnresolvedMosaicIdDto_1 = require("./UnresolvedMosaicIdDto");
class MosaicResolutionStatementBuilder extends ReceiptBuilder_1.ReceiptBuilder {
    constructor(version, type, unresolved, resolutionEntries) {
        super(version, type);
        this.unresolved = unresolved;
        this.resolutionEntries = resolutionEntries;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = ReceiptBuilder_1.ReceiptBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const unresolved = UnresolvedMosaicIdDto_1.UnresolvedMosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, unresolved.getSize());
        let resolutionEntriesByteSize = byteArray.length;
        const resolutionEntries = [];
        while (resolutionEntriesByteSize > 0) {
            const item = MosaicResolutionEntryBuilder_1.MosaicResolutionEntryBuilder.loadFromBinary(Uint8Array.from(byteArray));
            resolutionEntries.push(item);
            const itemSize = item.getSize();
            resolutionEntriesByteSize -= itemSize;
            byteArray.splice(0, itemSize);
        }
        return new MosaicResolutionStatementBuilder(superObject.version, superObject.type, unresolved, resolutionEntries);
    }
    getUnresolved() {
        return this.unresolved;
    }
    getResolutionEntries() {
        return this.resolutionEntries;
    }
    getSize() {
        let size = super.getSize();
        size += this.unresolved.getSize();
        this.resolutionEntries.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const unresolvedBytes = this.unresolved.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, unresolvedBytes);
        this.resolutionEntries.forEach((item) => {
            const resolutionEntriesBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, resolutionEntriesBytes);
        });
        return newArray;
    }
}
exports.MosaicResolutionStatementBuilder = MosaicResolutionStatementBuilder;

},{"./GeneratorUtils":220,"./MosaicResolutionEntryBuilder":257,"./ReceiptBuilder":283,"./UnresolvedMosaicIdDto":301}],259:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicRestrictionEntryBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicAddressRestrictionEntryBuilder_1 = require("./MosaicAddressRestrictionEntryBuilder");
const MosaicGlobalRestrictionEntryBuilder_1 = require("./MosaicGlobalRestrictionEntryBuilder");
const MosaicRestrictionEntryTypeDto_1 = require("./MosaicRestrictionEntryTypeDto");
class MosaicRestrictionEntryBuilder {
    constructor(addressEntry, globalEntry) {
        this.addressEntry = addressEntry;
        this.globalEntry = globalEntry;
        if (addressEntry) {
            this.entryType = MosaicRestrictionEntryTypeDto_1.MosaicRestrictionEntryTypeDto.ADDRESS;
        }
        else {
            this.entryType = MosaicRestrictionEntryTypeDto_1.MosaicRestrictionEntryTypeDto.GLOBAL;
        }
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const entryType = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const entryTypeConditionBytes = Uint8Array.from(byteArray.slice(0, 1));
        byteArray.splice(0, 1);
        let addressEntry;
        if (entryType === MosaicRestrictionEntryTypeDto_1.MosaicRestrictionEntryTypeDto.ADDRESS) {
            addressEntry = MosaicAddressRestrictionEntryBuilder_1.MosaicAddressRestrictionEntryBuilder.loadFromBinary(entryTypeConditionBytes);
        }
        let globalEntry;
        if (entryType === MosaicRestrictionEntryTypeDto_1.MosaicRestrictionEntryTypeDto.GLOBAL) {
            globalEntry = MosaicGlobalRestrictionEntryBuilder_1.MosaicGlobalRestrictionEntryBuilder.loadFromBinary(entryTypeConditionBytes);
        }
        return new MosaicRestrictionEntryBuilder(addressEntry, globalEntry);
    }
    getEntryType() {
        return this.entryType;
    }
    getAddressEntry() {
        if (this.entryType !== MosaicRestrictionEntryTypeDto_1.MosaicRestrictionEntryTypeDto.ADDRESS) {
            throw new Error('entryType is not set to ADDRESS.');
        }
        return this.addressEntry;
    }
    getGlobalEntry() {
        if (this.entryType !== MosaicRestrictionEntryTypeDto_1.MosaicRestrictionEntryTypeDto.GLOBAL) {
            throw new Error('entryType is not set to GLOBAL.');
        }
        return this.globalEntry;
    }
    getSize() {
        let size = 0;
        size += 1;
        if (this.entryType === MosaicRestrictionEntryTypeDto_1.MosaicRestrictionEntryTypeDto.ADDRESS) {
            size += this.addressEntry.getSize();
        }
        if (this.entryType === MosaicRestrictionEntryTypeDto_1.MosaicRestrictionEntryTypeDto.GLOBAL) {
            size += this.globalEntry.getSize();
        }
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const entryTypeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.entryType, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, entryTypeBytes);
        if (this.entryType === MosaicRestrictionEntryTypeDto_1.MosaicRestrictionEntryTypeDto.ADDRESS) {
            const addressEntryBytes = this.addressEntry.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressEntryBytes);
        }
        if (this.entryType === MosaicRestrictionEntryTypeDto_1.MosaicRestrictionEntryTypeDto.GLOBAL) {
            const globalEntryBytes = this.globalEntry.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, globalEntryBytes);
        }
        return newArray;
    }
}
exports.MosaicRestrictionEntryBuilder = MosaicRestrictionEntryBuilder;

},{"./GeneratorUtils":220,"./MosaicAddressRestrictionEntryBuilder":238,"./MosaicGlobalRestrictionEntryBuilder":249,"./MosaicRestrictionEntryTypeDto":260}],260:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicRestrictionEntryTypeDto = void 0;
var MosaicRestrictionEntryTypeDto;
(function (MosaicRestrictionEntryTypeDto) {
    MosaicRestrictionEntryTypeDto[MosaicRestrictionEntryTypeDto["ADDRESS"] = 0] = "ADDRESS";
    MosaicRestrictionEntryTypeDto[MosaicRestrictionEntryTypeDto["GLOBAL"] = 1] = "GLOBAL";
})(MosaicRestrictionEntryTypeDto = exports.MosaicRestrictionEntryTypeDto || (exports.MosaicRestrictionEntryTypeDto = {}));

},{}],261:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicRestrictionKeyDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class MosaicRestrictionKeyDto {
    constructor(mosaicRestrictionKey) {
        this.mosaicRestrictionKey = mosaicRestrictionKey;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const mosaicRestrictionKey = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new MosaicRestrictionKeyDto(mosaicRestrictionKey);
    }
    getMosaicRestrictionKey() {
        return this.mosaicRestrictionKey;
    }
    getSize() {
        return 8;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const mosaicRestrictionKeyBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getMosaicRestrictionKey());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicRestrictionKeyBytes);
        return newArray;
    }
}
exports.MosaicRestrictionKeyDto = MosaicRestrictionKeyDto;

},{"./GeneratorUtils":220}],262:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicSupplyChangeTransactionBodyBuilder = void 0;
const AmountDto_1 = require("./AmountDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const UnresolvedMosaicIdDto_1 = require("./UnresolvedMosaicIdDto");
class MosaicSupplyChangeTransactionBodyBuilder {
    constructor(mosaicId, delta, action) {
        this.mosaicId = mosaicId;
        this.delta = delta;
        this.action = action;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const mosaicId = UnresolvedMosaicIdDto_1.UnresolvedMosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicId.getSize());
        const delta = AmountDto_1.AmountDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, delta.getSize());
        const action = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        return new MosaicSupplyChangeTransactionBodyBuilder(mosaicId, delta, action);
    }
    getMosaicId() {
        return this.mosaicId;
    }
    getDelta() {
        return this.delta;
    }
    getAction() {
        return this.action;
    }
    getSize() {
        let size = 0;
        size += this.mosaicId.getSize();
        size += this.delta.getSize();
        size += 1;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const mosaicIdBytes = this.mosaicId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicIdBytes);
        const deltaBytes = this.delta.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, deltaBytes);
        const actionBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.action, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, actionBytes);
        return newArray;
    }
}
exports.MosaicSupplyChangeTransactionBodyBuilder = MosaicSupplyChangeTransactionBodyBuilder;

},{"./AmountDto":186,"./GeneratorUtils":220,"./UnresolvedMosaicIdDto":301}],263:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicSupplyChangeTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicSupplyChangeTransactionBodyBuilder_1 = require("./MosaicSupplyChangeTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class MosaicSupplyChangeTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, mosaicId, delta, action) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.mosaicSupplyChangeTransactionBody = new MosaicSupplyChangeTransactionBodyBuilder_1.MosaicSupplyChangeTransactionBodyBuilder(mosaicId, delta, action);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const mosaicSupplyChangeTransactionBody = MosaicSupplyChangeTransactionBodyBuilder_1.MosaicSupplyChangeTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicSupplyChangeTransactionBody.getSize());
        return new MosaicSupplyChangeTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, mosaicSupplyChangeTransactionBody.mosaicId, mosaicSupplyChangeTransactionBody.delta, mosaicSupplyChangeTransactionBody.action);
    }
    getMosaicId() {
        return this.mosaicSupplyChangeTransactionBody.getMosaicId();
    }
    getDelta() {
        return this.mosaicSupplyChangeTransactionBody.getDelta();
    }
    getAction() {
        return this.mosaicSupplyChangeTransactionBody.getAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.mosaicSupplyChangeTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const mosaicSupplyChangeTransactionBodyBytes = this.mosaicSupplyChangeTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicSupplyChangeTransactionBodyBytes);
        return newArray;
    }
}
exports.MosaicSupplyChangeTransactionBuilder = MosaicSupplyChangeTransactionBuilder;

},{"./GeneratorUtils":220,"./MosaicSupplyChangeTransactionBodyBuilder":262,"./TransactionBuilder":295}],264:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigAccountModificationTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const UnresolvedAddressDto_1 = require("./UnresolvedAddressDto");
class MultisigAccountModificationTransactionBodyBuilder {
    constructor(minRemovalDelta, minApprovalDelta, addressAdditions, addressDeletions) {
        this.minRemovalDelta = minRemovalDelta;
        this.minApprovalDelta = minApprovalDelta;
        this.multisigAccountModificationTransactionBody_Reserved1 = 0;
        this.addressAdditions = addressAdditions;
        this.addressDeletions = addressDeletions;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const minRemovalDelta = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const minApprovalDelta = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const addressAdditionsCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const addressDeletionsCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const multisigAccountModificationTransactionBody_Reserved1 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const addressAdditions = [];
        for (let i = 0; i < (Array.isArray(addressAdditionsCount) ? GeneratorUtils_1.GeneratorUtils.compact(addressAdditionsCount) : addressAdditionsCount); i++) {
            const item = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
            addressAdditions.push(item);
            byteArray.splice(0, item.getSize());
        }
        const addressDeletions = [];
        for (let i = 0; i < (Array.isArray(addressDeletionsCount) ? GeneratorUtils_1.GeneratorUtils.compact(addressDeletionsCount) : addressDeletionsCount); i++) {
            const item = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
            addressDeletions.push(item);
            byteArray.splice(0, item.getSize());
        }
        return new MultisigAccountModificationTransactionBodyBuilder(minRemovalDelta, minApprovalDelta, addressAdditions, addressDeletions);
    }
    getMinRemovalDelta() {
        return this.minRemovalDelta;
    }
    getMinApprovalDelta() {
        return this.minApprovalDelta;
    }
    getMultisigAccountModificationTransactionBody_Reserved1() {
        return this.multisigAccountModificationTransactionBody_Reserved1;
    }
    getAddressAdditions() {
        return this.addressAdditions;
    }
    getAddressDeletions() {
        return this.addressDeletions;
    }
    getSize() {
        let size = 0;
        size += 1;
        size += 1;
        size += 1;
        size += 1;
        size += 4;
        this.addressAdditions.forEach((o) => size += o.getSize());
        this.addressDeletions.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const minRemovalDeltaBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getMinRemovalDelta(), 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, minRemovalDeltaBytes);
        const minApprovalDeltaBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getMinApprovalDelta(), 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, minApprovalDeltaBytes);
        const addressAdditionsCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.addressAdditions.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressAdditionsCountBytes);
        const addressDeletionsCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.addressDeletions.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressDeletionsCountBytes);
        const multisigAccountModificationTransactionBody_Reserved1Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getMultisigAccountModificationTransactionBody_Reserved1(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, multisigAccountModificationTransactionBody_Reserved1Bytes);
        this.addressAdditions.forEach((item) => {
            const addressAdditionsBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressAdditionsBytes);
        });
        this.addressDeletions.forEach((item) => {
            const addressDeletionsBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressDeletionsBytes);
        });
        return newArray;
    }
}
exports.MultisigAccountModificationTransactionBodyBuilder = MultisigAccountModificationTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./UnresolvedAddressDto":299}],265:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigAccountModificationTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MultisigAccountModificationTransactionBodyBuilder_1 = require("./MultisigAccountModificationTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class MultisigAccountModificationTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, minRemovalDelta, minApprovalDelta, addressAdditions, addressDeletions) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.multisigAccountModificationTransactionBody = new MultisigAccountModificationTransactionBodyBuilder_1.MultisigAccountModificationTransactionBodyBuilder(minRemovalDelta, minApprovalDelta, addressAdditions, addressDeletions);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const multisigAccountModificationTransactionBody = MultisigAccountModificationTransactionBodyBuilder_1.MultisigAccountModificationTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, multisigAccountModificationTransactionBody.getSize());
        return new MultisigAccountModificationTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, multisigAccountModificationTransactionBody.minRemovalDelta, multisigAccountModificationTransactionBody.minApprovalDelta, multisigAccountModificationTransactionBody.addressAdditions, multisigAccountModificationTransactionBody.addressDeletions);
    }
    getMinRemovalDelta() {
        return this.multisigAccountModificationTransactionBody.getMinRemovalDelta();
    }
    getMinApprovalDelta() {
        return this.multisigAccountModificationTransactionBody.getMinApprovalDelta();
    }
    getMultisigAccountModificationTransactionBody_Reserved1() {
        return this.multisigAccountModificationTransactionBody.getMultisigAccountModificationTransactionBody_Reserved1();
    }
    getAddressAdditions() {
        return this.multisigAccountModificationTransactionBody.getAddressAdditions();
    }
    getAddressDeletions() {
        return this.multisigAccountModificationTransactionBody.getAddressDeletions();
    }
    getSize() {
        let size = super.getSize();
        size += this.multisigAccountModificationTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const multisigAccountModificationTransactionBodyBytes = this.multisigAccountModificationTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, multisigAccountModificationTransactionBodyBytes);
        return newArray;
    }
}
exports.MultisigAccountModificationTransactionBuilder = MultisigAccountModificationTransactionBuilder;

},{"./GeneratorUtils":220,"./MultisigAccountModificationTransactionBodyBuilder":264,"./TransactionBuilder":295}],266:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigEntryBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
class MultisigEntryBuilder {
    constructor(minApproval, minRemoval, accountAddress, cosignatoryAddresses, multisigAddresses) {
        this.minApproval = minApproval;
        this.minRemoval = minRemoval;
        this.accountAddress = accountAddress;
        this.cosignatoryAddresses = cosignatoryAddresses;
        this.multisigAddresses = multisigAddresses;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const minApproval = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const minRemoval = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const accountAddress = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, accountAddress.getSize());
        const cosignatoryAddressesCount = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const cosignatoryAddresses = [];
        for (let i = 0; i < (Array.isArray(cosignatoryAddressesCount) ? GeneratorUtils_1.GeneratorUtils.compact(cosignatoryAddressesCount) : cosignatoryAddressesCount); i++) {
            const item = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
            cosignatoryAddresses.push(item);
            byteArray.splice(0, item.getSize());
        }
        const multisigAddressesCount = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const multisigAddresses = [];
        for (let i = 0; i < (Array.isArray(multisigAddressesCount) ? GeneratorUtils_1.GeneratorUtils.compact(multisigAddressesCount) : multisigAddressesCount); i++) {
            const item = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
            multisigAddresses.push(item);
            byteArray.splice(0, item.getSize());
        }
        return new MultisigEntryBuilder(minApproval, minRemoval, accountAddress, cosignatoryAddresses, multisigAddresses);
    }
    getMinApproval() {
        return this.minApproval;
    }
    getMinRemoval() {
        return this.minRemoval;
    }
    getAccountAddress() {
        return this.accountAddress;
    }
    getCosignatoryAddresses() {
        return this.cosignatoryAddresses;
    }
    getMultisigAddresses() {
        return this.multisigAddresses;
    }
    getSize() {
        let size = 0;
        size += 4;
        size += 4;
        size += this.accountAddress.getSize();
        size += 8;
        this.cosignatoryAddresses.forEach((o) => size += o.getSize());
        size += 8;
        this.multisigAddresses.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const minApprovalBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getMinApproval(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, minApprovalBytes);
        const minRemovalBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getMinRemoval(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, minRemovalBytes);
        const accountAddressBytes = this.accountAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountAddressBytes);
        const cosignatoryAddressesCountBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(GeneratorUtils_1.GeneratorUtils.fromUint(this.cosignatoryAddresses.length));
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, cosignatoryAddressesCountBytes);
        this.cosignatoryAddresses.forEach((item) => {
            const cosignatoryAddressesBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, cosignatoryAddressesBytes);
        });
        const multisigAddressesCountBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(GeneratorUtils_1.GeneratorUtils.fromUint(this.multisigAddresses.length));
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, multisigAddressesCountBytes);
        this.multisigAddresses.forEach((item) => {
            const multisigAddressesBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, multisigAddressesBytes);
        });
        return newArray;
    }
}
exports.MultisigEntryBuilder = MultisigEntryBuilder;

},{"./AddressDto":178,"./GeneratorUtils":220}],267:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceAliasBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicIdDto_1 = require("./MosaicIdDto");
const NamespaceAliasTypeDto_1 = require("./NamespaceAliasTypeDto");
class NamespaceAliasBuilder {
    constructor(mosaicAlias, addressAlias) {
        this.mosaicAlias = mosaicAlias;
        this.addressAlias = addressAlias;
        if (mosaicAlias) {
            this.namespaceAliasType = NamespaceAliasTypeDto_1.NamespaceAliasTypeDto.MOSAIC_ID;
        }
        else {
            this.namespaceAliasType = NamespaceAliasTypeDto_1.NamespaceAliasTypeDto.ADDRESS;
        }
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const namespaceAliasType = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const namespaceAliasTypeConditionBytes = Uint8Array.from(byteArray.slice(0, 8));
        byteArray.splice(0, 8);
        let mosaicAlias;
        if (namespaceAliasType === NamespaceAliasTypeDto_1.NamespaceAliasTypeDto.MOSAIC_ID) {
            mosaicAlias = MosaicIdDto_1.MosaicIdDto.loadFromBinary(namespaceAliasTypeConditionBytes);
        }
        let addressAlias;
        if (namespaceAliasType === NamespaceAliasTypeDto_1.NamespaceAliasTypeDto.ADDRESS) {
            addressAlias = AddressDto_1.AddressDto.loadFromBinary(namespaceAliasTypeConditionBytes);
        }
        return new NamespaceAliasBuilder(mosaicAlias, addressAlias);
    }
    getNamespaceAliasType() {
        return this.namespaceAliasType;
    }
    getMosaicAlias() {
        if (this.namespaceAliasType !== NamespaceAliasTypeDto_1.NamespaceAliasTypeDto.MOSAIC_ID) {
            throw new Error('namespaceAliasType is not set to MOSAIC_ID.');
        }
        return this.mosaicAlias;
    }
    getAddressAlias() {
        if (this.namespaceAliasType !== NamespaceAliasTypeDto_1.NamespaceAliasTypeDto.ADDRESS) {
            throw new Error('namespaceAliasType is not set to ADDRESS.');
        }
        return this.addressAlias;
    }
    getSize() {
        let size = 0;
        size += 1;
        if (this.namespaceAliasType === NamespaceAliasTypeDto_1.NamespaceAliasTypeDto.MOSAIC_ID) {
            size += this.mosaicAlias.getSize();
        }
        if (this.namespaceAliasType === NamespaceAliasTypeDto_1.NamespaceAliasTypeDto.ADDRESS) {
            size += this.addressAlias.getSize();
        }
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const namespaceAliasTypeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.namespaceAliasType, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, namespaceAliasTypeBytes);
        if (this.namespaceAliasType === NamespaceAliasTypeDto_1.NamespaceAliasTypeDto.MOSAIC_ID) {
            const mosaicAliasBytes = this.mosaicAlias.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicAliasBytes);
        }
        if (this.namespaceAliasType === NamespaceAliasTypeDto_1.NamespaceAliasTypeDto.ADDRESS) {
            const addressAliasBytes = this.addressAlias.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressAliasBytes);
        }
        return newArray;
    }
}
exports.NamespaceAliasBuilder = NamespaceAliasBuilder;

},{"./AddressDto":178,"./GeneratorUtils":220,"./MosaicIdDto":252,"./NamespaceAliasTypeDto":268}],268:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceAliasTypeDto = void 0;
var NamespaceAliasTypeDto;
(function (NamespaceAliasTypeDto) {
    NamespaceAliasTypeDto[NamespaceAliasTypeDto["NONE"] = 0] = "NONE";
    NamespaceAliasTypeDto[NamespaceAliasTypeDto["MOSAIC_ID"] = 1] = "MOSAIC_ID";
    NamespaceAliasTypeDto[NamespaceAliasTypeDto["ADDRESS"] = 2] = "ADDRESS";
})(NamespaceAliasTypeDto = exports.NamespaceAliasTypeDto || (exports.NamespaceAliasTypeDto = {}));

},{}],269:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceExpiryReceiptBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const NamespaceIdDto_1 = require("./NamespaceIdDto");
const ReceiptBuilder_1 = require("./ReceiptBuilder");
class NamespaceExpiryReceiptBuilder extends ReceiptBuilder_1.ReceiptBuilder {
    constructor(version, type, artifactId) {
        super(version, type);
        this.artifactId = artifactId;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = ReceiptBuilder_1.ReceiptBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const artifactId = NamespaceIdDto_1.NamespaceIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, artifactId.getSize());
        return new NamespaceExpiryReceiptBuilder(superObject.version, superObject.type, artifactId);
    }
    getArtifactId() {
        return this.artifactId;
    }
    getSize() {
        let size = super.getSize();
        size += this.artifactId.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const artifactIdBytes = this.artifactId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, artifactIdBytes);
        return newArray;
    }
}
exports.NamespaceExpiryReceiptBuilder = NamespaceExpiryReceiptBuilder;

},{"./GeneratorUtils":220,"./NamespaceIdDto":270,"./ReceiptBuilder":283}],270:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceIdDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class NamespaceIdDto {
    constructor(namespaceId) {
        this.namespaceId = namespaceId;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const namespaceId = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new NamespaceIdDto(namespaceId);
    }
    getNamespaceId() {
        return this.namespaceId;
    }
    getSize() {
        return 8;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const namespaceIdBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getNamespaceId());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, namespaceIdBytes);
        return newArray;
    }
}
exports.NamespaceIdDto = NamespaceIdDto;

},{"./GeneratorUtils":220}],271:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceLifetimeBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const HeightDto_1 = require("./HeightDto");
class NamespaceLifetimeBuilder {
    constructor(lifetimeStart, lifetimeEnd) {
        this.lifetimeStart = lifetimeStart;
        this.lifetimeEnd = lifetimeEnd;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const lifetimeStart = HeightDto_1.HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, lifetimeStart.getSize());
        const lifetimeEnd = HeightDto_1.HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, lifetimeEnd.getSize());
        return new NamespaceLifetimeBuilder(lifetimeStart, lifetimeEnd);
    }
    getLifetimeStart() {
        return this.lifetimeStart;
    }
    getLifetimeEnd() {
        return this.lifetimeEnd;
    }
    getSize() {
        let size = 0;
        size += this.lifetimeStart.getSize();
        size += this.lifetimeEnd.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const lifetimeStartBytes = this.lifetimeStart.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, lifetimeStartBytes);
        const lifetimeEndBytes = this.lifetimeEnd.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, lifetimeEndBytes);
        return newArray;
    }
}
exports.NamespaceLifetimeBuilder = NamespaceLifetimeBuilder;

},{"./GeneratorUtils":220,"./HeightDto":230}],272:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceMetadataTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const NamespaceIdDto_1 = require("./NamespaceIdDto");
const UnresolvedAddressDto_1 = require("./UnresolvedAddressDto");
class NamespaceMetadataTransactionBodyBuilder {
    constructor(targetAddress, scopedMetadataKey, targetNamespaceId, valueSizeDelta, value) {
        this.targetAddress = targetAddress;
        this.scopedMetadataKey = scopedMetadataKey;
        this.targetNamespaceId = targetNamespaceId;
        this.valueSizeDelta = valueSizeDelta;
        this.value = value;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const targetAddress = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, targetAddress.getSize());
        const scopedMetadataKey = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const targetNamespaceId = NamespaceIdDto_1.NamespaceIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, targetNamespaceId.getSize());
        const valueSizeDelta = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const valueSize = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const value = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), valueSize);
        byteArray.splice(0, valueSize);
        return new NamespaceMetadataTransactionBodyBuilder(targetAddress, scopedMetadataKey, targetNamespaceId, valueSizeDelta, value);
    }
    getTargetAddress() {
        return this.targetAddress;
    }
    getScopedMetadataKey() {
        return this.scopedMetadataKey;
    }
    getTargetNamespaceId() {
        return this.targetNamespaceId;
    }
    getValueSizeDelta() {
        return this.valueSizeDelta;
    }
    getValue() {
        return this.value;
    }
    getSize() {
        let size = 0;
        size += this.targetAddress.getSize();
        size += 8;
        size += this.targetNamespaceId.getSize();
        size += 2;
        size += 2;
        size += this.value.length;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const targetAddressBytes = this.targetAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, targetAddressBytes);
        const scopedMetadataKeyBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getScopedMetadataKey());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, scopedMetadataKeyBytes);
        const targetNamespaceIdBytes = this.targetNamespaceId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, targetNamespaceIdBytes);
        const valueSizeDeltaBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getValueSizeDelta(), 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, valueSizeDeltaBytes);
        const valueSizeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.value.length, 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, valueSizeBytes);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.value);
        return newArray;
    }
}
exports.NamespaceMetadataTransactionBodyBuilder = NamespaceMetadataTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./NamespaceIdDto":270,"./UnresolvedAddressDto":299}],273:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceMetadataTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const NamespaceMetadataTransactionBodyBuilder_1 = require("./NamespaceMetadataTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class NamespaceMetadataTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, targetAddress, scopedMetadataKey, targetNamespaceId, valueSizeDelta, value) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.namespaceMetadataTransactionBody = new NamespaceMetadataTransactionBodyBuilder_1.NamespaceMetadataTransactionBodyBuilder(targetAddress, scopedMetadataKey, targetNamespaceId, valueSizeDelta, value);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const namespaceMetadataTransactionBody = NamespaceMetadataTransactionBodyBuilder_1.NamespaceMetadataTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, namespaceMetadataTransactionBody.getSize());
        return new NamespaceMetadataTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, namespaceMetadataTransactionBody.targetAddress, namespaceMetadataTransactionBody.scopedMetadataKey, namespaceMetadataTransactionBody.targetNamespaceId, namespaceMetadataTransactionBody.valueSizeDelta, namespaceMetadataTransactionBody.value);
    }
    getTargetAddress() {
        return this.namespaceMetadataTransactionBody.getTargetAddress();
    }
    getScopedMetadataKey() {
        return this.namespaceMetadataTransactionBody.getScopedMetadataKey();
    }
    getTargetNamespaceId() {
        return this.namespaceMetadataTransactionBody.getTargetNamespaceId();
    }
    getValueSizeDelta() {
        return this.namespaceMetadataTransactionBody.getValueSizeDelta();
    }
    getValue() {
        return this.namespaceMetadataTransactionBody.getValue();
    }
    getSize() {
        let size = super.getSize();
        size += this.namespaceMetadataTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const namespaceMetadataTransactionBodyBytes = this.namespaceMetadataTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, namespaceMetadataTransactionBodyBytes);
        return newArray;
    }
}
exports.NamespaceMetadataTransactionBuilder = NamespaceMetadataTransactionBuilder;

},{"./GeneratorUtils":220,"./NamespaceMetadataTransactionBodyBuilder":272,"./TransactionBuilder":295}],274:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespacePathBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const NamespaceAliasBuilder_1 = require("./NamespaceAliasBuilder");
class NamespacePathBuilder {
    constructor(path, alias) {
        this.path = path;
        this.alias = alias;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const pathSize = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const path = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), pathSize);
        byteArray.splice(0, pathSize);
        const alias = NamespaceAliasBuilder_1.NamespaceAliasBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, alias.getSize());
        return new NamespacePathBuilder(path, alias);
    }
    getPath() {
        return this.path;
    }
    getAlias() {
        return this.alias;
    }
    getSize() {
        let size = 0;
        size += 1;
        size += this.path.length;
        size += this.alias.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const pathSizeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.path.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, pathSizeBytes);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.path);
        const aliasBytes = this.alias.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, aliasBytes);
        return newArray;
    }
}
exports.NamespacePathBuilder = NamespacePathBuilder;

},{"./GeneratorUtils":220,"./NamespaceAliasBuilder":267}],275:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceRegistrationTransactionBodyBuilder = void 0;
const BlockDurationDto_1 = require("./BlockDurationDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const NamespaceIdDto_1 = require("./NamespaceIdDto");
const NamespaceRegistrationTypeDto_1 = require("./NamespaceRegistrationTypeDto");
class NamespaceRegistrationTransactionBodyBuilder {
    constructor(id, name, duration, parentId) {
        this.duration = duration;
        this.parentId = parentId;
        this.id = id;
        this.name = name;
        if (duration) {
            this.registrationType = NamespaceRegistrationTypeDto_1.NamespaceRegistrationTypeDto.ROOT;
        }
        else {
            this.registrationType = NamespaceRegistrationTypeDto_1.NamespaceRegistrationTypeDto.CHILD;
        }
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const registrationTypeConditionBytes = Uint8Array.from(byteArray.slice(0, 8));
        byteArray.splice(0, 8);
        const id = NamespaceIdDto_1.NamespaceIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, id.getSize());
        const registrationType = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const nameSize = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const name = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), nameSize);
        byteArray.splice(0, nameSize);
        let duration;
        if (registrationType === NamespaceRegistrationTypeDto_1.NamespaceRegistrationTypeDto.ROOT) {
            duration = BlockDurationDto_1.BlockDurationDto.loadFromBinary(registrationTypeConditionBytes);
        }
        let parentId;
        if (registrationType === NamespaceRegistrationTypeDto_1.NamespaceRegistrationTypeDto.CHILD) {
            parentId = NamespaceIdDto_1.NamespaceIdDto.loadFromBinary(registrationTypeConditionBytes);
        }
        return new NamespaceRegistrationTransactionBodyBuilder(id, name, duration, parentId);
    }
    getDuration() {
        if (this.registrationType !== NamespaceRegistrationTypeDto_1.NamespaceRegistrationTypeDto.ROOT) {
            throw new Error('registrationType is not set to ROOT.');
        }
        return this.duration;
    }
    getParentId() {
        if (this.registrationType !== NamespaceRegistrationTypeDto_1.NamespaceRegistrationTypeDto.CHILD) {
            throw new Error('registrationType is not set to CHILD.');
        }
        return this.parentId;
    }
    getId() {
        return this.id;
    }
    getRegistrationType() {
        return this.registrationType;
    }
    getName() {
        return this.name;
    }
    getSize() {
        let size = 0;
        if (this.registrationType === NamespaceRegistrationTypeDto_1.NamespaceRegistrationTypeDto.ROOT) {
            size += this.duration.getSize();
        }
        if (this.registrationType === NamespaceRegistrationTypeDto_1.NamespaceRegistrationTypeDto.CHILD) {
            size += this.parentId.getSize();
        }
        size += this.id.getSize();
        size += 1;
        size += 1;
        size += this.name.length;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        if (this.registrationType === NamespaceRegistrationTypeDto_1.NamespaceRegistrationTypeDto.ROOT) {
            const durationBytes = this.duration.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, durationBytes);
        }
        if (this.registrationType === NamespaceRegistrationTypeDto_1.NamespaceRegistrationTypeDto.CHILD) {
            const parentIdBytes = this.parentId.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, parentIdBytes);
        }
        const idBytes = this.id.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, idBytes);
        const registrationTypeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.registrationType, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, registrationTypeBytes);
        const nameSizeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.name.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, nameSizeBytes);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.name);
        return newArray;
    }
}
exports.NamespaceRegistrationTransactionBodyBuilder = NamespaceRegistrationTransactionBodyBuilder;

},{"./BlockDurationDto":189,"./GeneratorUtils":220,"./NamespaceIdDto":270,"./NamespaceRegistrationTypeDto":277}],276:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceRegistrationTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const NamespaceRegistrationTransactionBodyBuilder_1 = require("./NamespaceRegistrationTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class NamespaceRegistrationTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, id, name, duration, parentId) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.namespaceRegistrationTransactionBody = new NamespaceRegistrationTransactionBodyBuilder_1.NamespaceRegistrationTransactionBodyBuilder(id, name, duration, parentId);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const namespaceRegistrationTransactionBody = NamespaceRegistrationTransactionBodyBuilder_1.NamespaceRegistrationTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, namespaceRegistrationTransactionBody.getSize());
        return new NamespaceRegistrationTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, namespaceRegistrationTransactionBody.id, namespaceRegistrationTransactionBody.name, namespaceRegistrationTransactionBody.duration, namespaceRegistrationTransactionBody.parentId);
    }
    getDuration() {
        return this.namespaceRegistrationTransactionBody.getDuration();
    }
    getParentId() {
        return this.namespaceRegistrationTransactionBody.getParentId();
    }
    getId() {
        return this.namespaceRegistrationTransactionBody.getId();
    }
    getRegistrationType() {
        return this.namespaceRegistrationTransactionBody.getRegistrationType();
    }
    getName() {
        return this.namespaceRegistrationTransactionBody.getName();
    }
    getSize() {
        let size = super.getSize();
        size += this.namespaceRegistrationTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const namespaceRegistrationTransactionBodyBytes = this.namespaceRegistrationTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, namespaceRegistrationTransactionBodyBytes);
        return newArray;
    }
}
exports.NamespaceRegistrationTransactionBuilder = NamespaceRegistrationTransactionBuilder;

},{"./GeneratorUtils":220,"./NamespaceRegistrationTransactionBodyBuilder":275,"./TransactionBuilder":295}],277:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceRegistrationTypeDto = void 0;
var NamespaceRegistrationTypeDto;
(function (NamespaceRegistrationTypeDto) {
    NamespaceRegistrationTypeDto[NamespaceRegistrationTypeDto["ROOT"] = 0] = "ROOT";
    NamespaceRegistrationTypeDto[NamespaceRegistrationTypeDto["CHILD"] = 1] = "CHILD";
})(NamespaceRegistrationTypeDto = exports.NamespaceRegistrationTypeDto || (exports.NamespaceRegistrationTypeDto = {}));

},{}],278:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeKeyLinkTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const KeyDto_1 = require("./KeyDto");
class NodeKeyLinkTransactionBodyBuilder {
    constructor(linkedPublicKey, linkAction) {
        this.linkedPublicKey = linkedPublicKey;
        this.linkAction = linkAction;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const linkedPublicKey = KeyDto_1.KeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, linkedPublicKey.getSize());
        const linkAction = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        return new NodeKeyLinkTransactionBodyBuilder(linkedPublicKey, linkAction);
    }
    getLinkedPublicKey() {
        return this.linkedPublicKey;
    }
    getLinkAction() {
        return this.linkAction;
    }
    getSize() {
        let size = 0;
        size += this.linkedPublicKey.getSize();
        size += 1;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const linkedPublicKeyBytes = this.linkedPublicKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, linkedPublicKeyBytes);
        const linkActionBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.linkAction, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, linkActionBytes);
        return newArray;
    }
}
exports.NodeKeyLinkTransactionBodyBuilder = NodeKeyLinkTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./KeyDto":235}],279:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeKeyLinkTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const NodeKeyLinkTransactionBodyBuilder_1 = require("./NodeKeyLinkTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class NodeKeyLinkTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, linkedPublicKey, linkAction) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.nodeKeyLinkTransactionBody = new NodeKeyLinkTransactionBodyBuilder_1.NodeKeyLinkTransactionBodyBuilder(linkedPublicKey, linkAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const nodeKeyLinkTransactionBody = NodeKeyLinkTransactionBodyBuilder_1.NodeKeyLinkTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, nodeKeyLinkTransactionBody.getSize());
        return new NodeKeyLinkTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, nodeKeyLinkTransactionBody.linkedPublicKey, nodeKeyLinkTransactionBody.linkAction);
    }
    getLinkedPublicKey() {
        return this.nodeKeyLinkTransactionBody.getLinkedPublicKey();
    }
    getLinkAction() {
        return this.nodeKeyLinkTransactionBody.getLinkAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.nodeKeyLinkTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const nodeKeyLinkTransactionBodyBytes = this.nodeKeyLinkTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, nodeKeyLinkTransactionBodyBytes);
        return newArray;
    }
}
exports.NodeKeyLinkTransactionBuilder = NodeKeyLinkTransactionBuilder;

},{"./GeneratorUtils":220,"./NodeKeyLinkTransactionBodyBuilder":278,"./TransactionBuilder":295}],280:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProofGammaDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class ProofGammaDto {
    constructor(proofGamma) {
        this.proofGamma = proofGamma;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const proofGamma = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 32);
        byteArray.splice(0, 32);
        return new ProofGammaDto(proofGamma);
    }
    getProofGamma() {
        return this.proofGamma;
    }
    getSize() {
        return 32;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.proofGamma);
        return newArray;
    }
}
exports.ProofGammaDto = ProofGammaDto;

},{"./GeneratorUtils":220}],281:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProofScalarDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class ProofScalarDto {
    constructor(proofScalar) {
        this.proofScalar = proofScalar;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const proofScalar = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 32);
        byteArray.splice(0, 32);
        return new ProofScalarDto(proofScalar);
    }
    getProofScalar() {
        return this.proofScalar;
    }
    getSize() {
        return 32;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.proofScalar);
        return newArray;
    }
}
exports.ProofScalarDto = ProofScalarDto;

},{"./GeneratorUtils":220}],282:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProofVerificationHashDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class ProofVerificationHashDto {
    constructor(proofVerificationHash) {
        this.proofVerificationHash = proofVerificationHash;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const proofVerificationHash = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 16);
        byteArray.splice(0, 16);
        return new ProofVerificationHashDto(proofVerificationHash);
    }
    getProofVerificationHash() {
        return this.proofVerificationHash;
    }
    getSize() {
        return 16;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.proofVerificationHash);
        return newArray;
    }
}
exports.ProofVerificationHashDto = ProofVerificationHashDto;

},{"./GeneratorUtils":220}],283:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReceiptBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class ReceiptBuilder {
    constructor(version, type) {
        this.size = 0;
        this.version = version;
        this.type = type;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const size = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const version = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const type = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        return new ReceiptBuilder(version, type);
    }
    getVersion() {
        return this.version;
    }
    getType() {
        return this.type;
    }
    getSize() {
        let size = 0;
        size += 4;
        size += 2;
        size += 2;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const versionBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getVersion(), 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, versionBytes);
        const typeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.type, 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, typeBytes);
        return newArray;
    }
}
exports.ReceiptBuilder = ReceiptBuilder;

},{"./GeneratorUtils":220}],284:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReceiptSourceBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class ReceiptSourceBuilder {
    constructor(primaryId, secondaryId) {
        this.primaryId = primaryId;
        this.secondaryId = secondaryId;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const primaryId = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const secondaryId = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        return new ReceiptSourceBuilder(primaryId, secondaryId);
    }
    getPrimaryId() {
        return this.primaryId;
    }
    getSecondaryId() {
        return this.secondaryId;
    }
    getSize() {
        let size = 0;
        size += 4;
        size += 4;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const primaryIdBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getPrimaryId(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, primaryIdBytes);
        const secondaryIdBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getSecondaryId(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secondaryIdBytes);
        return newArray;
    }
}
exports.ReceiptSourceBuilder = ReceiptSourceBuilder;

},{"./GeneratorUtils":220}],285:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestrictionRuleBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const MosaicIdDto_1 = require("./MosaicIdDto");
class RestrictionRuleBuilder {
    constructor(referenceMosaicId, restrictionValue, restrictionType) {
        this.referenceMosaicId = referenceMosaicId;
        this.restrictionValue = restrictionValue;
        this.restrictionType = restrictionType;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const referenceMosaicId = MosaicIdDto_1.MosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, referenceMosaicId.getSize());
        const restrictionValue = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const restrictionType = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        return new RestrictionRuleBuilder(referenceMosaicId, restrictionValue, restrictionType);
    }
    getReferenceMosaicId() {
        return this.referenceMosaicId;
    }
    getRestrictionValue() {
        return this.restrictionValue;
    }
    getRestrictionType() {
        return this.restrictionType;
    }
    getSize() {
        let size = 0;
        size += this.referenceMosaicId.getSize();
        size += 8;
        size += 1;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const referenceMosaicIdBytes = this.referenceMosaicId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, referenceMosaicIdBytes);
        const restrictionValueBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getRestrictionValue());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionValueBytes);
        const restrictionTypeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.restrictionType, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, restrictionTypeBytes);
        return newArray;
    }
}
exports.RestrictionRuleBuilder = RestrictionRuleBuilder;

},{"./GeneratorUtils":220,"./MosaicIdDto":252}],286:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RootNamespaceHistoryBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const NamespaceIdDto_1 = require("./NamespaceIdDto");
const NamespaceLifetimeBuilder_1 = require("./NamespaceLifetimeBuilder");
const NamespacePathBuilder_1 = require("./NamespacePathBuilder");
class RootNamespaceHistoryBuilder {
    constructor(id, ownerAddress, lifetime, rootAlias, paths) {
        this.id = id;
        this.ownerAddress = ownerAddress;
        this.lifetime = lifetime;
        this.rootAlias = rootAlias;
        this.paths = paths;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const id = NamespaceIdDto_1.NamespaceIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, id.getSize());
        const ownerAddress = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, ownerAddress.getSize());
        const lifetime = NamespaceLifetimeBuilder_1.NamespaceLifetimeBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, lifetime.getSize());
        const rootAlias = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const childrenCount = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        const paths = [];
        for (let i = 0; i < (Array.isArray(childrenCount) ? GeneratorUtils_1.GeneratorUtils.compact(childrenCount) : childrenCount); i++) {
            const item = NamespacePathBuilder_1.NamespacePathBuilder.loadFromBinary(Uint8Array.from(byteArray));
            paths.push(item);
            byteArray.splice(0, item.getSize());
        }
        return new RootNamespaceHistoryBuilder(id, ownerAddress, lifetime, rootAlias, paths);
    }
    getId() {
        return this.id;
    }
    getOwnerAddress() {
        return this.ownerAddress;
    }
    getLifetime() {
        return this.lifetime;
    }
    getRootAlias() {
        return this.rootAlias;
    }
    getPaths() {
        return this.paths;
    }
    getSize() {
        let size = 0;
        size += this.id.getSize();
        size += this.ownerAddress.getSize();
        size += this.lifetime.getSize();
        size += 1;
        size += 8;
        this.paths.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const idBytes = this.id.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, idBytes);
        const ownerAddressBytes = this.ownerAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, ownerAddressBytes);
        const lifetimeBytes = this.lifetime.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, lifetimeBytes);
        const rootAliasBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.rootAlias, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, rootAliasBytes);
        const childrenCountBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(GeneratorUtils_1.GeneratorUtils.fromUint(this.paths.length));
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, childrenCountBytes);
        this.paths.forEach((item) => {
            const pathsBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, pathsBytes);
        });
        return newArray;
    }
}
exports.RootNamespaceHistoryBuilder = RootNamespaceHistoryBuilder;

},{"./AddressDto":178,"./GeneratorUtils":220,"./NamespaceIdDto":270,"./NamespaceLifetimeBuilder":271,"./NamespacePathBuilder":274}],287:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScopedMetadataKeyDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class ScopedMetadataKeyDto {
    constructor(scopedMetadataKey) {
        this.scopedMetadataKey = scopedMetadataKey;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const scopedMetadataKey = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new ScopedMetadataKeyDto(scopedMetadataKey);
    }
    getScopedMetadataKey() {
        return this.scopedMetadataKey;
    }
    getSize() {
        return 8;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const scopedMetadataKeyBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getScopedMetadataKey());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, scopedMetadataKeyBytes);
        return newArray;
    }
}
exports.ScopedMetadataKeyDto = ScopedMetadataKeyDto;

},{"./GeneratorUtils":220}],288:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretLockInfoBuilder = void 0;
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const Hash256Dto_1 = require("./Hash256Dto");
const HeightDto_1 = require("./HeightDto");
const MosaicBuilder_1 = require("./MosaicBuilder");
class SecretLockInfoBuilder {
    constructor(ownerAddress, mosaic, endHeight, status, hashAlgorithm, secret, recipient) {
        this.ownerAddress = ownerAddress;
        this.mosaic = mosaic;
        this.endHeight = endHeight;
        this.status = status;
        this.hashAlgorithm = hashAlgorithm;
        this.secret = secret;
        this.recipient = recipient;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const ownerAddress = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, ownerAddress.getSize());
        const mosaic = MosaicBuilder_1.MosaicBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaic.getSize());
        const endHeight = HeightDto_1.HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, endHeight.getSize());
        const status = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const hashAlgorithm = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const secret = Hash256Dto_1.Hash256Dto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, secret.getSize());
        const recipient = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, recipient.getSize());
        return new SecretLockInfoBuilder(ownerAddress, mosaic, endHeight, status, hashAlgorithm, secret, recipient);
    }
    getOwnerAddress() {
        return this.ownerAddress;
    }
    getMosaic() {
        return this.mosaic;
    }
    getEndHeight() {
        return this.endHeight;
    }
    getStatus() {
        return this.status;
    }
    getHashAlgorithm() {
        return this.hashAlgorithm;
    }
    getSecret() {
        return this.secret;
    }
    getRecipient() {
        return this.recipient;
    }
    getSize() {
        let size = 0;
        size += this.ownerAddress.getSize();
        size += this.mosaic.getSize();
        size += this.endHeight.getSize();
        size += 1;
        size += 1;
        size += this.secret.getSize();
        size += this.recipient.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const ownerAddressBytes = this.ownerAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, ownerAddressBytes);
        const mosaicBytes = this.mosaic.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicBytes);
        const endHeightBytes = this.endHeight.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, endHeightBytes);
        const statusBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.status, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, statusBytes);
        const hashAlgorithmBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.hashAlgorithm, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, hashAlgorithmBytes);
        const secretBytes = this.secret.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secretBytes);
        const recipientBytes = this.recipient.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, recipientBytes);
        return newArray;
    }
}
exports.SecretLockInfoBuilder = SecretLockInfoBuilder;

},{"./AddressDto":178,"./GeneratorUtils":220,"./Hash256Dto":223,"./HeightDto":230,"./MosaicBuilder":243}],289:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretLockTransactionBodyBuilder = void 0;
const BlockDurationDto_1 = require("./BlockDurationDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const Hash256Dto_1 = require("./Hash256Dto");
const UnresolvedAddressDto_1 = require("./UnresolvedAddressDto");
const UnresolvedMosaicBuilder_1 = require("./UnresolvedMosaicBuilder");
class SecretLockTransactionBodyBuilder {
    constructor(secret, mosaic, duration, hashAlgorithm, recipientAddress) {
        this.secret = secret;
        this.mosaic = mosaic;
        this.duration = duration;
        this.hashAlgorithm = hashAlgorithm;
        this.recipientAddress = recipientAddress;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const secret = Hash256Dto_1.Hash256Dto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, secret.getSize());
        const mosaic = UnresolvedMosaicBuilder_1.UnresolvedMosaicBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaic.getSize());
        const duration = BlockDurationDto_1.BlockDurationDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, duration.getSize());
        const hashAlgorithm = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const recipientAddress = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, recipientAddress.getSize());
        return new SecretLockTransactionBodyBuilder(secret, mosaic, duration, hashAlgorithm, recipientAddress);
    }
    getSecret() {
        return this.secret;
    }
    getMosaic() {
        return this.mosaic;
    }
    getDuration() {
        return this.duration;
    }
    getHashAlgorithm() {
        return this.hashAlgorithm;
    }
    getRecipientAddress() {
        return this.recipientAddress;
    }
    getSize() {
        let size = 0;
        size += this.secret.getSize();
        size += this.mosaic.getSize();
        size += this.duration.getSize();
        size += 1;
        size += this.recipientAddress.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const secretBytes = this.secret.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secretBytes);
        const mosaicBytes = this.mosaic.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicBytes);
        const durationBytes = this.duration.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, durationBytes);
        const hashAlgorithmBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.hashAlgorithm, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, hashAlgorithmBytes);
        const recipientAddressBytes = this.recipientAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, recipientAddressBytes);
        return newArray;
    }
}
exports.SecretLockTransactionBodyBuilder = SecretLockTransactionBodyBuilder;

},{"./BlockDurationDto":189,"./GeneratorUtils":220,"./Hash256Dto":223,"./UnresolvedAddressDto":299,"./UnresolvedMosaicBuilder":300}],290:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretLockTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const SecretLockTransactionBodyBuilder_1 = require("./SecretLockTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class SecretLockTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, secret, mosaic, duration, hashAlgorithm, recipientAddress) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.secretLockTransactionBody = new SecretLockTransactionBodyBuilder_1.SecretLockTransactionBodyBuilder(secret, mosaic, duration, hashAlgorithm, recipientAddress);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const secretLockTransactionBody = SecretLockTransactionBodyBuilder_1.SecretLockTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, secretLockTransactionBody.getSize());
        return new SecretLockTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, secretLockTransactionBody.secret, secretLockTransactionBody.mosaic, secretLockTransactionBody.duration, secretLockTransactionBody.hashAlgorithm, secretLockTransactionBody.recipientAddress);
    }
    getSecret() {
        return this.secretLockTransactionBody.getSecret();
    }
    getMosaic() {
        return this.secretLockTransactionBody.getMosaic();
    }
    getDuration() {
        return this.secretLockTransactionBody.getDuration();
    }
    getHashAlgorithm() {
        return this.secretLockTransactionBody.getHashAlgorithm();
    }
    getRecipientAddress() {
        return this.secretLockTransactionBody.getRecipientAddress();
    }
    getSize() {
        let size = super.getSize();
        size += this.secretLockTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const secretLockTransactionBodyBytes = this.secretLockTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secretLockTransactionBodyBytes);
        return newArray;
    }
}
exports.SecretLockTransactionBuilder = SecretLockTransactionBuilder;

},{"./GeneratorUtils":220,"./SecretLockTransactionBodyBuilder":289,"./TransactionBuilder":295}],291:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretProofTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const Hash256Dto_1 = require("./Hash256Dto");
const UnresolvedAddressDto_1 = require("./UnresolvedAddressDto");
class SecretProofTransactionBodyBuilder {
    constructor(secret, hashAlgorithm, recipientAddress, proof) {
        this.secret = secret;
        this.hashAlgorithm = hashAlgorithm;
        this.recipientAddress = recipientAddress;
        this.proof = proof;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const secret = Hash256Dto_1.Hash256Dto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, secret.getSize());
        const proofSize = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const hashAlgorithm = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const recipientAddress = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, recipientAddress.getSize());
        const proof = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), proofSize);
        byteArray.splice(0, proofSize);
        return new SecretProofTransactionBodyBuilder(secret, hashAlgorithm, recipientAddress, proof);
    }
    getSecret() {
        return this.secret;
    }
    getHashAlgorithm() {
        return this.hashAlgorithm;
    }
    getRecipientAddress() {
        return this.recipientAddress;
    }
    getProof() {
        return this.proof;
    }
    getSize() {
        let size = 0;
        size += this.secret.getSize();
        size += 2;
        size += 1;
        size += this.recipientAddress.getSize();
        size += this.proof.length;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const secretBytes = this.secret.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secretBytes);
        const proofSizeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.proof.length, 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, proofSizeBytes);
        const hashAlgorithmBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.hashAlgorithm, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, hashAlgorithmBytes);
        const recipientAddressBytes = this.recipientAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, recipientAddressBytes);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.proof);
        return newArray;
    }
}
exports.SecretProofTransactionBodyBuilder = SecretProofTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./Hash256Dto":223,"./UnresolvedAddressDto":299}],292:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretProofTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const SecretProofTransactionBodyBuilder_1 = require("./SecretProofTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class SecretProofTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, secret, hashAlgorithm, recipientAddress, proof) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.secretProofTransactionBody = new SecretProofTransactionBodyBuilder_1.SecretProofTransactionBodyBuilder(secret, hashAlgorithm, recipientAddress, proof);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const secretProofTransactionBody = SecretProofTransactionBodyBuilder_1.SecretProofTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, secretProofTransactionBody.getSize());
        return new SecretProofTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, secretProofTransactionBody.secret, secretProofTransactionBody.hashAlgorithm, secretProofTransactionBody.recipientAddress, secretProofTransactionBody.proof);
    }
    getSecret() {
        return this.secretProofTransactionBody.getSecret();
    }
    getHashAlgorithm() {
        return this.secretProofTransactionBody.getHashAlgorithm();
    }
    getRecipientAddress() {
        return this.secretProofTransactionBody.getRecipientAddress();
    }
    getProof() {
        return this.secretProofTransactionBody.getProof();
    }
    getSize() {
        let size = super.getSize();
        size += this.secretProofTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const secretProofTransactionBodyBytes = this.secretProofTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secretProofTransactionBodyBytes);
        return newArray;
    }
}
exports.SecretProofTransactionBuilder = SecretProofTransactionBuilder;

},{"./GeneratorUtils":220,"./SecretProofTransactionBodyBuilder":291,"./TransactionBuilder":295}],293:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignatureDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class SignatureDto {
    constructor(signature) {
        this.signature = signature;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const signature = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 64);
        byteArray.splice(0, 64);
        return new SignatureDto(signature);
    }
    getSignature() {
        return this.signature;
    }
    getSize() {
        return 64;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.signature);
        return newArray;
    }
}
exports.SignatureDto = SignatureDto;

},{"./GeneratorUtils":220}],294:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimestampDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class TimestampDto {
    constructor(timestamp) {
        this.timestamp = timestamp;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const timestamp = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new TimestampDto(timestamp);
    }
    getTimestamp() {
        return this.timestamp;
    }
    getSize() {
        return 8;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const timestampBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getTimestamp());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, timestampBytes);
        return newArray;
    }
}
exports.TimestampDto = TimestampDto;

},{"./GeneratorUtils":220}],295:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
const AmountDto_1 = require("./AmountDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const KeyDto_1 = require("./KeyDto");
const SignatureDto_1 = require("./SignatureDto");
const TimestampDto_1 = require("./TimestampDto");
class TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline) {
        this.size = 0;
        this.verifiableEntityHeader_Reserved1 = 0;
        this.signature = signature;
        this.signerPublicKey = signerPublicKey;
        this.entityBody_Reserved1 = 0;
        this.version = version;
        this.network = network;
        this.type = type;
        this.fee = fee;
        this.deadline = deadline;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const size = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const verifiableEntityHeader_Reserved1 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const signature = SignatureDto_1.SignatureDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, signature.getSize());
        const signerPublicKey = KeyDto_1.KeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, signerPublicKey.getSize());
        const entityBody_Reserved1 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const version = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const network = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const type = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const fee = AmountDto_1.AmountDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, fee.getSize());
        const deadline = TimestampDto_1.TimestampDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, deadline.getSize());
        return new TransactionBuilder(signature, signerPublicKey, version, network, type, fee, deadline);
    }
    getVerifiableEntityHeader_Reserved1() {
        return this.verifiableEntityHeader_Reserved1;
    }
    getSignature() {
        return this.signature;
    }
    getSignerPublicKey() {
        return this.signerPublicKey;
    }
    getEntityBody_Reserved1() {
        return this.entityBody_Reserved1;
    }
    getVersion() {
        return this.version;
    }
    getNetwork() {
        return this.network;
    }
    getType() {
        return this.type;
    }
    getFee() {
        return this.fee;
    }
    getDeadline() {
        return this.deadline;
    }
    getSize() {
        let size = 0;
        size += 4;
        size += 4;
        size += this.signature.getSize();
        size += this.signerPublicKey.getSize();
        size += 4;
        size += 1;
        size += 1;
        size += 2;
        size += this.fee.getSize();
        size += this.deadline.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const sizeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getSize(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, sizeBytes);
        const verifiableEntityHeader_Reserved1Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getVerifiableEntityHeader_Reserved1(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, verifiableEntityHeader_Reserved1Bytes);
        const signatureBytes = this.signature.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, signatureBytes);
        const signerPublicKeyBytes = this.signerPublicKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, signerPublicKeyBytes);
        const entityBody_Reserved1Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getEntityBody_Reserved1(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, entityBody_Reserved1Bytes);
        const versionBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getVersion(), 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, versionBytes);
        const networkBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.network, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, networkBytes);
        const typeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.type, 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, typeBytes);
        const feeBytes = this.fee.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, feeBytes);
        const deadlineBytes = this.deadline.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, deadlineBytes);
        return newArray;
    }
}
exports.TransactionBuilder = TransactionBuilder;

},{"./AmountDto":186,"./GeneratorUtils":220,"./KeyDto":235,"./SignatureDto":293,"./TimestampDto":294}],296:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionHelper = void 0;
const AccountAddressRestrictionTransactionBuilder_1 = require("./AccountAddressRestrictionTransactionBuilder");
const AccountKeyLinkTransactionBuilder_1 = require("./AccountKeyLinkTransactionBuilder");
const AccountMetadataTransactionBuilder_1 = require("./AccountMetadataTransactionBuilder");
const AccountMosaicRestrictionTransactionBuilder_1 = require("./AccountMosaicRestrictionTransactionBuilder");
const AccountOperationRestrictionTransactionBuilder_1 = require("./AccountOperationRestrictionTransactionBuilder");
const AddressAliasTransactionBuilder_1 = require("./AddressAliasTransactionBuilder");
const AggregateBondedTransactionBuilder_1 = require("./AggregateBondedTransactionBuilder");
const AggregateCompleteTransactionBuilder_1 = require("./AggregateCompleteTransactionBuilder");
const EntityTypeDto_1 = require("./EntityTypeDto");
const HashLockTransactionBuilder_1 = require("./HashLockTransactionBuilder");
const MosaicAddressRestrictionTransactionBuilder_1 = require("./MosaicAddressRestrictionTransactionBuilder");
const MosaicAliasTransactionBuilder_1 = require("./MosaicAliasTransactionBuilder");
const MosaicDefinitionTransactionBuilder_1 = require("./MosaicDefinitionTransactionBuilder");
const MosaicGlobalRestrictionTransactionBuilder_1 = require("./MosaicGlobalRestrictionTransactionBuilder");
const MosaicMetadataTransactionBuilder_1 = require("./MosaicMetadataTransactionBuilder");
const MosaicSupplyChangeTransactionBuilder_1 = require("./MosaicSupplyChangeTransactionBuilder");
const MultisigAccountModificationTransactionBuilder_1 = require("./MultisigAccountModificationTransactionBuilder");
const NamespaceMetadataTransactionBuilder_1 = require("./NamespaceMetadataTransactionBuilder");
const NamespaceRegistrationTransactionBuilder_1 = require("./NamespaceRegistrationTransactionBuilder");
const NodeKeyLinkTransactionBuilder_1 = require("./NodeKeyLinkTransactionBuilder");
const SecretLockTransactionBuilder_1 = require("./SecretLockTransactionBuilder");
const SecretProofTransactionBuilder_1 = require("./SecretProofTransactionBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
const TransferTransactionBuilder_1 = require("./TransferTransactionBuilder");
const VotingKeyLinkTransactionBuilder_1 = require("./VotingKeyLinkTransactionBuilder");
const VrfKeyLinkTransactionBuilder_1 = require("./VrfKeyLinkTransactionBuilder");
class TransactionHelper {
    static loadFromBinary(bytes) {
        const header = TransactionBuilder_1.TransactionBuilder.loadFromBinary(bytes);
        switch (header.getType()) {
            case EntityTypeDto_1.EntityTypeDto.MOSAIC_DEFINITION_TRANSACTION_BUILDER:
                return MosaicDefinitionTransactionBuilder_1.MosaicDefinitionTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.ACCOUNT_KEY_LINK_TRANSACTION_BUILDER:
                return AccountKeyLinkTransactionBuilder_1.AccountKeyLinkTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.NODE_KEY_LINK_TRANSACTION_BUILDER:
                return NodeKeyLinkTransactionBuilder_1.NodeKeyLinkTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.AGGREGATE_COMPLETE_TRANSACTION_BUILDER:
                return AggregateCompleteTransactionBuilder_1.AggregateCompleteTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.AGGREGATE_BONDED_TRANSACTION_BUILDER:
                return AggregateBondedTransactionBuilder_1.AggregateBondedTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.VOTING_KEY_LINK_TRANSACTION_BUILDER:
                return VotingKeyLinkTransactionBuilder_1.VotingKeyLinkTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.VRF_KEY_LINK_TRANSACTION_BUILDER:
                return VrfKeyLinkTransactionBuilder_1.VrfKeyLinkTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.HASH_LOCK_TRANSACTION_BUILDER:
                return HashLockTransactionBuilder_1.HashLockTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.SECRET_LOCK_TRANSACTION_BUILDER:
                return SecretLockTransactionBuilder_1.SecretLockTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.SECRET_PROOF_TRANSACTION_BUILDER:
                return SecretProofTransactionBuilder_1.SecretProofTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.ACCOUNT_METADATA_TRANSACTION_BUILDER:
                return AccountMetadataTransactionBuilder_1.AccountMetadataTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.MOSAIC_METADATA_TRANSACTION_BUILDER:
                return MosaicMetadataTransactionBuilder_1.MosaicMetadataTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.NAMESPACE_METADATA_TRANSACTION_BUILDER:
                return NamespaceMetadataTransactionBuilder_1.NamespaceMetadataTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.MOSAIC_SUPPLY_CHANGE_TRANSACTION_BUILDER:
                return MosaicSupplyChangeTransactionBuilder_1.MosaicSupplyChangeTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.MULTISIG_ACCOUNT_MODIFICATION_TRANSACTION_BUILDER:
                return MultisigAccountModificationTransactionBuilder_1.MultisigAccountModificationTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.ADDRESS_ALIAS_TRANSACTION_BUILDER:
                return AddressAliasTransactionBuilder_1.AddressAliasTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.MOSAIC_ALIAS_TRANSACTION_BUILDER:
                return MosaicAliasTransactionBuilder_1.MosaicAliasTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.NAMESPACE_REGISTRATION_TRANSACTION_BUILDER:
                return NamespaceRegistrationTransactionBuilder_1.NamespaceRegistrationTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.ACCOUNT_ADDRESS_RESTRICTION_TRANSACTION_BUILDER:
                return AccountAddressRestrictionTransactionBuilder_1.AccountAddressRestrictionTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.ACCOUNT_MOSAIC_RESTRICTION_TRANSACTION_BUILDER:
                return AccountMosaicRestrictionTransactionBuilder_1.AccountMosaicRestrictionTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.ACCOUNT_OPERATION_RESTRICTION_TRANSACTION_BUILDER:
                return AccountOperationRestrictionTransactionBuilder_1.AccountOperationRestrictionTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.MOSAIC_ADDRESS_RESTRICTION_TRANSACTION_BUILDER:
                return MosaicAddressRestrictionTransactionBuilder_1.MosaicAddressRestrictionTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.MOSAIC_GLOBAL_RESTRICTION_TRANSACTION_BUILDER:
                return MosaicGlobalRestrictionTransactionBuilder_1.MosaicGlobalRestrictionTransactionBuilder.loadFromBinary(bytes);
            case EntityTypeDto_1.EntityTypeDto.TRANSFER_TRANSACTION_BUILDER:
                return TransferTransactionBuilder_1.TransferTransactionBuilder.loadFromBinary(bytes);
            default:
                throw new Error(`Transaction type: ${header.getType()} not recognized.`);
        }
    }
}
exports.TransactionHelper = TransactionHelper;

},{"./AccountAddressRestrictionTransactionBuilder":158,"./AccountKeyLinkTransactionBuilder":161,"./AccountMetadataTransactionBuilder":163,"./AccountMosaicRestrictionTransactionBuilder":165,"./AccountOperationRestrictionTransactionBuilder":167,"./AddressAliasTransactionBuilder":177,"./AggregateBondedTransactionBuilder":183,"./AggregateCompleteTransactionBuilder":184,"./EntityTypeDto":219,"./HashLockTransactionBuilder":227,"./MosaicAddressRestrictionTransactionBuilder":240,"./MosaicAliasTransactionBuilder":242,"./MosaicDefinitionTransactionBuilder":246,"./MosaicGlobalRestrictionTransactionBuilder":251,"./MosaicMetadataTransactionBuilder":254,"./MosaicSupplyChangeTransactionBuilder":263,"./MultisigAccountModificationTransactionBuilder":265,"./NamespaceMetadataTransactionBuilder":273,"./NamespaceRegistrationTransactionBuilder":276,"./NodeKeyLinkTransactionBuilder":279,"./SecretLockTransactionBuilder":290,"./SecretProofTransactionBuilder":292,"./TransactionBuilder":295,"./TransferTransactionBuilder":298,"./VotingKeyLinkTransactionBuilder":304,"./VrfKeyLinkTransactionBuilder":306}],297:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const UnresolvedAddressDto_1 = require("./UnresolvedAddressDto");
const UnresolvedMosaicBuilder_1 = require("./UnresolvedMosaicBuilder");
class TransferTransactionBodyBuilder {
    constructor(recipientAddress, mosaics, message) {
        this.recipientAddress = recipientAddress;
        this.transferTransactionBody_Reserved1 = 0;
        this.transferTransactionBody_Reserved2 = 0;
        this.mosaics = mosaics;
        this.message = message;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const recipientAddress = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, recipientAddress.getSize());
        const messageSize = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const mosaicsCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const transferTransactionBody_Reserved1 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 4));
        byteArray.splice(0, 4);
        const transferTransactionBody_Reserved2 = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const mosaics = [];
        for (let i = 0; i < (Array.isArray(mosaicsCount) ? GeneratorUtils_1.GeneratorUtils.compact(mosaicsCount) : mosaicsCount); i++) {
            const item = UnresolvedMosaicBuilder_1.UnresolvedMosaicBuilder.loadFromBinary(Uint8Array.from(byteArray));
            mosaics.push(item);
            byteArray.splice(0, item.getSize());
        }
        const message = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), messageSize);
        byteArray.splice(0, messageSize);
        return new TransferTransactionBodyBuilder(recipientAddress, mosaics, message);
    }
    getRecipientAddress() {
        return this.recipientAddress;
    }
    getTransferTransactionBody_Reserved1() {
        return this.transferTransactionBody_Reserved1;
    }
    getTransferTransactionBody_Reserved2() {
        return this.transferTransactionBody_Reserved2;
    }
    getMosaics() {
        return this.mosaics;
    }
    getMessage() {
        return this.message;
    }
    getSize() {
        let size = 0;
        size += this.recipientAddress.getSize();
        size += 2;
        size += 1;
        size += 4;
        size += 1;
        this.mosaics.forEach((o) => size += o.getSize());
        size += this.message.length;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const recipientAddressBytes = this.recipientAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, recipientAddressBytes);
        const messageSizeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.message.length, 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, messageSizeBytes);
        const mosaicsCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.mosaics.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicsCountBytes);
        const transferTransactionBody_Reserved1Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getTransferTransactionBody_Reserved1(), 4);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, transferTransactionBody_Reserved1Bytes);
        const transferTransactionBody_Reserved2Bytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getTransferTransactionBody_Reserved2(), 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, transferTransactionBody_Reserved2Bytes);
        this.mosaics.forEach((item) => {
            const mosaicsBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicsBytes);
        });
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.message);
        return newArray;
    }
}
exports.TransferTransactionBodyBuilder = TransferTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./UnresolvedAddressDto":299,"./UnresolvedMosaicBuilder":300}],298:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const TransactionBuilder_1 = require("./TransactionBuilder");
const TransferTransactionBodyBuilder_1 = require("./TransferTransactionBodyBuilder");
class TransferTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, recipientAddress, mosaics, message) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.transferTransactionBody = new TransferTransactionBodyBuilder_1.TransferTransactionBodyBuilder(recipientAddress, mosaics, message);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const transferTransactionBody = TransferTransactionBodyBuilder_1.TransferTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, transferTransactionBody.getSize());
        return new TransferTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, transferTransactionBody.recipientAddress, transferTransactionBody.mosaics, transferTransactionBody.message);
    }
    getRecipientAddress() {
        return this.transferTransactionBody.getRecipientAddress();
    }
    getTransferTransactionBody_Reserved1() {
        return this.transferTransactionBody.getTransferTransactionBody_Reserved1();
    }
    getTransferTransactionBody_Reserved2() {
        return this.transferTransactionBody.getTransferTransactionBody_Reserved2();
    }
    getMosaics() {
        return this.transferTransactionBody.getMosaics();
    }
    getMessage() {
        return this.transferTransactionBody.getMessage();
    }
    getSize() {
        let size = super.getSize();
        size += this.transferTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const transferTransactionBodyBytes = this.transferTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, transferTransactionBodyBytes);
        return newArray;
    }
}
exports.TransferTransactionBuilder = TransferTransactionBuilder;

},{"./GeneratorUtils":220,"./TransactionBuilder":295,"./TransferTransactionBodyBuilder":297}],299:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnresolvedAddressDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class UnresolvedAddressDto {
    constructor(unresolvedAddress) {
        this.unresolvedAddress = unresolvedAddress;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const unresolvedAddress = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 24);
        byteArray.splice(0, 24);
        return new UnresolvedAddressDto(unresolvedAddress);
    }
    getUnresolvedAddress() {
        return this.unresolvedAddress;
    }
    getSize() {
        return 24;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.unresolvedAddress);
        return newArray;
    }
}
exports.UnresolvedAddressDto = UnresolvedAddressDto;

},{"./GeneratorUtils":220}],300:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnresolvedMosaicBuilder = void 0;
const AmountDto_1 = require("./AmountDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const UnresolvedMosaicIdDto_1 = require("./UnresolvedMosaicIdDto");
class UnresolvedMosaicBuilder {
    constructor(mosaicId, amount) {
        this.mosaicId = mosaicId;
        this.amount = amount;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const mosaicId = UnresolvedMosaicIdDto_1.UnresolvedMosaicIdDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaicId.getSize());
        const amount = AmountDto_1.AmountDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, amount.getSize());
        return new UnresolvedMosaicBuilder(mosaicId, amount);
    }
    getMosaicId() {
        return this.mosaicId;
    }
    getAmount() {
        return this.amount;
    }
    getSize() {
        let size = 0;
        size += this.mosaicId.getSize();
        size += this.amount.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const mosaicIdBytes = this.mosaicId.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicIdBytes);
        const amountBytes = this.amount.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, amountBytes);
        return newArray;
    }
}
exports.UnresolvedMosaicBuilder = UnresolvedMosaicBuilder;

},{"./AmountDto":186,"./GeneratorUtils":220,"./UnresolvedMosaicIdDto":301}],301:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnresolvedMosaicIdDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class UnresolvedMosaicIdDto {
    constructor(unresolvedMosaicId) {
        this.unresolvedMosaicId = unresolvedMosaicId;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const unresolvedMosaicId = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new UnresolvedMosaicIdDto(unresolvedMosaicId);
    }
    getUnresolvedMosaicId() {
        return this.unresolvedMosaicId;
    }
    getSize() {
        return 8;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const unresolvedMosaicIdBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getUnresolvedMosaicId());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, unresolvedMosaicIdBytes);
        return newArray;
    }
}
exports.UnresolvedMosaicIdDto = UnresolvedMosaicIdDto;

},{"./GeneratorUtils":220}],302:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VotingKeyDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class VotingKeyDto {
    constructor(votingKey) {
        this.votingKey = votingKey;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const votingKey = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 48);
        byteArray.splice(0, 48);
        return new VotingKeyDto(votingKey);
    }
    getVotingKey() {
        return this.votingKey;
    }
    getSize() {
        return 48;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.votingKey);
        return newArray;
    }
}
exports.VotingKeyDto = VotingKeyDto;

},{"./GeneratorUtils":220}],303:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VotingKeyLinkTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const VotingKeyDto_1 = require("./VotingKeyDto");
class VotingKeyLinkTransactionBodyBuilder {
    constructor(linkedPublicKey, linkAction) {
        this.linkedPublicKey = linkedPublicKey;
        this.linkAction = linkAction;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const linkedPublicKey = VotingKeyDto_1.VotingKeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, linkedPublicKey.getSize());
        const linkAction = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        return new VotingKeyLinkTransactionBodyBuilder(linkedPublicKey, linkAction);
    }
    getLinkedPublicKey() {
        return this.linkedPublicKey;
    }
    getLinkAction() {
        return this.linkAction;
    }
    getSize() {
        let size = 0;
        size += this.linkedPublicKey.getSize();
        size += 1;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const linkedPublicKeyBytes = this.linkedPublicKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, linkedPublicKeyBytes);
        const linkActionBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.linkAction, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, linkActionBytes);
        return newArray;
    }
}
exports.VotingKeyLinkTransactionBodyBuilder = VotingKeyLinkTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./VotingKeyDto":302}],304:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VotingKeyLinkTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const TransactionBuilder_1 = require("./TransactionBuilder");
const VotingKeyLinkTransactionBodyBuilder_1 = require("./VotingKeyLinkTransactionBodyBuilder");
class VotingKeyLinkTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, linkedPublicKey, linkAction) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.votingKeyLinkTransactionBody = new VotingKeyLinkTransactionBodyBuilder_1.VotingKeyLinkTransactionBodyBuilder(linkedPublicKey, linkAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const votingKeyLinkTransactionBody = VotingKeyLinkTransactionBodyBuilder_1.VotingKeyLinkTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, votingKeyLinkTransactionBody.getSize());
        return new VotingKeyLinkTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, votingKeyLinkTransactionBody.linkedPublicKey, votingKeyLinkTransactionBody.linkAction);
    }
    getLinkedPublicKey() {
        return this.votingKeyLinkTransactionBody.getLinkedPublicKey();
    }
    getLinkAction() {
        return this.votingKeyLinkTransactionBody.getLinkAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.votingKeyLinkTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const votingKeyLinkTransactionBodyBytes = this.votingKeyLinkTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, votingKeyLinkTransactionBodyBytes);
        return newArray;
    }
}
exports.VotingKeyLinkTransactionBuilder = VotingKeyLinkTransactionBuilder;

},{"./GeneratorUtils":220,"./TransactionBuilder":295,"./VotingKeyLinkTransactionBodyBuilder":303}],305:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VrfKeyLinkTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const KeyDto_1 = require("./KeyDto");
class VrfKeyLinkTransactionBodyBuilder {
    constructor(linkedPublicKey, linkAction) {
        this.linkedPublicKey = linkedPublicKey;
        this.linkAction = linkAction;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const linkedPublicKey = KeyDto_1.KeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, linkedPublicKey.getSize());
        const linkAction = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        return new VrfKeyLinkTransactionBodyBuilder(linkedPublicKey, linkAction);
    }
    getLinkedPublicKey() {
        return this.linkedPublicKey;
    }
    getLinkAction() {
        return this.linkAction;
    }
    getSize() {
        let size = 0;
        size += this.linkedPublicKey.getSize();
        size += 1;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const linkedPublicKeyBytes = this.linkedPublicKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, linkedPublicKeyBytes);
        const linkActionBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.linkAction, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, linkActionBytes);
        return newArray;
    }
}
exports.VrfKeyLinkTransactionBodyBuilder = VrfKeyLinkTransactionBodyBuilder;

},{"./GeneratorUtils":220,"./KeyDto":235}],306:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VrfKeyLinkTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const TransactionBuilder_1 = require("./TransactionBuilder");
const VrfKeyLinkTransactionBodyBuilder_1 = require("./VrfKeyLinkTransactionBodyBuilder");
class VrfKeyLinkTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, linkedPublicKey, linkAction) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.vrfKeyLinkTransactionBody = new VrfKeyLinkTransactionBodyBuilder_1.VrfKeyLinkTransactionBodyBuilder(linkedPublicKey, linkAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const vrfKeyLinkTransactionBody = VrfKeyLinkTransactionBodyBuilder_1.VrfKeyLinkTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, vrfKeyLinkTransactionBody.getSize());
        return new VrfKeyLinkTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, vrfKeyLinkTransactionBody.linkedPublicKey, vrfKeyLinkTransactionBody.linkAction);
    }
    getLinkedPublicKey() {
        return this.vrfKeyLinkTransactionBody.getLinkedPublicKey();
    }
    getLinkAction() {
        return this.vrfKeyLinkTransactionBody.getLinkAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.vrfKeyLinkTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const vrfKeyLinkTransactionBodyBytes = this.vrfKeyLinkTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, vrfKeyLinkTransactionBodyBytes);
        return newArray;
    }
}
exports.VrfKeyLinkTransactionBuilder = VrfKeyLinkTransactionBuilder;

},{"./GeneratorUtils":220,"./TransactionBuilder":295,"./VrfKeyLinkTransactionBodyBuilder":305}],307:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VrfProofBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const ProofGammaDto_1 = require("./ProofGammaDto");
const ProofScalarDto_1 = require("./ProofScalarDto");
const ProofVerificationHashDto_1 = require("./ProofVerificationHashDto");
class VrfProofBuilder {
    constructor(gamma, verificationHash, scalar) {
        this.gamma = gamma;
        this.verificationHash = verificationHash;
        this.scalar = scalar;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const gamma = ProofGammaDto_1.ProofGammaDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, gamma.getSize());
        const verificationHash = ProofVerificationHashDto_1.ProofVerificationHashDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, verificationHash.getSize());
        const scalar = ProofScalarDto_1.ProofScalarDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, scalar.getSize());
        return new VrfProofBuilder(gamma, verificationHash, scalar);
    }
    getGamma() {
        return this.gamma;
    }
    getVerificationHash() {
        return this.verificationHash;
    }
    getScalar() {
        return this.scalar;
    }
    getSize() {
        let size = 0;
        size += this.gamma.getSize();
        size += this.verificationHash.getSize();
        size += this.scalar.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const gammaBytes = this.gamma.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, gammaBytes);
        const verificationHashBytes = this.verificationHash.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, verificationHashBytes);
        const scalarBytes = this.scalar.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, scalarBytes);
        return newArray;
    }
}
exports.VrfProofBuilder = VrfProofBuilder;

},{"./GeneratorUtils":220,"./ProofGammaDto":280,"./ProofScalarDto":281,"./ProofVerificationHashDto":282}],308:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));
},{"./cipher-core":309,"./core":310,"./enc-base64":311,"./evpkdf":313,"./md5":318}],309:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./evpkdf"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./evpkdf"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));
},{"./core":310,"./evpkdf":313}],310:[function(require,module,exports){
(function (global){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && typeof require === 'function') {
	        try {
	            crypto = require('crypto');
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"crypto":55}],311:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));
},{"./core":310}],312:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));
},{"./core":310}],313:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));
},{"./core":310,"./hmac":315,"./sha1":334}],314:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));
},{"./cipher-core":309,"./core":310}],315:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));
},{"./core":310}],316:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"), require("./lib-typedarrays"), require("./enc-utf16"), require("./enc-base64"), require("./md5"), require("./sha1"), require("./sha256"), require("./sha224"), require("./sha512"), require("./sha384"), require("./sha3"), require("./ripemd160"), require("./hmac"), require("./pbkdf2"), require("./evpkdf"), require("./cipher-core"), require("./mode-cfb"), require("./mode-ctr"), require("./mode-ctr-gladman"), require("./mode-ofb"), require("./mode-ecb"), require("./pad-ansix923"), require("./pad-iso10126"), require("./pad-iso97971"), require("./pad-zeropadding"), require("./pad-nopadding"), require("./format-hex"), require("./aes"), require("./tripledes"), require("./rc4"), require("./rabbit"), require("./rabbit-legacy"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS;

}));
},{"./aes":308,"./cipher-core":309,"./core":310,"./enc-base64":311,"./enc-utf16":312,"./evpkdf":313,"./format-hex":314,"./hmac":315,"./lib-typedarrays":317,"./md5":318,"./mode-cfb":319,"./mode-ctr":321,"./mode-ctr-gladman":320,"./mode-ecb":322,"./mode-ofb":323,"./pad-ansix923":324,"./pad-iso10126":325,"./pad-iso97971":326,"./pad-nopadding":327,"./pad-zeropadding":328,"./pbkdf2":329,"./rabbit":331,"./rabbit-legacy":330,"./rc4":332,"./ripemd160":333,"./sha1":334,"./sha224":335,"./sha256":336,"./sha3":337,"./sha384":338,"./sha512":339,"./tripledes":340,"./x64-core":341}],317:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));
},{"./core":310}],318:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));
},{"./core":310}],319:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher Feedback block mode.
	 */
	CryptoJS.mode.CFB = (function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();

	    CFB.Encryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // Remember this block to use with next block
	            this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	    });

	    CFB.Decryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            // Remember this block to use with next block
	            var thisBlock = words.slice(offset, offset + blockSize);

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // This block becomes the previous block
	            this._prevBlock = thisBlock;
	        }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	        var keystream;

	        // Shortcut
	        var iv = this._iv;

	        // Generate keystream
	        if (iv) {
	            keystream = iv.slice(0);

	            // Remove IV for subsequent blocks
	            this._iv = undefined;
	        } else {
	            keystream = this._prevBlock;
	        }
	        cipher.encryptBlock(keystream, 0);

	        // Encrypt
	        for (var i = 0; i < blockSize; i++) {
	            words[offset + i] ^= keystream[i];
	        }
	    }

	    return CFB;
	}());


	return CryptoJS.mode.CFB;

}));
},{"./cipher-core":309,"./core":310}],320:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
	CryptoJS.mode.CTRGladman = (function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word)
		{
			if (((word >> 24) & 0xff) === 0xff) { //overflow
			var b1 = (word >> 16)&0xff;
			var b2 = (word >> 8)&0xff;
			var b3 = word & 0xff;

			if (b1 === 0xff) // overflow b1
			{
			b1 = 0;
			if (b2 === 0xff)
			{
				b2 = 0;
				if (b3 === 0xff)
				{
					b3 = 0;
				}
				else
				{
					++b3;
				}
			}
			else
			{
				++b2;
			}
			}
			else
			{
			++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
			}
			else
			{
			word += (0x01 << 24);
			}
			return word;
		}

		function incCounter(counter)
		{
			if ((counter[0] = incWord(counter[0])) === 0)
			{
				// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
				counter[1] = incWord(counter[1]);
			}
			return counter;
		}

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }

				incCounter(counter);

				var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTRGladman.Decryptor = Encryptor;

	    return CTRGladman;
	}());




	return CryptoJS.mode.CTRGladman;

}));
},{"./cipher-core":309,"./core":310}],321:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Counter block mode.
	 */
	CryptoJS.mode.CTR = (function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = CTR.Encryptor = CTR.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Increment counter
	            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTR.Decryptor = Encryptor;

	    return CTR;
	}());


	return CryptoJS.mode.CTR;

}));
},{"./cipher-core":309,"./core":310}],322:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Electronic Codebook block mode.
	 */
	CryptoJS.mode.ECB = (function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();

	    ECB.Encryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.encryptBlock(words, offset);
	        }
	    });

	    ECB.Decryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.decryptBlock(words, offset);
	        }
	    });

	    return ECB;
	}());


	return CryptoJS.mode.ECB;

}));
},{"./cipher-core":309,"./core":310}],323:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Output Feedback block mode.
	 */
	CryptoJS.mode.OFB = (function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = OFB.Encryptor = OFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var keystream = this._keystream;

	            // Generate keystream
	            if (iv) {
	                keystream = this._keystream = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    OFB.Decryptor = Encryptor;

	    return OFB;
	}());


	return CryptoJS.mode.OFB;

}));
},{"./cipher-core":309,"./core":310}],324:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ANSI X.923 padding strategy.
	 */
	CryptoJS.pad.AnsiX923 = {
	    pad: function (data, blockSize) {
	        // Shortcuts
	        var dataSigBytes = data.sigBytes;
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

	        // Compute last byte position
	        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

	        // Pad
	        data.clamp();
	        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
	        data.sigBytes += nPaddingBytes;
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Ansix923;

}));
},{"./cipher-core":309,"./core":310}],325:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO 10126 padding strategy.
	 */
	CryptoJS.pad.Iso10126 = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	        // Pad
	        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
	             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Iso10126;

}));
},{"./cipher-core":309,"./core":310}],326:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
	CryptoJS.pad.Iso97971 = {
	    pad: function (data, blockSize) {
	        // Add 0x80 byte
	        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

	        // Zero pad the rest
	        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },

	    unpad: function (data) {
	        // Remove zero padding
	        CryptoJS.pad.ZeroPadding.unpad(data);

	        // Remove one more byte -- the 0x80 byte
	        data.sigBytes--;
	    }
	};


	return CryptoJS.pad.Iso97971;

}));
},{"./cipher-core":309,"./core":310}],327:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * A noop padding strategy.
	 */
	CryptoJS.pad.NoPadding = {
	    pad: function () {
	    },

	    unpad: function () {
	    }
	};


	return CryptoJS.pad.NoPadding;

}));
},{"./cipher-core":309,"./core":310}],328:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Zero padding strategy.
	 */
	CryptoJS.pad.ZeroPadding = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Pad
	        data.clamp();
	        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
	    },

	    unpad: function (data) {
	        // Shortcut
	        var dataWords = data.words;

	        // Unpad
	        var i = data.sigBytes - 1;
	        for (var i = data.sigBytes - 1; i >= 0; i--) {
	            if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
	                data.sigBytes = i + 1;
	                break;
	            }
	        }
	    }
	};


	return CryptoJS.pad.ZeroPadding;

}));
},{"./cipher-core":309,"./core":310}],329:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA1 = C_algo.SHA1;
	    var HMAC = C_algo.HMAC;

	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */
	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA1
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: SHA1,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init HMAC
	            var hmac = HMAC.create(cfg.hasher, password);

	            // Initial values
	            var derivedKey = WordArray.create();
	            var blockIndex = WordArray.create([0x00000001]);

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var blockIndexWords = blockIndex.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                var block = hmac.update(salt).finalize(blockIndex);
	                hmac.reset();

	                // Shortcuts
	                var blockWords = block.words;
	                var blockWordsLength = blockWords.length;

	                // Iterations
	                var intermediate = block;
	                for (var i = 1; i < iterations; i++) {
	                    intermediate = hmac.finalize(intermediate);
	                    hmac.reset();

	                    // Shortcut
	                    var intermediateWords = intermediate.words;

	                    // XOR intermediate with block
	                    for (var j = 0; j < blockWordsLength; j++) {
	                        blockWords[j] ^= intermediateWords[j];
	                    }
	                }

	                derivedKey.concat(block);
	                blockIndexWords[0]++;
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.PBKDF2 = function (password, salt, cfg) {
	        return PBKDF2.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.PBKDF2;

}));
},{"./core":310,"./hmac":315,"./sha1":334}],330:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */
	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */
	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());


	return CryptoJS.RabbitLegacy;

}));
},{"./cipher-core":309,"./core":310,"./enc-base64":311,"./evpkdf":313,"./md5":318}],331:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm
	     */
	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
	                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
	            }

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */
	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());


	return CryptoJS.Rabbit;

}));
},{"./cipher-core":309,"./core":310,"./enc-base64":311,"./evpkdf":313,"./md5":318}],332:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    /**
	     * RC4 stream cipher algorithm.
	     */
	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySigBytes = key.sigBytes;

	            // Init sbox
	            var S = this._S = [];
	            for (var i = 0; i < 256; i++) {
	                S[i] = i;
	            }

	            // Key setup
	            for (var i = 0, j = 0; i < 256; i++) {
	                var keyByteIndex = i % keySigBytes;
	                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

	                j = (j + S[i] + keyByte) % 256;

	                // Swap
	                var t = S[i];
	                S[i] = S[j];
	                S[j] = t;
	            }

	            // Counters
	            this._i = this._j = 0;
	        },

	        _doProcessBlock: function (M, offset) {
	            M[offset] ^= generateKeystreamWord.call(this);
	        },

	        keySize: 256/32,

	        ivSize: 0
	    });

	    function generateKeystreamWord() {
	        // Shortcuts
	        var S = this._S;
	        var i = this._i;
	        var j = this._j;

	        // Generate keystream word
	        var keystreamWord = 0;
	        for (var n = 0; n < 4; n++) {
	            i = (i + 1) % 256;
	            j = (j + S[i]) % 256;

	            // Swap
	            var t = S[i];
	            S[i] = S[j];
	            S[j] = t;

	            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
	        }

	        // Update counters
	        this._i = i;
	        this._j = j;

	        return keystreamWord;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4 = StreamCipher._createHelper(RC4);

	    /**
	     * Modified RC4 stream cipher algorithm.
	     */
	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
	        cfg: RC4.cfg.extend({
	            drop: 192
	        }),

	        _doReset: function () {
	            RC4._doReset.call(this);

	            // Drop
	            for (var i = this.cfg.drop; i > 0; i--) {
	                generateKeystreamWord.call(this);
	            }
	        }
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());


	return CryptoJS.RC4;

}));
},{"./cipher-core":309,"./core":310,"./enc-base64":311,"./evpkdf":313,"./md5":318}],333:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var _zl = WordArray.create([
	        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
	    var _zr = WordArray.create([
	        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
	    var _sl = WordArray.create([
	         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
	    var _sr = WordArray.create([
	        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

	    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
	    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

	    /**
	     * RIPEMD160 hash algorithm.
	     */
	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	        _doReset: function () {
	            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	        },

	        _doProcessBlock: function (M, offset) {

	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                // Swap
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	            // Shortcut
	            var H  = this._hash.words;
	            var hl = _hl.words;
	            var hr = _hr.words;
	            var zl = _zl.words;
	            var zr = _zr.words;
	            var sl = _sl.words;
	            var sr = _sr.words;

	            // Working variables
	            var al, bl, cl, dl, el;
	            var ar, br, cr, dr, er;

	            ar = al = H[0];
	            br = bl = H[1];
	            cr = cl = H[2];
	            dr = dl = H[3];
	            er = el = H[4];
	            // Computation
	            var t;
	            for (var i = 0; i < 80; i += 1) {
	                t = (al +  M[offset+zl[i]])|0;
	                if (i<16){
		            t +=  f1(bl,cl,dl) + hl[0];
	                } else if (i<32) {
		            t +=  f2(bl,cl,dl) + hl[1];
	                } else if (i<48) {
		            t +=  f3(bl,cl,dl) + hl[2];
	                } else if (i<64) {
		            t +=  f4(bl,cl,dl) + hl[3];
	                } else {// if (i<80) {
		            t +=  f5(bl,cl,dl) + hl[4];
	                }
	                t = t|0;
	                t =  rotl(t,sl[i]);
	                t = (t+el)|0;
	                al = el;
	                el = dl;
	                dl = rotl(cl, 10);
	                cl = bl;
	                bl = t;

	                t = (ar + M[offset+zr[i]])|0;
	                if (i<16){
		            t +=  f5(br,cr,dr) + hr[0];
	                } else if (i<32) {
		            t +=  f4(br,cr,dr) + hr[1];
	                } else if (i<48) {
		            t +=  f3(br,cr,dr) + hr[2];
	                } else if (i<64) {
		            t +=  f2(br,cr,dr) + hr[3];
	                } else {// if (i<80) {
		            t +=  f1(br,cr,dr) + hr[4];
	                }
	                t = t|0;
	                t =  rotl(t,sr[i]) ;
	                t = (t+er)|0;
	                ar = er;
	                er = dr;
	                dr = rotl(cr, 10);
	                cr = br;
	                br = t;
	            }
	            // Intermediate hash value
	            t    = (H[1] + cl + dr)|0;
	            H[1] = (H[2] + dl + er)|0;
	            H[2] = (H[3] + el + ar)|0;
	            H[3] = (H[4] + al + br)|0;
	            H[4] = (H[0] + bl + cr)|0;
	            H[0] =  t;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	            );
	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 5; i++) {
	                // Shortcut
	                var H_i = H[i];

	                // Swap
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });


	    function f1(x, y, z) {
	        return ((x) ^ (y) ^ (z));

	    }

	    function f2(x, y, z) {
	        return (((x)&(y)) | ((~x)&(z)));
	    }

	    function f3(x, y, z) {
	        return (((x) | (~(y))) ^ (z));
	    }

	    function f4(x, y, z) {
	        return (((x) & (z)) | ((y)&(~(z))));
	    }

	    function f5(x, y, z) {
	        return ((x) ^ ((y) |(~(z))));

	    }

	    function rotl(x,n) {
	        return (x<<n) | (x>>>(32-n));
	    }


	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */
	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));


	return CryptoJS.RIPEMD160;

}));
},{"./core":310}],334:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));
},{"./core":310}],335:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha256"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha256"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;

	    /**
	     * SHA-224 hash algorithm.
	     */
	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA256._doFinalize.call(this);

	            hash.sigBytes -= 4;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
	    C.SHA224 = SHA256._createHelper(SHA224);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());


	return CryptoJS.SHA224;

}));
},{"./core":310,"./sha256":336}],336:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));
},{"./core":310}],337:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo;

	    // Constants tables
	    var RHO_OFFSETS = [];
	    var PI_INDEXES  = [];
	    var ROUND_CONSTANTS = [];

	    // Compute Constants
	    (function () {
	        // Compute rho offset constants
	        var x = 1, y = 0;
	        for (var t = 0; t < 24; t++) {
	            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

	            var newX = y % 5;
	            var newY = (2 * x + 3 * y) % 5;
	            x = newX;
	            y = newY;
	        }

	        // Compute pi index constants
	        for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
	            }
	        }

	        // Compute round constants
	        var LFSR = 0x01;
	        for (var i = 0; i < 24; i++) {
	            var roundConstantMsw = 0;
	            var roundConstantLsw = 0;

	            for (var j = 0; j < 7; j++) {
	                if (LFSR & 0x01) {
	                    var bitPosition = (1 << j) - 1;
	                    if (bitPosition < 32) {
	                        roundConstantLsw ^= 1 << bitPosition;
	                    } else /* if (bitPosition >= 32) */ {
	                        roundConstantMsw ^= 1 << (bitPosition - 32);
	                    }
	                }

	                // Compute next LFSR
	                if (LFSR & 0x80) {
	                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	                    LFSR = (LFSR << 1) ^ 0x71;
	                } else {
	                    LFSR <<= 1;
	                }
	            }

	            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	        }
	    }());

	    // Reusable objects for temporary values
	    var T = [];
	    (function () {
	        for (var i = 0; i < 25; i++) {
	            T[i] = X64Word.create();
	        }
	    }());

	    /**
	     * SHA-3 hash algorithm.
	     */
	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
	        cfg: Hasher.cfg.extend({
	            outputLength: 512
	        }),

	        _doReset: function () {
	            var state = this._state = []
	            for (var i = 0; i < 25; i++) {
	                state[i] = new X64Word.init();
	            }

	            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var state = this._state;
	            var nBlockSizeLanes = this.blockSize / 2;

	            // Absorb
	            for (var i = 0; i < nBlockSizeLanes; i++) {
	                // Shortcuts
	                var M2i  = M[offset + 2 * i];
	                var M2i1 = M[offset + 2 * i + 1];

	                // Swap endian
	                M2i = (
	                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
	                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
	                );
	                M2i1 = (
	                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
	                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
	                );

	                // Absorb message into state
	                var lane = state[i];
	                lane.high ^= M2i1;
	                lane.low  ^= M2i;
	            }

	            // Rounds
	            for (var round = 0; round < 24; round++) {
	                // Theta
	                for (var x = 0; x < 5; x++) {
	                    // Mix column lanes
	                    var tMsw = 0, tLsw = 0;
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        tMsw ^= lane.high;
	                        tLsw ^= lane.low;
	                    }

	                    // Temporary values
	                    var Tx = T[x];
	                    Tx.high = tMsw;
	                    Tx.low  = tLsw;
	                }
	                for (var x = 0; x < 5; x++) {
	                    // Shortcuts
	                    var Tx4 = T[(x + 4) % 5];
	                    var Tx1 = T[(x + 1) % 5];
	                    var Tx1Msw = Tx1.high;
	                    var Tx1Lsw = Tx1.low;

	                    // Mix surrounding columns
	                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
	                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        lane.high ^= tMsw;
	                        lane.low  ^= tLsw;
	                    }
	                }

	                // Rho Pi
	                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	                    var tMsw;
	                    var tLsw;

	                    // Shortcuts
	                    var lane = state[laneIndex];
	                    var laneMsw = lane.high;
	                    var laneLsw = lane.low;
	                    var rhoOffset = RHO_OFFSETS[laneIndex];

	                    // Rotate lanes
	                    if (rhoOffset < 32) {
	                        tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
	                        tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
	                    } else /* if (rhoOffset >= 32) */ {
	                        tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
	                        tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
	                    }

	                    // Transpose lanes
	                    var TPiLane = T[PI_INDEXES[laneIndex]];
	                    TPiLane.high = tMsw;
	                    TPiLane.low  = tLsw;
	                }

	                // Rho pi at x = y = 0
	                var T0 = T[0];
	                var state0 = state[0];
	                T0.high = state0.high;
	                T0.low  = state0.low;

	                // Chi
	                for (var x = 0; x < 5; x++) {
	                    for (var y = 0; y < 5; y++) {
	                        // Shortcuts
	                        var laneIndex = x + 5 * y;
	                        var lane = state[laneIndex];
	                        var TLane = T[laneIndex];
	                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
	                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

	                        // Mix rows
	                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
	                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
	                    }
	                }

	                // Iota
	                var lane = state[0];
	                var roundConstant = ROUND_CONSTANTS[round];
	                lane.high ^= roundConstant.high;
	                lane.low  ^= roundConstant.low;
	            }
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	            var blockSizeBits = this.blockSize * 32;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
	            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var state = this._state;
	            var outputLengthBytes = this.cfg.outputLength / 8;
	            var outputLengthLanes = outputLengthBytes / 8;

	            // Squeeze
	            var hashWords = [];
	            for (var i = 0; i < outputLengthLanes; i++) {
	                // Shortcuts
	                var lane = state[i];
	                var laneMsw = lane.high;
	                var laneLsw = lane.low;

	                // Swap endian
	                laneMsw = (
	                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
	                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
	                );
	                laneLsw = (
	                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
	                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
	                );

	                // Squeeze state to retrieve hash
	                hashWords.push(laneLsw);
	                hashWords.push(laneMsw);
	            }

	            // Return final computed hash
	            return new WordArray.init(hashWords, outputLengthBytes);
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);

	            var state = clone._state = this._state.slice(0);
	            for (var i = 0; i < 25; i++) {
	                state[i] = state[i].clone();
	            }

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
	    C.SHA3 = Hasher._createHelper(SHA3);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));


	return CryptoJS.SHA3;

}));
},{"./core":310,"./x64-core":341}],338:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"), require("./sha512"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./sha512"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;

	    /**
	     * SHA-384 hash algorithm.
	     */
	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
	                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
	                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
	                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA512._doFinalize.call(this);

	            hash.sigBytes -= 16;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
	    C.SHA384 = SHA512._createHelper(SHA384);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());


	return CryptoJS.SHA384;

}));
},{"./core":310,"./sha512":339,"./x64-core":341}],339:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	        return X64Word.create.apply(X64Word, arguments);
	    }

	    // Constants
	    var K = [
	        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
	        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
	        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
	        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
	        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
	        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
	        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
	        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
	        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
	        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
	        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
	        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
	        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
	        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
	        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
	        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
	        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
	        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
	        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
	        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
	        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
	        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
	        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
	        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
	        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
	        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
	        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
	        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
	        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
	        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
	        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
	        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
	        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
	        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
	        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
	        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
	        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
	        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
	        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
	        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
	    ];

	    // Reusable objects
	    var W = [];
	    (function () {
	        for (var i = 0; i < 80; i++) {
	            W[i] = X64Word_create();
	        }
	    }());

	    /**
	     * SHA-512 hash algorithm.
	     */
	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
	                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
	                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
	                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var H = this._hash.words;

	            var H0 = H[0];
	            var H1 = H[1];
	            var H2 = H[2];
	            var H3 = H[3];
	            var H4 = H[4];
	            var H5 = H[5];
	            var H6 = H[6];
	            var H7 = H[7];

	            var H0h = H0.high;
	            var H0l = H0.low;
	            var H1h = H1.high;
	            var H1l = H1.low;
	            var H2h = H2.high;
	            var H2l = H2.low;
	            var H3h = H3.high;
	            var H3l = H3.low;
	            var H4h = H4.high;
	            var H4l = H4.low;
	            var H5h = H5.high;
	            var H5l = H5.low;
	            var H6h = H6.high;
	            var H6l = H6.low;
	            var H7h = H7.high;
	            var H7l = H7.low;

	            // Working variables
	            var ah = H0h;
	            var al = H0l;
	            var bh = H1h;
	            var bl = H1l;
	            var ch = H2h;
	            var cl = H2l;
	            var dh = H3h;
	            var dl = H3l;
	            var eh = H4h;
	            var el = H4l;
	            var fh = H5h;
	            var fl = H5l;
	            var gh = H6h;
	            var gl = H6l;
	            var hh = H7h;
	            var hl = H7l;

	            // Rounds
	            for (var i = 0; i < 80; i++) {
	                var Wil;
	                var Wih;

	                // Shortcut
	                var Wi = W[i];

	                // Extend message
	                if (i < 16) {
	                    Wih = Wi.high = M[offset + i * 2]     | 0;
	                    Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	                } else {
	                    // Gamma0
	                    var gamma0x  = W[i - 15];
	                    var gamma0xh = gamma0x.high;
	                    var gamma0xl = gamma0x.low;
	                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	                    // Gamma1
	                    var gamma1x  = W[i - 2];
	                    var gamma1xh = gamma1x.high;
	                    var gamma1xl = gamma1x.low;
	                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	                    var Wi7  = W[i - 7];
	                    var Wi7h = Wi7.high;
	                    var Wi7l = Wi7.low;

	                    var Wi16  = W[i - 16];
	                    var Wi16h = Wi16.high;
	                    var Wi16l = Wi16.low;

	                    Wil = gamma0l + Wi7l;
	                    Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	                    Wil = Wil + gamma1l;
	                    Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	                    Wil = Wil + Wi16l;
	                    Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	                    Wi.high = Wih;
	                    Wi.low  = Wil;
	                }

	                var chh  = (eh & fh) ^ (~eh & gh);
	                var chl  = (el & fl) ^ (~el & gl);
	                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	                // t1 = h + sigma1 + ch + K[i] + W[i]
	                var Ki  = K[i];
	                var Kih = Ki.high;
	                var Kil = Ki.low;

	                var t1l = hl + sigma1l;
	                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	                var t1l = t1l + chl;
	                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	                var t1l = t1l + Kil;
	                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	                var t1l = t1l + Wil;
	                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	                // t2 = sigma0 + maj
	                var t2l = sigma0l + majl;
	                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	                // Update working variables
	                hh = gh;
	                hl = gl;
	                gh = fh;
	                gl = fl;
	                fh = eh;
	                fl = el;
	                el = (dl + t1l) | 0;
	                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	                dh = ch;
	                dl = cl;
	                ch = bh;
	                cl = bl;
	                bh = ah;
	                bl = al;
	                al = (t1l + t2l) | 0;
	                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	            }

	            // Intermediate hash value
	            H0l = H0.low  = (H0l + al);
	            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	            H1l = H1.low  = (H1l + bl);
	            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	            H2l = H2.low  = (H2l + cl);
	            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	            H3l = H3.low  = (H3l + dl);
	            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	            H4l = H4.low  = (H4l + el);
	            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	            H5l = H5.low  = (H5l + fl);
	            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	            H6l = H6.low  = (H6l + gl);
	            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	            H7l = H7.low  = (H7l + hl);
	            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Convert hash to 32-bit word array before returning
	            var hash = this._hash.toX32();

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        },

	        blockSize: 1024/32
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
	    C.SHA512 = Hasher._createHelper(SHA512);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());


	return CryptoJS.SHA512;

}));
},{"./core":310,"./x64-core":341}],340:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Permuted Choice 1 constants
	    var PC1 = [
	        57, 49, 41, 33, 25, 17, 9,  1,
	        58, 50, 42, 34, 26, 18, 10, 2,
	        59, 51, 43, 35, 27, 19, 11, 3,
	        60, 52, 44, 36, 63, 55, 47, 39,
	        31, 23, 15, 7,  62, 54, 46, 38,
	        30, 22, 14, 6,  61, 53, 45, 37,
	        29, 21, 13, 5,  28, 20, 12, 4
	    ];

	    // Permuted Choice 2 constants
	    var PC2 = [
	        14, 17, 11, 24, 1,  5,
	        3,  28, 15, 6,  21, 10,
	        23, 19, 12, 4,  26, 8,
	        16, 7,  27, 20, 13, 2,
	        41, 52, 31, 37, 47, 55,
	        30, 40, 51, 45, 33, 48,
	        44, 49, 39, 56, 34, 53,
	        46, 42, 50, 36, 29, 32
	    ];

	    // Cumulative bit shift constants
	    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

	    // SBOXes and round permutation constants
	    var SBOX_P = [
	        {
	            0x0: 0x808200,
	            0x10000000: 0x8000,
	            0x20000000: 0x808002,
	            0x30000000: 0x2,
	            0x40000000: 0x200,
	            0x50000000: 0x808202,
	            0x60000000: 0x800202,
	            0x70000000: 0x800000,
	            0x80000000: 0x202,
	            0x90000000: 0x800200,
	            0xa0000000: 0x8200,
	            0xb0000000: 0x808000,
	            0xc0000000: 0x8002,
	            0xd0000000: 0x800002,
	            0xe0000000: 0x0,
	            0xf0000000: 0x8202,
	            0x8000000: 0x0,
	            0x18000000: 0x808202,
	            0x28000000: 0x8202,
	            0x38000000: 0x8000,
	            0x48000000: 0x808200,
	            0x58000000: 0x200,
	            0x68000000: 0x808002,
	            0x78000000: 0x2,
	            0x88000000: 0x800200,
	            0x98000000: 0x8200,
	            0xa8000000: 0x808000,
	            0xb8000000: 0x800202,
	            0xc8000000: 0x800002,
	            0xd8000000: 0x8002,
	            0xe8000000: 0x202,
	            0xf8000000: 0x800000,
	            0x1: 0x8000,
	            0x10000001: 0x2,
	            0x20000001: 0x808200,
	            0x30000001: 0x800000,
	            0x40000001: 0x808002,
	            0x50000001: 0x8200,
	            0x60000001: 0x200,
	            0x70000001: 0x800202,
	            0x80000001: 0x808202,
	            0x90000001: 0x808000,
	            0xa0000001: 0x800002,
	            0xb0000001: 0x8202,
	            0xc0000001: 0x202,
	            0xd0000001: 0x800200,
	            0xe0000001: 0x8002,
	            0xf0000001: 0x0,
	            0x8000001: 0x808202,
	            0x18000001: 0x808000,
	            0x28000001: 0x800000,
	            0x38000001: 0x200,
	            0x48000001: 0x8000,
	            0x58000001: 0x800002,
	            0x68000001: 0x2,
	            0x78000001: 0x8202,
	            0x88000001: 0x8002,
	            0x98000001: 0x800202,
	            0xa8000001: 0x202,
	            0xb8000001: 0x808200,
	            0xc8000001: 0x800200,
	            0xd8000001: 0x0,
	            0xe8000001: 0x8200,
	            0xf8000001: 0x808002
	        },
	        {
	            0x0: 0x40084010,
	            0x1000000: 0x4000,
	            0x2000000: 0x80000,
	            0x3000000: 0x40080010,
	            0x4000000: 0x40000010,
	            0x5000000: 0x40084000,
	            0x6000000: 0x40004000,
	            0x7000000: 0x10,
	            0x8000000: 0x84000,
	            0x9000000: 0x40004010,
	            0xa000000: 0x40000000,
	            0xb000000: 0x84010,
	            0xc000000: 0x80010,
	            0xd000000: 0x0,
	            0xe000000: 0x4010,
	            0xf000000: 0x40080000,
	            0x800000: 0x40004000,
	            0x1800000: 0x84010,
	            0x2800000: 0x10,
	            0x3800000: 0x40004010,
	            0x4800000: 0x40084010,
	            0x5800000: 0x40000000,
	            0x6800000: 0x80000,
	            0x7800000: 0x40080010,
	            0x8800000: 0x80010,
	            0x9800000: 0x0,
	            0xa800000: 0x4000,
	            0xb800000: 0x40080000,
	            0xc800000: 0x40000010,
	            0xd800000: 0x84000,
	            0xe800000: 0x40084000,
	            0xf800000: 0x4010,
	            0x10000000: 0x0,
	            0x11000000: 0x40080010,
	            0x12000000: 0x40004010,
	            0x13000000: 0x40084000,
	            0x14000000: 0x40080000,
	            0x15000000: 0x10,
	            0x16000000: 0x84010,
	            0x17000000: 0x4000,
	            0x18000000: 0x4010,
	            0x19000000: 0x80000,
	            0x1a000000: 0x80010,
	            0x1b000000: 0x40000010,
	            0x1c000000: 0x84000,
	            0x1d000000: 0x40004000,
	            0x1e000000: 0x40000000,
	            0x1f000000: 0x40084010,
	            0x10800000: 0x84010,
	            0x11800000: 0x80000,
	            0x12800000: 0x40080000,
	            0x13800000: 0x4000,
	            0x14800000: 0x40004000,
	            0x15800000: 0x40084010,
	            0x16800000: 0x10,
	            0x17800000: 0x40000000,
	            0x18800000: 0x40084000,
	            0x19800000: 0x40000010,
	            0x1a800000: 0x40004010,
	            0x1b800000: 0x80010,
	            0x1c800000: 0x0,
	            0x1d800000: 0x4010,
	            0x1e800000: 0x40080010,
	            0x1f800000: 0x84000
	        },
	        {
	            0x0: 0x104,
	            0x100000: 0x0,
	            0x200000: 0x4000100,
	            0x300000: 0x10104,
	            0x400000: 0x10004,
	            0x500000: 0x4000004,
	            0x600000: 0x4010104,
	            0x700000: 0x4010000,
	            0x800000: 0x4000000,
	            0x900000: 0x4010100,
	            0xa00000: 0x10100,
	            0xb00000: 0x4010004,
	            0xc00000: 0x4000104,
	            0xd00000: 0x10000,
	            0xe00000: 0x4,
	            0xf00000: 0x100,
	            0x80000: 0x4010100,
	            0x180000: 0x4010004,
	            0x280000: 0x0,
	            0x380000: 0x4000100,
	            0x480000: 0x4000004,
	            0x580000: 0x10000,
	            0x680000: 0x10004,
	            0x780000: 0x104,
	            0x880000: 0x4,
	            0x980000: 0x100,
	            0xa80000: 0x4010000,
	            0xb80000: 0x10104,
	            0xc80000: 0x10100,
	            0xd80000: 0x4000104,
	            0xe80000: 0x4010104,
	            0xf80000: 0x4000000,
	            0x1000000: 0x4010100,
	            0x1100000: 0x10004,
	            0x1200000: 0x10000,
	            0x1300000: 0x4000100,
	            0x1400000: 0x100,
	            0x1500000: 0x4010104,
	            0x1600000: 0x4000004,
	            0x1700000: 0x0,
	            0x1800000: 0x4000104,
	            0x1900000: 0x4000000,
	            0x1a00000: 0x4,
	            0x1b00000: 0x10100,
	            0x1c00000: 0x4010000,
	            0x1d00000: 0x104,
	            0x1e00000: 0x10104,
	            0x1f00000: 0x4010004,
	            0x1080000: 0x4000000,
	            0x1180000: 0x104,
	            0x1280000: 0x4010100,
	            0x1380000: 0x0,
	            0x1480000: 0x10004,
	            0x1580000: 0x4000100,
	            0x1680000: 0x100,
	            0x1780000: 0x4010004,
	            0x1880000: 0x10000,
	            0x1980000: 0x4010104,
	            0x1a80000: 0x10104,
	            0x1b80000: 0x4000004,
	            0x1c80000: 0x4000104,
	            0x1d80000: 0x4010000,
	            0x1e80000: 0x4,
	            0x1f80000: 0x10100
	        },
	        {
	            0x0: 0x80401000,
	            0x10000: 0x80001040,
	            0x20000: 0x401040,
	            0x30000: 0x80400000,
	            0x40000: 0x0,
	            0x50000: 0x401000,
	            0x60000: 0x80000040,
	            0x70000: 0x400040,
	            0x80000: 0x80000000,
	            0x90000: 0x400000,
	            0xa0000: 0x40,
	            0xb0000: 0x80001000,
	            0xc0000: 0x80400040,
	            0xd0000: 0x1040,
	            0xe0000: 0x1000,
	            0xf0000: 0x80401040,
	            0x8000: 0x80001040,
	            0x18000: 0x40,
	            0x28000: 0x80400040,
	            0x38000: 0x80001000,
	            0x48000: 0x401000,
	            0x58000: 0x80401040,
	            0x68000: 0x0,
	            0x78000: 0x80400000,
	            0x88000: 0x1000,
	            0x98000: 0x80401000,
	            0xa8000: 0x400000,
	            0xb8000: 0x1040,
	            0xc8000: 0x80000000,
	            0xd8000: 0x400040,
	            0xe8000: 0x401040,
	            0xf8000: 0x80000040,
	            0x100000: 0x400040,
	            0x110000: 0x401000,
	            0x120000: 0x80000040,
	            0x130000: 0x0,
	            0x140000: 0x1040,
	            0x150000: 0x80400040,
	            0x160000: 0x80401000,
	            0x170000: 0x80001040,
	            0x180000: 0x80401040,
	            0x190000: 0x80000000,
	            0x1a0000: 0x80400000,
	            0x1b0000: 0x401040,
	            0x1c0000: 0x80001000,
	            0x1d0000: 0x400000,
	            0x1e0000: 0x40,
	            0x1f0000: 0x1000,
	            0x108000: 0x80400000,
	            0x118000: 0x80401040,
	            0x128000: 0x0,
	            0x138000: 0x401000,
	            0x148000: 0x400040,
	            0x158000: 0x80000000,
	            0x168000: 0x80001040,
	            0x178000: 0x40,
	            0x188000: 0x80000040,
	            0x198000: 0x1000,
	            0x1a8000: 0x80001000,
	            0x1b8000: 0x80400040,
	            0x1c8000: 0x1040,
	            0x1d8000: 0x80401000,
	            0x1e8000: 0x400000,
	            0x1f8000: 0x401040
	        },
	        {
	            0x0: 0x80,
	            0x1000: 0x1040000,
	            0x2000: 0x40000,
	            0x3000: 0x20000000,
	            0x4000: 0x20040080,
	            0x5000: 0x1000080,
	            0x6000: 0x21000080,
	            0x7000: 0x40080,
	            0x8000: 0x1000000,
	            0x9000: 0x20040000,
	            0xa000: 0x20000080,
	            0xb000: 0x21040080,
	            0xc000: 0x21040000,
	            0xd000: 0x0,
	            0xe000: 0x1040080,
	            0xf000: 0x21000000,
	            0x800: 0x1040080,
	            0x1800: 0x21000080,
	            0x2800: 0x80,
	            0x3800: 0x1040000,
	            0x4800: 0x40000,
	            0x5800: 0x20040080,
	            0x6800: 0x21040000,
	            0x7800: 0x20000000,
	            0x8800: 0x20040000,
	            0x9800: 0x0,
	            0xa800: 0x21040080,
	            0xb800: 0x1000080,
	            0xc800: 0x20000080,
	            0xd800: 0x21000000,
	            0xe800: 0x1000000,
	            0xf800: 0x40080,
	            0x10000: 0x40000,
	            0x11000: 0x80,
	            0x12000: 0x20000000,
	            0x13000: 0x21000080,
	            0x14000: 0x1000080,
	            0x15000: 0x21040000,
	            0x16000: 0x20040080,
	            0x17000: 0x1000000,
	            0x18000: 0x21040080,
	            0x19000: 0x21000000,
	            0x1a000: 0x1040000,
	            0x1b000: 0x20040000,
	            0x1c000: 0x40080,
	            0x1d000: 0x20000080,
	            0x1e000: 0x0,
	            0x1f000: 0x1040080,
	            0x10800: 0x21000080,
	            0x11800: 0x1000000,
	            0x12800: 0x1040000,
	            0x13800: 0x20040080,
	            0x14800: 0x20000000,
	            0x15800: 0x1040080,
	            0x16800: 0x80,
	            0x17800: 0x21040000,
	            0x18800: 0x40080,
	            0x19800: 0x21040080,
	            0x1a800: 0x0,
	            0x1b800: 0x21000000,
	            0x1c800: 0x1000080,
	            0x1d800: 0x40000,
	            0x1e800: 0x20040000,
	            0x1f800: 0x20000080
	        },
	        {
	            0x0: 0x10000008,
	            0x100: 0x2000,
	            0x200: 0x10200000,
	            0x300: 0x10202008,
	            0x400: 0x10002000,
	            0x500: 0x200000,
	            0x600: 0x200008,
	            0x700: 0x10000000,
	            0x800: 0x0,
	            0x900: 0x10002008,
	            0xa00: 0x202000,
	            0xb00: 0x8,
	            0xc00: 0x10200008,
	            0xd00: 0x202008,
	            0xe00: 0x2008,
	            0xf00: 0x10202000,
	            0x80: 0x10200000,
	            0x180: 0x10202008,
	            0x280: 0x8,
	            0x380: 0x200000,
	            0x480: 0x202008,
	            0x580: 0x10000008,
	            0x680: 0x10002000,
	            0x780: 0x2008,
	            0x880: 0x200008,
	            0x980: 0x2000,
	            0xa80: 0x10002008,
	            0xb80: 0x10200008,
	            0xc80: 0x0,
	            0xd80: 0x10202000,
	            0xe80: 0x202000,
	            0xf80: 0x10000000,
	            0x1000: 0x10002000,
	            0x1100: 0x10200008,
	            0x1200: 0x10202008,
	            0x1300: 0x2008,
	            0x1400: 0x200000,
	            0x1500: 0x10000000,
	            0x1600: 0x10000008,
	            0x1700: 0x202000,
	            0x1800: 0x202008,
	            0x1900: 0x0,
	            0x1a00: 0x8,
	            0x1b00: 0x10200000,
	            0x1c00: 0x2000,
	            0x1d00: 0x10002008,
	            0x1e00: 0x10202000,
	            0x1f00: 0x200008,
	            0x1080: 0x8,
	            0x1180: 0x202000,
	            0x1280: 0x200000,
	            0x1380: 0x10000008,
	            0x1480: 0x10002000,
	            0x1580: 0x2008,
	            0x1680: 0x10202008,
	            0x1780: 0x10200000,
	            0x1880: 0x10202000,
	            0x1980: 0x10200008,
	            0x1a80: 0x2000,
	            0x1b80: 0x202008,
	            0x1c80: 0x200008,
	            0x1d80: 0x0,
	            0x1e80: 0x10000000,
	            0x1f80: 0x10002008
	        },
	        {
	            0x0: 0x100000,
	            0x10: 0x2000401,
	            0x20: 0x400,
	            0x30: 0x100401,
	            0x40: 0x2100401,
	            0x50: 0x0,
	            0x60: 0x1,
	            0x70: 0x2100001,
	            0x80: 0x2000400,
	            0x90: 0x100001,
	            0xa0: 0x2000001,
	            0xb0: 0x2100400,
	            0xc0: 0x2100000,
	            0xd0: 0x401,
	            0xe0: 0x100400,
	            0xf0: 0x2000000,
	            0x8: 0x2100001,
	            0x18: 0x0,
	            0x28: 0x2000401,
	            0x38: 0x2100400,
	            0x48: 0x100000,
	            0x58: 0x2000001,
	            0x68: 0x2000000,
	            0x78: 0x401,
	            0x88: 0x100401,
	            0x98: 0x2000400,
	            0xa8: 0x2100000,
	            0xb8: 0x100001,
	            0xc8: 0x400,
	            0xd8: 0x2100401,
	            0xe8: 0x1,
	            0xf8: 0x100400,
	            0x100: 0x2000000,
	            0x110: 0x100000,
	            0x120: 0x2000401,
	            0x130: 0x2100001,
	            0x140: 0x100001,
	            0x150: 0x2000400,
	            0x160: 0x2100400,
	            0x170: 0x100401,
	            0x180: 0x401,
	            0x190: 0x2100401,
	            0x1a0: 0x100400,
	            0x1b0: 0x1,
	            0x1c0: 0x0,
	            0x1d0: 0x2100000,
	            0x1e0: 0x2000001,
	            0x1f0: 0x400,
	            0x108: 0x100400,
	            0x118: 0x2000401,
	            0x128: 0x2100001,
	            0x138: 0x1,
	            0x148: 0x2000000,
	            0x158: 0x100000,
	            0x168: 0x401,
	            0x178: 0x2100400,
	            0x188: 0x2000001,
	            0x198: 0x2100000,
	            0x1a8: 0x0,
	            0x1b8: 0x2100401,
	            0x1c8: 0x100401,
	            0x1d8: 0x400,
	            0x1e8: 0x2000400,
	            0x1f8: 0x100001
	        },
	        {
	            0x0: 0x8000820,
	            0x1: 0x20000,
	            0x2: 0x8000000,
	            0x3: 0x20,
	            0x4: 0x20020,
	            0x5: 0x8020820,
	            0x6: 0x8020800,
	            0x7: 0x800,
	            0x8: 0x8020000,
	            0x9: 0x8000800,
	            0xa: 0x20800,
	            0xb: 0x8020020,
	            0xc: 0x820,
	            0xd: 0x0,
	            0xe: 0x8000020,
	            0xf: 0x20820,
	            0x80000000: 0x800,
	            0x80000001: 0x8020820,
	            0x80000002: 0x8000820,
	            0x80000003: 0x8000000,
	            0x80000004: 0x8020000,
	            0x80000005: 0x20800,
	            0x80000006: 0x20820,
	            0x80000007: 0x20,
	            0x80000008: 0x8000020,
	            0x80000009: 0x820,
	            0x8000000a: 0x20020,
	            0x8000000b: 0x8020800,
	            0x8000000c: 0x0,
	            0x8000000d: 0x8020020,
	            0x8000000e: 0x8000800,
	            0x8000000f: 0x20000,
	            0x10: 0x20820,
	            0x11: 0x8020800,
	            0x12: 0x20,
	            0x13: 0x800,
	            0x14: 0x8000800,
	            0x15: 0x8000020,
	            0x16: 0x8020020,
	            0x17: 0x20000,
	            0x18: 0x0,
	            0x19: 0x20020,
	            0x1a: 0x8020000,
	            0x1b: 0x8000820,
	            0x1c: 0x8020820,
	            0x1d: 0x20800,
	            0x1e: 0x820,
	            0x1f: 0x8000000,
	            0x80000010: 0x20000,
	            0x80000011: 0x800,
	            0x80000012: 0x8020020,
	            0x80000013: 0x20820,
	            0x80000014: 0x20,
	            0x80000015: 0x8020000,
	            0x80000016: 0x8000000,
	            0x80000017: 0x8000820,
	            0x80000018: 0x8020820,
	            0x80000019: 0x8000020,
	            0x8000001a: 0x8000800,
	            0x8000001b: 0x0,
	            0x8000001c: 0x20800,
	            0x8000001d: 0x820,
	            0x8000001e: 0x20020,
	            0x8000001f: 0x8020800
	        }
	    ];

	    // Masks that select the SBOX input
	    var SBOX_MASK = [
	        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
	        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
	    ];

	    /**
	     * DES block cipher algorithm.
	     */
	    var DES = C_algo.DES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Select 56 bits according to PC1
	            var keyBits = [];
	            for (var i = 0; i < 56; i++) {
	                var keyBitPos = PC1[i] - 1;
	                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
	            }

	            // Assemble 16 subkeys
	            var subKeys = this._subKeys = [];
	            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	                // Create subkey
	                var subKey = subKeys[nSubKey] = [];

	                // Shortcut
	                var bitShift = BIT_SHIFTS[nSubKey];

	                // Select 48 bits according to PC2
	                for (var i = 0; i < 24; i++) {
	                    // Select from the left 28 key bits
	                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

	                    // Select from the right 28 key bits
	                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
	                }

	                // Since each subkey is applied to an expanded 32-bit input,
	                // the subkey can be broken into 8 values scaled to 32-bits,
	                // which allows the key to be used without expansion
	                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
	                for (var i = 1; i < 7; i++) {
	                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
	                }
	                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
	            }

	            // Compute inverse subkeys
	            var invSubKeys = this._invSubKeys = [];
	            for (var i = 0; i < 16; i++) {
	                invSubKeys[i] = subKeys[15 - i];
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._subKeys);
	        },

	        decryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._invSubKeys);
	        },

	        _doCryptBlock: function (M, offset, subKeys) {
	            // Get input
	            this._lBlock = M[offset];
	            this._rBlock = M[offset + 1];

	            // Initial permutation
	            exchangeLR.call(this, 4,  0x0f0f0f0f);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeLR.call(this, 1,  0x55555555);

	            // Rounds
	            for (var round = 0; round < 16; round++) {
	                // Shortcuts
	                var subKey = subKeys[round];
	                var lBlock = this._lBlock;
	                var rBlock = this._rBlock;

	                // Feistel function
	                var f = 0;
	                for (var i = 0; i < 8; i++) {
	                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	                }
	                this._lBlock = rBlock;
	                this._rBlock = lBlock ^ f;
	            }

	            // Undo swap from last round
	            var t = this._lBlock;
	            this._lBlock = this._rBlock;
	            this._rBlock = t;

	            // Final permutation
	            exchangeLR.call(this, 1,  0x55555555);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeLR.call(this, 4,  0x0f0f0f0f);

	            // Set output
	            M[offset] = this._lBlock;
	            M[offset + 1] = this._rBlock;
	        },

	        keySize: 64/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    // Swap bits across the left and right words
	    function exchangeLR(offset, mask) {
	        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
	        this._rBlock ^= t;
	        this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
	        this._lBlock ^= t;
	        this._rBlock ^= t << offset;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */
	    C.DES = BlockCipher._createHelper(DES);

	    /**
	     * Triple-DES block cipher algorithm.
	     */
	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            // Make sure the key length is valid (64, 128 or >= 192 bit)
	            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
	                throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');
	            }

	            // Extend the key according to the keying options defined in 3DES standard
	            var key1 = keyWords.slice(0, 2);
	            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
	            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);

	            // Create DES instances
	            this._des1 = DES.createEncryptor(WordArray.create(key1));
	            this._des2 = DES.createEncryptor(WordArray.create(key2));
	            this._des3 = DES.createEncryptor(WordArray.create(key3));
	        },

	        encryptBlock: function (M, offset) {
	            this._des1.encryptBlock(M, offset);
	            this._des2.decryptBlock(M, offset);
	            this._des3.encryptBlock(M, offset);
	        },

	        decryptBlock: function (M, offset) {
	            this._des3.decryptBlock(M, offset);
	            this._des2.encryptBlock(M, offset);
	            this._des1.decryptBlock(M, offset);
	        },

	        keySize: 192/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());


	return CryptoJS.TripleDES;

}));
},{"./cipher-core":309,"./core":310,"./enc-base64":311,"./evpkdf":313,"./md5":318}],341:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;

	    /**
	     * x64 namespace.
	     */
	    var C_x64 = C.x64 = {};

	    /**
	     * A 64-bit word.
	     */
	    var X64Word = C_x64.Word = Base.extend({
	        /**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
	        init: function (high, low) {
	            this.high = high;
	            this.low = low;
	        }

	        /**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
	        // not: function () {
	            // var high = ~this.high;
	            // var low = ~this.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
	        // and: function (word) {
	            // var high = this.high & word.high;
	            // var low = this.low & word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
	        // or: function (word) {
	            // var high = this.high | word.high;
	            // var low = this.low | word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
	        // xor: function (word) {
	            // var high = this.high ^ word.high;
	            // var low = this.low ^ word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
	        // shiftL: function (n) {
	            // if (n < 32) {
	                // var high = (this.high << n) | (this.low >>> (32 - n));
	                // var low = this.low << n;
	            // } else {
	                // var high = this.low << (n - 32);
	                // var low = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
	        // shiftR: function (n) {
	            // if (n < 32) {
	                // var low = (this.low >>> n) | (this.high << (32 - n));
	                // var high = this.high >>> n;
	            // } else {
	                // var low = this.high >>> (n - 32);
	                // var high = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
	        // rotL: function (n) {
	            // return this.shiftL(n).or(this.shiftR(64 - n));
	        // },

	        /**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
	        // rotR: function (n) {
	            // return this.shiftR(n).or(this.shiftL(64 - n));
	        // },

	        /**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
	        // add: function (word) {
	            // var low = (this.low + word.low) | 0;
	            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	            // var high = (this.high + word.high + carry) | 0;

	            // return X64Word.create(high, low);
	        // }
	    });

	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var X64WordArray = C_x64.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 8;
	            }
	        },

	        /**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
	        toX32: function () {
	            // Shortcuts
	            var x64Words = this.words;
	            var x64WordsLength = x64Words.length;

	            // Convert
	            var x32Words = [];
	            for (var i = 0; i < x64WordsLength; i++) {
	                var x64Word = x64Words[i];
	                x32Words.push(x64Word.high);
	                x32Words.push(x64Word.low);
	            }

	            return X32WordArray.create(x32Words, this.sigBytes);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);

	            // Clone "words" array
	            var words = clone.words = this.words.slice(0);

	            // Clone each X64Word object
	            var wordsLength = words.length;
	            for (var i = 0; i < wordsLength; i++) {
	                words[i] = words[i].clone();
	            }

	            return clone;
	        }
	    });
	}());


	return CryptoJS;

}));
},{"./core":310}],342:[function(require,module,exports){
(function (Buffer){
'use strict';

/**
 * @file
 *
 * Copyright 2018 FutoIn Project (https://futoin.org)
 * Copyright 2018 Andrey Galkin <andrey@futoin.org>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { createHash, createHmac } = require( 'crypto' );

const g_digestLenCache = {};

/**
 * Get expected hash length.
 *
 * @func
 * @alias hkdf.hash_length
 * @param {string} hash - Hash algorithm (as in underlying Node.js crypto library)
 * @returns {integer} hash digest byte length
 *
 * @note Values are hardcoded with fallback for unknown algorithms.
 */
const hash_length = ( hash ) => {
    switch ( hash ) {
    case 'sha256': return 32;
    case 'sha512': return 64;
    case 'sha224': return 28;
    case 'sha384': return 48;
    case 'sha3-256': return 32;
    case 'sha3-512': return 64;
    case 'sha3-224': return 28;
    case 'sha3-384': return 48;
    case 'blake2s256': return 32;
    case 'blake2b512': return 64;
    case 'sha1': return 20;
    case 'md5': return 16;
    default: {
        let len = g_digestLenCache[hash];

        if ( len === undefined ) {
            len = createHash( hash ).digest().length;
            g_digestLenCache[hash] = len;
        }

        return len;
    }
    }
};

/**
 * HKDF extract action.
 *
 * @func
 * @alias hkdf.extract
 * @param {string} hash - Hash algorithm (as in underlying Node.js crypto library)
 * @param {integer} hash_len - Hash digest length
 * @param {Buffer|string} ikm - Initial Keying Material
 * @param {Buffer|string} salt - Optional salt (recommended)
 * @returns {Buffer} A buffer with pseudorandom key
 *
 * @note Values are hardcoded with fallback for unknown algorithms.
 */
const hkdf_extract = ( hash, hash_len, ikm, salt ) => {
    const b_ikm = Buffer.isBuffer( ikm ) ? ikm : Buffer.from( ikm );
    const b_salt = ( salt && salt.length ) ? Buffer.from( salt ) : Buffer.alloc( hash_len, 0 );

    return createHmac( hash, b_salt ).update( b_ikm ).digest();
};

/**
 * HKDF expand action.
 *
 * @func
 * @alias hkdf.expand
 * @param {string} hash - Hash algorithm (as in underlying Node.js crypto library)
 * @param {integer} hash_len - Hash digest length
 * @param {Buffer|string} prk - A buffer with pseudorandom key
 * @param {integer} length - length of output keying material in octets
 * @param {Buffer|string} info - Optional context (safe to skip)
 * @returns {Buffer} A buffer with output keying material
 *
 * @note Values are hardcoded with fallback for unknown algorithms.
 */
const hkdf_expand = ( hash, hash_len, prk, length, info ) => {
    const b_info = Buffer.from( info || '' );
    const info_len = b_info.length;

    const steps = Math.ceil( length / hash_len );

    if ( steps > 0xFF ) {
        throw new Error( `OKM length ${length} is too long for ${hash} hash` );
    }

    // use single buffer with unnecessary create/copy/move operations
    const t = Buffer.alloc( hash_len * steps + info_len + 1 );

    for ( let c = 1, start = 0, end = 0; c <= steps; ++c ) {
        // add info
        b_info.copy( t, end );
        // add counter
        t[ end + info_len ] = c;

        createHmac( hash, prk )
            // use view: T(C) = T(C-1) | info | C
            .update( t.slice( start, end + info_len + 1 ) )
            .digest()
            // put back to the same buffer
            .copy( t, end );

        start = end; // used for T(C-1) start
        end += hash_len; // used for T(C-1) end & overall end
    }

    return t.slice( 0, length );
};

/**
 * HMAC-based Extract-and-Expand Key Derivation Function (HKDF)
 *
 * @param {Buffer|string} ikm - Initial Keying Material
 * @param {integer} length - Required byte length of output
 * @param {Buffer|string} salt='' - Optional salt (recommended)
 * @param {Buffer|string} info='' - Optional context (safe to skip)
 * @param {string} hash='SHA-256' - HMAC hash function to use
 * @returns {Buffer} Raw buffer with derived key of @p length bytes
 */
function hkdf( ikm, length, { salt='', info='', hash='SHA-256' } = {} ) {
    hash = hash.toLowerCase().replace( '-', '' );

    // 0. Hash length
    const hash_len = hash_length( hash );

    // 1. extract
    const prk = hkdf_extract( hash, hash_len, ikm, salt );

    // 2. expand
    return hkdf_expand( hash, hash_len, prk, length, info );
}

Object.defineProperties( hkdf, {
    hash_length : {
        configurable: false,
        enumerable: false,
        writable: false,
        value: hash_length,
    },
    extract : {
        configurable: false,
        enumerable: false,
        writable: false,
        value: hkdf_extract,
    },
    expand : {
        configurable: false,
        enumerable: false,
        writable: false,
        value: hkdf_expand,
    },
} );

module.exports = hkdf;

}).call(this,require("buffer").Buffer)
},{"buffer":47,"crypto":55}],343:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"dup":84,"inherits":345,"safe-buffer":549,"stream":151}],344:[function(require,module,exports){
arguments[4][98][0].apply(exports,arguments)
},{"dup":98}],345:[function(require,module,exports){
arguments[4][99][0].apply(exports,arguments)
},{"dup":99}],346:[function(require,module,exports){
//! @version js-joda - 1.11.0
//! @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors
//! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
//! @license BSD-3-Clause (see LICENSE in the root directory of this source tree)

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.JSJoda = {})));
}(this, (function (exports) { 'use strict';

    /**
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
     */

    function createErrorType(name, init) {
        var superErrorClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Error;

        function E(message) {
            if (!Error.captureStackTrace) {
                this.stack = new Error().stack;
            } else {
                Error.captureStackTrace(this, this.constructor);
            }
            this.message = message;
            init && init.apply(this, arguments);
            this.toString = function () {
                return this.name + ': ' + this.message;
            };
        }
        E.prototype = new superErrorClass();
        E.prototype.name = name;
        E.prototype.constructor = E;
        return E;
    }

    var DateTimeException = createErrorType('DateTimeException', messageWithCause);
    var DateTimeParseException = createErrorType('DateTimeParseException', messageForDateTimeParseException);
    var UnsupportedTemporalTypeException = createErrorType('UnsupportedTemporalTypeException', null, DateTimeException);
    var ArithmeticException = createErrorType('ArithmeticException');
    var IllegalArgumentException = createErrorType('IllegalArgumentException');
    var IllegalStateException = createErrorType('IllegalStateException');
    var NullPointerException = createErrorType('NullPointerException');

    function messageWithCause(message) {
        var cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var msg = message || this.name;
        if (cause !== null && cause instanceof Error) {
            msg += '\n-------\nCaused by: ' + cause.stack + '\n-------\n';
        }
        this.message = msg;
    }

    function messageForDateTimeParseException(message) {
        var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var cause = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

        var msg = message || this.name;
        msg += ': ' + text + ', at index: ' + index;
        if (cause !== null && cause instanceof Error) {
            msg += '\n-------\nCaused by: ' + cause.stack + '\n-------\n';
        }
        this.message = msg;
        this.parsedString = function () {
            return text;
        };
        this.errorIndex = function () {
            return index;
        };
    }

    /**
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
     */

    function assert(assertion, msg, error) {
        if (!assertion) {
            if (error) {
                throw new error(msg);
            } else {
                throw new Error(msg);
            }
        }
    }

    function requireNonNull(value, parameterName) {
        if (value == null) {
            throw new NullPointerException(parameterName + ' must not be null');
        }
        return value;
    }

    function requireInstance(value, _class, parameterName) {
        if (!(value instanceof _class)) {
            throw new IllegalArgumentException(parameterName + ' must be an instance of ' + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ', but is ' + value.constructor.name : ''));
        }
        return value;
    }

    function abstractMethodFail(methodName) {
        throw new TypeError('abstract method "' + methodName + '" is not implemented');
    }

    var assert$1 = /*#__PURE__*/Object.freeze({
        assert: assert,
        requireNonNull: requireNonNull,
        requireInstance: requireInstance,
        abstractMethodFail: abstractMethodFail
    });

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var MAX_SAFE_INTEGER = 9007199254740991;
    var MIN_SAFE_INTEGER = -9007199254740991;

    var MathUtil = function () {
        function MathUtil() {
            _classCallCheck(this, MathUtil);
        }

        MathUtil.intDiv = function intDiv(x, y) {
            var r = x / y;
            r = MathUtil.roundDown(r);
            return MathUtil.safeZero(r);
        };

        MathUtil.intMod = function intMod(x, y) {
            var r = x - MathUtil.intDiv(x, y) * y;
            r = MathUtil.roundDown(r);
            return MathUtil.safeZero(r);
        };

        MathUtil.roundDown = function roundDown(r) {
            if (r < 0) {
                return Math.ceil(r);
            } else {
                return Math.floor(r);
            }
        };

        MathUtil.floorDiv = function floorDiv(x, y) {
            var r = Math.floor(x / y);
            return MathUtil.safeZero(r);
        };

        MathUtil.floorMod = function floorMod(x, y) {
            var r = x - MathUtil.floorDiv(x, y) * y;
            return MathUtil.safeZero(r);
        };

        MathUtil.safeAdd = function safeAdd(x, y) {
            MathUtil.verifyInt(x);
            MathUtil.verifyInt(y);
            if (x === 0) {
                return MathUtil.safeZero(y);
            }
            if (y === 0) {
                return MathUtil.safeZero(x);
            }
            var r = MathUtil.safeToInt(x + y);
            if (r === x || r === y) {
                throw new ArithmeticException('Invalid addition beyond MAX_SAFE_INTEGER!');
            }
            return r;
        };

        MathUtil.safeSubtract = function safeSubtract(x, y) {
            MathUtil.verifyInt(x);
            MathUtil.verifyInt(y);
            if (x === 0 && y === 0) {
                return 0;
            } else if (x === 0) {
                return MathUtil.safeZero(-1 * y);
            } else if (y === 0) {
                return MathUtil.safeZero(x);
            }
            return MathUtil.safeToInt(x - y);
        };

        MathUtil.safeMultiply = function safeMultiply(x, y) {
            MathUtil.verifyInt(x);
            MathUtil.verifyInt(y);
            if (x === 1) {
                return MathUtil.safeZero(y);
            }
            if (y === 1) {
                return MathUtil.safeZero(x);
            }
            if (x === 0 || y === 0) {
                return 0;
            }
            var r = MathUtil.safeToInt(x * y);
            if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {
                throw new ArithmeticException('Multiplication overflows: ' + x + ' * ' + y);
            }
            return r;
        };

        MathUtil.parseInt = function (_parseInt) {
            function parseInt(_x) {
                return _parseInt.apply(this, arguments);
            }

            parseInt.toString = function () {
                return _parseInt.toString();
            };

            return parseInt;
        }(function (value) {
            var r = parseInt(value);
            return MathUtil.safeToInt(r);
        });

        MathUtil.safeToInt = function safeToInt(value) {
            MathUtil.verifyInt(value);
            return MathUtil.safeZero(value);
        };

        MathUtil.verifyInt = function verifyInt(value) {
            if (value == null) {
                throw new ArithmeticException('Invalid value: \'' + value + '\', using null or undefined as argument');
            }
            if (isNaN(value)) {
                throw new ArithmeticException('Invalid int value, using NaN as argument');
            }
            if (value % 1 !== 0) {
                throw new ArithmeticException('Invalid value: \'' + value + '\' is a float');
            }
            if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {
                throw new ArithmeticException('Calculation overflows an int: ' + value);
            }
        };

        MathUtil.safeZero = function safeZero(value) {
            return value === 0 ? 0 : +value;
        };

        MathUtil.compareNumbers = function compareNumbers(a, b) {
            if (a < b) {
                return -1;
            }
            if (a > b) {
                return 1;
            }
            return 0;
        };

        MathUtil.smi = function smi(int) {
            return int >>> 1 & 0x40000000 | int & 0xBFFFFFFF;
        };

        MathUtil.hash = function hash(number) {
            if (number !== number || number === Infinity) {
                return 0;
            }
            var result = number;
            while (number > 0xFFFFFFFF) {
                number /= 0xFFFFFFFF;
                result ^= number;
            }
            return MathUtil.smi(result);
        };

        MathUtil.hashCode = function hashCode() {
            var result = 17;

            for (var _len = arguments.length, numbers = Array(_len), _key = 0; _key < _len; _key++) {
                numbers[_key] = arguments[_key];
            }

            for (var _iterator = numbers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var n = _ref;

                result = (result << 5) - result + MathUtil.hash(n);
            }
            return MathUtil.hash(result);
        };

        return MathUtil;
    }();

    MathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
    MathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;

    function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    /**
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
     */
    var Enum = function () {
        function Enum(name) {
            _classCallCheck$1(this, Enum);

            this._name = name;
        }

        Enum.prototype.equals = function equals(other) {
            return this === other;
        };

        Enum.prototype.toString = function toString() {
            return this._name;
        };

        Enum.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        return Enum;
    }();

    function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var TemporalAmount = function () {
      function TemporalAmount() {
        _classCallCheck$2(this, TemporalAmount);
      }

      TemporalAmount.prototype.get = function get(unit) {
        abstractMethodFail('get');
      };

      TemporalAmount.prototype.units = function units() {
        abstractMethodFail('units');
      };

      TemporalAmount.prototype.addTo = function addTo(temporal) {
        abstractMethodFail('addTo');
      };

      TemporalAmount.prototype.subtractFrom = function subtractFrom(temporal) {
        abstractMethodFail('subtractFrom');
      };

      return TemporalAmount;
    }();

    function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var TemporalUnit = function () {
      function TemporalUnit() {
        _classCallCheck$3(this, TemporalUnit);
      }

      TemporalUnit.prototype.duration = function duration() {
        abstractMethodFail('duration');
      };

      TemporalUnit.prototype.isDurationEstimated = function isDurationEstimated() {
        abstractMethodFail('isDurationEstimated');
      };

      TemporalUnit.prototype.isDateBased = function isDateBased() {
        abstractMethodFail('isDateBased');
      };

      TemporalUnit.prototype.isTimeBased = function isTimeBased() {
        abstractMethodFail('isTimeBased');
      };

      TemporalUnit.prototype.isSupportedBy = function isSupportedBy(temporal) {
        abstractMethodFail('isSupportedBy');
      };

      TemporalUnit.prototype.addTo = function addTo(dateTime, periodToAdd) {
        abstractMethodFail('addTo');
      };

      TemporalUnit.prototype.between = function between(temporal1, temporal2) {
        abstractMethodFail('between');
      };

      return TemporalUnit;
    }();

    function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Duration = function (_TemporalAmount) {
        _inherits(Duration, _TemporalAmount);

        function Duration(seconds, nanos) {
            _classCallCheck$4(this, Duration);

            var _this = _possibleConstructorReturn(this, _TemporalAmount.call(this));

            _this._seconds = MathUtil.safeToInt(seconds);
            _this._nanos = MathUtil.safeToInt(nanos);
            return _this;
        }

        Duration.ofDays = function ofDays(days) {
            return Duration._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);
        };

        Duration.ofHours = function ofHours(hours) {
            return Duration._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);
        };

        Duration.ofMinutes = function ofMinutes(minutes) {
            return Duration._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);
        };

        Duration.ofSeconds = function ofSeconds(seconds) {
            var nanoAdjustment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));
            var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
            return Duration._create(secs, nos);
        };

        Duration.ofMillis = function ofMillis(millis) {
            var secs = MathUtil.intDiv(millis, 1000);
            var mos = MathUtil.intMod(millis, 1000);
            if (mos < 0) {
                mos += 1000;
                secs--;
            }
            return Duration._create(secs, mos * 1000000);
        };

        Duration.ofNanos = function ofNanos(nanos) {
            var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);
            var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);
            if (nos < 0) {
                nos += LocalTime.NANOS_PER_SECOND;
                secs--;
            }
            return this._create(secs, nos);
        };

        Duration.of = function of(amount, unit) {
            return Duration.ZERO.plus(amount, unit);
        };

        Duration.from = function from(amount) {
            requireNonNull(amount, 'amount');
            requireInstance(amount, TemporalAmount);
            var duration = Duration.ZERO;
            amount.units().forEach(function (unit) {
                duration = duration.plus(amount.get(unit), unit);
            });
            return duration;
        };

        Duration.between = function between(startInclusive, endExclusive) {
            requireNonNull(startInclusive, 'startInclusive');
            requireNonNull(endExclusive, 'endExclusive');
            var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);
            var nanos = 0;
            if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {
                try {
                    var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);
                    nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;
                    if (secs > 0 && nanos < 0) {
                        nanos += LocalTime.NANOS_PER_SECOND;
                    } else if (secs < 0 && nanos > 0) {
                        nanos -= LocalTime.NANOS_PER_SECOND;
                    } else if (secs === 0 && nanos !== 0) {
                        var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);
                        secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);
                    }
                } catch (e) {}
            }
            return this.ofSeconds(secs, nanos);
        };

        Duration.parse = function parse(text) {
            requireNonNull(text, 'text');

            var PATTERN = new RegExp('([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?', 'i');
            var matches = PATTERN.exec(text);
            if (matches !== null) {
                if ('T' === matches[3] === false) {
                    var negate = '-' === matches[1];
                    var dayMatch = matches[2];
                    var hourMatch = matches[4];
                    var minuteMatch = matches[5];
                    var secondMatch = matches[6];
                    var fractionMatch = matches[7];
                    if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {
                        var daysAsSecs = Duration._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, 'days');
                        var hoursAsSecs = Duration._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, 'hours');
                        var minsAsSecs = Duration._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, 'minutes');
                        var seconds = Duration._parseNumber(text, secondMatch, 1, 'seconds');
                        var negativeSecs = secondMatch != null && secondMatch.charAt(0) === '-';
                        var nanos = Duration._parseFraction(text, fractionMatch, negativeSecs ? -1 : 1);
                        try {
                            return Duration._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);
                        } catch (ex) {
                            throw new DateTimeParseException('Text cannot be parsed to a Duration: overflow', text, 0, ex);
                        }
                    }
                }
            }
            throw new DateTimeParseException('Text cannot be parsed to a Duration', text, 0);
        };

        Duration._parseNumber = function _parseNumber(text, parsed, multiplier, errorText) {
            if (parsed == null) {
                return 0;
            }
            try {
                if (parsed[0] === '+') {
                    parsed = parsed.substring(1);
                }
                return MathUtil.safeMultiply(parseFloat(parsed), multiplier);
            } catch (ex) {
                throw new DateTimeParseException('Text cannot be parsed to a Duration: ' + errorText, text, 0, ex);
            }
        };

        Duration._parseFraction = function _parseFraction(text, parsed, negate) {
            if (parsed == null || parsed.length === 0) {
                return 0;
            }
            parsed = (parsed + '000000000').substring(0, 9);
            return parseFloat(parsed) * negate;
        };

        Duration._create = function _create() {
            if (arguments.length <= 2) {
                return Duration._createSecondsNanos(arguments[0], arguments[1]);
            } else {
                return Duration._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
            }
        };

        Duration._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {
            var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));
            if (negate) {
                return Duration.ofSeconds(seconds, nanos).negated();
            }
            return Duration.ofSeconds(seconds, nanos);
        };

        Duration._createSecondsNanos = function _createSecondsNanos() {
            var seconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var nanoAdjustment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            if ((seconds | nanoAdjustment) === 0) {
                return Duration.ZERO;
            }
            return new Duration(seconds, nanoAdjustment);
        };

        Duration.prototype.get = function get(unit) {
            if (unit === ChronoUnit.SECONDS) {
                return this._seconds;
            } else if (unit === ChronoUnit.NANOS) {
                return this._nanos;
            } else {
                throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);
            }
        };

        Duration.prototype.units = function units() {
            return [ChronoUnit.SECONDS, ChronoUnit.NANOS];
        };

        Duration.prototype.isZero = function isZero() {
            return (this._seconds | this._nanos) === 0;
        };

        Duration.prototype.isNegative = function isNegative() {
            return this._seconds < 0;
        };

        Duration.prototype.seconds = function seconds() {
            return this._seconds;
        };

        Duration.prototype.nano = function nano() {
            return this._nanos;
        };

        Duration.prototype.withSeconds = function withSeconds(seconds) {
            return Duration._create(seconds, this._nanos);
        };

        Duration.prototype.withNanos = function withNanos(nanoOfSecond) {
            ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);
            return Duration._create(this._seconds, nanoOfSecond);
        };

        Duration.prototype.plusDuration = function plusDuration(duration) {
            requireNonNull(duration, 'duration');
            return this.plus(duration.seconds(), duration.nano());
        };

        Duration.prototype.plus = function plus(durationOrNumber, unitOrNumber) {
            if (arguments.length === 1) {
                return this.plusDuration(durationOrNumber);
            } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {
                return this.plusAmountUnit(durationOrNumber, unitOrNumber);
            } else {
                return this.plusSecondsNanos(durationOrNumber, unitOrNumber);
            }
        };

        Duration.prototype.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {
            requireNonNull(amountToAdd, 'amountToAdd');
            requireNonNull(unit, 'unit');
            if (unit === ChronoUnit.DAYS) {
                return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);
            }
            if (unit.isDurationEstimated()) {
                throw new UnsupportedTemporalTypeException('Unit must not have an estimated duration');
            }
            if (amountToAdd === 0) {
                return this;
            }
            if (unit instanceof ChronoUnit) {
                switch (unit) {
                    case ChronoUnit.NANOS:
                        return this.plusNanos(amountToAdd);
                    case ChronoUnit.MICROS:
                        return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1000000 * 1000) * 1000, MathUtil.intMod(amountToAdd, 1000000 * 1000) * 1000);
                    case ChronoUnit.MILLIS:
                        return this.plusMillis(amountToAdd);
                    case ChronoUnit.SECONDS:
                        return this.plusSeconds(amountToAdd);
                }
                return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);
            }
            var duration = unit.duration().multipliedBy(amountToAdd);
            return this.plusSecondsNanos(duration.seconds(), duration.nano());
        };

        Duration.prototype.plusDays = function plusDays(daysToAdd) {
            return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);
        };

        Duration.prototype.plusHours = function plusHours(hoursToAdd) {
            return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);
        };

        Duration.prototype.plusMinutes = function plusMinutes(minutesToAdd) {
            return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);
        };

        Duration.prototype.plusSeconds = function plusSeconds(secondsToAdd) {
            return this.plusSecondsNanos(secondsToAdd, 0);
        };

        Duration.prototype.plusMillis = function plusMillis(millisToAdd) {
            return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * 1000000);
        };

        Duration.prototype.plusNanos = function plusNanos(nanosToAdd) {
            return this.plusSecondsNanos(0, nanosToAdd);
        };

        Duration.prototype.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {
            requireNonNull(secondsToAdd, 'secondsToAdd');
            requireNonNull(nanosToAdd, 'nanosToAdd');
            if ((secondsToAdd | nanosToAdd) === 0) {
                return this;
            }
            var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);
            epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));
            nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);
            var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);
            return Duration.ofSeconds(epochSec, nanoAdjustment);
        };

        Duration.prototype.minus = function minus(durationOrNumber, unit) {
            if (arguments.length === 1) {
                return this.minusDuration(durationOrNumber);
            } else {
                return this.minusAmountUnit(durationOrNumber, unit);
            }
        };

        Duration.prototype.minusDuration = function minusDuration(duration) {
            requireNonNull(duration, 'duration');
            var secsToSubtract = duration.seconds();
            var nanosToSubtract = duration.nano();
            if (secsToSubtract === MIN_SAFE_INTEGER) {
                return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);
            }
            return this.plus(-secsToSubtract, -nanosToSubtract);
        };

        Duration.prototype.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {
            requireNonNull(amountToSubtract, 'amountToSubtract');
            requireNonNull(unit, 'unit');
            return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);
        };

        Duration.prototype.minusDays = function minusDays(daysToSubtract) {
            return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);
        };

        Duration.prototype.minusHours = function minusHours(hoursToSubtract) {
            return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);
        };

        Duration.prototype.minusMinutes = function minusMinutes(minutesToSubtract) {
            return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);
        };

        Duration.prototype.minusSeconds = function minusSeconds(secondsToSubtract) {
            return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);
        };

        Duration.prototype.minusMillis = function minusMillis(millisToSubtract) {
            return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);
        };

        Duration.prototype.minusNanos = function minusNanos(nanosToSubtract) {
            return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);
        };

        Duration.prototype.multipliedBy = function multipliedBy(multiplicand) {
            if (multiplicand === 0) {
                return Duration.ZERO;
            }
            if (multiplicand === 1) {
                return this;
            }
            var secs = MathUtil.safeMultiply(this._seconds, multiplicand);
            var nos = MathUtil.safeMultiply(this._nanos, multiplicand);
            secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);
            nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);
            return Duration.ofSeconds(secs, nos);
        };

        Duration.prototype.dividedBy = function dividedBy(divisor) {
            if (divisor === 0) {
                throw new ArithmeticException('Cannot divide by zero');
            }
            if (divisor === 1) {
                return this;
            }
            var secs = MathUtil.intDiv(this._seconds, divisor);
            var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);
            var nos = MathUtil.intDiv(this._nanos, divisor);
            nos = secsMod + nos;
            return Duration.ofSeconds(secs, nos);
        };

        Duration.prototype.negated = function negated() {
            return this.multipliedBy(-1);
        };

        Duration.prototype.abs = function abs() {
            return this.isNegative() ? this.negated() : this;
        };

        Duration.prototype.addTo = function addTo(temporal) {
            requireNonNull(temporal, 'temporal');
            if (this._seconds !== 0) {
                temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);
            }
            if (this._nanos !== 0) {
                temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);
            }
            return temporal;
        };

        Duration.prototype.subtractFrom = function subtractFrom(temporal) {
            requireNonNull(temporal, 'temporal');
            if (this._seconds !== 0) {
                temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);
            }
            if (this._nanos !== 0) {
                temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);
            }
            return temporal;
        };

        Duration.prototype.toDays = function toDays() {
            return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);
        };

        Duration.prototype.toHours = function toHours() {
            return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
        };

        Duration.prototype.toMinutes = function toMinutes() {
            return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);
        };

        Duration.prototype.toMillis = function toMillis() {
            var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1000));
            millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1000000));
            return millis;
        };

        Duration.prototype.toNanos = function toNanos() {
            var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);
            totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);
            return totalNanos;
        };

        Duration.prototype.compareTo = function compareTo(otherDuration) {
            requireNonNull(otherDuration, 'otherDuration');
            requireInstance(otherDuration, Duration, 'otherDuration');
            var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());
            if (cmp !== 0) {
                return cmp;
            }
            return this._nanos - otherDuration.nano();
        };

        Duration.prototype.equals = function equals(otherDuration) {
            if (this === otherDuration) {
                return true;
            }
            if (otherDuration instanceof Duration) {
                return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();
            }
            return false;
        };

        Duration.prototype.toString = function toString() {
            if (this === Duration.ZERO) {
                return 'PT0S';
            }
            var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
            var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);
            var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);
            var rval = 'PT';
            if (hours !== 0) {
                rval += hours + 'H';
            }
            if (minutes !== 0) {
                rval += minutes + 'M';
            }
            if (secs === 0 && this._nanos === 0 && rval.length > 2) {
                return rval;
            }
            if (secs < 0 && this._nanos > 0) {
                if (secs === -1) {
                    rval += '-0';
                } else {
                    rval += secs + 1;
                }
            } else {
                rval += secs;
            }
            if (this._nanos > 0) {
                rval += '.';
                var nanoString = void 0;
                if (secs < 0) {
                    nanoString = '' + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);
                } else {
                    nanoString = '' + (LocalTime.NANOS_PER_SECOND + this._nanos);
                }

                nanoString = nanoString.slice(1, nanoString.length);
                rval += nanoString;
                while (rval.charAt(rval.length - 1) === '0') {
                    rval = rval.slice(0, rval.length - 1);
                }
            }
            rval += 'S';
            return rval;
        };

        Duration.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        return Duration;
    }(TemporalAmount);

    function _init() {
        Duration.ZERO = new Duration(0, 0);
    }

    function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    /*
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)
     */

    var YearConstants = function YearConstants() {
      _classCallCheck$5(this, YearConstants);
    };

    function _init$1() {
      YearConstants.MIN_VALUE = -999999;

      YearConstants.MAX_VALUE = 999999;
    }

    function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ChronoUnit = function (_TemporalUnit) {
      _inherits$1(ChronoUnit, _TemporalUnit);

      function ChronoUnit(name, estimatedDuration) {
        _classCallCheck$6(this, ChronoUnit);

        var _this = _possibleConstructorReturn$1(this, _TemporalUnit.call(this));

        _this._name = name;
        _this._duration = estimatedDuration;
        return _this;
      }

      ChronoUnit.prototype.duration = function duration() {
        return this._duration;
      };

      ChronoUnit.prototype.isDurationEstimated = function isDurationEstimated() {
        return this.isDateBased() || this === ChronoUnit.FOREVER;
      };

      ChronoUnit.prototype.isDateBased = function isDateBased() {
        return this.compareTo(ChronoUnit.DAYS) >= 0 && this !== ChronoUnit.FOREVER;
      };

      ChronoUnit.prototype.isTimeBased = function isTimeBased() {
        return this.compareTo(ChronoUnit.DAYS) < 0;
      };

      ChronoUnit.prototype.isSupportedBy = function isSupportedBy(temporal) {
        if (this === ChronoUnit.FOREVER) {
          return false;
        }

        try {
          temporal.plus(1, this);
          return true;
        } catch (e) {
          try {
            temporal.plus(-1, this);
            return true;
          } catch (e2) {
            return false;
          }
        }
      };

      ChronoUnit.prototype.addTo = function addTo(temporal, amount) {
        return temporal.plus(amount, this);
      };

      ChronoUnit.prototype.between = function between(temporal1, temporal2) {
        return temporal1.until(temporal2, this);
      };

      ChronoUnit.prototype.toString = function toString() {
        return this._name;
      };

      ChronoUnit.prototype.compareTo = function compareTo(other) {
        return this.duration().compareTo(other.duration());
      };

      return ChronoUnit;
    }(TemporalUnit);

    function _init$2() {
      ChronoUnit.NANOS = new ChronoUnit('Nanos', Duration.ofNanos(1));

      ChronoUnit.MICROS = new ChronoUnit('Micros', Duration.ofNanos(1000));

      ChronoUnit.MILLIS = new ChronoUnit('Millis', Duration.ofNanos(1000000));

      ChronoUnit.SECONDS = new ChronoUnit('Seconds', Duration.ofSeconds(1));

      ChronoUnit.MINUTES = new ChronoUnit('Minutes', Duration.ofSeconds(60));

      ChronoUnit.HOURS = new ChronoUnit('Hours', Duration.ofSeconds(3600));

      ChronoUnit.HALF_DAYS = new ChronoUnit('HalfDays', Duration.ofSeconds(43200));

      ChronoUnit.DAYS = new ChronoUnit('Days', Duration.ofSeconds(86400));

      ChronoUnit.WEEKS = new ChronoUnit('Weeks', Duration.ofSeconds(7 * 86400));

      ChronoUnit.MONTHS = new ChronoUnit('Months', Duration.ofSeconds(31556952 / 12));

      ChronoUnit.YEARS = new ChronoUnit('Years', Duration.ofSeconds(31556952));

      ChronoUnit.DECADES = new ChronoUnit('Decades', Duration.ofSeconds(31556952 * 10));

      ChronoUnit.CENTURIES = new ChronoUnit('Centuries', Duration.ofSeconds(31556952 * 100));

      ChronoUnit.MILLENNIA = new ChronoUnit('Millennia', Duration.ofSeconds(31556952 * 1000));

      ChronoUnit.ERAS = new ChronoUnit('Eras', Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));

      ChronoUnit.FOREVER = new ChronoUnit('Forever', Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));
    }

    function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    /**
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
     * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
     */

    var TemporalField = function TemporalField() {
      _classCallCheck$7(this, TemporalField);
    };

    function _classCallCheck$8(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var ValueRange = function () {
        function ValueRange(minSmallest, minLargest, maxSmallest, maxLargest) {
            _classCallCheck$8(this, ValueRange);

            assert(!(minSmallest > minLargest), 'Smallest minimum value \'' + minSmallest + '\' must be less than largest minimum value \'' + minLargest + '\'', IllegalArgumentException);
            assert(!(maxSmallest > maxLargest), 'Smallest maximum value \'' + maxSmallest + '\' must be less than largest maximum value \'' + maxLargest + '\'', IllegalArgumentException);
            assert(!(minLargest > maxLargest), 'Minimum value \'' + minLargest + '\' must be less than maximum value \'' + maxLargest + '\'', IllegalArgumentException);

            this._minSmallest = minSmallest;
            this._minLargest = minLargest;
            this._maxLargest = maxLargest;
            this._maxSmallest = maxSmallest;
        }

        ValueRange.prototype.isFixed = function isFixed() {
            return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;
        };

        ValueRange.prototype.minimum = function minimum() {
            return this._minSmallest;
        };

        ValueRange.prototype.largestMinimum = function largestMinimum() {
            return this._minLargest;
        };

        ValueRange.prototype.maximum = function maximum() {
            return this._maxLargest;
        };

        ValueRange.prototype.smallestMaximum = function smallestMaximum() {
            return this._maxSmallest;
        };

        ValueRange.prototype.isValidValue = function isValidValue(value) {
            return this.minimum() <= value && value <= this.maximum();
        };

        ValueRange.prototype.checkValidValue = function checkValidValue(value, field) {
            var msg = void 0;
            if (!this.isValidValue(value)) {
                if (field != null) {
                    msg = 'Invalid value for ' + field + ' (valid values ' + this.toString() + '): ' + value;
                } else {
                    msg = 'Invalid value (valid values ' + this.toString() + '): ' + value;
                }
                return assert(false, msg, DateTimeException);
            }
        };

        ValueRange.prototype.checkValidIntValue = function checkValidIntValue(value, field) {
            if (this.isValidIntValue(value) === false) {
                throw new DateTimeException('Invalid int value for ' + field + ': ' + value);
            }
            return value;
        };

        ValueRange.prototype.isValidIntValue = function isValidIntValue(value) {
            return this.isIntValue() && this.isValidValue(value);
        };

        ValueRange.prototype.isIntValue = function isIntValue() {
            return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;
        };

        ValueRange.prototype.equals = function equals(other) {
            if (other === this) {
                return true;
            }
            if (other instanceof ValueRange) {
                return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;
            }
            return false;
        };

        ValueRange.prototype.hashCode = function hashCode() {
            return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);
        };

        ValueRange.prototype.toString = function toString() {
            var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? '/' + this.largestMinimum() : '');
            str += ' - ';
            str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? '/' + this.maximum() : '');
            return str;
        };

        ValueRange.of = function of() {
            if (arguments.length === 2) {
                return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[1]);
            } else if (arguments.length === 3) {
                return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[2]);
            } else if (arguments.length === 4) {
                return new ValueRange(arguments[0], arguments[1], arguments[2], arguments[3]);
            } else {
                return assert(false, 'Invalid number of arguments ' + arguments.length, IllegalArgumentException);
            }
        };

        return ValueRange;
    }();

    function _classCallCheck$9(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ChronoField = function (_TemporalField) {
        _inherits$2(ChronoField, _TemporalField);

        ChronoField.byName = function byName(fieldName) {
            for (var prop in ChronoField) {
                if (ChronoField.hasOwnProperty(prop)) {
                    if (ChronoField[prop] instanceof ChronoField && ChronoField[prop].name() === fieldName) {
                        return ChronoField[prop];
                    }
                }
            }
        };

        function ChronoField(name, baseUnit, rangeUnit, range) {
            _classCallCheck$9(this, ChronoField);

            var _this = _possibleConstructorReturn$2(this, _TemporalField.call(this));

            _this._name = name;
            _this._baseUnit = baseUnit;
            _this._rangeUnit = rangeUnit;
            _this._range = range;
            return _this;
        }

        ChronoField.prototype.name = function name() {
            return this._name;
        };

        ChronoField.prototype.baseUnit = function baseUnit() {
            return this._baseUnit;
        };

        ChronoField.prototype.rangeUnit = function rangeUnit() {
            return this._rangeUnit;
        };

        ChronoField.prototype.range = function range() {
            return this._range;
        };

        ChronoField.prototype.displayName = function displayName() {
            return this.toString();
        };

        ChronoField.prototype.checkValidValue = function checkValidValue(value) {
            return this.range().checkValidValue(value, this.name());
        };

        ChronoField.prototype.isDateBased = function isDateBased() {
            var dateBased = this === ChronoField.DAY_OF_WEEK || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField.DAY_OF_MONTH || this === ChronoField.DAY_OF_YEAR || this === ChronoField.EPOCH_DAY || this === ChronoField.ALIGNED_WEEK_OF_MONTH || this === ChronoField.ALIGNED_WEEK_OF_YEAR || this === ChronoField.MONTH_OF_YEAR || this === ChronoField.YEAR_OF_ERA || this === ChronoField.YEAR || this === ChronoField.ERA;
            return dateBased;
        };

        ChronoField.prototype.isTimeBased = function isTimeBased() {
            var timeBased = this === ChronoField.NANO_OF_SECOND || this === ChronoField.NANO_OF_DAY || this === ChronoField.MICRO_OF_SECOND || this === ChronoField.MICRO_OF_DAY || this === ChronoField.MILLI_OF_SECOND || this === ChronoField.MILLI_OF_DAY || this === ChronoField.SECOND_OF_MINUTE || this === ChronoField.SECOND_OF_DAY || this === ChronoField.MINUTE_OF_HOUR || this === ChronoField.MINUTE_OF_DAY || this === ChronoField.HOUR_OF_AMPM || this === ChronoField.CLOCK_HOUR_OF_AMPM || this === ChronoField.HOUR_OF_DAY || this === ChronoField.CLOCK_HOUR_OF_DAY || this === ChronoField.AMPM_OF_DAY;
            return timeBased;
        };

        ChronoField.prototype.rangeRefinedBy = function rangeRefinedBy(temporal) {
            return temporal.range(this);
        };

        ChronoField.prototype.checkValidIntValue = function checkValidIntValue(value) {
            return this.range().checkValidIntValue(value, this);
        };

        ChronoField.prototype.getFrom = function getFrom(temporal) {
            return temporal.getLong(this);
        };

        ChronoField.prototype.toString = function toString() {
            return this.name();
        };

        ChronoField.prototype.equals = function equals(other) {
            return this === other;
        };

        return ChronoField;
    }(TemporalField);

    function _init$3() {

        ChronoField.NANO_OF_SECOND = new ChronoField('NanoOfSecond', ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));

        ChronoField.NANO_OF_DAY = new ChronoField('NanoOfDay', ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000000 - 1));

        ChronoField.MICRO_OF_SECOND = new ChronoField('MicroOfSecond', ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));

        ChronoField.MICRO_OF_DAY = new ChronoField('MicroOfDay', ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000 - 1));

        ChronoField.MILLI_OF_SECOND = new ChronoField('MilliOfSecond', ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));

        ChronoField.MILLI_OF_DAY = new ChronoField('MilliOfDay', ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000 - 1));

        ChronoField.SECOND_OF_MINUTE = new ChronoField('SecondOfMinute', ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));

        ChronoField.SECOND_OF_DAY = new ChronoField('SecondOfDay', ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));

        ChronoField.MINUTE_OF_HOUR = new ChronoField('MinuteOfHour', ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));

        ChronoField.MINUTE_OF_DAY = new ChronoField('MinuteOfDay', ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));

        ChronoField.HOUR_OF_AMPM = new ChronoField('HourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));

        ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField('ClockHourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));

        ChronoField.HOUR_OF_DAY = new ChronoField('HourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));

        ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField('ClockHourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));

        ChronoField.AMPM_OF_DAY = new ChronoField('AmPmOfDay', ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));

        ChronoField.DAY_OF_WEEK = new ChronoField('DayOfWeek', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));

        ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField('AlignedDayOfWeekInMonth', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));

        ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField('AlignedDayOfWeekInYear', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));

        ChronoField.DAY_OF_MONTH = new ChronoField('DayOfMonth', ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), 'day');

        ChronoField.DAY_OF_YEAR = new ChronoField('DayOfYear', ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));

        ChronoField.EPOCH_DAY = new ChronoField('EpochDay', ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(Math.floor(YearConstants.MIN_VALUE * 365.25), Math.floor(YearConstants.MAX_VALUE * 365.25)));

        ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField('AlignedWeekOfMonth', ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));

        ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField('AlignedWeekOfYear', ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));

        ChronoField.MONTH_OF_YEAR = new ChronoField('MonthOfYear', ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), 'month');

        ChronoField.PROLEPTIC_MONTH = new ChronoField('ProlepticMonth', ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));

        ChronoField.YEAR_OF_ERA = new ChronoField('YearOfEra', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));

        ChronoField.YEAR = new ChronoField('Year', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), 'year');

        ChronoField.ERA = new ChronoField('Era', ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));

        ChronoField.INSTANT_SECONDS = new ChronoField('InstantSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));

        ChronoField.OFFSET_SECONDS = new ChronoField('OffsetSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));
    }

    function _classCallCheck$a(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    /**
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
     * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
     */

    var TemporalQueries = function () {
      function TemporalQueries() {
        _classCallCheck$a(this, TemporalQueries);
      }

      TemporalQueries.zoneId = function zoneId() {
        return TemporalQueries.ZONE_ID;
      };

      TemporalQueries.chronology = function chronology() {
        return TemporalQueries.CHRONO;
      };

      TemporalQueries.precision = function precision() {
        return TemporalQueries.PRECISION;
      };

      TemporalQueries.zone = function zone() {
        return TemporalQueries.ZONE;
      };

      TemporalQueries.offset = function offset() {
        return TemporalQueries.OFFSET;
      };

      TemporalQueries.localDate = function localDate() {
        return TemporalQueries.LOCAL_DATE;
      };

      TemporalQueries.localTime = function localTime() {
        return TemporalQueries.LOCAL_TIME;
      };

      return TemporalQueries;
    }();

    function _classCallCheck$b(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var TemporalAccessor = function () {
        function TemporalAccessor() {
            _classCallCheck$b(this, TemporalAccessor);
        }

        TemporalAccessor.prototype.query = function query(_query) {
            if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {
                return null;
            }
            return _query.queryFrom(this);
        };

        TemporalAccessor.prototype.get = function get(field) {
            return this.range(field).checkValidIntValue(this.getLong(field), field);
        };

        TemporalAccessor.prototype.range = function range(field) {
            if (field instanceof ChronoField) {
                if (this.isSupported(field)) {
                    return field.range();
                }
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.rangeRefinedBy(this);
        };

        return TemporalAccessor;
    }();

    function _classCallCheck$c(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$3(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Temporal = function (_TemporalAccessor) {
      _inherits$3(Temporal, _TemporalAccessor);

      function Temporal() {
        _classCallCheck$c(this, Temporal);

        return _possibleConstructorReturn$3(this, _TemporalAccessor.apply(this, arguments));
      }

      return Temporal;
    }(TemporalAccessor);

    function _classCallCheck$d(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$4(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$4(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var TemporalQuery = function (_Enum) {
      _inherits$4(TemporalQuery, _Enum);

      function TemporalQuery() {
        _classCallCheck$d(this, TemporalQuery);

        return _possibleConstructorReturn$4(this, _Enum.apply(this, arguments));
      }

      TemporalQuery.prototype.queryFrom = function queryFrom(temporal) {
        abstractMethodFail('queryFrom');
      };

      return TemporalQuery;
    }(Enum);

    function createTemporalQuery(name, queryFromFunction) {
      var ExtendedTemporalQuery = function (_TemporalQuery) {
        _inherits$4(ExtendedTemporalQuery, _TemporalQuery);

        function ExtendedTemporalQuery() {
          _classCallCheck$d(this, ExtendedTemporalQuery);

          return _possibleConstructorReturn$4(this, _TemporalQuery.apply(this, arguments));
        }

        return ExtendedTemporalQuery;
      }(TemporalQuery);

      ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;
      return new ExtendedTemporalQuery(name);
    }

    function _classCallCheck$e(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$5(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$5(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var DayOfWeek = function (_Temporal) {
        _inherits$5(DayOfWeek, _Temporal);

        function DayOfWeek(ordinal, name) {
            _classCallCheck$e(this, DayOfWeek);

            var _this = _possibleConstructorReturn$5(this, _Temporal.call(this));

            _this._ordinal = ordinal;
            _this._name = name;
            return _this;
        }

        DayOfWeek.prototype.ordinal = function ordinal() {
            return this._ordinal;
        };

        DayOfWeek.prototype.name = function name() {
            return this._name;
        };

        DayOfWeek.values = function values() {
            return ENUMS.slice();
        };

        DayOfWeek.valueOf = function valueOf(name) {
            var ordinal = 0;
            for (ordinal; ordinal < ENUMS.length; ordinal++) {
                if (ENUMS[ordinal].name() === name) {
                    break;
                }
            }
            return DayOfWeek.of(ordinal + 1);
        };

        DayOfWeek.of = function of(dayOfWeek) {
            if (dayOfWeek < 1 || dayOfWeek > 7) {
                throw new DateTimeException('Invalid value for DayOfWeek: ' + dayOfWeek);
            }
            return ENUMS[dayOfWeek - 1];
        };

        DayOfWeek.from = function from(temporal) {
            assert(temporal != null, 'temporal', NullPointerException);
            if (temporal instanceof DayOfWeek) {
                return temporal;
            }
            try {
                return DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));
            } catch (ex) {
                if (ex instanceof DateTimeException) {
                    throw new DateTimeException('Unable to obtain DayOfWeek from TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''), ex);
                } else {
                    throw ex;
                }
            }
        };

        DayOfWeek.prototype.value = function value() {
            return this._ordinal + 1;
        };

        DayOfWeek.prototype.getDisplayName = function getDisplayName(style, locale) {
            throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');
        };

        DayOfWeek.prototype.isSupported = function isSupported(field) {
            if (field instanceof ChronoField) {
                return field === ChronoField.DAY_OF_WEEK;
            }
            return field != null && field.isSupportedBy(this);
        };

        DayOfWeek.prototype.range = function range(field) {
            if (field === ChronoField.DAY_OF_WEEK) {
                return field.range();
            } else if (field instanceof ChronoField) {
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.rangeRefinedBy(this);
        };

        DayOfWeek.prototype.get = function get(field) {
            if (field === ChronoField.DAY_OF_WEEK) {
                return this.value();
            }
            return this.range(field).checkValidIntValue(this.getLong(field), field);
        };

        DayOfWeek.prototype.getLong = function getLong(field) {
            if (field === ChronoField.DAY_OF_WEEK) {
                return this.value();
            } else if (field instanceof ChronoField) {
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.getFrom(this);
        };

        DayOfWeek.prototype.plus = function plus(days) {
            var amount = MathUtil.floorMod(days, 7);
            return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];
        };

        DayOfWeek.prototype.minus = function minus(days) {
            return this.plus(-1 * MathUtil.floorMod(days, 7));
        };

        DayOfWeek.prototype.query = function query(_query) {
            if (_query === TemporalQueries.precision()) {
                return ChronoUnit.DAYS;
            } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
                return null;
            }
            assert(_query != null, 'query', NullPointerException);
            return _query.queryFrom(this);
        };

        DayOfWeek.prototype.adjustInto = function adjustInto(temporal) {
            requireNonNull(temporal, 'temporal');
            return temporal.with(ChronoField.DAY_OF_WEEK, this.value());
        };

        DayOfWeek.prototype.equals = function equals(other) {
            return this === other;
        };

        DayOfWeek.prototype.toString = function toString() {
            return this._name;
        };

        DayOfWeek.prototype.compareTo = function compareTo(other) {
            requireNonNull(other, 'other');
            requireInstance(other, DayOfWeek, 'other');
            return this._ordinal - other._ordinal;
        };

        DayOfWeek.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        return DayOfWeek;
    }(Temporal);


    var ENUMS = void 0;

    function _init$4() {
        DayOfWeek.MONDAY = new DayOfWeek(0, 'MONDAY');
        DayOfWeek.TUESDAY = new DayOfWeek(1, 'TUESDAY');
        DayOfWeek.WEDNESDAY = new DayOfWeek(2, 'WEDNESDAY');
        DayOfWeek.THURSDAY = new DayOfWeek(3, 'THURSDAY');
        DayOfWeek.FRIDAY = new DayOfWeek(4, 'FRIDAY');
        DayOfWeek.SATURDAY = new DayOfWeek(5, 'SATURDAY');
        DayOfWeek.SUNDAY = new DayOfWeek(6, 'SUNDAY');

        DayOfWeek.FROM = createTemporalQuery('DayOfWeek.FROM', function (temporal) {
            return DayOfWeek.from(temporal);
        });

        ENUMS = [DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY];
    }

    function _classCallCheck$f(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$6(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$6(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Month = function (_Temporal) {
        _inherits$6(Month, _Temporal);

        function Month(value, name) {
            _classCallCheck$f(this, Month);

            var _this = _possibleConstructorReturn$6(this, _Temporal.call(this));

            _this._value = MathUtil.safeToInt(value);
            _this._name = name;
            return _this;
        }

        Month.prototype.value = function value() {
            return this._value;
        };

        Month.prototype.ordinal = function ordinal() {
            return this._value - 1;
        };

        Month.prototype.name = function name() {
            return this._name;
        };

        Month.prototype.getDisplayName = function getDisplayName(style, locale) {
            throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');
        };

        Month.prototype.isSupported = function isSupported(field) {
            if (null === field) {
                return false;
            }
            if (field instanceof ChronoField) {
                return field === ChronoField.MONTH_OF_YEAR;
            }
            return field != null && field.isSupportedBy(this);
        };

        Month.prototype.get = function get(field) {
            if (field === ChronoField.MONTH_OF_YEAR) {
                return this.value();
            }
            return this.range(field).checkValidIntValue(this.getLong(field), field);
        };

        Month.prototype.getLong = function getLong(field) {
            if (field === ChronoField.MONTH_OF_YEAR) {
                return this.value();
            } else if (field instanceof ChronoField) {
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.getFrom(this);
        };

        Month.prototype.plus = function plus(months) {
            var amount = MathUtil.intMod(months, 12) + 12;
            var newMonthVal = MathUtil.intMod(this.value() + amount, 12);

            newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;
            return Month.of(newMonthVal);
        };

        Month.prototype.minus = function minus(months) {
            return this.plus(-1 * MathUtil.intMod(months, 12));
        };

        Month.prototype.length = function length(leapYear) {
            switch (this) {
                case Month.FEBRUARY:
                    return leapYear ? 29 : 28;
                case Month.APRIL:
                case Month.JUNE:
                case Month.SEPTEMBER:
                case Month.NOVEMBER:
                    return 30;
                default:
                    return 31;
            }
        };

        Month.prototype.minLength = function minLength() {
            switch (this) {
                case Month.FEBRUARY:
                    return 28;
                case Month.APRIL:
                case Month.JUNE:
                case Month.SEPTEMBER:
                case Month.NOVEMBER:
                    return 30;
                default:
                    return 31;
            }
        };

        Month.prototype.maxLength = function maxLength() {
            switch (this) {
                case Month.FEBRUARY:
                    return 29;
                case Month.APRIL:
                case Month.JUNE:
                case Month.SEPTEMBER:
                case Month.NOVEMBER:
                    return 30;
                default:
                    return 31;
            }
        };

        Month.prototype.firstDayOfYear = function firstDayOfYear(leapYear) {
            var leap = leapYear ? 1 : 0;
            switch (this) {
                case Month.JANUARY:
                    return 1;
                case Month.FEBRUARY:
                    return 32;
                case Month.MARCH:
                    return 60 + leap;
                case Month.APRIL:
                    return 91 + leap;
                case Month.MAY:
                    return 121 + leap;
                case Month.JUNE:
                    return 152 + leap;
                case Month.JULY:
                    return 182 + leap;
                case Month.AUGUST:
                    return 213 + leap;
                case Month.SEPTEMBER:
                    return 244 + leap;
                case Month.OCTOBER:
                    return 274 + leap;
                case Month.NOVEMBER:
                    return 305 + leap;
                case Month.DECEMBER:
                default:
                    return 335 + leap;
            }
        };

        Month.prototype.firstMonthOfQuarter = function firstMonthOfQuarter() {
            switch (this) {
                case Month.JANUARY:
                case Month.FEBRUARY:
                case Month.MARCH:
                    return Month.JANUARY;
                case Month.APRIL:
                case Month.MAY:
                case Month.JUNE:
                    return Month.APRIL;
                case Month.JULY:
                case Month.AUGUST:
                case Month.SEPTEMBER:
                    return Month.JULY;
                case Month.OCTOBER:
                case Month.NOVEMBER:
                case Month.DECEMBER:
                default:
                    return Month.OCTOBER;
            }
        };

        Month.prototype.query = function query(_query) {
            assert(_query != null, 'query() parameter must not be null', DateTimeException);
            if (_query === TemporalQueries.chronology()) {
                return IsoChronology.INSTANCE;
            } else if (_query === TemporalQueries.precision()) {
                return ChronoUnit.MONTHS;
            }
            return _Temporal.prototype.query.call(this, _query);
        };

        Month.prototype.toString = function toString() {
            switch (this) {
                case Month.JANUARY:
                    return 'JANUARY';
                case Month.FEBRUARY:
                    return 'FEBRUARY';
                case Month.MARCH:
                    return 'MARCH';
                case Month.APRIL:
                    return 'APRIL';
                case Month.MAY:
                    return 'MAY';
                case Month.JUNE:
                    return 'JUNE';
                case Month.JULY:
                    return 'JULY';
                case Month.AUGUST:
                    return 'AUGUST';
                case Month.SEPTEMBER:
                    return 'SEPTEMBER';
                case Month.OCTOBER:
                    return 'OCTOBER';
                case Month.NOVEMBER:
                    return 'NOVEMBER';
                case Month.DECEMBER:
                    return 'DECEMBER';
                default:
                    return 'unknown Month, value: ' + this.value();
            }
        };

        Month.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        Month.prototype.adjustInto = function adjustInto(temporal) {
            return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());
        };

        Month.prototype.compareTo = function compareTo(other) {
            requireNonNull(other, 'other');
            requireInstance(other, Month, 'other');
            return this._value - other._value;
        };

        Month.prototype.equals = function equals(other) {
            return this === other;
        };

        Month.valueOf = function valueOf(name) {
            var ordinal = 0;
            for (ordinal; ordinal < MONTHS.length; ordinal++) {
                if (MONTHS[ordinal].name() === name) {
                    break;
                }
            }
            return Month.of(ordinal + 1);
        };

        Month.values = function values() {
            return MONTHS.slice();
        };

        Month.of = function of(month) {
            if (month < 1 || month > 12) {
                assert(false, 'Invalid value for MonthOfYear: ' + month, DateTimeException);
            }
            return MONTHS[month - 1];
        };

        Month.from = function from(temporal) {
            if (temporal instanceof Month) {
                return temporal;
            }
            try {
                return Month.of(temporal.get(ChronoField.MONTH_OF_YEAR));
            } catch (ex) {
                throw new DateTimeException('Unable to obtain Month from TemporalAccessor: ' + temporal + ' of type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''), ex);
            }
        };

        return Month;
    }(Temporal);


    var MONTHS = void 0;

    function _init$5() {
        Month.JANUARY = new Month(1, 'JANUARY');
        Month.FEBRUARY = new Month(2, 'FEBRUARY');
        Month.MARCH = new Month(3, 'MARCH');
        Month.APRIL = new Month(4, 'APRIL');
        Month.MAY = new Month(5, 'MAY');
        Month.JUNE = new Month(6, 'JUNE');
        Month.JULY = new Month(7, 'JULY');
        Month.AUGUST = new Month(8, 'AUGUST');
        Month.SEPTEMBER = new Month(9, 'SEPTEMBER');
        Month.OCTOBER = new Month(10, 'OCTOBER');
        Month.NOVEMBER = new Month(11, 'NOVEMBER');
        Month.DECEMBER = new Month(12, 'DECEMBER');

        MONTHS = [Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE, Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER];
    }

    function _classCallCheck$g(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$7(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$7(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;

    var Period = function (_TemporalAmount) {
        _inherits$7(Period, _TemporalAmount);

        function Period(years, months, days) {
            _classCallCheck$g(this, Period);

            var _this = _possibleConstructorReturn$7(this, _TemporalAmount.call(this));

            var _years = MathUtil.safeToInt(years);
            var _months = MathUtil.safeToInt(months);
            var _days = MathUtil.safeToInt(days);

            if ((_years | _months | _days) === 0) {
                var _ret;

                if (!Period.ZERO) {
                    _this._years = _years;
                    _this._months = _months;
                    _this._days = _days;
                    Period.ZERO = _this;
                }
                return _ret = Period.ZERO, _possibleConstructorReturn$7(_this, _ret);
            }

            _this._years = _years;

            _this._months = _months;

            _this._days = _days;
            return _this;
        }

        Period.ofYears = function ofYears(years) {
            return Period.create(years, 0, 0);
        };

        Period.ofMonths = function ofMonths(months) {
            return Period.create(0, months, 0);
        };

        Period.ofWeeks = function ofWeeks(weeks) {
            return Period.create(0, 0, MathUtil.safeMultiply(weeks, 7));
        };

        Period.ofDays = function ofDays(days) {
            return Period.create(0, 0, days);
        };

        Period.of = function of(years, months, days) {
            return Period.create(years, months, days);
        };

        Period.from = function from(amount) {
            if (amount instanceof Period) {
                return amount;
            }

            requireNonNull(amount, 'amount');
            var years = 0;
            var months = 0;
            var days = 0;
            var units = amount.units();
            for (var i = 0; i < units.length; i++) {
                var unit = units[i];
                var unitAmount = amount.get(unit);
                if (unit === ChronoUnit.YEARS) {
                    years = MathUtil.safeToInt(unitAmount);
                } else if (unit === ChronoUnit.MONTHS) {
                    months = MathUtil.safeToInt(unitAmount);
                } else if (unit === ChronoUnit.DAYS) {
                    days = MathUtil.safeToInt(unitAmount);
                } else {
                    throw new DateTimeException('Unit must be Years, Months or Days, but was ' + unit);
                }
            }
            return Period.create(years, months, days);
        };

        Period.between = function between(startDate, endDate) {
            requireNonNull(startDate, 'startDate');
            requireNonNull(endDate, 'endDate');
            requireInstance(startDate, LocalDate, 'startDate');
            requireInstance(endDate, LocalDate, 'endDate');
            return startDate.until(endDate);
        };

        Period.parse = function parse(text) {
            requireNonNull(text, 'text');
            try {
                return Period._parse(text);
            } catch (ex) {
                if (ex instanceof ArithmeticException) {
                    throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0, ex);
                } else {
                    throw ex;
                }
            }
        };

        Period._parse = function _parse(text) {
            var matches = PATTERN.exec(text);
            if (matches != null) {
                var negate = '-' === matches[1] ? -1 : 1;
                var yearMatch = matches[2];
                var monthMatch = matches[3];
                var weekMatch = matches[4];
                var dayMatch = matches[5];
                if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {
                    var years = Period._parseNumber(text, yearMatch, negate);
                    var months = Period._parseNumber(text, monthMatch, negate);
                    var weeks = Period._parseNumber(text, weekMatch, negate);
                    var days = Period._parseNumber(text, dayMatch, negate);
                    days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));
                    return Period.create(years, months, days);
                }
            }
            throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0);
        };

        Period._parseNumber = function _parseNumber(text, str, negate) {
            if (str == null) {
                return 0;
            }
            var val = MathUtil.parseInt(str);
            return MathUtil.safeMultiply(val, negate);
        };

        Period.create = function create(years, months, days) {
            return new Period(years, months, days);
        };

        Period.prototype.units = function units() {
            return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];
        };

        Period.prototype.chronology = function chronology() {
            return IsoChronology.INSTANCE;
        };

        Period.prototype.get = function get(unit) {
            if (unit === ChronoUnit.YEARS) {
                return this._years;
            }
            if (unit === ChronoUnit.MONTHS) {
                return this._months;
            }
            if (unit === ChronoUnit.DAYS) {
                return this._days;
            }
            throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);
        };

        Period.prototype.isZero = function isZero() {
            return this === Period.ZERO;
        };

        Period.prototype.isNegative = function isNegative() {
            return this._years < 0 || this._months < 0 || this._days < 0;
        };

        Period.prototype.years = function years() {
            return this._years;
        };

        Period.prototype.months = function months() {
            return this._months;
        };

        Period.prototype.days = function days() {
            return this._days;
        };

        Period.prototype.withYears = function withYears(years) {
            if (years === this._years) {
                return this;
            }
            return Period.create(years, this._months, this._days);
        };

        Period.prototype.withMonths = function withMonths(months) {
            if (months === this._months) {
                return this;
            }
            return Period.create(this._years, months, this._days);
        };

        Period.prototype.withDays = function withDays(days) {
            if (days === this._days) {
                return this;
            }
            return Period.create(this._years, this._months, days);
        };

        Period.prototype.plus = function plus(amountToAdd) {
            var amount = Period.from(amountToAdd);
            return Period.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));
        };

        Period.prototype.plusYears = function plusYears(yearsToAdd) {
            if (yearsToAdd === 0) {
                return this;
            }
            return Period.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);
        };

        Period.prototype.plusMonths = function plusMonths(monthsToAdd) {
            if (monthsToAdd === 0) {
                return this;
            }
            return Period.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);
        };

        Period.prototype.plusDays = function plusDays(daysToAdd) {
            if (daysToAdd === 0) {
                return this;
            }
            return Period.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));
        };

        Period.prototype.minus = function minus(amountToSubtract) {
            var amount = Period.from(amountToSubtract);
            return Period.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));
        };

        Period.prototype.minusYears = function minusYears(yearsToSubtract) {
            return this.plusYears(-1 * yearsToSubtract);
        };

        Period.prototype.minusMonths = function minusMonths(monthsToSubtract) {
            return this.plusMonths(-1 * monthsToSubtract);
        };

        Period.prototype.minusDays = function minusDays(daysToSubtract) {
            return this.plusDays(-1 * daysToSubtract);
        };

        Period.prototype.multipliedBy = function multipliedBy(scalar) {
            if (this === Period.ZERO || scalar === 1) {
                return this;
            }
            return Period.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));
        };

        Period.prototype.negated = function negated() {
            return this.multipliedBy(-1);
        };

        Period.prototype.normalized = function normalized() {
            var totalMonths = this.toTotalMonths();
            var splitYears = MathUtil.intDiv(totalMonths, 12);
            var splitMonths = MathUtil.intMod(totalMonths, 12);
            if (splitYears === this._years && splitMonths === this._months) {
                return this;
            }
            return Period.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);
        };

        Period.prototype.toTotalMonths = function toTotalMonths() {
            return this._years * 12 + this._months;
        };

        Period.prototype.addTo = function addTo(temporal) {
            requireNonNull(temporal, 'temporal');
            if (this._years !== 0) {
                if (this._months !== 0) {
                    temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);
                } else {
                    temporal = temporal.plus(this._years, ChronoUnit.YEARS);
                }
            } else if (this._months !== 0) {
                temporal = temporal.plus(this._months, ChronoUnit.MONTHS);
            }
            if (this._days !== 0) {
                temporal = temporal.plus(this._days, ChronoUnit.DAYS);
            }
            return temporal;
        };

        Period.prototype.subtractFrom = function subtractFrom(temporal) {
            requireNonNull(temporal, 'temporal');
            if (this._years !== 0) {
                if (this._months !== 0) {
                    temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);
                } else {
                    temporal = temporal.minus(this._years, ChronoUnit.YEARS);
                }
            } else if (this._months !== 0) {
                temporal = temporal.minus(this._months, ChronoUnit.MONTHS);
            }
            if (this._days !== 0) {
                temporal = temporal.minus(this._days, ChronoUnit.DAYS);
            }
            return temporal;
        };

        Period.prototype.equals = function equals(obj) {
            if (this === obj) {
                return true;
            }
            if (obj instanceof Period) {
                var other = obj;
                return this._years === other._years && this._months === other._months && this._days === other._days;
            }
            return false;
        };

        Period.prototype.hashCode = function hashCode() {
            return MathUtil.hashCode(this._years, this._months, this._days);
        };

        Period.prototype.toString = function toString() {
            if (this === Period.ZERO) {
                return 'P0D';
            } else {
                var buf = 'P';
                if (this._years !== 0) {
                    buf += '' + this._years + 'Y';
                }
                if (this._months !== 0) {
                    buf += '' + this._months + 'M';
                }
                if (this._days !== 0) {
                    buf += '' + this._days + 'D';
                }
                return buf;
            }
        };

        Period.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        return Period;
    }(TemporalAmount);

    function _init$6() {
        Period.ofDays(0);
    }

    function _classCallCheck$h(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    /*
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
     * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
     */

    var ParsePosition = function () {
        function ParsePosition(index) {
            _classCallCheck$h(this, ParsePosition);

            this._index = index;
            this._errorIndex = -1;
        }

        ParsePosition.prototype.getIndex = function getIndex() {
            return this._index;
        };

        ParsePosition.prototype.setIndex = function setIndex(index) {
            this._index = index;
        };

        ParsePosition.prototype.getErrorIndex = function getErrorIndex() {
            return this._errorIndex;
        };

        ParsePosition.prototype.setErrorIndex = function setErrorIndex(errorIndex) {
            this._errorIndex = errorIndex;
        };

        return ParsePosition;
    }();

    function _classCallCheck$i(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    /*
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
     */

    var EnumMap = function () {
        function EnumMap() {
            _classCallCheck$i(this, EnumMap);

            this._map = {};
        }

        EnumMap.prototype.putAll = function putAll(otherMap) {
            for (var key in otherMap._map) {
                this._map[key] = otherMap._map[key];
            }
            return this;
        };

        EnumMap.prototype.containsKey = function containsKey(key) {
            return this._map.hasOwnProperty(key.name()) && this.get(key) !== undefined;
        };

        EnumMap.prototype.get = function get(key) {
            return this._map[key.name()];
        };

        EnumMap.prototype.put = function put(key, val) {
            return this.set(key, val);
        };

        EnumMap.prototype.set = function set(key, val) {
            this._map[key.name()] = val;
            return this;
        };

        EnumMap.prototype.retainAll = function retainAll(keyList) {
            var map = {};
            for (var i = 0; i < keyList.length; i++) {
                var key = keyList[i].name();
                map[key] = this._map[key];
            }
            this._map = map;
            return this;
        };

        EnumMap.prototype.remove = function remove(key) {
            var keyName = key.name();
            var val = this._map[keyName];
            this._map[keyName] = undefined;
            return val;
        };

        EnumMap.prototype.keySet = function keySet() {
            return this._map;
        };

        EnumMap.prototype.clear = function clear() {
            this._map = {};
        };

        return EnumMap;
    }();

    function _classCallCheck$j(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$8(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$8(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ResolverStyle = function (_Enum) {
      _inherits$8(ResolverStyle, _Enum);

      function ResolverStyle() {
        _classCallCheck$j(this, ResolverStyle);

        return _possibleConstructorReturn$8(this, _Enum.apply(this, arguments));
      }

      return ResolverStyle;
    }(Enum);

    ResolverStyle.STRICT = new ResolverStyle('STRICT');

    ResolverStyle.SMART = new ResolverStyle('SMART');

    ResolverStyle.LENIENT = new ResolverStyle('LENIENT');

    function _classCallCheck$k(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$9(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$9(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ChronoLocalDate = function (_Temporal) {
        _inherits$9(ChronoLocalDate, _Temporal);

        function ChronoLocalDate() {
            _classCallCheck$k(this, ChronoLocalDate);

            return _possibleConstructorReturn$9(this, _Temporal.apply(this, arguments));
        }

        ChronoLocalDate.prototype.isSupported = function isSupported(fieldOrUnit) {
            if (fieldOrUnit instanceof ChronoField) {
                return fieldOrUnit.isDateBased();
            } else if (fieldOrUnit instanceof ChronoUnit) {
                return fieldOrUnit.isDateBased();
            }
            return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
        };

        ChronoLocalDate.prototype.query = function query(_query) {
            if (_query === TemporalQueries.chronology()) {
                return this.chronology();
            } else if (_query === TemporalQueries.precision()) {
                return ChronoUnit.DAYS;
            } else if (_query === TemporalQueries.localDate()) {
                return LocalDate.ofEpochDay(this.toEpochDay());
            } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
                return null;
            }
            return _Temporal.prototype.query.call(this, _query);
        };

        ChronoLocalDate.prototype.adjustInto = function adjustInto(temporal) {
            return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());
        };

        ChronoLocalDate.prototype.format = function format(formatter) {
            requireNonNull(formatter, 'formatter');
            requireInstance(formatter, DateTimeFormatter, 'formatter');
            return formatter.format(this);
        };

        return ChronoLocalDate;
    }(Temporal);

    function _classCallCheck$l(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var StringUtil = function () {
        function StringUtil() {
            _classCallCheck$l(this, StringUtil);
        }

        StringUtil.startsWith = function startsWith(text, pattern) {
            return text.indexOf(pattern) === 0;
        };

        StringUtil.hashCode = function hashCode(text) {
            var len = text.length;
            if (len === 0) {
                return 0;
            }

            var hash = 0;
            for (var i = 0; i < len; i++) {
                var chr = text.charCodeAt(i);
                hash = (hash << 5) - hash + chr;
                hash |= 0;
            }
            return MathUtil.smi(hash);
        };

        return StringUtil;
    }();

    function _classCallCheck$m(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var ZoneId = function () {
        function ZoneId() {
            _classCallCheck$m(this, ZoneId);
        }

        ZoneId.systemDefault = function systemDefault() {
            throw new DateTimeException('not supported operation');
        };

        ZoneId.getAvailableZoneIds = function getAvailableZoneIds() {
            throw new DateTimeException('not supported operation');
        };

        ZoneId.of = function of(zoneId) {
            throw new DateTimeException('not supported operation' + zoneId);
        };

        ZoneId.ofOffset = function ofOffset(prefix, offset) {
            throw new DateTimeException('not supported operation' + prefix + offset);
        };

        ZoneId.from = function from(temporal) {
            throw new DateTimeException('not supported operation' + temporal);
        };

        ZoneId.prototype.id = function id() {
            abstractMethodFail('ZoneId.id');
        };

        ZoneId.prototype.rules = function rules() {
            abstractMethodFail('ZoneId.rules');
        };

        ZoneId.prototype.normalized = function normalized() {
            var rules = this.rules();
            if (rules.isFixedOffset()) {
                return rules.offset(Instant.EPOCH);
            }

            return this;
        };

        ZoneId.prototype.equals = function equals(other) {
            if (this === other) {
                return true;
            }
            if (other instanceof ZoneId) {
                return this.id() === other.id();
            }
            return false;
        };

        ZoneId.prototype.hashCode = function hashCode() {
            return StringUtil.hashCode(this.id());
        };

        ZoneId.prototype.toString = function toString() {
            return this.id();
        };

        ZoneId.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        return ZoneId;
    }();

    function _possibleConstructorReturn$a(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$a(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck$n(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var ZoneRules = function () {
        function ZoneRules() {
            _classCallCheck$n(this, ZoneRules);
        }

        ZoneRules.of = function of(offset) {
            requireNonNull(offset, 'offset');
            return new Fixed(offset);
        };

        ZoneRules.prototype.isFixedOffset = function isFixedOffset() {
            abstractMethodFail('ZoneRules.isFixedOffset');
        };

        ZoneRules.prototype.offset = function offset(instantOrLocalDateTime) {
            if (instantOrLocalDateTime instanceof Instant) {
                return this.offsetOfInstant(instantOrLocalDateTime);
            } else {
                return this.offsetOfLocalDateTime(instantOrLocalDateTime);
            }
        };

        ZoneRules.prototype.offsetOfInstant = function offsetOfInstant(instant) {
            abstractMethodFail('ZoneRules.offsetInstant');
        };

        ZoneRules.prototype.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
            abstractMethodFail('ZoneRules.offsetOfEpochMilli');
        };

        ZoneRules.prototype.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
            abstractMethodFail('ZoneRules.offsetLocalDateTime');
        };

        ZoneRules.prototype.validOffsets = function validOffsets(localDateTime) {
            abstractMethodFail('ZoneRules.validOffsets');
        };

        ZoneRules.prototype.transition = function transition(localDateTime) {
            abstractMethodFail('ZoneRules.transition');
        };

        ZoneRules.prototype.standardOffset = function standardOffset(instant) {
            abstractMethodFail('ZoneRules.standardOffset');
        };

        ZoneRules.prototype.daylightSavings = function daylightSavings(instant) {
            abstractMethodFail('ZoneRules.daylightSavings');
        };

        ZoneRules.prototype.isDaylightSavings = function isDaylightSavings(instant) {
            abstractMethodFail('ZoneRules.isDaylightSavings');
        };

        ZoneRules.prototype.isValidOffset = function isValidOffset(localDateTime, offset) {
            abstractMethodFail('ZoneRules.isValidOffset');
        };

        ZoneRules.prototype.nextTransition = function nextTransition(instant) {
            abstractMethodFail('ZoneRules.nextTransition');
        };

        ZoneRules.prototype.previousTransition = function previousTransition(instant) {
            abstractMethodFail('ZoneRules.previousTransition');
        };

        ZoneRules.prototype.transitions = function transitions() {
            abstractMethodFail('ZoneRules.transitions');
        };

        ZoneRules.prototype.transitionRules = function transitionRules() {
            abstractMethodFail('ZoneRules.transitionRules');
        };

        ZoneRules.prototype.toString = function toString() {
            abstractMethodFail('ZoneRules.toString');
        };

        ZoneRules.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        return ZoneRules;
    }();

    var Fixed = function (_ZoneRules) {
        _inherits$a(Fixed, _ZoneRules);

        function Fixed(offset) {
            _classCallCheck$n(this, Fixed);

            var _this = _possibleConstructorReturn$a(this, _ZoneRules.call(this));

            _this._offset = offset;
            return _this;
        }

        Fixed.prototype.isFixedOffset = function isFixedOffset() {
            return true;
        };

        Fixed.prototype.offsetOfInstant = function offsetOfInstant() {
            return this._offset;
        };

        Fixed.prototype.offsetOfEpochMilli = function offsetOfEpochMilli() {
            return this._offset;
        };

        Fixed.prototype.offsetOfLocalDateTime = function offsetOfLocalDateTime() {
            return this._offset;
        };

        Fixed.prototype.validOffsets = function validOffsets() {
            return [this._offset];
        };

        Fixed.prototype.transition = function transition() {
            return null;
        };

        Fixed.prototype.standardOffset = function standardOffset() {
            return this._offset;
        };

        Fixed.prototype.daylightSavings = function daylightSavings() {
            return Duration.ZERO;
        };

        Fixed.prototype.isDaylightSavings = function isDaylightSavings() {
            return false;
        };

        Fixed.prototype.isValidOffset = function isValidOffset(localDateTime, offset) {
            return this._offset.equals(offset);
        };

        Fixed.prototype.nextTransition = function nextTransition() {
            return null;
        };

        Fixed.prototype.previousTransition = function previousTransition() {
            return null;
        };

        Fixed.prototype.transitions = function transitions() {
            return [];
        };

        Fixed.prototype.transitionRules = function transitionRules() {
            return [];
        };

        Fixed.prototype.equals = function equals(other) {
            if (this === other) {
                return true;
            }
            if (other instanceof Fixed) {
                return this._offset.equals(other._offset);
            }
            return false;
        };

        Fixed.prototype.toString = function toString() {
            return 'FixedRules:' + this._offset.toString();
        };

        return Fixed;
    }(ZoneRules);

    function _classCallCheck$o(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$b(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$b(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var SECONDS_CACHE = {};
    var ID_CACHE = {};

    var ZoneOffset = function (_ZoneId) {
        _inherits$b(ZoneOffset, _ZoneId);

        function ZoneOffset(totalSeconds) {
            _classCallCheck$o(this, ZoneOffset);

            var _this = _possibleConstructorReturn$b(this, _ZoneId.call(this));

            ZoneOffset._validateTotalSeconds(totalSeconds);
            _this._totalSeconds = MathUtil.safeToInt(totalSeconds);
            _this._rules = ZoneRules.of(_this);
            _this._id = ZoneOffset._buildId(totalSeconds);
            return _this;
        }

        ZoneOffset.prototype.totalSeconds = function totalSeconds() {
            return this._totalSeconds;
        };

        ZoneOffset.prototype.id = function id() {
            return this._id;
        };

        ZoneOffset._buildId = function _buildId(totalSeconds) {
            if (totalSeconds === 0) {
                return 'Z';
            } else {
                var absTotalSeconds = Math.abs(totalSeconds);
                var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);
                var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
                var buf = '' + (totalSeconds < 0 ? '-' : '+') + (absHours < 10 ? '0' : '') + absHours + (absMinutes < 10 ? ':0' : ':') + absMinutes;
                var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);
                if (absSeconds !== 0) {
                    buf += (absSeconds < 10 ? ':0' : ':') + absSeconds;
                }
                return buf;
            }
        };

        ZoneOffset._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {
            if (Math.abs(totalSeconds) > ZoneOffset.MAX_SECONDS) {
                throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');
            }
        };

        ZoneOffset._validate = function _validate(hours, minutes, seconds) {
            if (hours < -18 || hours > 18) {
                throw new DateTimeException('Zone offset hours not in valid range: value ' + hours + ' is not in the range -18 to 18');
            }
            if (hours > 0) {
                if (minutes < 0 || seconds < 0) {
                    throw new DateTimeException('Zone offset minutes and seconds must be positive because hours is positive');
                }
            } else if (hours < 0) {
                if (minutes > 0 || seconds > 0) {
                    throw new DateTimeException('Zone offset minutes and seconds must be negative because hours is negative');
                }
            } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {
                throw new DateTimeException('Zone offset minutes and seconds must have the same sign');
            }
            if (Math.abs(minutes) > 59) {
                throw new DateTimeException('Zone offset minutes not in valid range: abs(value) ' + Math.abs(minutes) + ' is not in the range 0 to 59');
            }
            if (Math.abs(seconds) > 59) {
                throw new DateTimeException('Zone offset seconds not in valid range: abs(value) ' + Math.abs(seconds) + ' is not in the range 0 to 59');
            }
            if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {
                throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');
            }
        };

        ZoneOffset.of = function of(offsetId) {
            requireNonNull(offsetId, 'offsetId');

            var offset = ID_CACHE[offsetId];
            if (offset != null) {
                return offset;
            }

            var hours = void 0,
                minutes = void 0,
                seconds = void 0;
            switch (offsetId.length) {
                case 2:
                    offsetId = offsetId[0] + '0' + offsetId[1];
                case 3:
                    hours = ZoneOffset._parseNumber(offsetId, 1, false);
                    minutes = 0;
                    seconds = 0;
                    break;
                case 5:
                    hours = ZoneOffset._parseNumber(offsetId, 1, false);
                    minutes = ZoneOffset._parseNumber(offsetId, 3, false);
                    seconds = 0;
                    break;
                case 6:
                    hours = ZoneOffset._parseNumber(offsetId, 1, false);
                    minutes = ZoneOffset._parseNumber(offsetId, 4, true);
                    seconds = 0;
                    break;
                case 7:
                    hours = ZoneOffset._parseNumber(offsetId, 1, false);
                    minutes = ZoneOffset._parseNumber(offsetId, 3, false);
                    seconds = ZoneOffset._parseNumber(offsetId, 5, false);
                    break;
                case 9:
                    hours = ZoneOffset._parseNumber(offsetId, 1, false);
                    minutes = ZoneOffset._parseNumber(offsetId, 4, true);
                    seconds = ZoneOffset._parseNumber(offsetId, 7, true);
                    break;
                default:
                    throw new DateTimeException('Invalid ID for ZoneOffset, invalid format: ' + offsetId);
            }
            var first = offsetId[0];
            if (first !== '+' && first !== '-') {
                throw new DateTimeException('Invalid ID for ZoneOffset, plus/minus not found when expected: ' + offsetId);
            }
            if (first === '-') {
                return ZoneOffset.ofHoursMinutesSeconds(-hours, -minutes, -seconds);
            } else {
                return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, seconds);
            }
        };

        ZoneOffset._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {
            if (precededByColon && offsetId[pos - 1] !== ':') {
                throw new DateTimeException('Invalid ID for ZoneOffset, colon not found when expected: ' + offsetId);
            }
            var ch1 = offsetId[pos];
            var ch2 = offsetId[pos + 1];
            if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {
                throw new DateTimeException('Invalid ID for ZoneOffset, non numeric characters found: ' + offsetId);
            }
            return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
        };

        ZoneOffset.ofHours = function ofHours(hours) {
            return ZoneOffset.ofHoursMinutesSeconds(hours, 0, 0);
        };

        ZoneOffset.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {
            return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, 0);
        };

        ZoneOffset.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {
            ZoneOffset._validate(hours, minutes, seconds);
            var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;
            return ZoneOffset.ofTotalSeconds(totalSeconds);
        };

        ZoneOffset.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {
            var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;
            return ZoneOffset.ofTotalSeconds(totalSeconds);
        };

        ZoneOffset.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {
            if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {
                var totalSecs = totalSeconds;
                var result = SECONDS_CACHE[totalSecs];
                if (result == null) {
                    result = new ZoneOffset(totalSeconds);
                    SECONDS_CACHE[totalSecs] = result;
                    ID_CACHE[result.id()] = result;
                }
                return result;
            } else {
                return new ZoneOffset(totalSeconds);
            }
        };

        ZoneOffset.prototype.rules = function rules() {
            return this._rules;
        };

        ZoneOffset.prototype.get = function get(field) {
            return this.getLong(field);
        };

        ZoneOffset.prototype.getLong = function getLong(field) {
            if (field === ChronoField.OFFSET_SECONDS) {
                return this._totalSeconds;
            } else if (field instanceof ChronoField) {
                throw new DateTimeException('Unsupported field: ' + field);
            }
            return field.getFrom(this);
        };

        ZoneOffset.prototype.query = function query(_query) {
            requireNonNull(_query, 'query');
            if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
                return this;
            } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {
                return null;
            }
            return _query.queryFrom(this);
        };

        ZoneOffset.prototype.adjustInto = function adjustInto(temporal) {
            return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);
        };

        ZoneOffset.prototype.compareTo = function compareTo(other) {
            requireNonNull(other, 'other');
            return other._totalSeconds - this._totalSeconds;
        };

        ZoneOffset.prototype.equals = function equals(obj) {
            if (this === obj) {
                return true;
            }
            if (obj instanceof ZoneOffset) {
                return this._totalSeconds === obj._totalSeconds;
            }
            return false;
        };

        ZoneOffset.prototype.hashCode = function hashCode() {
            return this._totalSeconds;
        };

        ZoneOffset.prototype.toString = function toString() {
            return this._id;
        };

        return ZoneOffset;
    }(ZoneId);


    function _init$7() {
        ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;
        ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);
        ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);
        ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);
    }

    function _classCallCheck$p(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$c(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$c(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var DateTimeBuilder = function (_Temporal) {
        _inherits$c(DateTimeBuilder, _Temporal);

        DateTimeBuilder.create = function create(field, value) {
            var dtb = new DateTimeBuilder();
            dtb._addFieldValue(field, value);
            return dtb;
        };

        function DateTimeBuilder() {
            _classCallCheck$p(this, DateTimeBuilder);

            var _this = _possibleConstructorReturn$c(this, _Temporal.call(this));

            _this.fieldValues = new EnumMap();

            _this.chrono = null;

            _this.zone = null;

            _this.date = null;

            _this.time = null;

            _this.leapSecond = false;

            _this.excessDays = null;
            return _this;
        }

        DateTimeBuilder.prototype.getFieldValue0 = function getFieldValue0(field) {
            return this.fieldValues.get(field);
        };

        DateTimeBuilder.prototype._addFieldValue = function _addFieldValue(field, value) {
            requireNonNull(field, 'field');
            var old = this.getFieldValue0(field);
            if (old != null && old !== value) {
                throw new DateTimeException('Conflict found: ' + field + ' ' + old + ' differs from ' + field + ' ' + value + ': ' + this);
            }
            return this._putFieldValue0(field, value);
        };

        DateTimeBuilder.prototype._putFieldValue0 = function _putFieldValue0(field, value) {
            this.fieldValues.put(field, value);
            return this;
        };

        DateTimeBuilder.prototype.resolve = function resolve(resolverStyle, resolverFields) {
            if (resolverFields != null) {
                this.fieldValues.retainAll(resolverFields);
            }

            this._mergeDate(resolverStyle);
            this._mergeTime(resolverStyle);

            this._resolveTimeInferZeroes(resolverStyle);

            if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {
                this.date = this.date.plus(this.excessDays);
                this.excessDays = Period.ZERO;
            }

            this._resolveInstant();
            return this;
        };

        DateTimeBuilder.prototype._mergeDate = function _mergeDate(resolverStyle) {
            this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));
        };

        DateTimeBuilder.prototype._checkDate = function _checkDate(date) {
            if (date != null) {
                this._addObject(date);
                for (var fieldName in this.fieldValues.keySet()) {
                    var field = ChronoField.byName(fieldName);
                    if (field) {
                        if (this.fieldValues.get(field) !== undefined) {
                            if (field.isDateBased()) {
                                var val1 = void 0;
                                try {
                                    val1 = date.getLong(field);
                                } catch (ex) {
                                    if (ex instanceof DateTimeException) {
                                        continue;
                                    } else {
                                        throw ex;
                                    }
                                }
                                var val2 = this.fieldValues.get(field);
                                if (val1 !== val2) {
                                    throw new DateTimeException('Conflict found: Field ' + field + ' ' + val1 + ' differs from ' + field + ' ' + val2 + ' derived from ' + date);
                                }
                            }
                        }
                    }
                }
            }
        };

        DateTimeBuilder.prototype._mergeTime = function _mergeTime(resolverStyle) {
            if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {
                var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);
                if (resolverStyle !== ResolverStyle.LENIENT) {
                    if (resolverStyle === ResolverStyle.SMART && ch === 0) ; else {
                        ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);
                    }
                }
                this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);
            }
            if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {
                var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);
                if (resolverStyle !== ResolverStyle.LENIENT) {
                    if (resolverStyle === ResolverStyle.SMART && _ch === 0) ; else {
                        ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);
                    }
                }
                this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);
            }
            if (resolverStyle !== ResolverStyle.LENIENT) {
                if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {
                    ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));
                }
                if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
                    ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));
                }
            }
            if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
                var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);
                var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);
                this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);
            }

            if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {
                var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);
                if (resolverStyle !== ResolverStyle.LENIENT) {
                    ChronoField.NANO_OF_DAY.checkValidValue(nod);
                }
                this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1000000000));
                this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000));
            }
            if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {
                var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);
                if (resolverStyle !== ResolverStyle.LENIENT) {
                    ChronoField.MICRO_OF_DAY.checkValidValue(cod);
                }
                this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1000000));
                this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1000000));
            }
            if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {
                var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);
                if (resolverStyle !== ResolverStyle.LENIENT) {
                    ChronoField.MILLI_OF_DAY.checkValidValue(lod);
                }
                this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1000));
                this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1000));
            }
            if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {
                var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);
                if (resolverStyle !== ResolverStyle.LENIENT) {
                    ChronoField.SECOND_OF_DAY.checkValidValue(sod);
                }
                this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));
                this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));
                this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));
            }
            if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {
                var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);
                if (resolverStyle !== ResolverStyle.LENIENT) {
                    ChronoField.MINUTE_OF_DAY.checkValidValue(mod);
                }
                this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));
                this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));
            }

            if (resolverStyle !== ResolverStyle.LENIENT) {
                if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
                    ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));
                }
                if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
                    ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));
                }
            }
            if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
                var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
                var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);
                this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1000 + MathUtil.intMod(cos, 1000));
            }
            if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
                var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
                this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1000));
                this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
            }
            if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
                var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
                this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1000000));
                this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
            }
            if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
                var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
                this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1000);
            } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
                var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
                this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1000000);
            }
        };

        DateTimeBuilder.prototype._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {
            var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);
            var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);
            var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);
            var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
            if (hod == null) {
                return;
            }
            if (moh == null && (som != null || nos != null)) {
                return;
            }
            if (moh != null && som == null && nos != null) {
                return;
            }
            if (resolverStyle !== ResolverStyle.LENIENT) {
                if (hod != null) {
                    if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {
                        hod = 0;
                        this.excessDays = Period.ofDays(1);
                    }
                    var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);
                    if (moh != null) {
                        var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);
                        if (som != null) {
                            var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);
                            if (nos != null) {
                                var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);
                                this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));
                            } else {
                                this._addObject(LocalTime.of(hodVal, mohVal, somVal));
                            }
                        } else {
                            if (nos == null) {
                                this._addObject(LocalTime.of(hodVal, mohVal));
                            }
                        }
                    } else {
                        if (som == null && nos == null) {
                            this._addObject(LocalTime.of(hodVal, 0));
                        }
                    }
                }
            } else {
                if (hod != null) {
                    var _hodVal = hod;
                    if (moh != null) {
                        if (som != null) {
                            if (nos == null) {
                                nos = 0;
                            }
                            var totalNanos = MathUtil.safeMultiply(_hodVal, 3600000000000);
                            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 60000000000));
                            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1000000000));
                            totalNanos = MathUtil.safeAdd(totalNanos, nos);
                            var excessDays = MathUtil.floorDiv(totalNanos, 86400000000000);
                            var nod = MathUtil.floorMod(totalNanos, 86400000000000);
                            this._addObject(LocalTime.ofNanoOfDay(nod));
                            this.excessDays = Period.ofDays(excessDays);
                        } else {
                            var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);
                            totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));
                            var _excessDays = MathUtil.floorDiv(totalSecs, 86400);
                            var sod = MathUtil.floorMod(totalSecs, 86400);
                            this._addObject(LocalTime.ofSecondOfDay(sod));
                            this.excessDays = Period.ofDays(_excessDays);
                        }
                    } else {
                        var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));
                        _hodVal = MathUtil.floorMod(_hodVal, 24);
                        this._addObject(LocalTime.of(_hodVal, 0));
                        this.excessDays = Period.ofDays(_excessDays2);
                    }
                }
            }
            this.fieldValues.remove(ChronoField.HOUR_OF_DAY);
            this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);
            this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);
            this.fieldValues.remove(ChronoField.NANO_OF_SECOND);
        };

        DateTimeBuilder.prototype._addObject = function _addObject(dateOrTime) {
            if (dateOrTime instanceof ChronoLocalDate) {
                this.date = dateOrTime;
            } else if (dateOrTime instanceof LocalTime) {
                this.time = dateOrTime;
            }
        };

        DateTimeBuilder.prototype._resolveInstant = function _resolveInstant() {
            if (this.date != null && this.time != null) {
                var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);
                if (offsetSecs != null) {
                    var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
                    var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);
                    this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);
                } else if (this.zone != null) {
                    var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);
                    this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);
                }
            }
        };

        DateTimeBuilder.prototype.build = function build(type) {
            return type.queryFrom(this);
        };

        DateTimeBuilder.prototype.isSupported = function isSupported(field) {
            if (field == null) {
                return false;
            }
            return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== undefined || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);
        };

        DateTimeBuilder.prototype.getLong = function getLong(field) {
            requireNonNull(field, 'field');
            var value = this.getFieldValue0(field);
            if (value == null) {
                if (this.date != null && this.date.isSupported(field)) {
                    return this.date.getLong(field);
                }
                if (this.time != null && this.time.isSupported(field)) {
                    return this.time.getLong(field);
                }
                throw new DateTimeException('Field not found: ' + field);
            }
            return value;
        };

        DateTimeBuilder.prototype.query = function query(_query) {
            if (_query === TemporalQueries.zoneId()) {
                return this.zone;
            } else if (_query === TemporalQueries.chronology()) {
                return this.chrono;
            } else if (_query === TemporalQueries.localDate()) {
                return this.date != null ? LocalDate.from(this.date) : null;
            } else if (_query === TemporalQueries.localTime()) {
                return this.time;
            } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
                return _query.queryFrom(this);
            } else if (_query === TemporalQueries.precision()) {
                return null;
            }

            return _query.queryFrom(this);
        };

        return DateTimeBuilder;
    }(Temporal);

    function _possibleConstructorReturn$d(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$d(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck$q(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var DateTimeParseContext = function () {
        function DateTimeParseContext() {
            _classCallCheck$q(this, DateTimeParseContext);

            if (arguments.length === 1) {
                if (arguments[0] instanceof DateTimeParseContext) {
                    this._constructorSelf.apply(this, arguments);
                    return;
                } else {
                    this._constructorFormatter.apply(this, arguments);
                }
            } else {
                this._constructorParam.apply(this, arguments);
            }

            this._caseSensitive = true;
            this._strict = true;
            this._parsed = [new Parsed(this)];
        }

        DateTimeParseContext.prototype._constructorParam = function _constructorParam(locale, symbols, chronology) {
            this._locale = locale;
            this._symbols = symbols;
            this._overrideChronology = chronology;
        };

        DateTimeParseContext.prototype._constructorFormatter = function _constructorFormatter(formatter) {
            this._locale = formatter.locale();
            this._symbols = formatter.decimalStyle();
            this._overrideChronology = formatter.chronology();
        };

        DateTimeParseContext.prototype._constructorSelf = function _constructorSelf(other) {
            this._locale = other._locale;
            this._symbols = other._symbols;
            this._overrideChronology = other._overrideChronology;
            this._overrideZone = other._overrideZone;
            this._caseSensitive = other._caseSensitive;
            this._strict = other._strict;
            this._parsed = [new Parsed(this)];
        };

        DateTimeParseContext.prototype.copy = function copy() {
            return new DateTimeParseContext(this);
        };

        DateTimeParseContext.prototype.symbols = function symbols() {
            return this._symbols;
        };

        DateTimeParseContext.prototype.isStrict = function isStrict() {
            return this._strict;
        };

        DateTimeParseContext.prototype.setStrict = function setStrict(strict) {
            this._strict = strict;
        };

        DateTimeParseContext.prototype.locale = function locale() {
            return this._locale;
        };

        DateTimeParseContext.prototype.setLocale = function setLocale(locale) {
            this._locale = locale;
        };

        DateTimeParseContext.prototype.startOptional = function startOptional() {
            this._parsed.push(this.currentParsed().copy());
        };

        DateTimeParseContext.prototype.endOptional = function endOptional(successful) {
            if (successful) {
                this._parsed.splice(this._parsed.length - 2, 1);
            } else {
                this._parsed.splice(this._parsed.length - 1, 1);
            }
        };

        DateTimeParseContext.prototype.isCaseSensitive = function isCaseSensitive() {
            return this._caseSensitive;
        };

        DateTimeParseContext.prototype.setCaseSensitive = function setCaseSensitive(caseSensitive) {
            this._caseSensitive = caseSensitive;
        };

        DateTimeParseContext.prototype.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {
            if (offset1 + length > cs1.length || offset2 + length > cs2.length) {
                return false;
            }
            if (!this.isCaseSensitive()) {
                cs1 = cs1.toLowerCase();
                cs2 = cs2.toLowerCase();
            }
            for (var i = 0; i < length; i++) {
                var ch1 = cs1[offset1 + i];
                var ch2 = cs2[offset2 + i];
                if (ch1 !== ch2) {
                    return false;
                }
            }
            return true;
        };

        DateTimeParseContext.prototype.charEquals = function charEquals(ch1, ch2) {
            if (this.isCaseSensitive()) {
                return ch1 === ch2;
            }
            return this.charEqualsIgnoreCase(ch1, ch2);
        };

        DateTimeParseContext.prototype.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {
            return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();
        };

        DateTimeParseContext.prototype.setParsedField = function setParsedField(field, value, errorPos, successPos) {
            var currentParsedFieldValues = this.currentParsed().fieldValues;
            var old = currentParsedFieldValues.get(field);
            currentParsedFieldValues.set(field, value);
            return old != null && old !== value ? ~errorPos : successPos;
        };

        DateTimeParseContext.prototype.setParsedZone = function setParsedZone(zone) {
            requireNonNull(zone, 'zone');
            this.currentParsed().zone = zone;
        };

        DateTimeParseContext.prototype.getParsed = function getParsed(field) {
            return this.currentParsed().fieldValues.get(field);
        };

        DateTimeParseContext.prototype.toParsed = function toParsed() {
            return this.currentParsed();
        };

        DateTimeParseContext.prototype.currentParsed = function currentParsed() {
            return this._parsed[this._parsed.length - 1];
        };

        DateTimeParseContext.prototype.setParsedLeapSecond = function setParsedLeapSecond() {
            this.currentParsed().leapSecond = true;
        };

        DateTimeParseContext.prototype.getEffectiveChronology = function getEffectiveChronology() {
            var chrono = this.currentParsed().chrono;
            if (chrono == null) {
                chrono = this._overrideChronology;
                if (chrono == null) {
                    chrono = IsoChronology.INSTANCE;
                }
            }
            return chrono;
        };

        return DateTimeParseContext;
    }();

    var Parsed = function (_Temporal) {
        _inherits$d(Parsed, _Temporal);

        function Parsed(dateTimeParseContext) {
            _classCallCheck$q(this, Parsed);

            var _this = _possibleConstructorReturn$d(this, _Temporal.call(this));

            _this.chrono = null;
            _this.zone = null;
            _this.fieldValues = new EnumMap();
            _this.leapSecond = false;
            _this.dateTimeParseContext = dateTimeParseContext;
            return _this;
        }

        Parsed.prototype.copy = function copy() {
            var cloned = new Parsed();
            cloned.chrono = this.chrono;
            cloned.zone = this.zone;
            cloned.fieldValues.putAll(this.fieldValues);
            cloned.leapSecond = this.leapSecond;
            cloned.dateTimeParseContext = this.dateTimeParseContext;
            return cloned;
        };

        Parsed.prototype.toString = function toString() {
            return this.fieldValues + ', ' + this.chrono + ', ' + this.zone;
        };

        Parsed.prototype.isSupported = function isSupported(field) {
            return this.fieldValues.containsKey(field);
        };

        Parsed.prototype.get = function get(field) {
            var val = this.fieldValues.get(field);
            assert(val != null);
            return val;
        };

        Parsed.prototype.query = function query(_query) {
            if (_query === TemporalQueries.chronology()) {
                return this.chrono;
            }
            if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
                return this.zone;
            }
            return _Temporal.prototype.query.call(this, _query);
        };

        Parsed.prototype.toBuilder = function toBuilder() {
            var builder = new DateTimeBuilder();
            builder.fieldValues.putAll(this.fieldValues);
            builder.chrono = this.dateTimeParseContext.getEffectiveChronology();
            if (this.zone != null) {
                builder.zone = this.zone;
            } else {
                builder.zone = this.overrideZone;
            }
            builder.leapSecond = this.leapSecond;
            builder.excessDays = this.excessDays;
            return builder;
        };

        return Parsed;
    }(Temporal);

    function _classCallCheck$r(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var DateTimePrintContext = function () {
        function DateTimePrintContext(temporal, localeOrFormatter, symbols) {
            _classCallCheck$r(this, DateTimePrintContext);

            if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {
                this._temporal = DateTimePrintContext.adjust(temporal, localeOrFormatter);
                this._locale = localeOrFormatter.locale();
                this._symbols = localeOrFormatter.decimalStyle();
            } else {
                this._temporal = temporal;
                this._locale = localeOrFormatter;
                this._symbols = symbols;
            }
            this._optional = 0;
        }

        DateTimePrintContext.adjust = function adjust(temporal, formatter) {
            return temporal;
        };

        DateTimePrintContext.prototype.symbols = function symbols() {
            return this._symbols;
        };

        DateTimePrintContext.prototype.startOptional = function startOptional() {
            this._optional++;
        };

        DateTimePrintContext.prototype.endOptional = function endOptional() {
            this._optional--;
        };

        DateTimePrintContext.prototype.getValueQuery = function getValueQuery(query) {
            var result = this._temporal.query(query);
            if (result == null && this._optional === 0) {
                throw new DateTimeException('Unable to extract value: ' + this._temporal);
            }
            return result;
        };

        DateTimePrintContext.prototype.getValue = function getValue(field) {
            try {
                return this._temporal.getLong(field);
            } catch (ex) {
                if (ex instanceof DateTimeException && this._optional > 0) {
                    return null;
                }
                throw ex;
            }
        };

        DateTimePrintContext.prototype.temporal = function temporal() {
            return this._temporal;
        };

        DateTimePrintContext.prototype.locale = function locale() {
            return this._locale;
        };

        DateTimePrintContext.prototype.setDateTime = function setDateTime(temporal) {
            this._temporal = temporal;
        };

        DateTimePrintContext.prototype.setLocale = function setLocale(locale) {
            this._locale = locale;
        };

        return DateTimePrintContext;
    }();

    function _possibleConstructorReturn$e(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$e(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck$s(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var IsoFields = function IsoFields() {
        _classCallCheck$s(this, IsoFields);
    };

    var QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];

    var Field = function (_TemporalField) {
        _inherits$e(Field, _TemporalField);

        function Field() {
            _classCallCheck$s(this, Field);

            return _possibleConstructorReturn$e(this, _TemporalField.apply(this, arguments));
        }

        Field.prototype.isDateBased = function isDateBased() {
            return true;
        };

        Field.prototype.isTimeBased = function isTimeBased() {
            return false;
        };

        Field.prototype._isIso = function _isIso() {
            return true;
        };

        Field._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date) {
            var wby = Field._getWeekBasedYear(date);
            return ValueRange.of(1, Field._getWeekRangeByYear(wby));
        };

        Field._getWeekRangeByYear = function _getWeekRangeByYear(wby) {
            var date = LocalDate.of(wby, 1, 1);

            if (date.dayOfWeek() === DayOfWeek.THURSDAY || date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear()) {
                return 53;
            }
            return 52;
        };

        Field._getWeek = function _getWeek(date) {
            var dow0 = date.dayOfWeek().ordinal();
            var doy0 = date.dayOfYear() - 1;
            var doyThu0 = doy0 + (3 - dow0);
            var alignedWeek = MathUtil.intDiv(doyThu0, 7);
            var firstThuDoy0 = doyThu0 - alignedWeek * 7;
            var firstMonDoy0 = firstThuDoy0 - 3;
            if (firstMonDoy0 < -3) {
                firstMonDoy0 += 7;
            }
            if (doy0 < firstMonDoy0) {
                return Field._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();
            }
            var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;
            if (week === 53) {
                if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date.isLeapYear()) === false) {
                    week = 1;
                }
            }
            return week;
        };

        Field._getWeekBasedYear = function _getWeekBasedYear(date) {
            var year = date.year();
            var doy = date.dayOfYear();
            if (doy <= 3) {
                var dow = date.dayOfWeek().ordinal();
                if (doy - dow < -2) {
                    year--;
                }
            } else if (doy >= 363) {
                var _dow = date.dayOfWeek().ordinal();
                doy = doy - 363 - (date.isLeapYear() ? 1 : 0);
                if (doy - _dow >= 0) {
                    year++;
                }
            }
            return year;
        };

        Field.prototype.getDisplayName = function getDisplayName() {
            return this.toString();
        };

        Field.prototype.resolve = function resolve() {
            return null;
        };

        Field.prototype.name = function name() {
            return this.toString();
        };

        return Field;
    }(TemporalField);

    var DAY_OF_QUARTER_FIELD = function (_Field) {
        _inherits$e(DAY_OF_QUARTER_FIELD, _Field);

        function DAY_OF_QUARTER_FIELD() {
            _classCallCheck$s(this, DAY_OF_QUARTER_FIELD);

            return _possibleConstructorReturn$e(this, _Field.apply(this, arguments));
        }

        DAY_OF_QUARTER_FIELD.prototype.toString = function toString() {
            return 'DayOfQuarter';
        };

        DAY_OF_QUARTER_FIELD.prototype.baseUnit = function baseUnit() {
            return ChronoUnit.DAYS;
        };

        DAY_OF_QUARTER_FIELD.prototype.rangeUnit = function rangeUnit() {
            return QUARTER_YEARS;
        };

        DAY_OF_QUARTER_FIELD.prototype.range = function range() {
            return ValueRange.of(1, 90, 92);
        };

        DAY_OF_QUARTER_FIELD.prototype.isSupportedBy = function isSupportedBy(temporal) {
            return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);
        };

        DAY_OF_QUARTER_FIELD.prototype.rangeRefinedBy = function rangeRefinedBy(temporal) {
            if (temporal.isSupported(this) === false) {
                throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');
            }
            var qoy = temporal.getLong(QUARTER_OF_YEAR);
            if (qoy === 1) {
                var year = temporal.getLong(ChronoField.YEAR);
                return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);
            } else if (qoy === 2) {
                return ValueRange.of(1, 91);
            } else if (qoy === 3 || qoy === 4) {
                return ValueRange.of(1, 92);
            }
            return this.range();
        };

        DAY_OF_QUARTER_FIELD.prototype.getFrom = function getFrom(temporal) {
            if (temporal.isSupported(this) === false) {
                throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');
            }
            var doy = temporal.get(ChronoField.DAY_OF_YEAR);
            var moy = temporal.get(ChronoField.MONTH_OF_YEAR);
            var year = temporal.getLong(ChronoField.YEAR);
            return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];
        };

        DAY_OF_QUARTER_FIELD.prototype.adjustInto = function adjustInto(temporal, newValue) {
            var curValue = this.getFrom(temporal);
            this.range().checkValidValue(newValue, this);
            return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));
        };

        DAY_OF_QUARTER_FIELD.prototype.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
            var yearLong = fieldValues.get(ChronoField.YEAR);
            var qoyLong = fieldValues.get(QUARTER_OF_YEAR);
            if (yearLong == null || qoyLong == null) {
                return null;
            }
            var y = ChronoField.YEAR.checkValidIntValue(yearLong);
            var doq = fieldValues.get(DAY_OF_QUARTER);
            var date = void 0;
            if (resolverStyle === ResolverStyle.LENIENT) {
                var qoy = qoyLong;
                date = LocalDate.of(y, 1, 1);
                date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));
                date = date.plusDays(MathUtil.safeSubtract(doq, 1));
            } else {
                var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);
                if (resolverStyle === ResolverStyle.STRICT) {
                    var max = 92;
                    if (_qoy === 1) {
                        max = IsoChronology.isLeapYear(y) ? 91 : 90;
                    } else if (_qoy === 2) {
                        max = 91;
                    }
                    ValueRange.of(1, max).checkValidValue(doq, this);
                } else {
                    this.range().checkValidValue(doq, this);
                }
                date = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);
            }
            fieldValues.remove(this);
            fieldValues.remove(ChronoField.YEAR);
            fieldValues.remove(QUARTER_OF_YEAR);
            return date;
        };

        return DAY_OF_QUARTER_FIELD;
    }(Field);

    var QUARTER_OF_YEAR_FIELD = function (_Field2) {
        _inherits$e(QUARTER_OF_YEAR_FIELD, _Field2);

        function QUARTER_OF_YEAR_FIELD() {
            _classCallCheck$s(this, QUARTER_OF_YEAR_FIELD);

            return _possibleConstructorReturn$e(this, _Field2.apply(this, arguments));
        }

        QUARTER_OF_YEAR_FIELD.prototype.toString = function toString() {
            return 'QuarterOfYear';
        };

        QUARTER_OF_YEAR_FIELD.prototype.baseUnit = function baseUnit() {
            return QUARTER_YEARS;
        };

        QUARTER_OF_YEAR_FIELD.prototype.rangeUnit = function rangeUnit() {
            return ChronoUnit.YEARS;
        };

        QUARTER_OF_YEAR_FIELD.prototype.range = function range() {
            return ValueRange.of(1, 4);
        };

        QUARTER_OF_YEAR_FIELD.prototype.isSupportedBy = function isSupportedBy(temporal) {
            return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);
        };

        QUARTER_OF_YEAR_FIELD.prototype.rangeRefinedBy = function rangeRefinedBy(temporal) {
            return this.range();
        };

        QUARTER_OF_YEAR_FIELD.prototype.getFrom = function getFrom(temporal) {
            if (temporal.isSupported(this) === false) {
                throw new UnsupportedTemporalTypeException('Unsupported field: QuarterOfYear');
            }
            var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);
            return MathUtil.intDiv(moy + 2, 3);
        };

        QUARTER_OF_YEAR_FIELD.prototype.adjustInto = function adjustInto(temporal, newValue) {
            var curValue = this.getFrom(temporal);
            this.range().checkValidValue(newValue, this);
            return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);
        };

        return QUARTER_OF_YEAR_FIELD;
    }(Field);

    var WEEK_OF_WEEK_BASED_YEAR_FIELD = function (_Field3) {
        _inherits$e(WEEK_OF_WEEK_BASED_YEAR_FIELD, _Field3);

        function WEEK_OF_WEEK_BASED_YEAR_FIELD() {
            _classCallCheck$s(this, WEEK_OF_WEEK_BASED_YEAR_FIELD);

            return _possibleConstructorReturn$e(this, _Field3.apply(this, arguments));
        }

        WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.toString = function toString() {
            return 'WeekOfWeekBasedYear';
        };

        WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.baseUnit = function baseUnit() {
            return ChronoUnit.WEEKS;
        };

        WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.rangeUnit = function rangeUnit() {
            return WEEK_BASED_YEARS;
        };

        WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.range = function range() {
            return ValueRange.of(1, 52, 53);
        };

        WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.isSupportedBy = function isSupportedBy(temporal) {
            return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
        };

        WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.rangeRefinedBy = function rangeRefinedBy(temporal) {
            if (temporal.isSupported(this) === false) {
                throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');
            }
            return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));
        };

        WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.getFrom = function getFrom(temporal) {
            if (temporal.isSupported(this) === false) {
                throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');
            }
            return Field._getWeek(LocalDate.from(temporal));
        };

        WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.adjustInto = function adjustInto(temporal, newValue) {
            this.range().checkValidValue(newValue, this);
            return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);
        };

        WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
            var wbyLong = fieldValues.get(WEEK_BASED_YEAR);
            var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);
            if (wbyLong == null || dowLong == null) {
                return null;
            }
            var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);
            var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);
            var date = void 0;
            if (resolverStyle === ResolverStyle.LENIENT) {
                var dow = dowLong;
                var weeks = 0;
                if (dow > 7) {
                    weeks = MathUtil.intDiv(dow - 1, 7);
                    dow = MathUtil.intMod(dow - 1, 7) + 1;
                } else if (dow < 1) {
                    weeks = MathUtil.intDiv(dow, 7) - 1;
                    dow = MathUtil.intMod(dow, 7) + 7;
                }
                date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);
            } else {
                var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);
                if (resolverStyle === ResolverStyle.STRICT) {
                    var temp = LocalDate.of(wby, 1, 4);
                    var range = Field._getWeekRangeByLocalDate(temp);
                    range.checkValidValue(wowby, this);
                } else {
                    this.range().checkValidValue(wowby, this);
                }
                date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);
            }
            fieldValues.remove(this);
            fieldValues.remove(WEEK_BASED_YEAR);
            fieldValues.remove(ChronoField.DAY_OF_WEEK);
            return date;
        };

        WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype.getDisplayName = function getDisplayName() {
            return 'Week';
        };

        return WEEK_OF_WEEK_BASED_YEAR_FIELD;
    }(Field);

    var WEEK_BASED_YEAR_FIELD = function (_Field4) {
        _inherits$e(WEEK_BASED_YEAR_FIELD, _Field4);

        function WEEK_BASED_YEAR_FIELD() {
            _classCallCheck$s(this, WEEK_BASED_YEAR_FIELD);

            return _possibleConstructorReturn$e(this, _Field4.apply(this, arguments));
        }

        WEEK_BASED_YEAR_FIELD.prototype.toString = function toString() {
            return 'WeekBasedYear';
        };

        WEEK_BASED_YEAR_FIELD.prototype.baseUnit = function baseUnit() {
            return WEEK_BASED_YEARS;
        };

        WEEK_BASED_YEAR_FIELD.prototype.rangeUnit = function rangeUnit() {
            return ChronoUnit.FOREVER;
        };

        WEEK_BASED_YEAR_FIELD.prototype.range = function range() {
            return ChronoField.YEAR.range();
        };

        WEEK_BASED_YEAR_FIELD.prototype.isSupportedBy = function isSupportedBy(temporal) {
            return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
        };

        WEEK_BASED_YEAR_FIELD.prototype.rangeRefinedBy = function rangeRefinedBy(temporal) {
            return ChronoField.YEAR.range();
        };

        WEEK_BASED_YEAR_FIELD.prototype.getFrom = function getFrom(temporal) {
            if (temporal.isSupported(this) === false) {
                throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');
            }
            return Field._getWeekBasedYear(LocalDate.from(temporal));
        };

        WEEK_BASED_YEAR_FIELD.prototype.adjustInto = function adjustInto(temporal, newValue) {
            if (this.isSupportedBy(temporal) === false) {
                throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');
            }
            var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);
            var date = LocalDate.from(temporal);
            var dow = date.get(ChronoField.DAY_OF_WEEK);
            var week = Field._getWeek(date);
            if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {
                week = 52;
            }
            var resolved = LocalDate.of(newWby, 1, 4);
            var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;
            resolved = resolved.plusDays(days);
            return temporal.with(resolved);
        };

        return WEEK_BASED_YEAR_FIELD;
    }(Field);

    var Unit = function (_TemporalUnit) {
        _inherits$e(Unit, _TemporalUnit);

        function Unit(name, estimatedDuration) {
            _classCallCheck$s(this, Unit);

            var _this6 = _possibleConstructorReturn$e(this, _TemporalUnit.call(this));

            _this6._name = name;
            _this6._duration = estimatedDuration;
            return _this6;
        }

        Unit.prototype.duration = function duration() {
            return this._duration;
        };

        Unit.prototype.isDurationEstimated = function isDurationEstimated() {
            return true;
        };

        Unit.prototype.isDateBased = function isDateBased() {
            return true;
        };

        Unit.prototype.isTimeBased = function isTimeBased() {
            return false;
        };

        Unit.prototype.isSupportedBy = function isSupportedBy(temporal) {
            return temporal.isSupported(ChronoField.EPOCH_DAY);
        };

        Unit.prototype.addTo = function addTo(temporal, periodToAdd) {
            switch (this) {
                case WEEK_BASED_YEARS:
                    {
                        var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);
                        return temporal.with(WEEK_BASED_YEAR, added);
                    }
                case QUARTER_YEARS:
                    return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);
                default:
                    throw new IllegalStateException('Unreachable');
            }
        };

        Unit.prototype.between = function between(temporal1, temporal2) {
            switch (this) {
                case WEEK_BASED_YEARS:
                    return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));
                case QUARTER_YEARS:
                    return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);
                default:
                    throw new IllegalStateException('Unreachable');
            }
        };

        Unit.prototype.toString = function toString() {
            return name;
        };

        return Unit;
    }(TemporalUnit);

    var DAY_OF_QUARTER = null;
    var QUARTER_OF_YEAR = null;
    var WEEK_OF_WEEK_BASED_YEAR = null;
    var WEEK_BASED_YEAR = null;
    var WEEK_BASED_YEARS = null;
    var QUARTER_YEARS = null;

    function _init$8() {
        DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();
        QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();
        WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();
        WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();

        WEEK_BASED_YEARS = new Unit('WeekBasedYears', Duration.ofSeconds(31556952));
        QUARTER_YEARS = new Unit('QuarterYears', Duration.ofSeconds(31556952 / 4));

        IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;
        IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;
        IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;
        IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;
        IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;
        IsoFields.QUARTER_YEARS = QUARTER_YEARS;

        LocalDate.prototype.isoWeekOfWeekyear = function () {
            return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);
        };

        LocalDate.prototype.isoWeekyear = function () {
            return this.get(IsoFields.WEEK_BASED_YEAR);
        };
    }

    function _classCallCheck$t(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    /**
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
     * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
     */

    var DecimalStyle = function () {
        function DecimalStyle(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {
            _classCallCheck$t(this, DecimalStyle);

            this._zeroDigit = zeroChar;
            this._zeroDigitCharCode = zeroChar.charCodeAt(0);
            this._positiveSign = positiveSignChar;
            this._negativeSign = negativeSignChar;
            this._decimalSeparator = decimalPointChar;
        }

        DecimalStyle.prototype.positiveSign = function positiveSign() {
            return this._positiveSign;
        };

        DecimalStyle.prototype.withPositiveSign = function withPositiveSign(positiveSign) {
            if (positiveSign === this._positiveSign) {
                return this;
            }
            return new DecimalStyle(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);
        };

        DecimalStyle.prototype.negativeSign = function negativeSign() {
            return this._negativeSign;
        };

        DecimalStyle.prototype.withNegativeSign = function withNegativeSign(negativeSign) {
            if (negativeSign === this._negativeSign) {
                return this;
            }
            return new DecimalStyle(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);
        };

        DecimalStyle.prototype.zeroDigit = function zeroDigit() {
            return this._zeroDigit;
        };

        DecimalStyle.prototype.withZeroDigit = function withZeroDigit(zeroDigit) {
            if (zeroDigit === this._zeroDigit) {
                return this;
            }
            return new DecimalStyle(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);
        };

        DecimalStyle.prototype.decimalSeparator = function decimalSeparator() {
            return this._decimalSeparator;
        };

        DecimalStyle.prototype.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {
            if (decimalSeparator === this._decimalSeparator) {
                return this;
            }
            return new DecimalStyle(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);
        };

        DecimalStyle.prototype.convertToDigit = function convertToDigit(char) {
            var val = char.charCodeAt(0) - this._zeroDigitCharCode;
            return val >= 0 && val <= 9 ? val : -1;
        };

        DecimalStyle.prototype.convertNumberToI18N = function convertNumberToI18N(numericText) {
            if (this._zeroDigit === '0') {
                return numericText;
            }
            var diff = this._zeroDigitCharCode - '0'.charCodeAt(0);
            var convertedText = '';
            for (var i = 0; i < numericText.length; i++) {
                convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);
            }
            return convertedText;
        };

        DecimalStyle.prototype.equals = function equals(other) {
            if (this === other) {
                return true;
            }
            if (other instanceof DecimalStyle) {
                return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;
            }
            return false;
        };

        DecimalStyle.prototype.hashCode = function hashCode() {
            return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;
        };

        DecimalStyle.prototype.toString = function toString() {
            return 'DecimalStyle[' + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + ']';
        };

        DecimalStyle.of = function of() {
            throw new Error('not yet supported');
        };

        DecimalStyle.availableLocales = function availableLocales() {
            throw new Error('not yet supported');
        };

        return DecimalStyle;
    }();

    DecimalStyle.STANDARD = new DecimalStyle('0', '+', '-', '.');

    function _classCallCheck$u(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$f(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$f(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var SignStyle = function (_Enum) {
        _inherits$f(SignStyle, _Enum);

        function SignStyle() {
            _classCallCheck$u(this, SignStyle);

            return _possibleConstructorReturn$f(this, _Enum.apply(this, arguments));
        }

        SignStyle.prototype.parse = function parse(positive, strict, fixedWidth) {
            switch (this) {
                case SignStyle.NORMAL:
                    return !positive || !strict;
                case SignStyle.ALWAYS:
                case SignStyle.EXCEEDS_PAD:
                    return true;
                default:
                    return !strict && !fixedWidth;
            }
        };

        return SignStyle;
    }(Enum);

    SignStyle.NORMAL = new SignStyle('NORMAL');
    SignStyle.NEVER = new SignStyle('NEVER');
    SignStyle.ALWAYS = new SignStyle('ALWAYS');
    SignStyle.EXCEEDS_PAD = new SignStyle('EXCEEDS_PAD');
    SignStyle.NOT_NEGATIVE = new SignStyle('NOT_NEGATIVE');

    function _classCallCheck$v(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$g(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$g(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var TextStyle = function (_Enum) {
        _inherits$g(TextStyle, _Enum);

        function TextStyle() {
            _classCallCheck$v(this, TextStyle);

            return _possibleConstructorReturn$g(this, _Enum.apply(this, arguments));
        }

        TextStyle.prototype.isStandalone = function isStandalone() {
            switch (this) {
                case TextStyle.FULL_STANDALONE:
                case TextStyle.SHORT_STANDALONE:
                case TextStyle.NARROW_STANDALONE:
                    return true;
                default:
                    return false;
            }
        };

        TextStyle.prototype.asStandalone = function asStandalone() {
            switch (this) {
                case TextStyle.FULL:
                    return TextStyle.FULL_STANDALONE;
                case TextStyle.SHORT:
                    return TextStyle.SHORT_STANDALONE;
                case TextStyle.NARROW:
                    return TextStyle.NARROW_STANDALONE;
                default:
                    return this;
            }
        };

        TextStyle.prototype.asNormal = function asNormal() {
            switch (this) {
                case TextStyle.FULL_STANDALONE:
                    return TextStyle.FULL;
                case TextStyle.SHORT_STANDALONE:
                    return TextStyle.SHORT;
                case TextStyle.NARROW_STANDALONE:
                    return TextStyle.NARROW;
                default:
                    return this;
            }
        };

        return TextStyle;
    }(Enum);

    TextStyle.FULL = new TextStyle('FULL');

    TextStyle.FULL_STANDALONE = new TextStyle('FULL_STANDALONE');

    TextStyle.SHORT = new TextStyle('SHORT');

    TextStyle.SHORT_STANDALONE = new TextStyle('SHORT_STANDALONE');

    TextStyle.NARROW = new TextStyle('NARROW');

    TextStyle.NARROW_STANDALONE = new TextStyle('NARROW_STANDALONE');

    function _classCallCheck$w(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var CharLiteralPrinterParser = function () {
        function CharLiteralPrinterParser(literal) {
            _classCallCheck$w(this, CharLiteralPrinterParser);

            if (literal.length > 1) {
                throw new IllegalArgumentException('invalid literal, too long: "' + literal + '"');
            }
            this._literal = literal;
        }

        CharLiteralPrinterParser.prototype.print = function print(context, buf) {
            buf.append(this._literal);
            return true;
        };

        CharLiteralPrinterParser.prototype.parse = function parse(context, text, position) {
            var length = text.length;
            if (position === length) {
                return ~position;
            }
            var ch = text.charAt(position);
            if (context.charEquals(this._literal, ch) === false) {
                return ~position;
            }
            return position + this._literal.length;
        };

        CharLiteralPrinterParser.prototype.toString = function toString() {
            if (this._literal === '\'') {
                return "''";
            }
            return "'" + this._literal + "'";
        };

        return CharLiteralPrinterParser;
    }();

    function _classCallCheck$x(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    /**
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
     * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
     */

    var CompositePrinterParser = function () {
        function CompositePrinterParser(printerParsers, optional) {
            _classCallCheck$x(this, CompositePrinterParser);

            this._printerParsers = printerParsers;
            this._optional = optional;
        }

        CompositePrinterParser.prototype.withOptional = function withOptional(optional) {
            if (optional === this._optional) {
                return this;
            }
            return new CompositePrinterParser(this._printerParsers, optional);
        };

        CompositePrinterParser.prototype.print = function print(context, buf) {
            var length = buf.length();
            if (this._optional) {
                context.startOptional();
            }
            try {
                for (var i = 0; i < this._printerParsers.length; i++) {
                    var pp = this._printerParsers[i];
                    if (pp.print(context, buf) === false) {
                        buf.setLength(length);
                        return true;
                    }
                }
            } finally {
                if (this._optional) {
                    context.endOptional();
                }
            }
            return true;
        };

        CompositePrinterParser.prototype.parse = function parse(context, text, position) {
            if (this._optional) {
                context.startOptional();
                var pos = position;
                for (var i = 0; i < this._printerParsers.length; i++) {
                    var pp = this._printerParsers[i];
                    pos = pp.parse(context, text, pos);
                    if (pos < 0) {
                        context.endOptional(false);
                        return position;
                    }
                }
                context.endOptional(true);
                return pos;
            } else {
                for (var _i = 0; _i < this._printerParsers.length; _i++) {
                    var _pp = this._printerParsers[_i];
                    position = _pp.parse(context, text, position);
                    if (position < 0) {
                        break;
                    }
                }
                return position;
            }
        };

        CompositePrinterParser.prototype.toString = function toString() {
            var buf = '';
            if (this._printerParsers != null) {
                buf += this._optional ? '[' : '(';
                for (var i = 0; i < this._printerParsers.length; i++) {
                    var pp = this._printerParsers[i];
                    buf += pp.toString();
                }
                buf += this._optional ? ']' : ')';
            }
            return buf;
        };

        return CompositePrinterParser;
    }();

    function _classCallCheck$y(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var FractionPrinterParser = function () {
        function FractionPrinterParser(field, minWidth, maxWidth, decimalPoint) {
            _classCallCheck$y(this, FractionPrinterParser);

            requireNonNull(field, 'field');
            if (field.range().isFixed() === false) {
                throw new IllegalArgumentException('Field must have a fixed set of values: ' + field);
            }
            if (minWidth < 0 || minWidth > 9) {
                throw new IllegalArgumentException('Minimum width must be from 0 to 9 inclusive but was ' + minWidth);
            }
            if (maxWidth < 1 || maxWidth > 9) {
                throw new IllegalArgumentException('Maximum width must be from 1 to 9 inclusive but was ' + maxWidth);
            }
            if (maxWidth < minWidth) {
                throw new IllegalArgumentException('Maximum width must exceed or equal the minimum width but ' + maxWidth + ' < ' + minWidth);
            }
            this.field = field;
            this.minWidth = minWidth;
            this.maxWidth = maxWidth;
            this.decimalPoint = decimalPoint;
        }

        FractionPrinterParser.prototype.print = function print(context, buf) {
            var value = context.getValue(this.field);
            if (value === null) {
                return false;
            }
            var symbols = context.symbols();
            if (value === 0) {
                if (this.minWidth > 0) {
                    if (this.decimalPoint) {
                        buf.append(symbols.decimalSeparator());
                    }
                    for (var i = 0; i < this.minWidth; i++) {
                        buf.append(symbols.zeroDigit());
                    }
                }
            } else {
                var fraction = this.convertToFraction(value, symbols.zeroDigit());
                var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);
                fraction = fraction.substr(0, outputScale);
                if (fraction * 1 > 0) {
                    while (fraction.length > this.minWidth && fraction[fraction.length - 1] === '0') {
                        fraction = fraction.substr(0, fraction.length - 1);
                    }
                }
                var str = fraction;
                str = symbols.convertNumberToI18N(str);
                if (this.decimalPoint) {
                    buf.append(symbols.decimalSeparator());
                }
                buf.append(str);
            }
            return true;
        };

        FractionPrinterParser.prototype.parse = function parse(context, text, position) {
            var effectiveMin = context.isStrict() ? this.minWidth : 0;
            var effectiveMax = context.isStrict() ? this.maxWidth : 9;
            var length = text.length;
            if (position === length) {
                return effectiveMin > 0 ? ~position : position;
            }
            if (this.decimalPoint) {
                if (text[position] !== context.symbols().decimalSeparator()) {
                    return effectiveMin > 0 ? ~position : position;
                }
                position++;
            }
            var minEndPos = position + effectiveMin;
            if (minEndPos > length) {
                return ~position;
            }
            var maxEndPos = Math.min(position + effectiveMax, length);
            var total = 0;
            var pos = position;
            while (pos < maxEndPos) {
                var ch = text.charAt(pos++);
                var digit = context.symbols().convertToDigit(ch);
                if (digit < 0) {
                    if (pos < minEndPos) {
                        return ~position;
                    }
                    pos--;
                    break;
                }
                total = total * 10 + digit;
            }
            var moveLeft = pos - position;
            var scale = Math.pow(10, moveLeft);
            var value = this.convertFromFraction(total, scale);
            return context.setParsedField(this.field, value, position, pos);
        };

        FractionPrinterParser.prototype.convertToFraction = function convertToFraction(value, zeroDigit) {
            var range = this.field.range();
            range.checkValidValue(value, this.field);
            var _min = range.minimum();
            var _range = range.maximum() - _min + 1;
            var _value = value - _min;
            var _scaled = MathUtil.intDiv(_value * 1000000000, _range);
            var fraction = '' + _scaled;
            while (fraction.length < 9) {
                fraction = zeroDigit + fraction;
            }
            return fraction;
        };

        FractionPrinterParser.prototype.convertFromFraction = function convertFromFraction(total, scale) {
            var range = this.field.range();
            var _min = range.minimum();
            var _range = range.maximum() - _min + 1;
            var _value = MathUtil.intDiv(total * _range, scale);
            return _value;
        };

        FractionPrinterParser.prototype.toString = function toString() {
            var decimal = this.decimalPoint ? ',DecimalPoint' : '';
            return 'Fraction(' + this.field + ',' + this.minWidth + ',' + this.maxWidth + decimal + ')';
        };

        return FractionPrinterParser;
    }();

    function _possibleConstructorReturn$h(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$h(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck$z(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var MAX_WIDTH = 15;

    var EXCEED_POINTS = [0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];

    var NumberPrinterParser = function () {
        function NumberPrinterParser(field, minWidth, maxWidth, signStyle) {
            var subsequentWidth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

            _classCallCheck$z(this, NumberPrinterParser);

            this._field = field;
            this._minWidth = minWidth;
            this._maxWidth = maxWidth;
            this._signStyle = signStyle;
            this._subsequentWidth = subsequentWidth;
        }

        NumberPrinterParser.prototype.field = function field() {
            return this._field;
        };

        NumberPrinterParser.prototype.minWidth = function minWidth() {
            return this._minWidth;
        };

        NumberPrinterParser.prototype.maxWidth = function maxWidth() {
            return this._maxWidth;
        };

        NumberPrinterParser.prototype.signStyle = function signStyle() {
            return this._signStyle;
        };

        NumberPrinterParser.prototype.withFixedWidth = function withFixedWidth() {
            if (this._subsequentWidth === -1) {
                return this;
            }
            return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);
        };

        NumberPrinterParser.prototype.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
            return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);
        };

        NumberPrinterParser.prototype._isFixedWidth = function _isFixedWidth() {
            return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;
        };

        NumberPrinterParser.prototype.print = function print(context, buf) {
            var contextValue = context.getValue(this._field);
            if (contextValue == null) {
                return false;
            }
            var value = this._getValue(context, contextValue);
            var symbols = context.symbols();
            var str = '' + Math.abs(value);
            if (str.length > this._maxWidth) {
                throw new DateTimeException('Field ' + this._field + ' cannot be printed as the value ' + value + ' exceeds the maximum print width of ' + this._maxWidth);
            }
            str = symbols.convertNumberToI18N(str);

            if (value >= 0) {
                switch (this._signStyle) {
                    case SignStyle.EXCEEDS_PAD:
                        if (this._minWidth < MAX_WIDTH && value >= EXCEED_POINTS[this._minWidth]) {
                            buf.append(symbols.positiveSign());
                        }
                        break;
                    case SignStyle.ALWAYS:
                        buf.append(symbols.positiveSign());
                        break;
                }
            } else {
                switch (this._signStyle) {
                    case SignStyle.NORMAL:
                    case SignStyle.EXCEEDS_PAD:
                    case SignStyle.ALWAYS:
                        buf.append(symbols.negativeSign());
                        break;
                    case SignStyle.NOT_NEGATIVE:
                        throw new DateTimeException('Field ' + this._field + ' cannot be printed as the value ' + value + ' cannot be negative according to the SignStyle');
                }
            }
            for (var i = 0; i < this._minWidth - str.length; i++) {
                buf.append(symbols.zeroDigit());
            }
            buf.append(str);
            return true;
        };

        NumberPrinterParser.prototype.parse = function parse(context, text, position) {
            var length = text.length;
            if (position === length) {
                return ~position;
            }
            assert(position >= 0 && position < length);
            var sign = text.charAt(position);
            var negative = false;
            var positive = false;
            if (sign === context.symbols().positiveSign()) {
                if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {
                    return ~position;
                }
                positive = true;
                position++;
            } else if (sign === context.symbols().negativeSign()) {
                if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {
                    return ~position;
                }
                negative = true;
                position++;
            } else {
                if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {
                    return ~position;
                }
            }
            var effMinWidth = context.isStrict() || this._isFixedWidth() ? this._minWidth : 1;
            var minEndPos = position + effMinWidth;
            if (minEndPos > length) {
                return ~position;
            }
            var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);
            var total = 0;
            var pos = position;
            for (var pass = 0; pass < 2; pass++) {
                var maxEndPos = Math.min(pos + effMaxWidth, length);
                while (pos < maxEndPos) {
                    var ch = text.charAt(pos++);
                    var digit = context.symbols().convertToDigit(ch);
                    if (digit < 0) {
                        pos--;
                        if (pos < minEndPos) {
                            return ~position;
                        }
                        break;
                    }
                    if (pos - position > MAX_WIDTH) {
                        throw new ArithmeticException('number text exceeds length');
                    } else {
                        total = total * 10 + digit;
                    }
                }
                if (this._subsequentWidth > 0 && pass === 0) {
                    var parseLen = pos - position;
                    effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);
                    pos = position;
                    total = 0;
                } else {
                    break;
                }
            }
            if (negative) {
                if (total === 0 && context.isStrict()) {
                    return ~(position - 1);
                }
                if (total !== 0) {
                    total = -total;
                }
            } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {
                var _parseLen = pos - position;
                if (positive) {
                    if (_parseLen <= this._minWidth) {
                        return ~(position - 1);
                    }
                } else {
                    if (_parseLen > this._minWidth) {
                        return ~position;
                    }
                }
            }
            return this._setValue(context, total, position, pos);
        };

        NumberPrinterParser.prototype._getValue = function _getValue(context, value) {
            return value;
        };

        NumberPrinterParser.prototype._setValue = function _setValue(context, value, errorPos, successPos) {
            return context.setParsedField(this._field, value, errorPos, successPos);
        };

        NumberPrinterParser.prototype.toString = function toString() {
            if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH && this._signStyle === SignStyle.NORMAL) {
                return 'Value(' + this._field + ')';
            }
            if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {
                return 'Value(' + this._field + ',' + this._minWidth + ')';
            }
            return 'Value(' + this._field + ',' + this._minWidth + ',' + this._maxWidth + ',' + this._signStyle + ')';
        };

        return NumberPrinterParser;
    }();

    var ReducedPrinterParser = function (_NumberPrinterParser) {
        _inherits$h(ReducedPrinterParser, _NumberPrinterParser);

        function ReducedPrinterParser(field, width, maxWidth, baseValue, baseDate) {
            _classCallCheck$z(this, ReducedPrinterParser);

            var _this = _possibleConstructorReturn$h(this, _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE));

            if (width < 1 || width > 10) {
                throw new IllegalArgumentException('The width must be from 1 to 10 inclusive but was ' + width);
            }
            if (maxWidth < 1 || maxWidth > 10) {
                throw new IllegalArgumentException('The maxWidth must be from 1 to 10 inclusive but was ' + maxWidth);
            }
            if (maxWidth < width) {
                throw new IllegalArgumentException('The maxWidth must be greater than the width');
            }
            if (baseDate === null) {
                if (field.range().isValidValue(baseValue) === false) {
                    throw new IllegalArgumentException('The base value must be within the range of the field');
                }
                if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {
                    throw new DateTimeException('Unable to add printer-parser as the range exceeds the capacity of an int');
                }
            }
            _this._baseValue = baseValue;
            _this._baseDate = baseDate;
            return _this;
        }

        ReducedPrinterParser.prototype._getValue = function _getValue(context, value) {
            var absValue = Math.abs(value);
            var baseValue = this._baseValue;
            if (this._baseDate !== null) {
                context.temporal();
                var chrono = IsoChronology.INSTANCE;
                baseValue = chrono.date(this._baseDate).get(this._field);
            }
            if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {
                return absValue % EXCEED_POINTS[this._minWidth];
            }
            return absValue % EXCEED_POINTS[this._maxWidth];
        };

        ReducedPrinterParser.prototype._setValue = function _setValue(context, value, errorPos, successPos) {
            var baseValue = this._baseValue;
            if (this._baseDate != null) {
                var chrono = context.getEffectiveChronology();
                baseValue = chrono.date(this._baseDate).get(this._field);
            }
            var parseLen = successPos - errorPos;
            if (parseLen === this._minWidth && value >= 0) {
                var range = EXCEED_POINTS[this._minWidth];
                var lastPart = baseValue % range;
                var basePart = baseValue - lastPart;
                if (baseValue > 0) {
                    value = basePart + value;
                } else {
                    value = basePart - value;
                }
                if (value < baseValue) {
                    value += range;
                }
            }
            return context.setParsedField(this._field, value, errorPos, successPos);
        };

        ReducedPrinterParser.prototype.withFixedWidth = function withFixedWidth() {
            if (this._subsequentWidth === -1) {
                return this;
            }
            return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, -1);
        };

        ReducedPrinterParser.prototype.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
            return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);
        };

        ReducedPrinterParser.prototype.isFixedWidth = function isFixedWidth(context) {
            if (context.isStrict() === false) {
                return false;
            }
            return _NumberPrinterParser.prototype.isFixedWidth.call(this, context);
        };

        ReducedPrinterParser.prototype.toString = function toString() {
            return 'ReducedValue(' + this._field + ',' + this._minWidth + ',' + this._maxWidth + ',' + (this._baseDate != null ? this._baseDate : this._baseValue) + ')';
        };

        return ReducedPrinterParser;
    }(NumberPrinterParser);

    function _classCallCheck$A(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var PATTERNS = ['+HH', '+HHmm', '+HH:mm', '+HHMM', '+HH:MM', '+HHMMss', '+HH:MM:ss', '+HHMMSS', '+HH:MM:SS'];

    var OffsetIdPrinterParser = function () {
        function OffsetIdPrinterParser(noOffsetText, pattern) {
            _classCallCheck$A(this, OffsetIdPrinterParser);

            requireNonNull(noOffsetText, 'noOffsetText');
            requireNonNull(pattern, 'pattern');
            this.noOffsetText = noOffsetText;
            this.type = this._checkPattern(pattern);
        }

        OffsetIdPrinterParser.prototype._checkPattern = function _checkPattern(pattern) {
            for (var i = 0; i < PATTERNS.length; i++) {
                if (PATTERNS[i] === pattern) {
                    return i;
                }
            }
            throw new IllegalArgumentException('Invalid zone offset pattern: ' + pattern);
        };

        OffsetIdPrinterParser.prototype.print = function print(context, buf) {
            var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);
            if (offsetSecs == null) {
                return false;
            }
            var totalSecs = MathUtil.safeToInt(offsetSecs);
            if (totalSecs === 0) {
                buf.append(this.noOffsetText);
            } else {
                var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));
                var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));
                var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));
                var bufPos = buf.length();
                var output = absHours;
                buf.append(totalSecs < 0 ? '-' : '+').appendChar(MathUtil.intDiv(absHours, 10) + '0').appendChar(MathUtil.intMod(absHours, 10) + '0');
                if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {
                    buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absMinutes, 10) + '0').appendChar(absMinutes % 10 + '0');
                    output += absMinutes;
                    if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {
                        buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absSeconds, 10) + '0').appendChar(absSeconds % 10 + '0');
                        output += absSeconds;
                    }
                }
                if (output === 0) {
                    buf.setLength(bufPos);
                    buf.append(this.noOffsetText);
                }
            }
            return true;
        };

        OffsetIdPrinterParser.prototype.parse = function parse(context, text, position) {
            var length = text.length;
            var noOffsetLen = this.noOffsetText.length;
            if (noOffsetLen === 0) {
                if (position === length) {
                    return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);
                }
            } else {
                if (position === length) {
                    return ~position;
                }
                if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {
                    return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
                }
            }

            var sign = text[position];
            if (sign === '+' || sign === '-') {
                var negative = sign === '-' ? -1 : 1;
                var array = [0, 0, 0, 0];
                array[0] = position + 1;
                if ((this._parseNumber(array, 1, text, true) || this._parseNumber(array, 2, text, this.type >= 3) || this._parseNumber(array, 3, text, false)) === false) {
                    var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));
                    return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);
                }
            }

            if (noOffsetLen === 0) {
                return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
            }
            return ~position;
        };

        OffsetIdPrinterParser.prototype._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {
            if ((this.type + 3) / 2 < arrayIndex) {
                return false;
            }
            var pos = array[0];
            if (this.type % 2 === 0 && arrayIndex > 1) {
                if (pos + 1 > parseText.length || parseText[pos] !== ':') {
                    return required;
                }
                pos++;
            }
            if (pos + 2 > parseText.length) {
                return required;
            }
            var ch1 = parseText[pos++];
            var ch2 = parseText[pos++];
            if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {
                return required;
            }
            var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
            if (value < 0 || value > 59) {
                return required;
            }
            array[arrayIndex] = value;
            array[0] = pos;
            return false;
        };

        OffsetIdPrinterParser.prototype.toString = function toString() {
            var converted = this.noOffsetText.replace('\'', '\'\'');
            return 'Offset(' + PATTERNS[this.type] + ',\'' + converted + '\')';
        };

        return OffsetIdPrinterParser;
    }();
    OffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser('Z', '+HH:MM:ss');
    OffsetIdPrinterParser.PATTERNS = PATTERNS;

    function _classCallCheck$B(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var PadPrinterParserDecorator = function () {
        function PadPrinterParserDecorator(printerParser, padWidth, padChar) {
            _classCallCheck$B(this, PadPrinterParserDecorator);

            this._printerParser = printerParser;
            this._padWidth = padWidth;
            this._padChar = padChar;
        }

        PadPrinterParserDecorator.prototype.print = function print(context, buf) {
            var preLen = buf.length();
            if (this._printerParser.print(context, buf) === false) {
                return false;
            }
            var len = buf.length() - preLen;
            if (len > this._padWidth) {
                throw new DateTimeException('Cannot print as output of ' + len + ' characters exceeds pad width of ' + this._padWidth);
            }
            for (var i = 0; i < this._padWidth - len; i++) {
                buf.insert(preLen, this._padChar);
            }
            return true;
        };

        PadPrinterParserDecorator.prototype.parse = function parse(context, text, position) {
            var strict = context.isStrict();
            var caseSensitive = context.isCaseSensitive();

            assert(!(position > text.length));
            assert(position >= 0);
            if (position === text.length) {
                return ~position;
            }
            var endPos = position + this._padWidth;
            if (endPos > text.length) {
                if (strict) {
                    return ~position;
                }
                endPos = text.length;
            }
            var pos = position;
            while (pos < endPos && (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {
                pos++;
            }
            text = text.substring(0, endPos);
            var resultPos = this._printerParser.parse(context, text, pos);
            if (resultPos !== endPos && strict) {
                return ~(position + pos);
            }
            return resultPos;
        };

        PadPrinterParserDecorator.prototype.toString = function toString() {
            return 'Pad(' + this._printerParser + ',' + this._padWidth + (this._padChar === ' ' ? ')' : ',\'' + this._padChar + '\')');
        };

        return PadPrinterParserDecorator;
    }();

    function _classCallCheck$C(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$i(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$i(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var SettingsParser = function (_Enum) {
        _inherits$i(SettingsParser, _Enum);

        function SettingsParser() {
            _classCallCheck$C(this, SettingsParser);

            return _possibleConstructorReturn$i(this, _Enum.apply(this, arguments));
        }

        SettingsParser.prototype.print = function print() {
            return true;
        };

        SettingsParser.prototype.parse = function parse(context, text, position) {
            switch (this) {
                case SettingsParser.SENSITIVE:
                    context.setCaseSensitive(true);break;
                case SettingsParser.INSENSITIVE:
                    context.setCaseSensitive(false);break;
                case SettingsParser.STRICT:
                    context.setStrict(true);break;
                case SettingsParser.LENIENT:
                    context.setStrict(false);break;
            }
            return position;
        };

        SettingsParser.prototype.toString = function toString() {
            switch (this) {
                case SettingsParser.SENSITIVE:
                    return 'ParseCaseSensitive(true)';
                case SettingsParser.INSENSITIVE:
                    return 'ParseCaseSensitive(false)';
                case SettingsParser.STRICT:
                    return 'ParseStrict(true)';
                case SettingsParser.LENIENT:
                    return 'ParseStrict(false)';
            }
        };

        return SettingsParser;
    }(Enum);

    SettingsParser.SENSITIVE = new SettingsParser('SENSITIVE');
    SettingsParser.INSENSITIVE = new SettingsParser('INSENSITIVE');
    SettingsParser.STRICT = new SettingsParser('STRICT');
    SettingsParser.LENIENT = new SettingsParser('LENIENT');

    function _classCallCheck$D(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var StringLiteralPrinterParser = function () {
        function StringLiteralPrinterParser(literal) {
            _classCallCheck$D(this, StringLiteralPrinterParser);

            this._literal = literal;
        }

        StringLiteralPrinterParser.prototype.print = function print(context, buf) {
            buf.append(this._literal);
            return true;
        };

        StringLiteralPrinterParser.prototype.parse = function parse(context, text, position) {
            var length = text.length;
            assert(!(position > length || position < 0));

            if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {
                return ~position;
            }
            return position + this._literal.length;
        };

        StringLiteralPrinterParser.prototype.toString = function toString() {
            var converted = this._literal.replace("'", "''");
            return '\'' + converted + '\'';
        };

        return StringLiteralPrinterParser;
    }();

    function _classCallCheck$E(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var ZoneRulesProvider = function () {
      function ZoneRulesProvider() {
        _classCallCheck$E(this, ZoneRulesProvider);
      }

      ZoneRulesProvider.getRules = function getRules(zoneId) {
        throw new DateTimeException('unsupported ZoneId:' + zoneId);
      };

      ZoneRulesProvider.getAvailableZoneIds = function getAvailableZoneIds() {
        return [];
      };

      return ZoneRulesProvider;
    }();

    function _classCallCheck$F(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$j(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$j(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ZoneRegion = function (_ZoneId) {
      _inherits$j(ZoneRegion, _ZoneId);

      ZoneRegion.ofId = function ofId(zoneId) {
        var rules = ZoneRulesProvider.getRules(zoneId);
        return new ZoneRegion(zoneId, rules);
      };

      function ZoneRegion(id, rules) {
        _classCallCheck$F(this, ZoneRegion);

        var _this = _possibleConstructorReturn$j(this, _ZoneId.call(this));

        _this._id = id;
        _this._rules = rules;
        return _this;
      }

      ZoneRegion.prototype.id = function id() {
        return this._id;
      };

      ZoneRegion.prototype.rules = function rules() {
        return this._rules;
      };

      return ZoneRegion;
    }(ZoneId);

    function _classCallCheck$G(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var ZoneIdPrinterParser = function () {
        function ZoneIdPrinterParser(query, description) {
            _classCallCheck$G(this, ZoneIdPrinterParser);

            this.query = query;
            this.description = description;
        }

        ZoneIdPrinterParser.prototype.print = function print(context, buf) {
            var zone = context.getValueQuery(this.query);
            if (zone == null) {
                return false;
            }
            buf.append(zone.id());
            return true;
        };

        ZoneIdPrinterParser.prototype.parse = function parse(context, text, position) {
            var length = text.length;
            if (position > length) {
                return ~position;
            }
            if (position === length) {
                return ~position;
            }

            var nextChar = text.charAt(position);
            if (nextChar === '+' || nextChar === '-') {
                var newContext = context.copy();
                var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
                if (endPos < 0) {
                    return endPos;
                }
                var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);
                var zone = ZoneOffset.ofTotalSeconds(offset);
                context.setParsedZone(zone);
                return endPos;
            } else if (length >= position + 2) {
                var nextNextChar = text.charAt(position + 1);
                if (context.charEquals(nextChar, 'U') && context.charEquals(nextNextChar, 'T')) {
                    if (length >= position + 3 && context.charEquals(text.charAt(position + 2), 'C')) {
                        return this._parsePrefixedOffset(context, text, position, position + 3);
                    }
                    return this._parsePrefixedOffset(context, text, position, position + 2);
                } else if (context.charEquals(nextChar, 'G') && length >= position + 3 && context.charEquals(nextNextChar, 'M') && context.charEquals(text.charAt(position + 2), 'T')) {
                    return this._parsePrefixedOffset(context, text, position, position + 3);
                }
            }

            if (text.substr(position, 6) === 'SYSTEM') {
                context.setParsedZone(ZoneId.systemDefault());
                return position + 6;
            }

            if (context.charEquals(nextChar, 'Z')) {
                context.setParsedZone(ZoneOffset.UTC);
                return position + 1;
            }

            var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();
            if (zoneIdTree.size !== availableZoneIds.length) {
                zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);
            }

            var maxParseLength = length - position;
            var treeMap = zoneIdTree.treeMap;
            var parsedZoneId = null;
            var parseLength = 0;
            while (treeMap != null) {
                var parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));
                treeMap = treeMap.get(parsedSubZoneId);
                if (treeMap != null && treeMap.isLeaf) {
                    parsedZoneId = parsedSubZoneId;
                    parseLength = treeMap.length;
                }
            }
            if (parsedZoneId != null) {
                context.setParsedZone(ZoneRegion.ofId(parsedZoneId));
                return position + parseLength;
            }

            return ~position;
        };

        ZoneIdPrinterParser.prototype._parsePrefixedOffset = function _parsePrefixedOffset(context, text, prefixPos, position) {
            var prefix = text.substring(prefixPos, position).toUpperCase();
            var newContext = context.copy();
            if (position < text.length && context.charEquals(text.charAt(position), 'Z')) {
                context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
                return position;
            }
            var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
            if (endPos < 0) {
                context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
                return position;
            }
            var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);
            var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
            context.setParsedZone(ZoneId.ofOffset(prefix, offset));
            return endPos;
        };

        ZoneIdPrinterParser.prototype.toString = function toString() {
            return this.description;
        };

        return ZoneIdPrinterParser;
    }();

    var ZoneIdTree = function () {
        ZoneIdTree.createTreeMap = function createTreeMap(availableZoneIds) {
            var sortedZoneIds = availableZoneIds.sort(function (a, b) {
                return a.length - b.length;
            });
            var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);
            for (var i = 0; i < sortedZoneIds.length; i++) {
                treeMap.add(sortedZoneIds[i]);
            }
            return new ZoneIdTree(sortedZoneIds.length, treeMap);
        };

        function ZoneIdTree(size, treeMap) {
            _classCallCheck$G(this, ZoneIdTree);

            this.size = size;
            this.treeMap = treeMap;
        }

        return ZoneIdTree;
    }();

    var ZoneIdTreeMap = function () {
        function ZoneIdTreeMap() {
            var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var isLeaf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            _classCallCheck$G(this, ZoneIdTreeMap);

            this.length = length;
            this.isLeaf = isLeaf;
            this._treeMap = {};
        }

        ZoneIdTreeMap.prototype.add = function add(zoneId) {
            var idLength = zoneId.length;
            if (idLength === this.length) {
                this._treeMap[zoneId] = new ZoneIdTreeMap(idLength, true);
            } else if (idLength > this.length) {
                var subZoneId = zoneId.substr(0, this.length);
                var subTreeMap = this._treeMap[subZoneId];
                if (subTreeMap == null) {
                    subTreeMap = new ZoneIdTreeMap(idLength, false);
                    this._treeMap[subZoneId] = subTreeMap;
                }
                subTreeMap.add(zoneId);
            }
        };

        ZoneIdTreeMap.prototype.get = function get(zoneId) {
            return this._treeMap[zoneId];
        };

        return ZoneIdTreeMap;
    }();

    var zoneIdTree = new ZoneIdTree([]);

    function _classCallCheck$H(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var MAX_WIDTH$1 = 15;

    var DateTimeFormatterBuilder = function () {
        function DateTimeFormatterBuilder() {
            _classCallCheck$H(this, DateTimeFormatterBuilder);

            this._active = this;

            this._parent = null;

            this._printerParsers = [];

            this._optional = false;

            this._padNextWidth = 0;

            this._padNextChar = null;

            this._valueParserIndex = -1;
        }

        DateTimeFormatterBuilder._of = function _of(parent, optional) {
            requireNonNull(parent, 'parent');
            requireNonNull(optional, 'optional');

            var dtFormatterBuilder = new DateTimeFormatterBuilder();
            dtFormatterBuilder._parent = parent;
            dtFormatterBuilder._optional = optional;

            return dtFormatterBuilder;
        };

        DateTimeFormatterBuilder.prototype.parseCaseSensitive = function parseCaseSensitive() {
            this._appendInternalPrinterParser(SettingsParser.SENSITIVE);
            return this;
        };

        DateTimeFormatterBuilder.prototype.parseCaseInsensitive = function parseCaseInsensitive() {
            this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);
            return this;
        };

        DateTimeFormatterBuilder.prototype.parseStrict = function parseStrict() {
            this._appendInternalPrinterParser(SettingsParser.STRICT);
            return this;
        };

        DateTimeFormatterBuilder.prototype.parseLenient = function parseLenient() {
            this._appendInternalPrinterParser(SettingsParser.LENIENT);
            return this;
        };

        DateTimeFormatterBuilder.prototype.appendValue = function appendValue() {
            if (arguments.length === 1) {
                return this._appendValue1.apply(this, arguments);
            } else if (arguments.length === 2) {
                return this._appendValue2.apply(this, arguments);
            } else {
                return this._appendValue4.apply(this, arguments);
            }
        };

        DateTimeFormatterBuilder.prototype._appendValue1 = function _appendValue1(field) {
            requireNonNull(field);
            this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH$1, SignStyle.NORMAL));
            return this;
        };

        DateTimeFormatterBuilder.prototype._appendValue2 = function _appendValue2(field, width) {
            requireNonNull(field);
            if (width < 1 || width > MAX_WIDTH$1) {
                throw new IllegalArgumentException('The width must be from 1 to ' + MAX_WIDTH$1 + ' inclusive but was ' + width);
            }
            var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);
            this._appendValuePrinterParser(pp);
            return this;
        };

        DateTimeFormatterBuilder.prototype._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {
            requireNonNull(field);
            requireNonNull(signStyle);
            if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {
                return this._appendValue2(field, maxWidth);
            }
            if (minWidth < 1 || minWidth > MAX_WIDTH$1) {
                throw new IllegalArgumentException('The minimum width must be from 1 to ' + MAX_WIDTH$1 + ' inclusive but was ' + minWidth);
            }
            if (maxWidth < 1 || maxWidth > MAX_WIDTH$1) {
                throw new IllegalArgumentException('The minimum width must be from 1 to ' + MAX_WIDTH$1 + ' inclusive but was ' + maxWidth);
            }
            if (maxWidth < minWidth) {
                throw new IllegalArgumentException('The maximum width must exceed or equal the minimum width but ' + maxWidth + ' < ' + minWidth);
            }
            var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);
            this._appendValuePrinterParser(pp);
            return this;
        };

        DateTimeFormatterBuilder.prototype.appendValueReduced = function appendValueReduced() {
            if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {
                return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);
            } else {
                return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);
            }
        };

        DateTimeFormatterBuilder.prototype._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {
            requireNonNull(field, 'field');
            var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);
            this._appendValuePrinterParser(pp);
            return this;
        };

        DateTimeFormatterBuilder.prototype._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {
            requireNonNull(field, 'field');
            requireNonNull(baseDate, 'baseDate');
            requireInstance(baseDate, ChronoLocalDate, 'baseDate');
            var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);
            this._appendValuePrinterParser(pp);
            return this;
        };

        DateTimeFormatterBuilder.prototype._appendValuePrinterParser = function _appendValuePrinterParser(pp) {
            assert(pp != null);
            if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {
                var activeValueParser = this._active._valueParserIndex;

                var basePP = this._active._printerParsers[activeValueParser];
                if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {
                    basePP = basePP.withSubsequentWidth(pp.maxWidth());

                    this._appendInternal(pp.withFixedWidth());

                    this._active._valueParserIndex = activeValueParser;
                } else {
                    basePP = basePP.withFixedWidth();

                    this._active._valueParserIndex = this._appendInternal(pp);
                }

                this._active._printerParsers[activeValueParser] = basePP;
            } else {
                this._active._valueParserIndex = this._appendInternal(pp);
            }
            return this;
        };

        DateTimeFormatterBuilder.prototype.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {
            this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));
            return this;
        };

        DateTimeFormatterBuilder.prototype.appendInstant = function appendInstant() {
            var fractionalDigits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -2;

            if (fractionalDigits < -2 || fractionalDigits > 9) {
                throw new IllegalArgumentException('Invalid fractional digits: ' + fractionalDigits);
            }
            this._appendInternal(new InstantPrinterParser(fractionalDigits));
            return this;
        };

        DateTimeFormatterBuilder.prototype.appendOffsetId = function appendOffsetId() {
            this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);
            return this;
        };

        DateTimeFormatterBuilder.prototype.appendOffset = function appendOffset(pattern, noOffsetText) {
            this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));
            return this;
        };

        DateTimeFormatterBuilder.prototype.appendZoneId = function appendZoneId() {
            this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), 'ZoneId()'));
            return this;
        };

        DateTimeFormatterBuilder.prototype.appendPattern = function appendPattern(pattern) {
            requireNonNull(pattern, 'pattern');
            this._parsePattern(pattern);
            return this;
        };

        DateTimeFormatterBuilder.prototype.appendZoneText = function appendZoneText() {
            throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');
        };

        DateTimeFormatterBuilder.prototype.appendText = function appendText() {
            throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');
        };

        DateTimeFormatterBuilder.prototype.appendLocalizedOffset = function appendLocalizedOffset() {
            throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');
        };

        DateTimeFormatterBuilder.prototype.appendWeekField = function appendWeekField() {
            throw new IllegalArgumentException('Pattern using (localized) text not implemented, use js-joda-locale plugin!');
        };

        DateTimeFormatterBuilder.prototype._parsePattern = function _parsePattern(pattern) {
            var FIELD_MAP = {
                'G': ChronoField.ERA,
                'y': ChronoField.YEAR_OF_ERA,
                'u': ChronoField.YEAR,
                'Q': IsoFields.QUARTER_OF_YEAR,
                'q': IsoFields.QUARTER_OF_YEAR,
                'M': ChronoField.MONTH_OF_YEAR,
                'L': ChronoField.MONTH_OF_YEAR,
                'D': ChronoField.DAY_OF_YEAR,
                'd': ChronoField.DAY_OF_MONTH,
                'F': ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,
                'E': ChronoField.DAY_OF_WEEK,
                'c': ChronoField.DAY_OF_WEEK,
                'e': ChronoField.DAY_OF_WEEK,
                'a': ChronoField.AMPM_OF_DAY,
                'H': ChronoField.HOUR_OF_DAY,
                'k': ChronoField.CLOCK_HOUR_OF_DAY,
                'K': ChronoField.HOUR_OF_AMPM,
                'h': ChronoField.CLOCK_HOUR_OF_AMPM,
                'm': ChronoField.MINUTE_OF_HOUR,
                's': ChronoField.SECOND_OF_MINUTE,
                'S': ChronoField.NANO_OF_SECOND,
                'A': ChronoField.MILLI_OF_DAY,
                'n': ChronoField.NANO_OF_SECOND,
                'N': ChronoField.NANO_OF_DAY
            };

            for (var pos = 0; pos < pattern.length; pos++) {
                var cur = pattern.charAt(pos);
                if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {
                    var start = pos++;
                    for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) {}
                    var count = pos - start;

                    if (cur === 'p') {
                        var pad = 0;
                        if (pos < pattern.length) {
                            cur = pattern.charAt(pos);
                            if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {
                                pad = count;
                                start = pos++;
                                for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) {}
                                count = pos - start;
                            }
                        }
                        if (pad === 0) {
                            throw new IllegalArgumentException('Pad letter \'p\' must be followed by valid pad pattern: ' + pattern);
                        }
                        this.padNext(pad);
                    }

                    var field = FIELD_MAP[cur];
                    if (field != null) {
                        this._parseField(cur, count, field);
                    } else if (cur === 'z') {
                        if (count > 4) {
                            throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                        } else if (count === 4) {
                            this.appendZoneText(TextStyle.FULL);
                        } else {
                            this.appendZoneText(TextStyle.SHORT);
                        }
                    } else if (cur === 'V') {
                        if (count !== 2) {
                            throw new IllegalArgumentException('Pattern letter count must be 2: ' + cur);
                        }
                        this.appendZoneId();
                    } else if (cur === 'Z') {
                        if (count < 4) {
                            this.appendOffset('+HHMM', '+0000');
                        } else if (count === 4) {
                            this.appendLocalizedOffset(TextStyle.FULL);
                        } else if (count === 5) {
                            this.appendOffset('+HH:MM:ss', 'Z');
                        } else {
                            throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                        }
                    } else if (cur === 'O') {
                        if (count === 1) {
                            this.appendLocalizedOffset(TextStyle.SHORT);
                        } else if (count === 4) {
                            this.appendLocalizedOffset(TextStyle.FULL);
                        } else {
                            throw new IllegalArgumentException('Pattern letter count must be 1 or 4: ' + cur);
                        }
                    } else if (cur === 'X') {
                        if (count > 5) {
                            throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                        }
                        this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], 'Z');
                    } else if (cur === 'x') {
                        if (count > 5) {
                            throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                        }
                        var zero = count === 1 ? '+00' : count % 2 === 0 ? '+0000' : '+00:00';
                        this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);
                    } else if (cur === 'W') {
                        if (count > 1) {
                            throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                        }
                        this.appendWeekField('W', count);
                    } else if (cur === 'w') {
                        if (count > 2) {
                            throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                        }
                        this.appendWeekField('w', count);
                    } else if (cur === 'Y') {
                        this.appendWeekField('Y', count);
                    } else {
                        throw new IllegalArgumentException('Unknown pattern letter: ' + cur);
                    }
                    pos--;
                } else if (cur === '\'') {
                    var _start = pos++;
                    for (; pos < pattern.length; pos++) {
                        if (pattern.charAt(pos) === '\'') {
                            if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === '\'') {
                                pos++;
                            } else {
                                break;
                            }
                        }
                    }
                    if (pos >= pattern.length) {
                        throw new IllegalArgumentException('Pattern ends with an incomplete string literal: ' + pattern);
                    }
                    var str = pattern.substring(_start + 1, pos);
                    if (str.length === 0) {
                        this.appendLiteral('\'');
                    } else {
                        this.appendLiteral(str.replace('\'\'', '\''));
                    }
                } else if (cur === '[') {
                    this.optionalStart();
                } else if (cur === ']') {
                    if (this._active._parent === null) {
                        throw new IllegalArgumentException('Pattern invalid as it contains ] without previous [');
                    }
                    this.optionalEnd();
                } else if (cur === '{' || cur === '}' || cur === '#') {
                    throw new IllegalArgumentException('Pattern includes reserved character: \'' + cur + '\'');
                } else {
                    this.appendLiteral(cur);
                }
            }
        };

        DateTimeFormatterBuilder.prototype._parseField = function _parseField(cur, count, field) {
            switch (cur) {
                case 'u':
                case 'y':
                    if (count === 2) {
                        this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);
                    } else if (count < 4) {
                        this.appendValue(field, count, MAX_WIDTH$1, SignStyle.NORMAL);
                    } else {
                        this.appendValue(field, count, MAX_WIDTH$1, SignStyle.EXCEEDS_PAD);
                    }
                    break;
                case 'M':
                case 'Q':
                    switch (count) {
                        case 1:
                            this.appendValue(field);
                            break;
                        case 2:
                            this.appendValue(field, 2);
                            break;
                        case 3:
                            this.appendText(field, TextStyle.SHORT);
                            break;
                        case 4:
                            this.appendText(field, TextStyle.FULL);
                            break;
                        case 5:
                            this.appendText(field, TextStyle.NARROW);
                            break;
                        default:
                            throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                    }
                    break;
                case 'L':
                case 'q':
                    switch (count) {
                        case 1:
                            this.appendValue(field);
                            break;
                        case 2:
                            this.appendValue(field, 2);
                            break;
                        case 3:
                            this.appendText(field, TextStyle.SHORT_STANDALONE);
                            break;
                        case 4:
                            this.appendText(field, TextStyle.FULL_STANDALONE);
                            break;
                        case 5:
                            this.appendText(field, TextStyle.NARROW_STANDALONE);
                            break;
                        default:
                            throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                    }
                    break;
                case 'e':
                    switch (count) {
                        case 1:
                        case 2:
                            this.appendWeekField('e', count);
                            break;
                        case 3:
                            this.appendText(field, TextStyle.SHORT);
                            break;
                        case 4:
                            this.appendText(field, TextStyle.FULL);
                            break;
                        case 5:
                            this.appendText(field, TextStyle.NARROW);
                            break;
                        default:
                            throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                    }

                    break;
                case 'c':
                    switch (count) {
                        case 1:
                            this.appendWeekField('c', count);
                            break;
                        case 2:
                            throw new IllegalArgumentException('Invalid number of pattern letters: ' + cur);
                        case 3:
                            this.appendText(field, TextStyle.SHORT_STANDALONE);
                            break;
                        case 4:
                            this.appendText(field, TextStyle.FULL_STANDALONE);
                            break;
                        case 5:
                            this.appendText(field, TextStyle.NARROW_STANDALONE);
                            break;
                        default:
                            throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                    }

                    break;
                case 'a':
                    if (count === 1) {
                        this.appendText(field, TextStyle.SHORT);
                    } else {
                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                    }

                    break;
                case 'E':
                case 'G':
                    switch (count) {
                        case 1:
                        case 2:
                        case 3:
                            this.appendText(field, TextStyle.SHORT);
                            break;
                        case 4:
                            this.appendText(field, TextStyle.FULL);
                            break;
                        case 5:
                            this.appendText(field, TextStyle.NARROW);
                            break;
                        default:
                            throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                    }

                    break;
                case 'S':
                    this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);
                    break;
                case 'F':
                    if (count === 1) {
                        this.appendValue(field);
                    } else {
                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                    }
                    break;
                case 'd':
                case 'h':
                case 'H':
                case 'k':
                case 'K':
                case 'm':
                case 's':
                    if (count === 1) {
                        this.appendValue(field);
                    } else if (count === 2) {
                        this.appendValue(field, count);
                    } else {
                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                    }
                    break;
                case 'D':
                    if (count === 1) {
                        this.appendValue(field);
                    } else if (count <= 3) {
                        this.appendValue(field, count);
                    } else {
                        throw new IllegalArgumentException('Too many pattern letters: ' + cur);
                    }
                    break;
                default:
                    if (count === 1) {
                        this.appendValue(field);
                    } else {
                        this.appendValue(field, count);
                    }
                    break;
            }
        };

        DateTimeFormatterBuilder.prototype.padNext = function padNext() {
            if (arguments.length === 1) {
                return this._padNext1.apply(this, arguments);
            } else {
                return this._padNext2.apply(this, arguments);
            }
        };

        DateTimeFormatterBuilder.prototype._padNext1 = function _padNext1(padWidth) {
            return this._padNext2(padWidth, ' ');
        };

        DateTimeFormatterBuilder.prototype._padNext2 = function _padNext2(padWidth, padChar) {
            if (padWidth < 1) {
                throw new IllegalArgumentException('The pad width must be at least one but was ' + padWidth);
            }
            this._active._padNextWidth = padWidth;
            this._active._padNextChar = padChar;
            this._active._valueParserIndex = -1;
            return this;
        };

        DateTimeFormatterBuilder.prototype.optionalStart = function optionalStart() {
            this._active._valueParserIndex = -1;
            this._active = DateTimeFormatterBuilder._of(this._active, true);
            return this;
        };

        DateTimeFormatterBuilder.prototype.optionalEnd = function optionalEnd() {
            if (this._active._parent == null) {
                throw new IllegalStateException('Cannot call optionalEnd() as there was no previous call to optionalStart()');
            }
            if (this._active._printerParsers.length > 0) {
                var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);
                this._active = this._active._parent;
                this._appendInternal(cpp);
            } else {
                this._active = this._active._parent;
            }
            return this;
        };

        DateTimeFormatterBuilder.prototype._appendInternal = function _appendInternal(pp) {
            assert(pp != null);
            if (this._active._padNextWidth > 0) {
                if (pp != null) {
                    pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
                }
                this._active._padNextWidth = 0;
                this._active._padNextChar = 0;
            }
            this._active._printerParsers.push(pp);
            this._active._valueParserIndex = -1;
            return this._active._printerParsers.length - 1;
        };

        DateTimeFormatterBuilder.prototype.appendLiteral = function appendLiteral(literal) {
            assert(literal != null);
            if (literal.length > 0) {
                if (literal.length === 1) {
                    this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));
                } else {
                    this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));
                }
            }
            return this;
        };

        DateTimeFormatterBuilder.prototype._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {
            assert(pp != null);
            if (this._active._padNextWidth > 0) {
                if (pp != null) {
                    pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
                }
                this._active._padNextWidth = 0;
                this._active._padNextChar = 0;
            }
            this._active._printerParsers.push(pp);
            this._active._valueParserIndex = -1;
            return this._active._printerParsers.length - 1;
        };

        DateTimeFormatterBuilder.prototype.append = function append(formatter) {
            requireNonNull(formatter, 'formatter');
            this._appendInternal(formatter._toPrinterParser(false));
            return this;
        };

        DateTimeFormatterBuilder.prototype.toFormatter = function toFormatter() {
            var resolverStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ResolverStyle.SMART;

            while (this._active._parent != null) {
                this.optionalEnd();
            }
            var pp = new CompositePrinterParser(this._printerParsers, false);
            return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);
        };

        return DateTimeFormatterBuilder;
    }();

    var SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;
    var SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;

    var InstantPrinterParser = function () {
        function InstantPrinterParser(fractionalDigits) {
            _classCallCheck$H(this, InstantPrinterParser);

            this.fractionalDigits = fractionalDigits;
        }

        InstantPrinterParser.prototype.print = function print(context, buf) {
            var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);
            var inNanos = 0;
            if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {
                inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);
            }
            if (inSecs == null) {
                return false;
            }
            var inSec = inSecs;
            var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);
            if (inSec >= -SECONDS_0000_TO_1970) {
                var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;
                var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;
                var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);
                var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
                if (hi > 0) {
                    buf.append('+').append(hi);
                }
                buf.append(ldt);
                if (ldt.second() === 0) {
                    buf.append(':00');
                }
            } else {
                var _zeroSecs = inSec + SECONDS_0000_TO_1970;
                var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);
                var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);
                var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
                var pos = buf.length();
                buf.append(_ldt);
                if (_ldt.second() === 0) {
                    buf.append(':00');
                }
                if (_hi < 0) {
                    if (_ldt.year() === -10000) {
                        buf.replace(pos, pos + 2, '' + (_hi - 1));
                    } else if (_lo === 0) {
                        buf.insert(pos, _hi);
                    } else {
                        buf.insert(pos + 1, Math.abs(_hi));
                    }
                }
            }

            if (this.fractionalDigits === -2) {
                if (inNano !== 0) {
                    buf.append('.');
                    if (MathUtil.intMod(inNano, 1000000) === 0) {
                        buf.append(('' + (MathUtil.intDiv(inNano, 1000000) + 1000)).substring(1));
                    } else if (MathUtil.intMod(inNano, 1000) === 0) {
                        buf.append(('' + (MathUtil.intDiv(inNano, 1000) + 1000000)).substring(1));
                    } else {
                        buf.append(('' + (inNano + 1000000000)).substring(1));
                    }
                }
            } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {
                buf.append('.');
                var div = 100000000;
                for (var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++) {
                    var digit = MathUtil.intDiv(inNano, div);
                    buf.append(digit);
                    inNano = inNano - digit * div;
                    div = MathUtil.intDiv(div, 10);
                }
            }
            buf.append('Z');
            return true;
        };

        InstantPrinterParser.prototype.parse = function parse(context, text, position) {
            var newContext = context.copy();
            var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;
            var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;
            var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral('Z').toFormatter()._toPrinterParser(false);
            var pos = parser.parse(newContext, text, position);
            if (pos < 0) {
                return pos;
            }

            var yearParsed = newContext.getParsed(ChronoField.YEAR);
            var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);
            var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);
            var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);
            var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);
            var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);
            var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);
            var sec = secVal != null ? secVal : 0;
            var nano = nanoVal != null ? nanoVal : 0;
            var year = MathUtil.intMod(yearParsed, 10000);
            var days = 0;
            if (hour === 24 && min === 0 && sec === 0 && nano === 0) {
                hour = 0;
                days = 1;
            } else if (hour === 23 && min === 59 && sec === 60) {
                context.setParsedLeapSecond();
                sec = 59;
            }
            var instantSecs = void 0;
            try {
                var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);
                instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);
                instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 10000), SECONDS_PER_10000_YEARS);
            } catch (ex) {
                return ~position;
            }
            var successPos = pos;
            successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);
            return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);
        };

        InstantPrinterParser.prototype.toString = function toString() {
            return 'Instant()';
        };

        return InstantPrinterParser;
    }();

    function _init$9() {
        ReducedPrinterParser.BASE_DATE = LocalDate.of(2000, 1, 1);

        DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;
        DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;
        DateTimeFormatterBuilder.SettingsParser = SettingsParser;
        DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;
        DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;
        DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;
        DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;
        DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;
        DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;
        DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;
        DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;
    }

    function _classCallCheck$I(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    /*
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
     */

    var StringBuilder = function () {
        function StringBuilder() {
            _classCallCheck$I(this, StringBuilder);

            this._str = '';
        }

        StringBuilder.prototype.append = function append(str) {
            this._str += str;
            return this;
        };

        StringBuilder.prototype.appendChar = function appendChar(str) {
            this._str += str[0];
            return this;
        };

        StringBuilder.prototype.insert = function insert(offset, str) {
            this._str = this._str.slice(0, offset) + str + this._str.slice(offset);
            return this;
        };

        StringBuilder.prototype.replace = function replace(start, end, str) {
            this._str = this._str.slice(0, start) + str + this._str.slice(end);
            return this;
        };

        StringBuilder.prototype.length = function length() {
            return this._str.length;
        };

        StringBuilder.prototype.setLength = function setLength(length) {
            this._str = this._str.slice(0, length);
            return this;
        };

        StringBuilder.prototype.toString = function toString() {
            return this._str;
        };

        return StringBuilder;
    }();

    function _classCallCheck$J(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var DateTimeFormatter = function () {
        DateTimeFormatter.parsedExcessDays = function parsedExcessDays() {
            return DateTimeFormatter.PARSED_EXCESS_DAYS;
        };

        DateTimeFormatter.parsedLeapSecond = function parsedLeapSecond() {
            return DateTimeFormatter.PARSED_LEAP_SECOND;
        };

        DateTimeFormatter.ofPattern = function ofPattern(pattern) {
            return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
        };

        function DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields) {
            var chrono = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : IsoChronology.INSTANCE;
            var zone = arguments[6];

            _classCallCheck$J(this, DateTimeFormatter);

            assert(printerParser != null);
            assert(decimalStyle != null);
            assert(resolverStyle != null);

            this._printerParser = printerParser;

            this._locale = locale;

            this._decimalStyle = decimalStyle;

            this._resolverStyle = resolverStyle;

            this._resolverFields = resolverFields;

            this._chrono = chrono;

            this._zone = zone;
        }

        DateTimeFormatter.prototype.locale = function locale() {
            return this._locale;
        };

        DateTimeFormatter.prototype.decimalStyle = function decimalStyle() {
            return this._decimalStyle;
        };

        DateTimeFormatter.prototype.chronology = function chronology() {
            return this._chrono;
        };

        DateTimeFormatter.prototype.withChronology = function withChronology(chrono) {
            if (this._chrono != null && this._chrono.equals(chrono)) {
                return this;
            }
            return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);
        };

        DateTimeFormatter.prototype.withLocale = function withLocale() {
            return this;
        };

        DateTimeFormatter.prototype.withResolverStyle = function withResolverStyle(resolverStyle) {
            requireNonNull(resolverStyle, 'resolverStyle');
            if (resolverStyle.equals(this._resolverStyle)) {
                return this;
            }
            return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);
        };

        DateTimeFormatter.prototype.format = function format(temporal) {
            var buf = new StringBuilder(32);
            this._formatTo(temporal, buf);
            return buf.toString();
        };

        DateTimeFormatter.prototype._formatTo = function _formatTo(temporal, appendable) {
            requireNonNull(temporal, 'temporal');
            requireNonNull(appendable, 'appendable');
            var context = new DateTimePrintContext(temporal, this);
            this._printerParser.print(context, appendable);
        };

        DateTimeFormatter.prototype.parse = function parse(text, type) {
            if (arguments.length === 1) {
                return this.parse1(text);
            } else {
                return this.parse2(text, type);
            }
        };

        DateTimeFormatter.prototype.parse1 = function parse1(text) {
            requireNonNull(text, 'text');
            try {
                return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
            } catch (ex) {
                if (ex instanceof DateTimeParseException) {
                    throw ex;
                } else {
                    throw this._createError(text, ex);
                }
            }
        };

        DateTimeFormatter.prototype.parse2 = function parse2(text, type) {
            requireNonNull(text, 'text');
            requireNonNull(type, 'type');
            try {
                var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
                return builder.build(type);
            } catch (ex) {
                if (ex instanceof DateTimeParseException) {
                    throw ex;
                } else {
                    throw this._createError(text, ex);
                }
            }
        };

        DateTimeFormatter.prototype._createError = function _createError(text, ex) {
            var abbr = '';
            if (text.length > 64) {
                abbr = text.substring(0, 64) + '...';
            } else {
                abbr = text;
            }
            return new DateTimeParseException('Text \'' + abbr + '\' could not be parsed: ' + ex.message, text, 0, ex);
        };

        DateTimeFormatter.prototype._parseToBuilder = function _parseToBuilder(text, position) {
            var pos = position != null ? position : new ParsePosition(0);
            var result = this._parseUnresolved0(text, pos);
            if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text.length) {
                var abbr = '';
                if (text.length > 64) {
                    abbr = text.substr(0, 64).toString() + '...';
                } else {
                    abbr = text;
                }
                if (pos.getErrorIndex() >= 0) {
                    throw new DateTimeParseException('Text \'' + abbr + '\' could not be parsed at index ' + pos.getErrorIndex(), text, pos.getErrorIndex());
                } else {
                    throw new DateTimeParseException('Text \'' + abbr + '\' could not be parsed, unparsed text found at index ' + pos.getIndex(), text, pos.getIndex());
                }
            }
            return result.toBuilder();
        };

        DateTimeFormatter.prototype.parseUnresolved = function parseUnresolved(text, position) {
            return this._parseUnresolved0(text, position);
        };

        DateTimeFormatter.prototype._parseUnresolved0 = function _parseUnresolved0(text, position) {
            assert(text != null, 'text', NullPointerException);
            assert(position != null, 'position', NullPointerException);
            var context = new DateTimeParseContext(this);
            var pos = position.getIndex();
            pos = this._printerParser.parse(context, text, pos);
            if (pos < 0) {
                position.setErrorIndex(~pos);
                return null;
            }
            position.setIndex(pos);
            return context.toParsed();
        };

        DateTimeFormatter.prototype._toPrinterParser = function _toPrinterParser(optional) {
            return this._printerParser.withOptional(optional);
        };

        DateTimeFormatter.prototype.toString = function toString() {
            var pattern = this._printerParser.toString();
            return pattern.indexOf('[') === 0 ? pattern : pattern.substring(1, pattern.length - 1);
        };

        return DateTimeFormatter;
    }();

    function _init$a() {

        DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);

        DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);

        DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);

        DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);

        DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);

        DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral('[').parseCaseSensitive().appendZoneId().appendLiteral(']').toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);

        DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery('PARSED_EXCESS_DAYS', function (temporal) {
            if (temporal instanceof DateTimeBuilder) {
                return temporal.excessDays;
            } else {
                return Period.ZERO;
            }
        });

        DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery('PARSED_LEAP_SECOND', function (temporal) {
            if (temporal instanceof DateTimeBuilder) {
                return temporal.leapSecond;
            } else {
                return false;
            }
        });
    }

    function _classCallCheck$K(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$k(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$k(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var MonthDay = function (_Temporal) {
        _inherits$k(MonthDay, _Temporal);

        MonthDay.now = function now(zoneIdOrClock) {
            if (arguments.length === 0) {
                return MonthDay.now0();
            } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
                return MonthDay.nowZoneId(zoneIdOrClock);
            } else {
                return MonthDay.nowClock(zoneIdOrClock);
            }
        };

        MonthDay.now0 = function now0() {
            return this.nowClock(Clock.systemDefaultZone());
        };

        MonthDay.nowZoneId = function nowZoneId(zone) {
            requireNonNull(zone, 'zone');
            return this.nowClock(Clock.system(zone));
        };

        MonthDay.nowClock = function nowClock(clock) {
            requireNonNull(clock, 'clock');
            var now = LocalDate.now(clock);
            return MonthDay.of(now.month(), now.dayOfMonth());
        };

        MonthDay.of = function of(monthOrNumber, number) {
            if (arguments.length === 2 && monthOrNumber instanceof Month) {
                return MonthDay.ofMonthNumber(monthOrNumber, number);
            } else {
                return MonthDay.ofNumberNumber(monthOrNumber, number);
            }
        };

        MonthDay.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {
            requireNonNull(month, 'month');
            ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
            if (dayOfMonth > month.maxLength()) {
                throw new DateTimeException('Illegal value for DayOfMonth field, value ' + dayOfMonth + ' is not valid for month ' + month.toString());
            }
            return new MonthDay(month.value(), dayOfMonth);
        };

        MonthDay.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {
            requireNonNull(month, 'month');
            requireNonNull(dayOfMonth, 'dayOfMonth');
            return MonthDay.of(Month.of(month), dayOfMonth);
        };

        MonthDay.from = function from(temporal) {
            requireNonNull(temporal, 'temporal');
            requireInstance(temporal, TemporalAccessor, 'temporal');
            if (temporal instanceof MonthDay) {
                return temporal;
            }
            try {
                return MonthDay.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));
            } catch (ex) {
                throw new DateTimeException('Unable to obtain MonthDay from TemporalAccessor: ' + temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));
            }
        };

        MonthDay.parse = function parse(text, formatter) {
            if (arguments.length === 1) {
                return MonthDay.parseString(text);
            } else {
                return MonthDay.parseStringFormatter(text, formatter);
            }
        };

        MonthDay.parseString = function parseString(text) {
            return MonthDay.parseStringFormatter(text, PARSER);
        };

        MonthDay.parseStringFormatter = function parseStringFormatter(text, formatter) {
            requireNonNull(text, 'text');
            requireNonNull(formatter, 'formatter');
            requireInstance(formatter, DateTimeFormatter, 'formatter');
            return formatter.parse(text, MonthDay.FROM);
        };

        function MonthDay(month, dayOfMonth) {
            _classCallCheck$K(this, MonthDay);

            var _this = _possibleConstructorReturn$k(this, _Temporal.call(this));

            _this._month = MathUtil.safeToInt(month);
            _this._day = MathUtil.safeToInt(dayOfMonth);
            return _this;
        }

        MonthDay.prototype.monthValue = function monthValue() {
            return this._month;
        };

        MonthDay.prototype.month = function month() {
            return Month.of(this._month);
        };

        MonthDay.prototype.dayOfMonth = function dayOfMonth() {
            return this._day;
        };

        MonthDay.prototype.isSupported = function isSupported(field) {
            if (field instanceof ChronoField) {
                return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;
            }
            return field != null && field.isSupportedBy(this);
        };

        MonthDay.prototype.range = function range(field) {
            if (field === ChronoField.MONTH_OF_YEAR) {
                return field.range();
            } else if (field === ChronoField.DAY_OF_MONTH) {
                return ValueRange.of(1, this.month().minLength(), this.month().maxLength());
            }
            return _Temporal.prototype.range.call(this, field);
        };

        MonthDay.prototype.get = function get(field) {
            return this.range(field).checkValidIntValue(this.getLong(field), field);
        };

        MonthDay.prototype.getLong = function getLong(field) {
            requireNonNull(field, 'field');
            if (field instanceof ChronoField) {
                switch (field) {
                    case ChronoField.DAY_OF_MONTH:
                        return this._day;
                    case ChronoField.MONTH_OF_YEAR:
                        return this._month;
                }
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.getFrom(this);
        };

        MonthDay.prototype.isValidYear = function isValidYear(year) {
            return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;
        };

        MonthDay.prototype.withMonth = function withMonth(month) {
            return this.with(Month.of(month));
        };

        MonthDay.prototype.with = function _with(month) {
            requireNonNull(month, 'month');
            if (month.value() === this._month) {
                return this;
            }
            var day = Math.min(this._day, month.maxLength());
            return new MonthDay(month.value(), day);
        };

        MonthDay.prototype.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
            if (dayOfMonth === this._day) {
                return this;
            }
            return MonthDay.of(this._month, dayOfMonth);
        };

        MonthDay.prototype.query = function query(_query) {
            requireNonNull(_query, 'query');
            requireInstance(_query, TemporalQuery, 'query');
            if (_query === TemporalQueries.chronology()) {
                return IsoChronology.INSTANCE;
            }
            return _Temporal.prototype.query.call(this, _query);
        };

        MonthDay.prototype.adjustInto = function adjustInto(temporal) {
            requireNonNull(temporal, 'temporal');

            temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);
            return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));
        };

        MonthDay.prototype.atYear = function atYear(year) {
            return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);
        };

        MonthDay.prototype.compareTo = function compareTo(other) {
            requireNonNull(other, 'other');
            requireInstance(other, MonthDay, 'other');
            var cmp = this._month - other.monthValue();
            if (cmp === 0) {
                cmp = this._day - other.dayOfMonth();
            }
            return cmp;
        };

        MonthDay.prototype.isAfter = function isAfter(other) {
            requireNonNull(other, 'other');
            requireInstance(other, MonthDay, 'other');
            return this.compareTo(other) > 0;
        };

        MonthDay.prototype.isBefore = function isBefore(other) {
            requireNonNull(other, 'other');
            requireInstance(other, MonthDay, 'other');
            return this.compareTo(other) < 0;
        };

        MonthDay.prototype.equals = function equals(obj) {
            if (this === obj) {
                return true;
            }
            if (obj instanceof MonthDay) {
                var other = obj;
                return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();
            }
            return false;
        };

        MonthDay.prototype.toString = function toString() {
            return '--' + (this._month < 10 ? '0' : '') + this._month + (this._day < 10 ? '-0' : '-') + this._day;
        };

        MonthDay.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        MonthDay.prototype.format = function format(formatter) {
            requireNonNull(formatter, 'formatter');
            requireInstance(formatter, DateTimeFormatter, 'formatter');
            return formatter.format(this);
        };

        return MonthDay;
    }(Temporal);


    var PARSER = void 0;

    function _init$b() {
        PARSER = new DateTimeFormatterBuilder().appendLiteral('--').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();

        MonthDay.FROM = createTemporalQuery('MonthDay.FROM', function (temporal) {
            return MonthDay.from(temporal);
        });
    }

    function _classCallCheck$L(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$l(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$l(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var YearMonth = function (_Temporal) {
        _inherits$l(YearMonth, _Temporal);

        YearMonth.now = function now(zoneIdOrClock) {
            if (arguments.length === 0) {
                return YearMonth.now0();
            } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
                return YearMonth.nowZoneId(zoneIdOrClock);
            } else {
                return YearMonth.nowClock(zoneIdOrClock);
            }
        };

        YearMonth.now0 = function now0() {
            return YearMonth.nowClock(Clock.systemDefaultZone());
        };

        YearMonth.nowZoneId = function nowZoneId(zone) {
            return YearMonth.nowClock(Clock.system(zone));
        };

        YearMonth.nowClock = function nowClock(clock) {
            var now = LocalDate.now(clock);
            return YearMonth.of(now.year(), now.month());
        };

        YearMonth.of = function of(year, monthOrNumber) {
            if (arguments.length === 2 && monthOrNumber instanceof Month) {
                return YearMonth.ofNumberMonth(year, monthOrNumber);
            } else {
                return YearMonth.ofNumberNumber(year, monthOrNumber);
            }
        };

        YearMonth.ofNumberMonth = function ofNumberMonth(year, month) {
            requireNonNull(month, 'month');
            requireInstance(month, Month, 'month');
            return YearMonth.ofNumberNumber(year, month.value());
        };

        YearMonth.ofNumberNumber = function ofNumberNumber(year, month) {
            requireNonNull(year, 'year');
            requireNonNull(month, 'month');
            ChronoField.YEAR.checkValidValue(year);
            ChronoField.MONTH_OF_YEAR.checkValidValue(month);
            return new YearMonth(year, month);
        };

        YearMonth.from = function from(temporal) {
            requireNonNull(temporal, 'temporal');
            if (temporal instanceof YearMonth) {
                return temporal;
            }
            try {
                return YearMonth.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));
            } catch (ex) {
                throw new DateTimeException('Unable to obtain YearMonth from TemporalAccessor: ' + temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));
            }
        };

        YearMonth.parse = function parse(text, formatter) {
            if (arguments.length === 1) {
                return YearMonth.parseString(text);
            } else {
                return YearMonth.parseStringFormatter(text, formatter);
            }
        };

        YearMonth.parseString = function parseString(text) {
            return YearMonth.parseStringFormatter(text, PARSER$1);
        };

        YearMonth.parseStringFormatter = function parseStringFormatter(text, formatter) {
            requireNonNull(formatter, 'formatter');
            return formatter.parse(text, YearMonth.FROM);
        };

        function YearMonth(year, month) {
            _classCallCheck$L(this, YearMonth);

            var _this = _possibleConstructorReturn$l(this, _Temporal.call(this));

            _this._year = MathUtil.safeToInt(year);
            _this._month = MathUtil.safeToInt(month);
            return _this;
        }

        YearMonth.prototype.isSupported = function isSupported(fieldOrUnit) {
            if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
                return this.isSupportedField(fieldOrUnit);
            } else {
                return this.isSupportedUnit(fieldOrUnit);
            }
        };

        YearMonth.prototype.isSupportedField = function isSupportedField(field) {
            if (field instanceof ChronoField) {
                return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
            }
            return field != null && field.isSupportedBy(this);
        };

        YearMonth.prototype.isSupportedUnit = function isSupportedUnit(unit) {
            if (unit instanceof ChronoUnit) {
                return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
            }
            return unit != null && unit.isSupportedBy(this);
        };

        YearMonth.prototype.range = function range(field) {
            if (field === ChronoField.YEAR_OF_ERA) {
                return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
            }
            return _Temporal.prototype.range.call(this, field);
        };

        YearMonth.prototype.get = function get(field) {
            requireNonNull(field, 'field');
            requireInstance(field, TemporalField, 'field');
            return this.range(field).checkValidIntValue(this.getLong(field), field);
        };

        YearMonth.prototype.getLong = function getLong(field) {
            requireNonNull(field, 'field');
            requireInstance(field, TemporalField, 'field');
            if (field instanceof ChronoField) {
                switch (field) {
                    case ChronoField.MONTH_OF_YEAR:
                        return this._month;
                    case ChronoField.PROLEPTIC_MONTH:
                        return this._getProlepticMonth();
                    case ChronoField.YEAR_OF_ERA:
                        return this._year < 1 ? 1 - this._year : this._year;
                    case ChronoField.YEAR:
                        return this._year;
                    case ChronoField.ERA:
                        return this._year < 1 ? 0 : 1;
                }
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.getFrom(this);
        };

        YearMonth.prototype._getProlepticMonth = function _getProlepticMonth() {
            return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);
        };

        YearMonth.prototype.year = function year() {
            return this._year;
        };

        YearMonth.prototype.monthValue = function monthValue() {
            return this._month;
        };

        YearMonth.prototype.month = function month() {
            return Month.of(this._month);
        };

        YearMonth.prototype.isLeapYear = function isLeapYear() {
            return IsoChronology.isLeapYear(this._year);
        };

        YearMonth.prototype.isValidDay = function isValidDay(dayOfMonth) {
            return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();
        };

        YearMonth.prototype.lengthOfMonth = function lengthOfMonth() {
            return this.month().length(this.isLeapYear());
        };

        YearMonth.prototype.lengthOfYear = function lengthOfYear() {
            return this.isLeapYear() ? 366 : 365;
        };

        YearMonth.prototype.with = function _with(adjusterOrFieldOrNumber, value) {
            if (arguments.length === 1) {
                return this.withAdjuster(adjusterOrFieldOrNumber);
            } else if (arguments.length === 2 && adjusterOrFieldOrNumber instanceof TemporalField) {
                return this.withFieldValue(adjusterOrFieldOrNumber, value);
            } else {
                return this.withYearMonth(adjusterOrFieldOrNumber, value);
            }
        };

        YearMonth.prototype.withYearMonth = function withYearMonth(newYear, newMonth) {
            requireNonNull(newYear);
            requireNonNull(newMonth);
            if (this._year === newYear && this._month === newMonth) {
                return this;
            }
            return new YearMonth(newYear, newMonth);
        };

        YearMonth.prototype.withAdjuster = function withAdjuster(adjuster) {
            requireNonNull(adjuster, 'adjuster');
            return adjuster.adjustInto(this);
        };

        YearMonth.prototype.withFieldValue = function withFieldValue(field, newValue) {
            requireNonNull(field, 'field');
            requireInstance(field, TemporalField, 'field');
            if (field instanceof ChronoField) {
                var f = field;
                f.checkValidValue(newValue);
                switch (f) {
                    case ChronoField.MONTH_OF_YEAR:
                        return this.withMonth(newValue);
                    case ChronoField.PROLEPTIC_MONTH:
                        return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
                    case ChronoField.YEAR_OF_ERA:
                        return this.withYear(this._year < 1 ? 1 - newValue : newValue);
                    case ChronoField.YEAR:
                        return this.withYear(newValue);
                    case ChronoField.ERA:
                        return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
                }
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.adjustInto(this, newValue);
        };

        YearMonth.prototype.withYear = function withYear(year) {
            ChronoField.YEAR.checkValidValue(year);
            return this.withYearMonth(year, this._month);
        };

        YearMonth.prototype.withMonth = function withMonth(month) {
            ChronoField.MONTH_OF_YEAR.checkValidValue(month);
            return this.withYearMonth(this._year, month);
        };

        YearMonth.prototype.plus = function plus(amountOrNumber, unit) {
            if (arguments.length === 1) {
                return this.plusAmount(amountOrNumber);
            } else {
                return this.plusAmountUnit(amountOrNumber, unit);
            }
        };

        YearMonth.prototype.plusAmount = function plusAmount(amount) {
            requireNonNull(amount, 'amount');
            requireInstance(amount, TemporalAmount, 'amount');
            return amount.addTo(this);
        };

        YearMonth.prototype.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {
            requireNonNull(unit, 'unit');
            requireInstance(unit, TemporalUnit, 'unit');
            if (unit instanceof ChronoUnit) {
                switch (unit) {
                    case ChronoUnit.MONTHS:
                        return this.plusMonths(amountToAdd);
                    case ChronoUnit.YEARS:
                        return this.plusYears(amountToAdd);
                    case ChronoUnit.DECADES:
                        return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
                    case ChronoUnit.CENTURIES:
                        return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
                    case ChronoUnit.MILLENNIA:
                        return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));
                    case ChronoUnit.ERAS:
                        return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
                }
                throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);
            }
            return unit.addTo(this, amountToAdd);
        };

        YearMonth.prototype.plusYears = function plusYears(yearsToAdd) {
            if (yearsToAdd === 0) {
                return this;
            }
            var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
            return this.withYearMonth(newYear, this._month);
        };

        YearMonth.prototype.plusMonths = function plusMonths(monthsToAdd) {
            if (monthsToAdd === 0) {
                return this;
            }
            var monthCount = this._year * 12 + (this._month - 1);
            var calcMonths = monthCount + monthsToAdd;
            var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
            var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
            return this.withYearMonth(newYear, newMonth);
        };

        YearMonth.prototype.minus = function minus(amountOrNumber, unit) {
            if (arguments.length === 1) {
                return this.minusAmount(amountOrNumber);
            } else {
                return this.minusAmountUnit(amountOrNumber, unit);
            }
        };

        YearMonth.prototype.minusAmount = function minusAmount(amount) {
            requireNonNull(amount, 'amount');
            return amount.subtractFrom(this);
        };

        YearMonth.prototype.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {
            return amountToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusAmountUnit(MathUtil.MAX_SAFE_INTEGER, unit).plusAmountUnit(1, unit) : this.plusAmountUnit(-amountToSubtract, unit);
        };

        YearMonth.prototype.minusYears = function minusYears(yearsToSubtract) {
            return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
        };

        YearMonth.prototype.minusMonths = function minusMonths(monthsToSubtract) {
            return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);
        };

        YearMonth.prototype.query = function query(_query) {
            requireNonNull(_query, 'query');
            requireInstance(_query, TemporalQuery, 'query');
            if (_query === TemporalQueries.chronology()) {
                return IsoChronology.INSTANCE;
            } else if (_query === TemporalQueries.precision()) {
                return ChronoUnit.MONTHS;
            } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
                return null;
            }
            return _Temporal.prototype.query.call(this, _query);
        };

        YearMonth.prototype.adjustInto = function adjustInto(temporal) {
            requireNonNull(temporal, 'temporal');
            requireInstance(temporal, Temporal, 'temporal');

            return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());
        };

        YearMonth.prototype.until = function until(endExclusive, unit) {
            requireNonNull(endExclusive, 'endExclusive');
            requireNonNull(unit, 'unit');
            requireInstance(endExclusive, Temporal, 'endExclusive');
            requireInstance(unit, TemporalUnit, 'unit');

            var end = YearMonth.from(endExclusive);
            if (unit instanceof ChronoUnit) {
                var monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();
                switch (unit) {
                    case ChronoUnit.MONTHS:
                        return monthsUntil;
                    case ChronoUnit.YEARS:
                        return monthsUntil / 12;
                    case ChronoUnit.DECADES:
                        return monthsUntil / 120;
                    case ChronoUnit.CENTURIES:
                        return monthsUntil / 1200;
                    case ChronoUnit.MILLENNIA:
                        return monthsUntil / 12000;
                    case ChronoUnit.ERAS:
                        return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
                }
                throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);
            }
            return unit.between(this, end);
        };

        YearMonth.prototype.atDay = function atDay(dayOfMonth) {
            return LocalDate.of(this._year, this._month, dayOfMonth);
        };

        YearMonth.prototype.atEndOfMonth = function atEndOfMonth() {
            return LocalDate.of(this._year, this._month, this.lengthOfMonth());
        };

        YearMonth.prototype.compareTo = function compareTo(other) {
            requireNonNull(other, 'other');
            requireInstance(other, YearMonth, 'other');
            var cmp = this._year - other.year();
            if (cmp === 0) {
                cmp = this._month - other.monthValue();
            }
            return cmp;
        };

        YearMonth.prototype.isAfter = function isAfter(other) {
            return this.compareTo(other) > 0;
        };

        YearMonth.prototype.isBefore = function isBefore(other) {
            return this.compareTo(other) < 0;
        };

        YearMonth.prototype.equals = function equals(obj) {
            if (this === obj) {
                return true;
            }
            if (obj instanceof YearMonth) {
                var other = obj;
                return this.year() === other.year() && this.monthValue() === other.monthValue();
            }
            return false;
        };

        YearMonth.prototype.toString = function toString() {
            return PARSER$1.format(this);
        };

        YearMonth.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        YearMonth.prototype.format = function format(formatter) {
            requireNonNull(formatter, 'formatter');
            return formatter.format(this);
        };

        return YearMonth;
    }(Temporal);


    var PARSER$1 = void 0;

    function _init$c() {

        PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();

        YearMonth.FROM = createTemporalQuery('YearMonth.FROM', function (temporal) {
            return YearMonth.from(temporal);
        });
    }

    function _classCallCheck$M(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$m(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$m(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var Year = function (_Temporal) {
        _inherits$m(Year, _Temporal);

        function Year(value) {
            _classCallCheck$M(this, Year);

            var _this = _possibleConstructorReturn$m(this, _Temporal.call(this));

            _this._year = MathUtil.safeToInt(value);
            return _this;
        }

        Year.prototype.value = function value() {
            return this._year;
        };

        Year.now = function now() {
            var zoneIdOrClock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

            if (zoneIdOrClock === undefined) {
                return Year.now0();
            } else if (zoneIdOrClock instanceof ZoneId) {
                return Year.nowZoneId(zoneIdOrClock);
            } else {
                return Year.nowClock(zoneIdOrClock);
            }
        };

        Year.now0 = function now0() {
            return Year.nowClock(Clock.systemDefaultZone());
        };

        Year.nowZoneId = function nowZoneId(zone) {
            requireNonNull(zone, 'zone');
            requireInstance(zone, ZoneId, 'zone');
            return Year.nowClock(Clock.system(zone));
        };

        Year.nowClock = function nowClock(clock) {
            requireNonNull(clock, 'clock');
            requireInstance(clock, Clock, 'clock');
            var now = LocalDate.now(clock);
            return Year.of(now.year());
        };

        Year.of = function of(isoYear) {
            requireNonNull(isoYear, 'isoYear');
            ChronoField.YEAR.checkValidValue(isoYear);
            return new Year(isoYear);
        };

        Year.from = function from(temporal) {
            requireNonNull(temporal, 'temporal');
            requireInstance(temporal, TemporalAccessor, 'temporal');
            if (temporal instanceof Year) {
                return temporal;
            }
            try {
                return Year.of(temporal.get(ChronoField.YEAR));
            } catch (ex) {
                throw new DateTimeException('Unable to obtain Year from TemporalAccessor: ' + temporal + ', type ' + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));
            }
        };

        Year.parse = function parse(text, formatter) {
            if (arguments.length <= 1) {
                return Year.parseText(text);
            } else {
                return Year.parseTextFormatter(text, formatter);
            }
        };

        Year.parseText = function parseText(text) {
            requireNonNull(text, 'text');
            return Year.parse(text, PARSER$2);
        };

        Year.parseTextFormatter = function parseTextFormatter(text) {
            var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PARSER$2;

            requireNonNull(text, 'text');
            requireNonNull(formatter, 'formatter');
            requireInstance(formatter, DateTimeFormatter, 'formatter');
            return formatter.parse(text, Year.FROM);
        };

        Year.isLeap = function isLeap(year) {
            return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);
        };

        Year.prototype.isSupported = function isSupported(fieldOrUnit) {
            if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
                return this.isSupportedField(fieldOrUnit);
            } else {
                return this.isSupportedUnit(fieldOrUnit);
            }
        };

        Year.prototype.isSupportedField = function isSupportedField(field) {
            if (field instanceof ChronoField) {
                return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
            }
            return field != null && field.isSupportedBy(this);
        };

        Year.prototype.isSupportedUnit = function isSupportedUnit(unit) {
            if (unit instanceof ChronoUnit) {
                return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
            }
            return unit != null && unit.isSupportedBy(this);
        };

        Year.prototype.range = function range(field) {
            if (this.isSupported(field)) {
                return field.range();
            } else if (field instanceof ChronoField) {
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return _Temporal.prototype.range.call(this, field);
        };

        Year.prototype.get = function get(field) {
            return this.range(field).checkValidIntValue(this.getLong(field), field);
        };

        Year.prototype.getLong = function getLong(field) {
            requireNonNull(field, 'field');
            if (field instanceof ChronoField) {
                switch (field) {
                    case ChronoField.YEAR_OF_ERA:
                        return this._year < 1 ? 1 - this._year : this._year;
                    case ChronoField.YEAR:
                        return this._year;
                    case ChronoField.ERA:
                        return this._year < 1 ? 0 : 1;
                }
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.getFrom(this);
        };

        Year.prototype.isLeap = function isLeap() {
            return Year.isLeap(this._year);
        };

        Year.prototype.with = function _with(adjusterOrFieldOrNumber, value) {
            if (arguments.length === 2 && adjusterOrFieldOrNumber instanceof TemporalField) {
                return this.withFieldValue(adjusterOrFieldOrNumber, value);
            } else {
                return this.withAdjuster(adjusterOrFieldOrNumber);
            }
        };

        Year.prototype.withAdjuster = function withAdjuster(adjuster) {
            requireNonNull(adjuster, 'adjuster');
            return adjuster.adjustInto(this);
        };

        Year.prototype.withFieldValue = function withFieldValue(field, newValue) {
            requireNonNull(field, 'field');
            requireInstance(field, TemporalField, 'field');
            if (field instanceof ChronoField) {
                field.checkValidValue(newValue);
                switch (field) {
                    case ChronoField.YEAR_OF_ERA:
                        return Year.of(this._year < 1 ? 1 - newValue : newValue);
                    case ChronoField.YEAR:
                        return Year.of(newValue);
                    case ChronoField.ERA:
                        return this.getLong(ChronoField.ERA) === newValue ? this : Year.of(1 - this._year);
                }
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.adjustInto(this, newValue);
        };

        Year.prototype.plus = function plus(amountOrNumber, unit) {
            if (arguments.length === 1) {
                return this.plusAmount(amountOrNumber);
            } else {
                return this.plusAmountToAddUnit(amountOrNumber, unit);
            }
        };

        Year.prototype.plusAmount = function plusAmount(amount) {
            requireNonNull(amount, 'amount');
            requireInstance(amount, TemporalAmount, 'amount');
            return amount.addTo(this);
        };

        Year.prototype.plusAmountToAddUnit = function plusAmountToAddUnit(amountToAdd, unit) {
            requireNonNull(amountToAdd, 'amountToAdd');
            requireNonNull(unit, 'unit');
            requireInstance(unit, TemporalUnit, 'unit');
            if (unit instanceof ChronoUnit) {
                switch (unit) {
                    case ChronoUnit.YEARS:
                        return this.plusYears(amountToAdd);
                    case ChronoUnit.DECADES:
                        return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
                    case ChronoUnit.CENTURIES:
                        return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
                    case ChronoUnit.MILLENNIA:
                        return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));
                    case ChronoUnit.ERAS:
                        return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
                }
                throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);
            }
            return unit.addTo(this, amountToAdd);
        };

        Year.prototype.plusYears = function plusYears(yearsToAdd) {
            if (yearsToAdd === 0) {
                return this;
            }
            return Year.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));
        };

        Year.prototype.minus = function minus(amountOrNumber, unit) {
            if (arguments.length === 1) {
                return this.minusAmount(amountOrNumber);
            } else {
                return this.minusAmountToSubtractUnit(amountOrNumber, unit);
            }
        };

        Year.prototype.minusAmount = function minusAmount(amount) {
            requireNonNull(amount, 'amount');
            requireInstance(amount, TemporalAmount, 'amount');
            return amount.subtractFrom(this);
        };

        Year.prototype.minusAmountToSubtractUnit = function minusAmountToSubtractUnit(amountToSubtract, unit) {
            requireNonNull(amountToSubtract, 'amountToSubtract');
            requireNonNull(unit, 'unit');
            requireInstance(unit, TemporalUnit, 'unit');
            return amountToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plus(MathUtil.MAX_SAFE_INTEGER, unit).plus(1, unit) : this.plus(-amountToSubtract, unit);
        };

        Year.prototype.minusYears = function minusYears(yearsToSubtract) {
            return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
        };

        Year.prototype.adjustInto = function adjustInto(temporal) {
            requireNonNull(temporal, 'temporal');

            return temporal.with(ChronoField.YEAR, this._year);
        };

        Year.prototype.isValidMonthDay = function isValidMonthDay(monthDay) {
            return monthDay != null && monthDay.isValidYear(this._year);
        };

        Year.prototype.length = function length() {
            return this.isLeap() ? 366 : 365;
        };

        Year.prototype.atDay = function atDay(dayOfYear) {
            return LocalDate.ofYearDay(this._year, dayOfYear);
        };

        Year.prototype.atMonth = function atMonth(monthOrNumber) {
            if (arguments.length === 1 && monthOrNumber instanceof Month) {
                return this.atMonthMonth(monthOrNumber);
            } else {
                return this.atMonthNumber(monthOrNumber);
            }
        };

        Year.prototype.atMonthMonth = function atMonthMonth(month) {
            requireNonNull(month, 'month');
            requireInstance(month, Month, 'month');
            return YearMonth.of(this._year, month);
        };

        Year.prototype.atMonthNumber = function atMonthNumber(month) {
            requireNonNull(month, 'month');
            return YearMonth.of(this._year, month);
        };

        Year.prototype.atMonthDay = function atMonthDay(monthDay) {
            requireNonNull(monthDay, 'monthDay');
            requireInstance(monthDay, MonthDay, 'monthDay');
            return monthDay.atYear(this._year);
        };

        Year.prototype.query = function query(_query) {
            requireNonNull(_query, 'query()');
            requireInstance(_query, TemporalQuery, 'query()');
            if (_query === TemporalQueries.chronology()) {
                return IsoChronology.INSTANCE;
            } else if (_query === TemporalQueries.precision()) {
                return ChronoUnit.YEARS;
            } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
                return null;
            }
            return _Temporal.prototype.query.call(this, _query);
        };

        Year.prototype.compareTo = function compareTo(other) {
            requireNonNull(other, 'other');
            requireInstance(other, Year, 'other');
            return this._year - other._year;
        };

        Year.prototype.isAfter = function isAfter(other) {
            requireNonNull(other, 'other');
            requireInstance(other, Year, 'other');
            return this._year > other._year;
        };

        Year.prototype.isBefore = function isBefore(other) {
            requireNonNull(other, 'other');
            requireInstance(other, Year, 'other');
            return this._year < other._year;
        };

        Year.prototype.format = function format(formatter) {
            requireNonNull(formatter, 'formatter');
            requireInstance(formatter, DateTimeFormatter, 'formatter');
            return formatter.format(this);
        };

        Year.prototype.equals = function equals(otherYear) {
            if (this === otherYear) {
                return true;
            }
            if (otherYear instanceof Year) {
                return this.value() === otherYear.value();
            }
            return false;
        };

        Year.prototype.toString = function toString() {
            return '' + this._year;
        };

        Year.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        return Year;
    }(Temporal);


    var PARSER$2 = void 0;

    function _init$d() {

        Year.MIN_VALUE = YearConstants.MIN_VALUE;
        Year.MAX_VALUE = YearConstants.MAX_VALUE;

        PARSER$2 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();

        Year.FROM = createTemporalQuery('Year.FROM', function (temporal) {
            return Year.from(temporal);
        });
    }

    function _classCallCheck$N(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var TemporalAdjuster = function () {
      function TemporalAdjuster() {
        _classCallCheck$N(this, TemporalAdjuster);
      }

      TemporalAdjuster.prototype.adjustInto = function adjustInto(temporal) {
        abstractMethodFail('adjustInto');
      };

      return TemporalAdjuster;
    }();

    function _possibleConstructorReturn$n(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$n(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck$O(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var TemporalAdjusters = function () {
        function TemporalAdjusters() {
            _classCallCheck$O(this, TemporalAdjusters);
        }

        TemporalAdjusters.firstDayOfMonth = function firstDayOfMonth() {
            return Impl.FIRST_DAY_OF_MONTH;
        };

        TemporalAdjusters.lastDayOfMonth = function lastDayOfMonth() {
            return Impl.LAST_DAY_OF_MONTH;
        };

        TemporalAdjusters.firstDayOfNextMonth = function firstDayOfNextMonth() {
            return Impl.FIRST_DAY_OF_NEXT_MONTH;
        };

        TemporalAdjusters.firstDayOfYear = function firstDayOfYear() {
            return Impl.FIRST_DAY_OF_YEAR;
        };

        TemporalAdjusters.lastDayOfYear = function lastDayOfYear() {
            return Impl.LAST_DAY_OF_YEAR;
        };

        TemporalAdjusters.firstDayOfNextYear = function firstDayOfNextYear() {
            return Impl.FIRST_DAY_OF_NEXT_YEAR;
        };

        TemporalAdjusters.firstInMonth = function firstInMonth(dayOfWeek) {
            requireNonNull(dayOfWeek, 'dayOfWeek');
            return new DayOfWeekInMonth(1, dayOfWeek);
        };

        TemporalAdjusters.lastInMonth = function lastInMonth(dayOfWeek) {
            requireNonNull(dayOfWeek, 'dayOfWeek');
            return new DayOfWeekInMonth(-1, dayOfWeek);
        };

        TemporalAdjusters.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {
            requireNonNull(dayOfWeek, 'dayOfWeek');
            return new DayOfWeekInMonth(ordinal, dayOfWeek);
        };

        TemporalAdjusters.next = function next(dayOfWeek) {
            return new RelativeDayOfWeek(2, dayOfWeek);
        };

        TemporalAdjusters.nextOrSame = function nextOrSame(dayOfWeek) {
            return new RelativeDayOfWeek(0, dayOfWeek);
        };

        TemporalAdjusters.previous = function previous(dayOfWeek) {
            return new RelativeDayOfWeek(3, dayOfWeek);
        };

        TemporalAdjusters.previousOrSame = function previousOrSame(dayOfWeek) {
            return new RelativeDayOfWeek(1, dayOfWeek);
        };

        return TemporalAdjusters;
    }();

    var Impl = function (_TemporalAdjuster) {
        _inherits$n(Impl, _TemporalAdjuster);

        function Impl(ordinal) {
            _classCallCheck$O(this, Impl);

            var _this = _possibleConstructorReturn$n(this, _TemporalAdjuster.call(this));

            _this._ordinal = ordinal;
            return _this;
        }

        Impl.prototype.adjustInto = function adjustInto(temporal) {
            switch (this._ordinal) {
                case 0:
                    return temporal.with(ChronoField.DAY_OF_MONTH, 1);
                case 1:
                    return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
                case 2:
                    return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);
                case 3:
                    return temporal.with(ChronoField.DAY_OF_YEAR, 1);
                case 4:
                    return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());
                case 5:
                    return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);
            }
            throw new IllegalStateException('Unreachable');
        };

        return Impl;
    }(TemporalAdjuster);

    Impl.FIRST_DAY_OF_MONTH = new Impl(0);

    Impl.LAST_DAY_OF_MONTH = new Impl(1);

    Impl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);

    Impl.FIRST_DAY_OF_YEAR = new Impl(3);

    Impl.LAST_DAY_OF_YEAR = new Impl(4);

    Impl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);

    var DayOfWeekInMonth = function (_TemporalAdjuster2) {
        _inherits$n(DayOfWeekInMonth, _TemporalAdjuster2);

        function DayOfWeekInMonth(ordinal, dow) {
            _classCallCheck$O(this, DayOfWeekInMonth);

            var _this2 = _possibleConstructorReturn$n(this, _TemporalAdjuster2.call(this));

            _this2._ordinal = ordinal;
            _this2._dowValue = dow.value();
            return _this2;
        }

        DayOfWeekInMonth.prototype.adjustInto = function adjustInto(temporal) {
            if (this._ordinal >= 0) {
                var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);
                var curDow = temp.get(ChronoField.DAY_OF_WEEK);
                var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);
                dowDiff += (this._ordinal - 1) * 7;
                return temp.plus(dowDiff, ChronoUnit.DAYS);
            } else {
                var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
                var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);
                var daysDiff = this._dowValue - _curDow;
                daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;
                daysDiff -= (-this._ordinal - 1) * 7;
                return _temp.plus(daysDiff, ChronoUnit.DAYS);
            }
        };

        return DayOfWeekInMonth;
    }(TemporalAdjuster);

    var RelativeDayOfWeek = function (_TemporalAdjuster3) {
        _inherits$n(RelativeDayOfWeek, _TemporalAdjuster3);

        function RelativeDayOfWeek(relative, dayOfWeek) {
            _classCallCheck$O(this, RelativeDayOfWeek);

            var _this3 = _possibleConstructorReturn$n(this, _TemporalAdjuster3.call(this));

            requireNonNull(dayOfWeek, 'dayOfWeek');

            _this3._relative = relative;

            _this3._dowValue = dayOfWeek.value();
            return _this3;
        }

        RelativeDayOfWeek.prototype.adjustInto = function adjustInto(temporal) {
            var calDow = temporal.get(ChronoField.DAY_OF_WEEK);
            if (this._relative < 2 && calDow === this._dowValue) {
                return temporal;
            }
            if ((this._relative & 1) === 0) {
                var daysDiff = calDow - this._dowValue;
                return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);
            } else {
                var _daysDiff = this._dowValue - calDow;
                return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);
            }
        };

        return RelativeDayOfWeek;
    }(TemporalAdjuster);

    function _classCallCheck$P(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$o(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$o(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var IsoChronology = function (_Enum) {
        _inherits$o(IsoChronology, _Enum);

        function IsoChronology() {
            _classCallCheck$P(this, IsoChronology);

            return _possibleConstructorReturn$o(this, _Enum.apply(this, arguments));
        }

        IsoChronology.isLeapYear = function isLeapYear(prolepticYear) {
            return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);
        };

        IsoChronology.prototype._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {
            requireNonNull(fieldValues, 'fieldValues');
            requireNonNull(field, 'field');
            var current = fieldValues.get(field);
            if (current != null && current !== value) {
                throw new DateTimeException('Invalid state, field: ' + field + ' ' + current + ' conflicts with ' + field + ' ' + value);
            }
            fieldValues.put(field, value);
        };

        IsoChronology.prototype.resolveDate = function resolveDate(fieldValues, resolverStyle) {
            if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {
                return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));
            }

            var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);
            if (prolepticMonth != null) {
                if (resolverStyle !== ResolverStyle.LENIENT) {
                    ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);
                }
                this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);
                this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));
            }

            var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);
            if (yoeLong != null) {
                if (resolverStyle !== ResolverStyle.LENIENT) {
                    ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);
                }
                var era = fieldValues.remove(ChronoField.ERA);
                if (era == null) {
                    var year = fieldValues.get(ChronoField.YEAR);
                    if (resolverStyle === ResolverStyle.STRICT) {
                        if (year != null) {
                            this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
                        } else {
                            fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);
                        }
                    } else {
                        this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
                    }
                } else if (era === 1) {
                    this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);
                } else if (era === 0) {
                    this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));
                } else {
                    throw new DateTimeException('Invalid value for era: ' + era);
                }
            } else if (fieldValues.containsKey(ChronoField.ERA)) {
                ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));
            }

            if (fieldValues.containsKey(ChronoField.YEAR)) {
                if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {
                    if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {
                        var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
                        var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);
                        var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);
                        if (resolverStyle === ResolverStyle.LENIENT) {
                            var months = moy - 1;
                            var days = dom - 1;
                            return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);
                        } else if (resolverStyle === ResolverStyle.SMART) {
                            ChronoField.DAY_OF_MONTH.checkValidValue(dom);
                            if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {
                                dom = Math.min(dom, 30);
                            } else if (moy === 2) {
                                dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));
                            }
                            return LocalDate.of(y, moy, dom);
                        } else {
                            return LocalDate.of(y, moy, dom);
                        }
                    }
                }
                if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {
                    var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
                    if (resolverStyle === ResolverStyle.LENIENT) {
                        var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);
                        return LocalDate.ofYearDay(_y, 1).plusDays(_days);
                    }
                    var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));
                    return LocalDate.ofYearDay(_y, doy);
                }
                if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {
                    if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {
                        var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
                        if (resolverStyle === ResolverStyle.LENIENT) {
                            var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
                            var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);
                            return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);
                        }
                        var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
                        var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
                        var date = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));
                        if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== _y2) {
                            throw new DateTimeException('Strict mode rejected date parsed to a different year');
                        }
                        return date;
                    }
                    if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {
                        var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
                        if (resolverStyle === ResolverStyle.LENIENT) {
                            var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
                            var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);
                            return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);
                        }
                        var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
                        var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));
                        var _date = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));
                        if (resolverStyle === ResolverStyle.STRICT && _date.get(ChronoField.YEAR) !== _y3) {
                            throw new DateTimeException('Strict mode rejected date parsed to a different month');
                        }
                        return _date;
                    }
                }
            }
            return null;
        };

        IsoChronology.prototype.date = function date(temporal) {
            return LocalDate.from(temporal);
        };

        return IsoChronology;
    }(Enum);

    function _init$e() {
        IsoChronology.INSTANCE = new IsoChronology('IsoChronology');
    }

    function _classCallCheck$Q(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$p(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$p(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ChronoZonedDateTime = function (_Temporal) {
        _inherits$p(ChronoZonedDateTime, _Temporal);

        function ChronoZonedDateTime() {
            _classCallCheck$Q(this, ChronoZonedDateTime);

            return _possibleConstructorReturn$p(this, _Temporal.apply(this, arguments));
        }

        ChronoZonedDateTime.prototype.query = function query(_query) {
            if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
                return this.zone();
            } else if (_query === TemporalQueries.chronology()) {
                return this.toLocalDate().chronology();
            } else if (_query === TemporalQueries.precision()) {
                return ChronoUnit.NANOS;
            } else if (_query === TemporalQueries.offset()) {
                return this.offset();
            } else if (_query === TemporalQueries.localDate()) {
                return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
            } else if (_query === TemporalQueries.localTime()) {
                return this.toLocalTime();
            }
            return _Temporal.prototype.query.call(this, _query);
        };

        ChronoZonedDateTime.prototype.format = function format(formatter) {
            requireNonNull(formatter, 'formatter');
            return formatter.format(this);
        };

        ChronoZonedDateTime.prototype.toInstant = function toInstant() {
            return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());
        };

        ChronoZonedDateTime.prototype.toEpochSecond = function toEpochSecond() {
            var epochDay = this.toLocalDate().toEpochDay();
            var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
            secs -= this.offset().totalSeconds();
            return secs;
        };

        ChronoZonedDateTime.prototype.compareTo = function compareTo(other) {
            requireNonNull(other, 'other');
            var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
            if (cmp === 0) {
                cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
                if (cmp === 0) {
                    cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
                    if (cmp === 0) {
                        cmp = strcmp(this.zone().id(), other.zone().id());
                    }
                }
            }
            return cmp;
        };

        ChronoZonedDateTime.prototype.isAfter = function isAfter(other) {
            requireNonNull(other, 'other');
            var thisEpochSec = this.toEpochSecond();
            var otherEpochSec = other.toEpochSecond();
            return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
        };

        ChronoZonedDateTime.prototype.isBefore = function isBefore(other) {
            requireNonNull(other, 'other');
            var thisEpochSec = this.toEpochSecond();
            var otherEpochSec = other.toEpochSecond();
            return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
        };

        ChronoZonedDateTime.prototype.isEqual = function isEqual(other) {
            requireNonNull(other, 'other');
            return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
        };

        ChronoZonedDateTime.prototype.equals = function equals(other) {
            if (this === other) {
                return true;
            }
            if (other instanceof ChronoZonedDateTime) {
                return this.compareTo(other) === 0;
            }
            return false;
        };

        return ChronoZonedDateTime;
    }(Temporal);


    function strcmp(a, b) {
        if (a < b) {
            return -1;
        }
        if (a > b) {
            return 1;
        }
        return 0;
    }

    function _classCallCheck$R(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$q(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$q(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ZonedDateTime = function (_ChronoZonedDateTime) {
        _inherits$q(ZonedDateTime, _ChronoZonedDateTime);

        ZonedDateTime.now = function now(clockOrZone) {
            var clock = void 0;
            if (clockOrZone instanceof ZoneId) {
                clock = Clock.system(clockOrZone);
            } else {
                clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;
            }
            return ZonedDateTime.ofInstant(clock.instant(), clock.zone());
        };

        ZonedDateTime.of = function of() {
            if (arguments.length <= 2) {
                return ZonedDateTime.of2.apply(this, arguments);
            } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {
                return ZonedDateTime.of3.apply(this, arguments);
            } else {
                return ZonedDateTime.of8.apply(this, arguments);
            }
        };

        ZonedDateTime.of3 = function of3(date, time, zone) {
            return ZonedDateTime.of2(LocalDateTime.of(date, time), zone);
        };

        ZonedDateTime.of2 = function of2(localDateTime, zone) {
            return ZonedDateTime.ofLocal(localDateTime, zone, null);
        };

        ZonedDateTime.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {
            var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
            return ZonedDateTime.ofLocal(dt, zone, null);
        };

        ZonedDateTime.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {
            requireNonNull(localDateTime, 'localDateTime');
            requireNonNull(zone, 'zone');
            if (zone instanceof ZoneOffset) {
                return new ZonedDateTime(localDateTime, zone, zone);
            }
            var offset = null;
            var rules = zone.rules();
            var validOffsets = rules.validOffsets(localDateTime);
            if (validOffsets.length === 1) {
                offset = validOffsets[0];
            } else if (validOffsets.length === 0) {
                var trans = rules.transition(localDateTime);
                localDateTime = localDateTime.plusSeconds(trans.duration().seconds());
                offset = trans.offsetAfter();
            } else {
                if (preferredOffset != null && validOffsets.some(function (validOffset) {
                    return validOffset.equals(preferredOffset);
                })) {
                    offset = preferredOffset;
                } else {
                    offset = requireNonNull(validOffsets[0], 'offset');
                }
            }

            return new ZonedDateTime(localDateTime, offset, zone);
        };

        ZonedDateTime.ofInstant = function ofInstant() {
            if (arguments.length === 2) {
                return ZonedDateTime.ofInstant2.apply(this, arguments);
            } else {
                return ZonedDateTime.ofInstant3.apply(this, arguments);
            }
        };

        ZonedDateTime.ofInstant2 = function ofInstant2(instant, zone) {
            requireNonNull(instant, 'instant');
            requireNonNull(zone, 'zone');
            return ZonedDateTime._create(instant.epochSecond(), instant.nano(), zone);
        };

        ZonedDateTime.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {
            requireNonNull(localDateTime, 'localDateTime');
            requireNonNull(offset, 'offset');
            requireNonNull(zone, 'zone');
            return ZonedDateTime._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);
        };

        ZonedDateTime._create = function _create(epochSecond, nanoOfSecond, zone) {
            var rules = zone.rules();
            var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);
            var offset = rules.offset(instant);
            var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);
            return new ZonedDateTime(ldt, offset, zone);
        };

        ZonedDateTime.ofStrict = function ofStrict(localDateTime, offset, zone) {
            requireNonNull(localDateTime, 'localDateTime');
            requireNonNull(offset, 'offset');
            requireNonNull(zone, 'zone');
            var rules = zone.rules();
            if (rules.isValidOffset(localDateTime, offset) === false) {
                var trans = rules.transition(localDateTime);
                if (trans != null && trans.isGap()) {
                    throw new DateTimeException('LocalDateTime ' + localDateTime + ' does not exist in zone ' + zone + ' due to a gap in the local time-line, typically caused by daylight savings');
                }
                throw new DateTimeException('ZoneOffset "' + offset + '" is not valid for LocalDateTime "' + localDateTime + '" in zone "' + zone + '"');
            }
            return new ZonedDateTime(localDateTime, offset, zone);
        };

        ZonedDateTime.ofLenient = function ofLenient(localDateTime, offset, zone) {
            requireNonNull(localDateTime, 'localDateTime');
            requireNonNull(offset, 'offset');
            requireNonNull(zone, 'zone');
            if (zone instanceof ZoneOffset && offset.equals(zone) === false) {
                throw new IllegalArgumentException('ZoneId must match ZoneOffset');
            }
            return new ZonedDateTime(localDateTime, offset, zone);
        };

        ZonedDateTime.from = function from(temporal) {
            requireNonNull(temporal, 'temporal');
            if (temporal instanceof ZonedDateTime) {
                return temporal;
            }
            var zone = ZoneId.from(temporal);
            if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {
                var zdt = ZonedDateTime._from(temporal, zone);
                if (zdt != null) return zdt;
            }
            var ldt = LocalDateTime.from(temporal);
            return ZonedDateTime.of2(ldt, zone);
        };

        ZonedDateTime._from = function _from(temporal, zone) {
            try {
                return ZonedDateTime.__from(temporal, zone);
            } catch (ex) {
                if (!(ex instanceof DateTimeException)) throw ex;
            }
        };

        ZonedDateTime.__from = function __from(temporal, zone) {
            var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);
            var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
            return ZonedDateTime._create(epochSecond, nanoOfSecond, zone);
        };

        ZonedDateTime.parse = function parse(text) {
            var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DateTimeFormatter.ISO_ZONED_DATE_TIME;

            requireNonNull(formatter, 'formatter');
            return formatter.parse(text, ZonedDateTime.FROM);
        };

        function ZonedDateTime(dateTime, offset, zone) {
            _classCallCheck$R(this, ZonedDateTime);

            requireNonNull(dateTime, 'dateTime');
            requireNonNull(offset, 'offset');
            requireNonNull(zone, 'zone');

            var _this = _possibleConstructorReturn$q(this, _ChronoZonedDateTime.call(this));

            _this._dateTime = dateTime;

            _this._offset = offset;

            _this._zone = zone;
            return _this;
        }

        ZonedDateTime.prototype._resolveLocal = function _resolveLocal(newDateTime) {
            requireNonNull(newDateTime, 'newDateTime');
            return ZonedDateTime.ofLocal(newDateTime, this._zone, this._offset);
        };

        ZonedDateTime.prototype._resolveInstant = function _resolveInstant(newDateTime) {
            return ZonedDateTime.ofInstant3(newDateTime, this._offset, this._zone);
        };

        ZonedDateTime.prototype._resolveOffset = function _resolveOffset(offset) {
            if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {
                return new ZonedDateTime(this._dateTime, offset, this._zone);
            }
            return this;
        };

        ZonedDateTime.prototype.isSupported = function isSupported(fieldOrUnit) {
            if (fieldOrUnit instanceof ChronoField) {
                return true;
            } else if (fieldOrUnit instanceof ChronoUnit) {
                return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
            }
            return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
        };

        ZonedDateTime.prototype.range = function range(field) {
            if (field instanceof ChronoField) {
                if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
                    return field.range();
                }
                return this._dateTime.range(field);
            }
            return field.rangeRefinedBy(this);
        };

        ZonedDateTime.prototype.get = function get(field) {
            return this.getLong(field);
        };

        ZonedDateTime.prototype.getLong = function getLong(field) {
            if (field instanceof ChronoField) {
                switch (field) {
                    case ChronoField.INSTANT_SECONDS:
                        return this.toEpochSecond();
                    case ChronoField.OFFSET_SECONDS:
                        return this._offset.totalSeconds();
                }
                return this._dateTime.getLong(field);
            }
            requireNonNull(field, 'field');
            return field.getFrom(this);
        };

        ZonedDateTime.prototype.offset = function offset() {
            return this._offset;
        };

        ZonedDateTime.prototype.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {
            var trans = this._zone.rules().transition(this._dateTime);
            if (trans != null && trans.isOverlap()) {
                var earlierOffset = trans.offsetBefore();
                if (earlierOffset.equals(this._offset) === false) {
                    return new ZonedDateTime(this._dateTime, earlierOffset, this._zone);
                }
            }
            return this;
        };

        ZonedDateTime.prototype.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {
            var trans = this._zone.rules().transition(this.toLocalDateTime());
            if (trans != null) {
                var laterOffset = trans.offsetAfter();
                if (laterOffset.equals(this._offset) === false) {
                    return new ZonedDateTime(this._dateTime, laterOffset, this._zone);
                }
            }
            return this;
        };

        ZonedDateTime.prototype.zone = function zone() {
            return this._zone;
        };

        ZonedDateTime.prototype.withZoneSameLocal = function withZoneSameLocal(zone) {
            requireNonNull(zone, 'zone');
            return this._zone.equals(zone) ? this : ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);
        };

        ZonedDateTime.prototype.withZoneSameInstant = function withZoneSameInstant(zone) {
            requireNonNull(zone, 'zone');
            return this._zone.equals(zone) ? this : ZonedDateTime._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);
        };

        ZonedDateTime.prototype.withFixedOffsetZone = function withFixedOffsetZone() {
            return this._zone.equals(this._offset) ? this : new ZonedDateTime(this._dateTime, this._offset, this._offset);
        };

        ZonedDateTime.prototype.year = function year() {
            return this._dateTime.year();
        };

        ZonedDateTime.prototype.monthValue = function monthValue() {
            return this._dateTime.monthValue();
        };

        ZonedDateTime.prototype.month = function month() {
            return this._dateTime.month();
        };

        ZonedDateTime.prototype.dayOfMonth = function dayOfMonth() {
            return this._dateTime.dayOfMonth();
        };

        ZonedDateTime.prototype.dayOfYear = function dayOfYear() {
            return this._dateTime.dayOfYear();
        };

        ZonedDateTime.prototype.dayOfWeek = function dayOfWeek() {
            return this._dateTime.dayOfWeek();
        };

        ZonedDateTime.prototype.hour = function hour() {
            return this._dateTime.hour();
        };

        ZonedDateTime.prototype.minute = function minute() {
            return this._dateTime.minute();
        };

        ZonedDateTime.prototype.second = function second() {
            return this._dateTime.second();
        };

        ZonedDateTime.prototype.nano = function nano() {
            return this._dateTime.nano();
        };

        ZonedDateTime.prototype.with = function _with() {
            if (arguments.length === 1) {
                return this.withTemporalAdjuster.apply(this, arguments);
            } else {
                return this.with2.apply(this, arguments);
            }
        };

        ZonedDateTime.prototype.withTemporalAdjuster = function withTemporalAdjuster(adjuster) {
            if (adjuster instanceof LocalDate) {
                return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));
            } else if (adjuster instanceof LocalTime) {
                return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));
            } else if (adjuster instanceof LocalDateTime) {
                return this._resolveLocal(adjuster);
            } else if (adjuster instanceof Instant) {
                var instant = adjuster;
                return ZonedDateTime._create(instant.epochSecond(), instant.nano(), this._zone);
            } else if (adjuster instanceof ZoneOffset) {
                return this._resolveOffset(adjuster);
            }
            requireNonNull(adjuster, 'adjuster');
            return adjuster.adjustInto(this);
        };

        ZonedDateTime.prototype.with2 = function with2(field, newValue) {
            if (field instanceof ChronoField) {
                switch (field) {
                    case ChronoField.INSTANT_SECONDS:
                        return ZonedDateTime._create(newValue, this.nano(), this._zone);
                    case ChronoField.OFFSET_SECONDS:
                        {
                            var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));
                            return this._resolveOffset(offset);
                        }
                }
                return this._resolveLocal(this._dateTime.with(field, newValue));
            }
            return field.adjustInto(this, newValue);
        };

        ZonedDateTime.prototype.withYear = function withYear(year) {
            return this._resolveLocal(this._dateTime.withYear(year));
        };

        ZonedDateTime.prototype.withMonth = function withMonth(month) {
            return this._resolveLocal(this._dateTime.withMonth(month));
        };

        ZonedDateTime.prototype.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
            return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));
        };

        ZonedDateTime.prototype.withDayOfYear = function withDayOfYear(dayOfYear) {
            return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));
        };

        ZonedDateTime.prototype.withHour = function withHour(hour) {
            return this._resolveLocal(this._dateTime.withHour(hour));
        };

        ZonedDateTime.prototype.withMinute = function withMinute(minute) {
            return this._resolveLocal(this._dateTime.withMinute(minute));
        };

        ZonedDateTime.prototype.withSecond = function withSecond(second) {
            return this._resolveLocal(this._dateTime.withSecond(second));
        };

        ZonedDateTime.prototype.withNano = function withNano(nanoOfSecond) {
            return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));
        };

        ZonedDateTime.prototype.truncatedTo = function truncatedTo(unit) {
            return this._resolveLocal(this._dateTime.truncatedTo(unit));
        };

        ZonedDateTime.prototype.plus = function plus() {
            if (arguments.length === 1) {
                return this.plusTemporalAmount.apply(this, arguments);
            } else {
                return this.plus2.apply(this, arguments);
            }
        };

        ZonedDateTime.prototype.plusTemporalAmount = function plusTemporalAmount(amount) {
            requireNonNull(amount);
            return amount.addTo(this);
        };

        ZonedDateTime.prototype.plus2 = function plus2(amountToAdd, unit) {
            if (unit instanceof ChronoUnit) {
                if (unit.isDateBased()) {
                    return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));
                } else {
                    return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));
                }
            }
            requireNonNull(unit, 'unit');
            return unit.addTo(this, amountToAdd);
        };

        ZonedDateTime.prototype.plusYears = function plusYears(years) {
            return this._resolveLocal(this._dateTime.plusYears(years));
        };

        ZonedDateTime.prototype.plusMonths = function plusMonths(months) {
            return this._resolveLocal(this._dateTime.plusMonths(months));
        };

        ZonedDateTime.prototype.plusWeeks = function plusWeeks(weeks) {
            return this._resolveLocal(this._dateTime.plusWeeks(weeks));
        };

        ZonedDateTime.prototype.plusDays = function plusDays(days) {
            return this._resolveLocal(this._dateTime.plusDays(days));
        };

        ZonedDateTime.prototype.plusHours = function plusHours(hours) {
            return this._resolveInstant(this._dateTime.plusHours(hours));
        };

        ZonedDateTime.prototype.plusMinutes = function plusMinutes(minutes) {
            return this._resolveInstant(this._dateTime.plusMinutes(minutes));
        };

        ZonedDateTime.prototype.plusSeconds = function plusSeconds(seconds) {
            return this._resolveInstant(this._dateTime.plusSeconds(seconds));
        };

        ZonedDateTime.prototype.plusNanos = function plusNanos(nanos) {
            return this._resolveInstant(this._dateTime.plusNanos(nanos));
        };

        ZonedDateTime.prototype.minus = function minus() {
            if (arguments.length === 1) {
                return this.minusTemporalAmount.apply(this, arguments);
            } else {
                return this.minus2.apply(this, arguments);
            }
        };

        ZonedDateTime.prototype.minusTemporalAmount = function minusTemporalAmount(amount) {
            requireNonNull(amount, 'amount');
            return amount.subtractFrom(this);
        };

        ZonedDateTime.prototype.minus2 = function minus2(amountToSubtract, unit) {
            return this.plus2(-1 * amountToSubtract, unit);
        };

        ZonedDateTime.prototype.minusYears = function minusYears(years) {
            return this.plusYears(-1 * years);
        };

        ZonedDateTime.prototype.minusMonths = function minusMonths(months) {
            return this.plusMonths(-1 * months);
        };

        ZonedDateTime.prototype.minusWeeks = function minusWeeks(weeks) {
            return this.plusWeeks(-1 * weeks);
        };

        ZonedDateTime.prototype.minusDays = function minusDays(days) {
            return this.plusDays(-1 * days);
        };

        ZonedDateTime.prototype.minusHours = function minusHours(hours) {
            return this.plusHours(-1 * hours);
        };

        ZonedDateTime.prototype.minusMinutes = function minusMinutes(minutes) {
            return this.plusMinutes(-1 * minutes);
        };

        ZonedDateTime.prototype.minusSeconds = function minusSeconds(seconds) {
            return this.plusSeconds(-1 * seconds);
        };

        ZonedDateTime.prototype.minusNanos = function minusNanos(nanos) {
            return this.plusNanos(-1 * nanos);
        };

        ZonedDateTime.prototype.query = function query(_query) {
            if (_query === TemporalQueries.localDate()) {
                return this.toLocalDate();
            }
            requireNonNull(_query, 'query');
            return _ChronoZonedDateTime.prototype.query.call(this, _query);
        };

        ZonedDateTime.prototype.until = function until(endExclusive, unit) {
            var end = ZonedDateTime.from(endExclusive);
            if (unit instanceof ChronoUnit) {
                end = end.withZoneSameInstant(this._zone);
                if (unit.isDateBased()) {
                    return this._dateTime.until(end._dateTime, unit);
                } else {
                    var difference = this._offset.totalSeconds() - end._offset.totalSeconds();
                    var adjustedEnd = end._dateTime.plusSeconds(difference);
                    return this._dateTime.until(adjustedEnd, unit);
                }
            }
            return unit.between(this, end);
        };

        ZonedDateTime.prototype.toLocalDateTime = function toLocalDateTime() {
            return this._dateTime;
        };

        ZonedDateTime.prototype.toLocalDate = function toLocalDate() {
            return this._dateTime.toLocalDate();
        };

        ZonedDateTime.prototype.toLocalTime = function toLocalTime() {
            return this._dateTime.toLocalTime();
        };

        ZonedDateTime.prototype.equals = function equals(other) {
            if (this === other) {
                return true;
            }
            if (other instanceof ZonedDateTime) {
                return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);
            }
            return false;
        };

        ZonedDateTime.prototype.hashCode = function hashCode() {
            return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());
        };

        ZonedDateTime.prototype.toString = function toString() {
            var str = this._dateTime.toString() + this._offset.toString();
            if (this._offset !== this._zone) {
                str += '[' + this._zone.toString() + ']';
            }
            return str;
        };

        ZonedDateTime.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        ZonedDateTime.prototype.format = function format(formatter) {
            return _ChronoZonedDateTime.prototype.format.call(this, formatter);
        };

        return ZonedDateTime;
    }(ChronoZonedDateTime);


    function _init$f() {
        ZonedDateTime.FROM = createTemporalQuery('ZonedDateTime.FROM', function (temporal) {
            return ZonedDateTime.from(temporal);
        });
    }

    function _classCallCheck$S(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$r(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$r(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var DAYS_PER_CYCLE = 146097;

    var DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);

    var LocalDate = function (_ChronoLocalDate) {
        _inherits$r(LocalDate, _ChronoLocalDate);

        LocalDate.now = function now(clockOrZone) {
            var clock = void 0;
            if (clockOrZone == null) {
                clock = Clock.systemDefaultZone();
            } else if (clockOrZone instanceof ZoneId) {
                clock = Clock.system(clockOrZone);
            } else {
                clock = clockOrZone;
            }
            return LocalDate.ofInstant(clock.instant(), clock.zone());
        };

        LocalDate.ofInstant = function ofInstant(instant) {
            var zone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZoneId.systemDefault();

            requireNonNull(instant, 'instant');
            var offset = zone.rules().offset(instant);
            var epochSec = instant.epochSecond() + offset.totalSeconds();
            var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);
            return LocalDate.ofEpochDay(epochDay);
        };

        LocalDate.of = function of(year, month, dayOfMonth) {
            return new LocalDate(year, month, dayOfMonth);
        };

        LocalDate.ofYearDay = function ofYearDay(year, dayOfYear) {
            ChronoField.YEAR.checkValidValue(year);

            var leap = IsoChronology.isLeapYear(year);
            if (dayOfYear === 366 && leap === false) {
                assert(false, 'Invalid date \'DayOfYear 366\' as \'' + year + '\' is not a leap year', DateTimeException);
            }
            var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));
            var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;
            if (dayOfYear > monthEnd) {
                moy = moy.plus(1);
            }
            var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;
            return new LocalDate(year, moy.value(), dom);
        };

        LocalDate.ofEpochDay = function ofEpochDay() {
            var epochDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            var adjust = void 0,
                adjustCycles = void 0,
                doyEst = void 0,
                yearEst = void 0,
                zeroDay = void 0;
            zeroDay = epochDay + DAYS_0000_TO_1970;
            zeroDay -= 60;
            adjust = 0;
            if (zeroDay < 0) {
                adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;
                adjust = adjustCycles * 400;
                zeroDay += -adjustCycles * DAYS_PER_CYCLE;
            }
            yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);
            doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
            if (doyEst < 0) {
                yearEst--;
                doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
            }
            yearEst += adjust;
            var marchDoy0 = doyEst;
            var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);
            var month = (marchMonth0 + 2) % 12 + 1;
            var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;
            yearEst += MathUtil.intDiv(marchMonth0, 10);
            var year = yearEst;
            return new LocalDate(year, month, dom);
        };

        LocalDate.from = function from(temporal) {
            requireNonNull(temporal, 'temporal');
            var date = temporal.query(TemporalQueries.localDate());
            if (date == null) {
                throw new DateTimeException('Unable to obtain LocalDate from TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''));
            }
            return date;
        };

        LocalDate.parse = function parse(text) {
            var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DateTimeFormatter.ISO_LOCAL_DATE;

            assert(formatter != null, 'formatter', NullPointerException);
            return formatter.parse(text, LocalDate.FROM);
        };

        LocalDate._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {
            switch (month) {
                case 2:
                    day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);
                    break;
                case 4:
                case 6:
                case 9:
                case 11:
                    day = Math.min(day, 30);
                    break;
            }
            return LocalDate.of(year, month, day);
        };

        function LocalDate(year, month, dayOfMonth) {
            _classCallCheck$S(this, LocalDate);

            var _this = _possibleConstructorReturn$r(this, _ChronoLocalDate.call(this));

            if (month instanceof Month) {
                month = month.value();
            }
            _this._year = MathUtil.safeToInt(year);
            _this._month = MathUtil.safeToInt(month);
            _this._day = MathUtil.safeToInt(dayOfMonth);
            LocalDate._validate(_this._year, _this._month, _this._day);
            return _this;
        }

        LocalDate._validate = function _validate(year, month, dayOfMonth) {
            var dom = void 0;
            ChronoField.YEAR.checkValidValue(year);
            ChronoField.MONTH_OF_YEAR.checkValidValue(month);
            ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);

            if (dayOfMonth > 28) {
                dom = 31;
                switch (month) {
                    case 2:
                        dom = IsoChronology.isLeapYear(year) ? 29 : 28;
                        break;
                    case 4:
                    case 6:
                    case 9:
                    case 11:
                        dom = 30;
                }
                if (dayOfMonth > dom) {
                    if (dayOfMonth === 29) {
                        assert(false, 'Invalid date \'February 29\' as \'' + year + '\' is not a leap year', DateTimeException);
                    } else {
                        assert(false, 'Invalid date \'' + year + '\' \'' + month + '\' \'' + dayOfMonth + '\'', DateTimeException);
                    }
                }
            }
        };

        LocalDate.prototype.isSupported = function isSupported(field) {
            return _ChronoLocalDate.prototype.isSupported.call(this, field);
        };

        LocalDate.prototype.range = function range(field) {
            if (field instanceof ChronoField) {
                if (field.isDateBased()) {
                    switch (field) {
                        case ChronoField.DAY_OF_MONTH:
                            return ValueRange.of(1, this.lengthOfMonth());
                        case ChronoField.DAY_OF_YEAR:
                            return ValueRange.of(1, this.lengthOfYear());
                        case ChronoField.ALIGNED_WEEK_OF_MONTH:
                            return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);
                        case ChronoField.YEAR_OF_ERA:
                            return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
                    }
                    return field.range();
                }
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.rangeRefinedBy(this);
        };

        LocalDate.prototype.get = function get(field) {
            return this.getLong(field);
        };

        LocalDate.prototype.getLong = function getLong(field) {
            assert(field != null, '', NullPointerException);
            if (field instanceof ChronoField) {
                return this._get0(field);
            }
            return field.getFrom(this);
        };

        LocalDate.prototype._get0 = function _get0(field) {
            switch (field) {
                case ChronoField.DAY_OF_WEEK:
                    return this.dayOfWeek().value();
                case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
                    return MathUtil.intMod(this._day - 1, 7) + 1;
                case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
                    return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;
                case ChronoField.DAY_OF_MONTH:
                    return this._day;
                case ChronoField.DAY_OF_YEAR:
                    return this.dayOfYear();
                case ChronoField.EPOCH_DAY:
                    return this.toEpochDay();
                case ChronoField.ALIGNED_WEEK_OF_MONTH:
                    return MathUtil.intDiv(this._day - 1, 7) + 1;
                case ChronoField.ALIGNED_WEEK_OF_YEAR:
                    return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;
                case ChronoField.MONTH_OF_YEAR:
                    return this._month;
                case ChronoField.PROLEPTIC_MONTH:
                    return this._prolepticMonth();
                case ChronoField.YEAR_OF_ERA:
                    return this._year >= 1 ? this._year : 1 - this._year;
                case ChronoField.YEAR:
                    return this._year;
                case ChronoField.ERA:
                    return this._year >= 1 ? 1 : 0;
            }
            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
        };

        LocalDate.prototype._prolepticMonth = function _prolepticMonth() {
            return this._year * 12 + (this._month - 1);
        };

        LocalDate.prototype.chronology = function chronology() {
            return IsoChronology.INSTANCE;
        };

        LocalDate.prototype.year = function year() {
            return this._year;
        };

        LocalDate.prototype.monthValue = function monthValue() {
            return this._month;
        };

        LocalDate.prototype.month = function month() {
            return Month.of(this._month);
        };

        LocalDate.prototype.dayOfMonth = function dayOfMonth() {
            return this._day;
        };

        LocalDate.prototype.dayOfYear = function dayOfYear() {
            return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;
        };

        LocalDate.prototype.dayOfWeek = function dayOfWeek() {
            var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);
            return DayOfWeek.of(dow0 + 1);
        };

        LocalDate.prototype.isLeapYear = function isLeapYear() {
            return IsoChronology.isLeapYear(this._year);
        };

        LocalDate.prototype.lengthOfMonth = function lengthOfMonth() {
            switch (this._month) {
                case 2:
                    return this.isLeapYear() ? 29 : 28;
                case 4:
                case 6:
                case 9:
                case 11:
                    return 30;
                default:
                    return 31;
            }
        };

        LocalDate.prototype.lengthOfYear = function lengthOfYear() {
            return this.isLeapYear() ? 366 : 365;
        };

        LocalDate.prototype.with = function _with(fieldOrAdjuster, newValue) {
            if (arguments.length < 2) {
                return this.withTemporalAdjuster(fieldOrAdjuster);
            } else {
                return this.withFieldAndValue(fieldOrAdjuster, newValue);
            }
        };

        LocalDate.prototype.withTemporalAdjuster = function withTemporalAdjuster(adjuster) {
            requireNonNull(adjuster, 'adjuster');

            if (adjuster instanceof LocalDate) {
                return adjuster;
            }
            assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);
            return adjuster.adjustInto(this);
        };

        LocalDate.prototype.withFieldAndValue = function withFieldAndValue(field, newValue) {
            assert(field != null, 'field', NullPointerException);
            if (field instanceof ChronoField) {
                var f = field;
                f.checkValidValue(newValue);
                switch (f) {
                    case ChronoField.DAY_OF_WEEK:
                        return this.plusDays(newValue - this.dayOfWeek().value());
                    case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
                        return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));
                    case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
                        return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
                    case ChronoField.DAY_OF_MONTH:
                        return this.withDayOfMonth(newValue);
                    case ChronoField.DAY_OF_YEAR:
                        return this.withDayOfYear(newValue);
                    case ChronoField.EPOCH_DAY:
                        return LocalDate.ofEpochDay(newValue);
                    case ChronoField.ALIGNED_WEEK_OF_MONTH:
                        return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));
                    case ChronoField.ALIGNED_WEEK_OF_YEAR:
                        return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));
                    case ChronoField.MONTH_OF_YEAR:
                        return this.withMonth(newValue);
                    case ChronoField.PROLEPTIC_MONTH:
                        return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
                    case ChronoField.YEAR_OF_ERA:
                        return this.withYear(this._year >= 1 ? newValue : 1 - newValue);
                    case ChronoField.YEAR:
                        return this.withYear(newValue);
                    case ChronoField.ERA:
                        return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
                }
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.adjustInto(this, newValue);
        };

        LocalDate.prototype.withYear = function withYear(year) {
            if (this._year === year) {
                return this;
            }
            ChronoField.YEAR.checkValidValue(year);
            return LocalDate._resolvePreviousValid(year, this._month, this._day);
        };

        LocalDate.prototype.withMonth = function withMonth(month) {
            var m = month instanceof Month ? month.value() : month;
            if (this._month === m) {
                return this;
            }
            ChronoField.MONTH_OF_YEAR.checkValidValue(m);
            return LocalDate._resolvePreviousValid(this._year, m, this._day);
        };

        LocalDate.prototype.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
            if (this._day === dayOfMonth) {
                return this;
            }
            return LocalDate.of(this._year, this._month, dayOfMonth);
        };

        LocalDate.prototype.withDayOfYear = function withDayOfYear(dayOfYear) {
            if (this.dayOfYear() === dayOfYear) {
                return this;
            }
            return LocalDate.ofYearDay(this._year, dayOfYear);
        };

        LocalDate.prototype.plus = function plus(p1, p2) {
            if (arguments.length < 2) {
                return this.plus1(p1);
            } else {
                return this.plus2(p1, p2);
            }
        };

        LocalDate.prototype.plus1 = function plus1(amount) {
            requireNonNull(amount, 'amount');
            return amount.addTo(this);
        };

        LocalDate.prototype.plus2 = function plus2(amountToAdd, unit) {
            requireNonNull(amountToAdd, 'amountToAdd');
            requireNonNull(unit, 'unit');
            if (unit instanceof ChronoUnit) {
                switch (unit) {
                    case ChronoUnit.DAYS:
                        return this.plusDays(amountToAdd);
                    case ChronoUnit.WEEKS:
                        return this.plusWeeks(amountToAdd);
                    case ChronoUnit.MONTHS:
                        return this.plusMonths(amountToAdd);
                    case ChronoUnit.YEARS:
                        return this.plusYears(amountToAdd);
                    case ChronoUnit.DECADES:
                        return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
                    case ChronoUnit.CENTURIES:
                        return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
                    case ChronoUnit.MILLENNIA:
                        return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));
                    case ChronoUnit.ERAS:
                        return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
                }
                throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);
            }
            return unit.addTo(this, amountToAdd);
        };

        LocalDate.prototype.plusYears = function plusYears(yearsToAdd) {
            if (yearsToAdd === 0) {
                return this;
            }
            var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
            return LocalDate._resolvePreviousValid(newYear, this._month, this._day);
        };

        LocalDate.prototype.plusMonths = function plusMonths(monthsToAdd) {
            if (monthsToAdd === 0) {
                return this;
            }
            var monthCount = this._year * 12 + (this._month - 1);
            var calcMonths = monthCount + monthsToAdd;
            var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
            var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
            return LocalDate._resolvePreviousValid(newYear, newMonth, this._day);
        };

        LocalDate.prototype.plusWeeks = function plusWeeks(weeksToAdd) {
            return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));
        };

        LocalDate.prototype.plusDays = function plusDays(daysToAdd) {
            if (daysToAdd === 0) {
                return this;
            }
            var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);
            return LocalDate.ofEpochDay(mjDay);
        };

        LocalDate.prototype.minus = function minus(p1, p2) {
            if (arguments.length < 2) {
                return this.minus1(p1);
            } else {
                return this.minus2(p1, p2);
            }
        };

        LocalDate.prototype.minus1 = function minus1(amount) {
            requireNonNull(amount, 'amount');
            return amount.subtractFrom(this);
        };

        LocalDate.prototype.minus2 = function minus2(amountToSubtract, unit) {
            requireNonNull(amountToSubtract, 'amountToSubtract');
            requireNonNull(unit, 'unit');
            return this.plus2(-1 * amountToSubtract, unit);
        };

        LocalDate.prototype.minusYears = function minusYears(yearsToSubtract) {
            return this.plusYears(yearsToSubtract * -1);
        };

        LocalDate.prototype.minusMonths = function minusMonths(monthsToSubtract) {
            return this.plusMonths(monthsToSubtract * -1);
        };

        LocalDate.prototype.minusWeeks = function minusWeeks(weeksToSubtract) {
            return this.plusWeeks(weeksToSubtract * -1);
        };

        LocalDate.prototype.minusDays = function minusDays(daysToSubtract) {
            return this.plusDays(daysToSubtract * -1);
        };

        LocalDate.prototype.query = function query(_query) {
            requireNonNull(_query, 'query');
            if (_query === TemporalQueries.localDate()) {
                return this;
            }
            return _ChronoLocalDate.prototype.query.call(this, _query);
        };

        LocalDate.prototype.adjustInto = function adjustInto(temporal) {
            return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);
        };

        LocalDate.prototype.until = function until(p1, p2) {
            if (arguments.length < 2) {
                return this.until1(p1);
            } else {
                return this.until2(p1, p2);
            }
        };

        LocalDate.prototype.until2 = function until2(endExclusive, unit) {
            var end = LocalDate.from(endExclusive);
            if (unit instanceof ChronoUnit) {
                switch (unit) {
                    case ChronoUnit.DAYS:
                        return this.daysUntil(end);
                    case ChronoUnit.WEEKS:
                        return MathUtil.intDiv(this.daysUntil(end), 7);
                    case ChronoUnit.MONTHS:
                        return this._monthsUntil(end);
                    case ChronoUnit.YEARS:
                        return MathUtil.intDiv(this._monthsUntil(end), 12);
                    case ChronoUnit.DECADES:
                        return MathUtil.intDiv(this._monthsUntil(end), 120);
                    case ChronoUnit.CENTURIES:
                        return MathUtil.intDiv(this._monthsUntil(end), 1200);
                    case ChronoUnit.MILLENNIA:
                        return MathUtil.intDiv(this._monthsUntil(end), 12000);
                    case ChronoUnit.ERAS:
                        return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
                }
                throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);
            }
            return unit.between(this, end);
        };

        LocalDate.prototype.daysUntil = function daysUntil(end) {
            return end.toEpochDay() - this.toEpochDay();
        };

        LocalDate.prototype._monthsUntil = function _monthsUntil(end) {
            var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();
            var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();
            return MathUtil.intDiv(packed2 - packed1, 32);
        };

        LocalDate.prototype.until1 = function until1(endDate) {
            var end = LocalDate.from(endDate);
            var totalMonths = end._prolepticMonth() - this._prolepticMonth();
            var days = end._day - this._day;
            if (totalMonths > 0 && days < 0) {
                totalMonths--;
                var calcDate = this.plusMonths(totalMonths);
                days = end.toEpochDay() - calcDate.toEpochDay();
            } else if (totalMonths < 0 && days > 0) {
                totalMonths++;
                days -= end.lengthOfMonth();
            }
            var years = MathUtil.intDiv(totalMonths, 12);
            var months = MathUtil.intMod(totalMonths, 12);
            return Period.of(years, months, days);
        };

        LocalDate.prototype.atTime = function atTime() {
            if (arguments.length === 1) {
                return this.atTime1.apply(this, arguments);
            } else {
                return this.atTime4.apply(this, arguments);
            }
        };

        LocalDate.prototype.atTime1 = function atTime1(time) {
            return LocalDateTime.of(this, time);
        };

        LocalDate.prototype.atTime4 = function atTime4(hour, minute) {
            var second = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var nanoOfSecond = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

            return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));
        };

        LocalDate.prototype.atStartOfDay = function atStartOfDay(zone) {
            if (zone != null) {
                return this.atStartOfDayWithZone(zone);
            } else {
                return LocalDateTime.of(this, LocalTime.MIDNIGHT);
            }
        };

        LocalDate.prototype.atStartOfDayWithZone = function atStartOfDayWithZone(zone) {
            requireNonNull(zone, 'zone');
            var ldt = this.atTime(LocalTime.MIDNIGHT);

            if (zone instanceof ZoneOffset === false) {
                var trans = zone.rules().transition(ldt);
                if (trans != null && trans.isGap()) {
                    ldt = trans.dateTimeAfter();
                }
            }
            return ZonedDateTime.of(ldt, zone);
        };

        LocalDate.prototype.toEpochDay = function toEpochDay() {
            var y = this._year;
            var m = this._month;
            var total = 0;
            total += 365 * y;
            if (y >= 0) {
                total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);
            } else {
                total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);
            }
            total += MathUtil.intDiv(367 * m - 362, 12);
            total += this.dayOfMonth() - 1;
            if (m > 2) {
                total--;
                if (!IsoChronology.isLeapYear(y)) {
                    total--;
                }
            }
            return total - DAYS_0000_TO_1970;
        };

        LocalDate.prototype.compareTo = function compareTo(other) {
            requireNonNull(other, 'other');
            requireInstance(other, LocalDate, 'other');
            return this._compareTo0(other);
        };

        LocalDate.prototype._compareTo0 = function _compareTo0(otherDate) {
            var cmp = this._year - otherDate._year;
            if (cmp === 0) {
                cmp = this._month - otherDate._month;
                if (cmp === 0) {
                    cmp = this._day - otherDate._day;
                }
            }
            return cmp;
        };

        LocalDate.prototype.isAfter = function isAfter(other) {
            return this.compareTo(other) > 0;
        };

        LocalDate.prototype.isBefore = function isBefore(other) {
            return this.compareTo(other) < 0;
        };

        LocalDate.prototype.isEqual = function isEqual(other) {
            return this.compareTo(other) === 0;
        };

        LocalDate.prototype.equals = function equals(otherDate) {
            if (this === otherDate) {
                return true;
            }
            if (otherDate instanceof LocalDate) {
                return this._compareTo0(otherDate) === 0;
            }
            return false;
        };

        LocalDate.prototype.hashCode = function hashCode() {
            var yearValue = this._year;
            var monthValue = this._month;
            var dayValue = this._day;
            return MathUtil.hash(yearValue & 0xFFFFF800 ^ (yearValue << 11) + (monthValue << 6) + dayValue);
        };

        LocalDate.prototype.toString = function toString() {
            var dayString = void 0,
                monthString = void 0,
                yearString = void 0;

            var yearValue = this._year;
            var monthValue = this._month;
            var dayValue = this._day;

            var absYear = Math.abs(yearValue);

            if (absYear < 1000) {
                if (yearValue < 0) {
                    yearString = '-' + ('' + (yearValue - 10000)).slice(-4);
                } else {
                    yearString = ('' + (yearValue + 10000)).slice(-4);
                }
            } else {
                if (yearValue > 9999) {
                    yearString = '+' + yearValue;
                } else {
                    yearString = '' + yearValue;
                }
            }

            if (monthValue < 10) {
                monthString = '-0' + monthValue;
            } else {
                monthString = '-' + monthValue;
            }

            if (dayValue < 10) {
                dayString = '-0' + dayValue;
            } else {
                dayString = '-' + dayValue;
            }

            return yearString + monthString + dayString;
        };

        LocalDate.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        LocalDate.prototype.format = function format(formatter) {
            requireNonNull(formatter, 'formatter');
            requireInstance(formatter, DateTimeFormatter, 'formatter');
            return _ChronoLocalDate.prototype.format.call(this, formatter);
        };

        return LocalDate;
    }(ChronoLocalDate);


    function _init$g() {
        LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);

        LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);

        LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);

        LocalDate.FROM = createTemporalQuery('LocalDate.FROM', function (temporal) {
            return LocalDate.from(temporal);
        });
    }

    function _classCallCheck$T(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$s(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$s(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var ChronoLocalDateTime = function (_Temporal) {
        _inherits$s(ChronoLocalDateTime, _Temporal);

        function ChronoLocalDateTime() {
            _classCallCheck$T(this, ChronoLocalDateTime);

            return _possibleConstructorReturn$s(this, _Temporal.apply(this, arguments));
        }

        ChronoLocalDateTime.prototype.chronology = function chronology() {
            return this.toLocalDate().chronology();
        };

        ChronoLocalDateTime.prototype.query = function query(_query) {
            if (_query === TemporalQueries.chronology()) {
                return this.chronology();
            } else if (_query === TemporalQueries.precision()) {
                return ChronoUnit.NANOS;
            } else if (_query === TemporalQueries.localDate()) {
                return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
            } else if (_query === TemporalQueries.localTime()) {
                return this.toLocalTime();
            } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
                return null;
            }
            return _Temporal.prototype.query.call(this, _query);
        };

        ChronoLocalDateTime.prototype.adjustInto = function adjustInto(temporal) {
            return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());
        };

        ChronoLocalDateTime.prototype.toInstant = function toInstant(offset) {
            requireInstance(offset, ZoneOffset, 'zoneId');
            return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());
        };

        ChronoLocalDateTime.prototype.toEpochSecond = function toEpochSecond(offset) {
            requireNonNull(offset, 'offset');
            var epochDay = this.toLocalDate().toEpochDay();
            var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
            secs -= offset.totalSeconds();
            return MathUtil.safeToInt(secs);
        };

        return ChronoLocalDateTime;
    }(Temporal);

    function _classCallCheck$U(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$t(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$t(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var LocalDateTime = function (_ChronoLocalDateTime) {
        _inherits$t(LocalDateTime, _ChronoLocalDateTime);

        LocalDateTime.now = function now(clockOrZone) {
            if (clockOrZone == null) {
                return LocalDateTime._now(Clock.systemDefaultZone());
            } else if (clockOrZone instanceof Clock) {
                return LocalDateTime._now(clockOrZone);
            } else {
                return LocalDateTime._now(Clock.system(clockOrZone));
            }
        };

        LocalDateTime._now = function _now(clock) {
            requireNonNull(clock, 'clock');
            return LocalDateTime.ofInstant(clock.instant(), clock.zone());
        };

        LocalDateTime._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {
            var localSecond = MathUtil.floorDiv(epochMilli, 1000) + offset.totalSeconds();
            var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
            var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
            var nanoOfSecond = MathUtil.floorMod(epochMilli, 1000) * 1000000;
            var date = LocalDate.ofEpochDay(localEpochDay);
            var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
            return new LocalDateTime(date, time);
        };

        LocalDateTime.of = function of() {
            if (arguments.length === 2 && (arguments[0] instanceof LocalDate || arguments[1] instanceof LocalTime)) {
                return LocalDateTime.ofDateAndTime.apply(this, arguments);
            } else {
                return LocalDateTime.ofNumbers.apply(this, arguments);
            }
        };

        LocalDateTime.ofNumbers = function ofNumbers() {
            var year = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var month = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var dayOfMonth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var hour = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            var minute = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
            var second = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
            var nanoOfSecond = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;

            var date = LocalDate.of(year, month, dayOfMonth);
            var time = LocalTime.of(hour, minute, second, nanoOfSecond);
            return new LocalDateTime(date, time);
        };

        LocalDateTime.ofDateAndTime = function ofDateAndTime(date, time) {
            requireNonNull(date, 'date');
            requireNonNull(time, 'time');
            return new LocalDateTime(date, time);
        };

        LocalDateTime.ofInstant = function ofInstant(instant) {
            var zone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZoneId.systemDefault();

            requireNonNull(instant, 'instant');
            requireInstance(instant, Instant, 'instant');
            requireNonNull(zone, 'zone');
            var offset = zone.rules().offset(instant);
            return LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
        };

        LocalDateTime.ofEpochSecond = function ofEpochSecond() {
            var epochSecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var nanoOfSecond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var offset = arguments[2];

            if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {
                offset = nanoOfSecond;
                nanoOfSecond = 0;
            }
            requireNonNull(offset, 'offset');
            var localSecond = epochSecond + offset.totalSeconds();
            var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
            var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
            var date = LocalDate.ofEpochDay(localEpochDay);
            var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
            return new LocalDateTime(date, time);
        };

        LocalDateTime.from = function from(temporal) {
            requireNonNull(temporal, 'temporal');
            if (temporal instanceof LocalDateTime) {
                return temporal;
            } else if (temporal instanceof ZonedDateTime) {
                return temporal.toLocalDateTime();
            }
            try {
                var date = LocalDate.from(temporal);
                var time = LocalTime.from(temporal);
                return new LocalDateTime(date, time);
            } catch (ex) {
                throw new DateTimeException('Unable to obtain LocalDateTime TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''));
            }
        };

        LocalDateTime.parse = function parse(text) {
            var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DateTimeFormatter.ISO_LOCAL_DATE_TIME;

            requireNonNull(formatter, 'formatter');
            return formatter.parse(text, LocalDateTime.FROM);
        };

        function LocalDateTime(date, time) {
            _classCallCheck$U(this, LocalDateTime);

            var _this = _possibleConstructorReturn$t(this, _ChronoLocalDateTime.call(this));

            requireInstance(date, LocalDate, 'date');
            requireInstance(time, LocalTime, 'time');
            _this._date = date;
            _this._time = time;
            return _this;
        }

        LocalDateTime.prototype._withDateTime = function _withDateTime(newDate, newTime) {
            if (this._date === newDate && this._time === newTime) {
                return this;
            }
            return new LocalDateTime(newDate, newTime);
        };

        LocalDateTime.prototype.isSupported = function isSupported(fieldOrUnit) {
            if (fieldOrUnit instanceof ChronoField) {
                return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
            } else if (fieldOrUnit instanceof ChronoUnit) {
                return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
            }
            return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
        };

        LocalDateTime.prototype.range = function range(field) {
            if (field instanceof ChronoField) {
                return field.isTimeBased() ? this._time.range(field) : this._date.range(field);
            }
            return field.rangeRefinedBy(this);
        };

        LocalDateTime.prototype.get = function get(field) {
            if (field instanceof ChronoField) {
                return field.isTimeBased() ? this._time.get(field) : this._date.get(field);
            }
            return _ChronoLocalDateTime.prototype.get.call(this, field);
        };

        LocalDateTime.prototype.getLong = function getLong(field) {
            requireNonNull(field, 'field');
            if (field instanceof ChronoField) {
                return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);
            }
            return field.getFrom(this);
        };

        LocalDateTime.prototype.year = function year() {
            return this._date.year();
        };

        LocalDateTime.prototype.monthValue = function monthValue() {
            return this._date.monthValue();
        };

        LocalDateTime.prototype.month = function month() {
            return this._date.month();
        };

        LocalDateTime.prototype.dayOfMonth = function dayOfMonth() {
            return this._date.dayOfMonth();
        };

        LocalDateTime.prototype.dayOfYear = function dayOfYear() {
            return this._date.dayOfYear();
        };

        LocalDateTime.prototype.dayOfWeek = function dayOfWeek() {
            return this._date.dayOfWeek();
        };

        LocalDateTime.prototype.hour = function hour() {
            return this._time.hour();
        };

        LocalDateTime.prototype.minute = function minute() {
            return this._time.minute();
        };

        LocalDateTime.prototype.second = function second() {
            return this._time.second();
        };

        LocalDateTime.prototype.nano = function nano() {
            return this._time.nano();
        };

        LocalDateTime.prototype.with = function _with(adjusterOrField, newValue) {
            if (arguments.length === 1) {
                return this.withTemporalAdjuster(adjusterOrField);
            } else {
                return this.with2(adjusterOrField, newValue);
            }
        };

        LocalDateTime.prototype.withTemporalAdjuster = function withTemporalAdjuster(adjuster) {
            requireNonNull(adjuster, 'adjuster');

            if (adjuster instanceof LocalDate) {
                return this._withDateTime(adjuster, this._time);
            } else if (adjuster instanceof LocalTime) {
                return this._withDateTime(this._date, adjuster);
            } else if (adjuster instanceof LocalDateTime) {
                return adjuster;
            }
            assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);
            return adjuster.adjustInto(this);
        };

        LocalDateTime.prototype.with2 = function with2(field, newValue) {
            requireNonNull(field, 'field');
            if (field instanceof ChronoField) {
                if (field.isTimeBased()) {
                    return this._withDateTime(this._date, this._time.with(field, newValue));
                } else {
                    return this._withDateTime(this._date.with(field, newValue), this._time);
                }
            }
            return field.adjustInto(this, newValue);
        };

        LocalDateTime.prototype.withYear = function withYear(year) {
            return this._withDateTime(this._date.withYear(year), this._time);
        };

        LocalDateTime.prototype.withMonth = function withMonth(month) {
            return this._withDateTime(this._date.withMonth(month), this._time);
        };

        LocalDateTime.prototype.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
            return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);
        };

        LocalDateTime.prototype.withDayOfYear = function withDayOfYear(dayOfYear) {
            return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);
        };

        LocalDateTime.prototype.withHour = function withHour(hour) {
            var newTime = this._time.withHour(hour);
            return this._withDateTime(this._date, newTime);
        };

        LocalDateTime.prototype.withMinute = function withMinute(minute) {
            var newTime = this._time.withMinute(minute);
            return this._withDateTime(this._date, newTime);
        };

        LocalDateTime.prototype.withSecond = function withSecond(second) {
            var newTime = this._time.withSecond(second);
            return this._withDateTime(this._date, newTime);
        };

        LocalDateTime.prototype.withNano = function withNano(nanoOfSecond) {
            var newTime = this._time.withNano(nanoOfSecond);
            return this._withDateTime(this._date, newTime);
        };

        LocalDateTime.prototype.truncatedTo = function truncatedTo(unit) {
            return this._withDateTime(this._date, this._time.truncatedTo(unit));
        };

        LocalDateTime.prototype.plus = function plus(amount, unit) {
            if (arguments.length === 1) {
                return this.plusTemporalAmount(amount);
            } else {
                return this.plus2(amount, unit);
            }
        };

        LocalDateTime.prototype.plusTemporalAmount = function plusTemporalAmount(amount) {
            requireNonNull(amount, 'amount');
            return amount.addTo(this);
        };

        LocalDateTime.prototype.plus2 = function plus2(amountToAdd, unit) {
            requireNonNull(unit, 'unit');
            if (unit instanceof ChronoUnit) {
                switch (unit) {
                    case ChronoUnit.NANOS:
                        return this.plusNanos(amountToAdd);
                    case ChronoUnit.MICROS:
                        return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);
                    case ChronoUnit.MILLIS:
                        return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);
                    case ChronoUnit.SECONDS:
                        return this.plusSeconds(amountToAdd);
                    case ChronoUnit.MINUTES:
                        return this.plusMinutes(amountToAdd);
                    case ChronoUnit.HOURS:
                        return this.plusHours(amountToAdd);
                    case ChronoUnit.HALF_DAYS:
                        return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);}
                return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);
            }
            return unit.addTo(this, amountToAdd);
        };

        LocalDateTime.prototype.plusYears = function plusYears(years) {
            var newDate = this._date.plusYears(years);
            return this._withDateTime(newDate, this._time);
        };

        LocalDateTime.prototype.plusMonths = function plusMonths(months) {
            var newDate = this._date.plusMonths(months);
            return this._withDateTime(newDate, this._time);
        };

        LocalDateTime.prototype.plusWeeks = function plusWeeks(weeks) {
            var newDate = this._date.plusWeeks(weeks);
            return this._withDateTime(newDate, this._time);
        };

        LocalDateTime.prototype.plusDays = function plusDays(days) {
            var newDate = this._date.plusDays(days);
            return this._withDateTime(newDate, this._time);
        };

        LocalDateTime.prototype.plusHours = function plusHours(hours) {
            return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);
        };

        LocalDateTime.prototype.plusMinutes = function plusMinutes(minutes) {
            return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);
        };

        LocalDateTime.prototype.plusSeconds = function plusSeconds(seconds) {
            return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);
        };

        LocalDateTime.prototype.plusNanos = function plusNanos(nanos) {
            return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);
        };

        LocalDateTime.prototype.minus = function minus(amount, unit) {
            if (arguments.length === 1) {
                return this.minusTemporalAmount(amount);
            } else {
                return this.minus2(amount, unit);
            }
        };

        LocalDateTime.prototype.minusTemporalAmount = function minusTemporalAmount(amount) {
            requireNonNull(amount, 'amount');
            return amount.subtractFrom(this);
        };

        LocalDateTime.prototype.minus2 = function minus2(amountToSubtract, unit) {
            requireNonNull(unit, 'unit');
            return this.plus2(-1 * amountToSubtract, unit);
        };

        LocalDateTime.prototype.minusYears = function minusYears(years) {
            return this.plusYears(-1 * years);
        };

        LocalDateTime.prototype.minusMonths = function minusMonths(months) {
            return this.plusMonths(-1 * months);
        };

        LocalDateTime.prototype.minusWeeks = function minusWeeks(weeks) {
            return this.plusWeeks(-1 * weeks);
        };

        LocalDateTime.prototype.minusDays = function minusDays(days) {
            return this.plusDays(-1 * days);
        };

        LocalDateTime.prototype.minusHours = function minusHours(hours) {
            return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);
        };

        LocalDateTime.prototype.minusMinutes = function minusMinutes(minutes) {
            return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);
        };

        LocalDateTime.prototype.minusSeconds = function minusSeconds(seconds) {
            return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);
        };

        LocalDateTime.prototype.minusNanos = function minusNanos(nanos) {
            return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);
        };

        LocalDateTime.prototype._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {
            if ((hours | minutes | seconds | nanos) === 0) {
                return this._withDateTime(newDate, this._time);
            }
            var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);
            totDays *= sign;
            var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;
            var curNoD = this._time.toNanoOfDay();
            totNanos = totNanos * sign + curNoD;
            totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);
            var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);
            var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);
            return this._withDateTime(newDate.plusDays(totDays), newTime);
        };

        LocalDateTime.prototype.query = function query(_query) {
            requireNonNull(_query, 'query');
            if (_query === TemporalQueries.localDate()) {
                return this.toLocalDate();
            }
            return _ChronoLocalDateTime.prototype.query.call(this, _query);
        };

        LocalDateTime.prototype.adjustInto = function adjustInto(temporal) {
            return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);
        };

        LocalDateTime.prototype.until = function until(endExclusive, unit) {
            requireNonNull(endExclusive, 'endExclusive');
            requireNonNull(unit, 'unit');
            var end = LocalDateTime.from(endExclusive);
            if (unit instanceof ChronoUnit) {
                if (unit.isTimeBased()) {
                    var daysUntil = this._date.daysUntil(end._date);
                    var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();
                    if (daysUntil > 0 && timeUntil < 0) {
                        daysUntil--;
                        timeUntil += LocalTime.NANOS_PER_DAY;
                    } else if (daysUntil < 0 && timeUntil > 0) {
                        daysUntil++;
                        timeUntil -= LocalTime.NANOS_PER_DAY;
                    }
                    var amount = daysUntil;
                    switch (unit) {
                        case ChronoUnit.NANOS:
                            amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);
                            return MathUtil.safeAdd(amount, timeUntil);
                        case ChronoUnit.MICROS:
                            amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);
                            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000));
                        case ChronoUnit.MILLIS:
                            amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);
                            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000000));
                        case ChronoUnit.SECONDS:
                            amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);
                            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));
                        case ChronoUnit.MINUTES:
                            amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);
                            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));
                        case ChronoUnit.HOURS:
                            amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);
                            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));
                        case ChronoUnit.HALF_DAYS:
                            amount = MathUtil.safeMultiply(amount, 2);
                            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));
                    }
                    throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);
                }
                var endDate = end._date;
                var endTime = end._time;
                if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {
                    endDate = endDate.minusDays(1);
                } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {
                    endDate = endDate.plusDays(1);
                }
                return this._date.until(endDate, unit);
            }
            return unit.between(this, end);
        };

        LocalDateTime.prototype.atZone = function atZone(zone) {
            return ZonedDateTime.of(this, zone);
        };

        LocalDateTime.prototype.toLocalDate = function toLocalDate() {
            return this._date;
        };

        LocalDateTime.prototype.toLocalTime = function toLocalTime() {
            return this._time;
        };

        LocalDateTime.prototype.compareTo = function compareTo(other) {
            requireNonNull(other, 'other');
            requireInstance(other, LocalDateTime, 'other');
            return this._compareTo0(other);
        };

        LocalDateTime.prototype._compareTo0 = function _compareTo0(other) {
            var cmp = this._date.compareTo(other.toLocalDate());
            if (cmp === 0) {
                cmp = this._time.compareTo(other.toLocalTime());
            }
            return cmp;
        };

        LocalDateTime.prototype.isAfter = function isAfter(other) {
            return this.compareTo(other) > 0;
        };

        LocalDateTime.prototype.isBefore = function isBefore(other) {
            return this.compareTo(other) < 0;
        };

        LocalDateTime.prototype.isEqual = function isEqual(other) {
            return this.compareTo(other) === 0;
        };

        LocalDateTime.prototype.equals = function equals(other) {
            if (this === other) {
                return true;
            }
            if (other instanceof LocalDateTime) {
                return this._date.equals(other._date) && this._time.equals(other._time);
            }
            return false;
        };

        LocalDateTime.prototype.hashCode = function hashCode() {
            return this._date.hashCode() ^ this._time.hashCode();
        };

        LocalDateTime.prototype.toString = function toString() {
            return this._date.toString() + 'T' + this._time.toString();
        };

        LocalDateTime.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        LocalDateTime.prototype.format = function format(formatter) {
            requireNonNull(formatter, 'formatter');
            return formatter.format(this);
        };

        return LocalDateTime;
    }(ChronoLocalDateTime);


    function _init$h() {
        LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);

        LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);

        LocalDateTime.FROM = createTemporalQuery('LocalDateTime.FROM', function (temporal) {
            return LocalDateTime.from(temporal);
        });
    }

    function _classCallCheck$V(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$u(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$u(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var LocalTime = function (_Temporal) {
        _inherits$u(LocalTime, _Temporal);

        LocalTime.now = function now(clockOrZone) {
            if (clockOrZone == null) {
                return LocalTime._now(Clock.systemDefaultZone());
            } else if (clockOrZone instanceof Clock) {
                return LocalTime._now(clockOrZone);
            } else {
                return LocalTime._now(Clock.system(clockOrZone));
            }
        };

        LocalTime._now = function _now() {
            var clock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Clock.systemDefaultZone();

            requireNonNull(clock, 'clock');
            return LocalTime.ofInstant(clock.instant(), clock.zone());
        };

        LocalTime.ofInstant = function ofInstant(instant) {
            var zone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZoneId.systemDefault();

            var offset = zone.rules().offset(instant);
            var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime.SECONDS_PER_DAY);
            secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime.SECONDS_PER_DAY);
            if (secsOfDay < 0) {
                secsOfDay += LocalTime.SECONDS_PER_DAY;
            }
            return LocalTime.ofSecondOfDay(secsOfDay, instant.nano());
        };

        LocalTime.of = function of(hour, minute, second, nanoOfSecond) {
            return new LocalTime(hour, minute, second, nanoOfSecond);
        };

        LocalTime.ofSecondOfDay = function ofSecondOfDay() {
            var secondOfDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var nanoOfSecond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);
            ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
            var hours = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_HOUR);
            secondOfDay -= hours * LocalTime.SECONDS_PER_HOUR;
            var minutes = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_MINUTE);
            secondOfDay -= minutes * LocalTime.SECONDS_PER_MINUTE;
            return new LocalTime(hours, minutes, secondOfDay, nanoOfSecond);
        };

        LocalTime.ofNanoOfDay = function ofNanoOfDay() {
            var nanoOfDay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);
            var hours = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_HOUR);
            nanoOfDay -= hours * LocalTime.NANOS_PER_HOUR;
            var minutes = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_MINUTE);
            nanoOfDay -= minutes * LocalTime.NANOS_PER_MINUTE;
            var seconds = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_SECOND);
            nanoOfDay -= seconds * LocalTime.NANOS_PER_SECOND;
            return new LocalTime(hours, minutes, seconds, nanoOfDay);
        };

        LocalTime.from = function from(temporal) {
            requireNonNull(temporal, 'temporal');
            var time = temporal.query(TemporalQueries.localTime());
            if (time == null) {
                throw new DateTimeException('Unable to obtain LocalTime TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''));
            }
            return time;
        };

        LocalTime.parse = function parse(text) {
            var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DateTimeFormatter.ISO_LOCAL_TIME;

            requireNonNull(formatter, 'formatter');
            return formatter.parse(text, LocalTime.FROM);
        };

        function LocalTime() {
            var hour = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var minute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var second = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var nanoOfSecond = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

            _classCallCheck$V(this, LocalTime);

            var _this = _possibleConstructorReturn$u(this, _Temporal.call(this));

            var _hour = MathUtil.safeToInt(hour);
            var _minute = MathUtil.safeToInt(minute);
            var _second = MathUtil.safeToInt(second);
            var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);
            LocalTime._validate(_hour, _minute, _second, _nanoOfSecond);
            if ((_minute | _second | _nanoOfSecond) === 0) {
                var _ret;

                if (!LocalTime.HOURS[_hour]) {
                    _this._hour = _hour;
                    _this._minute = _minute;
                    _this._second = _second;
                    _this._nano = _nanoOfSecond;
                    LocalTime.HOURS[_hour] = _this;
                }
                return _ret = LocalTime.HOURS[_hour], _possibleConstructorReturn$u(_this, _ret);
            }
            _this._hour = _hour;
            _this._minute = _minute;
            _this._second = _second;
            _this._nano = _nanoOfSecond;
            return _this;
        }

        LocalTime._validate = function _validate(hour, minute, second, nanoOfSecond) {
            ChronoField.HOUR_OF_DAY.checkValidValue(hour);
            ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);
            ChronoField.SECOND_OF_MINUTE.checkValidValue(second);
            ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
        };

        LocalTime.prototype.isSupported = function isSupported(fieldOrUnit) {
            if (fieldOrUnit instanceof ChronoField) {
                return fieldOrUnit.isTimeBased();
            } else if (fieldOrUnit instanceof ChronoUnit) {
                return fieldOrUnit.isTimeBased();
            }
            return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
        };

        LocalTime.prototype.range = function range(field) {
            requireNonNull(field);
            return _Temporal.prototype.range.call(this, field);
        };

        LocalTime.prototype.get = function get(field) {
            return this.getLong(field);
        };

        LocalTime.prototype.getLong = function getLong(field) {
            requireNonNull(field, 'field');
            if (field instanceof ChronoField) {
                return this._get0(field);
            }
            return field.getFrom(this);
        };

        LocalTime.prototype._get0 = function _get0(field) {
            switch (field) {
                case ChronoField.NANO_OF_SECOND:
                    return this._nano;
                case ChronoField.NANO_OF_DAY:
                    return this.toNanoOfDay();
                case ChronoField.MICRO_OF_SECOND:
                    return MathUtil.intDiv(this._nano, 1000);
                case ChronoField.MICRO_OF_DAY:
                    return MathUtil.intDiv(this.toNanoOfDay(), 1000);
                case ChronoField.MILLI_OF_SECOND:
                    return MathUtil.intDiv(this._nano, 1000000);
                case ChronoField.MILLI_OF_DAY:
                    return MathUtil.intDiv(this.toNanoOfDay(), 1000000);
                case ChronoField.SECOND_OF_MINUTE:
                    return this._second;
                case ChronoField.SECOND_OF_DAY:
                    return this.toSecondOfDay();
                case ChronoField.MINUTE_OF_HOUR:
                    return this._minute;
                case ChronoField.MINUTE_OF_DAY:
                    return this._hour * 60 + this._minute;
                case ChronoField.HOUR_OF_AMPM:
                    return MathUtil.intMod(this._hour, 12);
                case ChronoField.CLOCK_HOUR_OF_AMPM:
                    {
                        var ham = MathUtil.intMod(this._hour, 12);
                        return ham % 12 === 0 ? 12 : ham;
                    }
                case ChronoField.HOUR_OF_DAY:
                    return this._hour;
                case ChronoField.CLOCK_HOUR_OF_DAY:
                    return this._hour === 0 ? 24 : this._hour;
                case ChronoField.AMPM_OF_DAY:
                    return MathUtil.intDiv(this._hour, 12);
            }
            throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
        };

        LocalTime.prototype.hour = function hour() {
            return this._hour;
        };

        LocalTime.prototype.minute = function minute() {
            return this._minute;
        };

        LocalTime.prototype.second = function second() {
            return this._second;
        };

        LocalTime.prototype.nano = function nano() {
            return this._nano;
        };

        LocalTime.prototype.with = function _with(adjusterOrField, newValue) {
            if (arguments.length < 2) {
                return this.withTemporalAdjuster(adjusterOrField);
            } else {
                return this.with2(adjusterOrField, newValue);
            }
        };

        LocalTime.prototype.withTemporalAdjuster = function withTemporalAdjuster(adjuster) {
            requireNonNull(adjuster, 'adjuster');

            if (adjuster instanceof LocalTime) {
                return adjuster;
            }
            assert(typeof adjuster.adjustInto === 'function', 'adjuster', IllegalArgumentException);
            return adjuster.adjustInto(this);
        };

        LocalTime.prototype.with2 = function with2(field, newValue) {
            requireNonNull(field, 'field');
            requireInstance(field, TemporalField, 'field');
            if (field instanceof ChronoField) {
                field.checkValidValue(newValue);
                switch (field) {
                    case ChronoField.NANO_OF_SECOND:
                        return this.withNano(newValue);
                    case ChronoField.NANO_OF_DAY:
                        return LocalTime.ofNanoOfDay(newValue);
                    case ChronoField.MICRO_OF_SECOND:
                        return this.withNano(newValue * 1000);
                    case ChronoField.MICRO_OF_DAY:
                        return LocalTime.ofNanoOfDay(newValue * 1000);
                    case ChronoField.MILLI_OF_SECOND:
                        return this.withNano(newValue * 1000000);
                    case ChronoField.MILLI_OF_DAY:
                        return LocalTime.ofNanoOfDay(newValue * 1000000);
                    case ChronoField.SECOND_OF_MINUTE:
                        return this.withSecond(newValue);
                    case ChronoField.SECOND_OF_DAY:
                        return this.plusSeconds(newValue - this.toSecondOfDay());
                    case ChronoField.MINUTE_OF_HOUR:
                        return this.withMinute(newValue);
                    case ChronoField.MINUTE_OF_DAY:
                        return this.plusMinutes(newValue - (this._hour * 60 + this._minute));
                    case ChronoField.HOUR_OF_AMPM:
                        return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));
                    case ChronoField.CLOCK_HOUR_OF_AMPM:
                        return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));
                    case ChronoField.HOUR_OF_DAY:
                        return this.withHour(newValue);
                    case ChronoField.CLOCK_HOUR_OF_DAY:
                        return this.withHour(newValue === 24 ? 0 : newValue);
                    case ChronoField.AMPM_OF_DAY:
                        return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);
                }
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.adjustInto(this, newValue);
        };

        LocalTime.prototype.withHour = function withHour() {
            var hour = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            if (this._hour === hour) {
                return this;
            }
            return new LocalTime(hour, this._minute, this._second, this._nano);
        };

        LocalTime.prototype.withMinute = function withMinute() {
            var minute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            if (this._minute === minute) {
                return this;
            }
            return new LocalTime(this._hour, minute, this._second, this._nano);
        };

        LocalTime.prototype.withSecond = function withSecond() {
            var second = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            if (this._second === second) {
                return this;
            }
            return new LocalTime(this._hour, this._minute, second, this._nano);
        };

        LocalTime.prototype.withNano = function withNano() {
            var nanoOfSecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            if (this._nano === nanoOfSecond) {
                return this;
            }
            return new LocalTime(this._hour, this._minute, this._second, nanoOfSecond);
        };

        LocalTime.prototype.truncatedTo = function truncatedTo(unit) {
            requireNonNull(unit, 'unit');
            if (unit === ChronoUnit.NANOS) {
                return this;
            }
            var unitDur = unit.duration();
            if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
                throw new DateTimeException('Unit is too large to be used for truncation');
            }
            var dur = unitDur.toNanos();
            if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
                throw new DateTimeException('Unit must divide into a standard day without remainder');
            }
            var nod = this.toNanoOfDay();
            return LocalTime.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);
        };

        LocalTime.prototype.plus = function plus(amount, unit) {
            if (arguments.length < 2) {
                return this.plus1(amount);
            } else {
                return this.plus2(amount, unit);
            }
        };

        LocalTime.prototype.plus1 = function plus1(amount) {
            requireNonNull(amount, 'amount');
            return amount.addTo(this);
        };

        LocalTime.prototype.plus2 = function plus2(amountToAdd, unit) {
            requireNonNull(unit, 'unit');
            if (unit instanceof ChronoUnit) {
                switch (unit) {
                    case ChronoUnit.NANOS:
                        return this.plusNanos(amountToAdd);
                    case ChronoUnit.MICROS:
                        return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);
                    case ChronoUnit.MILLIS:
                        return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);
                    case ChronoUnit.SECONDS:
                        return this.plusSeconds(amountToAdd);
                    case ChronoUnit.MINUTES:
                        return this.plusMinutes(amountToAdd);
                    case ChronoUnit.HOURS:
                        return this.plusHours(amountToAdd);
                    case ChronoUnit.HALF_DAYS:
                        return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);
                }
                throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);
            }
            return unit.addTo(this, amountToAdd);
        };

        LocalTime.prototype.plusHours = function plusHours(hoursToAdd) {
            if (hoursToAdd === 0) {
                return this;
            }

            var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime.HOURS_PER_DAY) + this._hour + LocalTime.HOURS_PER_DAY, LocalTime.HOURS_PER_DAY);
            return new LocalTime(newHour, this._minute, this._second, this._nano);
        };

        LocalTime.prototype.plusMinutes = function plusMinutes(minutesToAdd) {
            if (minutesToAdd === 0) {
                return this;
            }
            var mofd = this._hour * LocalTime.MINUTES_PER_HOUR + this._minute;
            var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime.MINUTES_PER_DAY) + mofd + LocalTime.MINUTES_PER_DAY, LocalTime.MINUTES_PER_DAY);
            if (mofd === newMofd) {
                return this;
            }
            var newHour = MathUtil.intDiv(newMofd, LocalTime.MINUTES_PER_HOUR);
            var newMinute = MathUtil.intMod(newMofd, LocalTime.MINUTES_PER_HOUR);
            return new LocalTime(newHour, newMinute, this._second, this._nano);
        };

        LocalTime.prototype.plusSeconds = function plusSeconds(secondsToAdd) {
            if (secondsToAdd === 0) {
                return this;
            }
            var sofd = this._hour * LocalTime.SECONDS_PER_HOUR + this._minute * LocalTime.SECONDS_PER_MINUTE + this._second;
            var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime.SECONDS_PER_DAY) + sofd + LocalTime.SECONDS_PER_DAY, LocalTime.SECONDS_PER_DAY);
            if (sofd === newSofd) {
                return this;
            }
            var newHour = MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_HOUR);
            var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
            var newSecond = MathUtil.intMod(newSofd, LocalTime.SECONDS_PER_MINUTE);
            return new LocalTime(newHour, newMinute, newSecond, this._nano);
        };

        LocalTime.prototype.plusNanos = function plusNanos(nanosToAdd) {
            if (nanosToAdd === 0) {
                return this;
            }
            var nofd = this.toNanoOfDay();
            var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_DAY) + nofd + LocalTime.NANOS_PER_DAY, LocalTime.NANOS_PER_DAY);
            if (nofd === newNofd) {
                return this;
            }
            var newHour = MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_HOUR);
            var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
            var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_SECOND), LocalTime.SECONDS_PER_MINUTE);
            var newNano = MathUtil.intMod(newNofd, LocalTime.NANOS_PER_SECOND);
            return new LocalTime(newHour, newMinute, newSecond, newNano);
        };

        LocalTime.prototype.minus = function minus(amount, unit) {
            if (arguments.length < 2) {
                return this.minus1(amount);
            } else {
                return this.minus2(amount, unit);
            }
        };

        LocalTime.prototype.minus1 = function minus1(amount) {
            requireNonNull(amount, 'amount');
            return amount.subtractFrom(this);
        };

        LocalTime.prototype.minus2 = function minus2(amountToSubtract, unit) {
            requireNonNull(unit, 'unit');
            return this.plus2(-1 * amountToSubtract, unit);
        };

        LocalTime.prototype.minusHours = function minusHours(hoursToSubtract) {
            return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime.HOURS_PER_DAY));
        };

        LocalTime.prototype.minusMinutes = function minusMinutes(minutesToSubtract) {
            return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime.MINUTES_PER_DAY));
        };

        LocalTime.prototype.minusSeconds = function minusSeconds(secondsToSubtract) {
            return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime.SECONDS_PER_DAY));
        };

        LocalTime.prototype.minusNanos = function minusNanos(nanosToSubtract) {
            return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime.NANOS_PER_DAY));
        };

        LocalTime.prototype.query = function query(_query) {
            requireNonNull(_query, 'query');
            if (_query === TemporalQueries.precision()) {
                return ChronoUnit.NANOS;
            } else if (_query === TemporalQueries.localTime()) {
                return this;
            }

            if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {
                return null;
            }
            return _query.queryFrom(this);
        };

        LocalTime.prototype.adjustInto = function adjustInto(temporal) {
            return temporal.with(LocalTime.NANO_OF_DAY, this.toNanoOfDay());
        };

        LocalTime.prototype.until = function until(endExclusive, unit) {
            requireNonNull(endExclusive, 'endExclusive');
            requireNonNull(unit, 'unit');
            var end = LocalTime.from(endExclusive);
            if (unit instanceof ChronoUnit) {
                var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();
                switch (unit) {
                    case ChronoUnit.NANOS:
                        return nanosUntil;
                    case ChronoUnit.MICROS:
                        return MathUtil.intDiv(nanosUntil, 1000);
                    case ChronoUnit.MILLIS:
                        return MathUtil.intDiv(nanosUntil, 1000000);
                    case ChronoUnit.SECONDS:
                        return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);
                    case ChronoUnit.MINUTES:
                        return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);
                    case ChronoUnit.HOURS:
                        return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);
                    case ChronoUnit.HALF_DAYS:
                        return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);
                }
                throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);
            }
            return unit.between(this, end);
        };

        LocalTime.prototype.atDate = function atDate(date) {
            return LocalDateTime.of(date, this);
        };

        LocalTime.prototype.toSecondOfDay = function toSecondOfDay() {
            var total = this._hour * LocalTime.SECONDS_PER_HOUR;
            total += this._minute * LocalTime.SECONDS_PER_MINUTE;
            total += this._second;
            return total;
        };

        LocalTime.prototype.toNanoOfDay = function toNanoOfDay() {
            var total = this._hour * LocalTime.NANOS_PER_HOUR;
            total += this._minute * LocalTime.NANOS_PER_MINUTE;
            total += this._second * LocalTime.NANOS_PER_SECOND;
            total += this._nano;
            return total;
        };

        LocalTime.prototype.compareTo = function compareTo(other) {
            requireNonNull(other, 'other');
            requireInstance(other, LocalTime, 'other');
            var cmp = MathUtil.compareNumbers(this._hour, other._hour);
            if (cmp === 0) {
                cmp = MathUtil.compareNumbers(this._minute, other._minute);
                if (cmp === 0) {
                    cmp = MathUtil.compareNumbers(this._second, other._second);
                    if (cmp === 0) {
                        cmp = MathUtil.compareNumbers(this._nano, other._nano);
                    }
                }
            }
            return cmp;
        };

        LocalTime.prototype.isAfter = function isAfter(other) {
            return this.compareTo(other) > 0;
        };

        LocalTime.prototype.isBefore = function isBefore(other) {
            return this.compareTo(other) < 0;
        };

        LocalTime.prototype.equals = function equals(other) {
            if (this === other) {
                return true;
            }
            if (other instanceof LocalTime) {
                return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;
            }
            return false;
        };

        LocalTime.prototype.hashCode = function hashCode() {
            var nod = this.toNanoOfDay();
            return MathUtil.hash(nod);
        };

        LocalTime.prototype.toString = function toString() {
            var buf = '';
            var hourValue = this._hour;
            var minuteValue = this._minute;
            var secondValue = this._second;
            var nanoValue = this._nano;
            buf += hourValue < 10 ? '0' : '';
            buf += hourValue;
            buf += minuteValue < 10 ? ':0' : ':';
            buf += minuteValue;
            if (secondValue > 0 || nanoValue > 0) {
                buf += secondValue < 10 ? ':0' : ':';
                buf += secondValue;
                if (nanoValue > 0) {
                    buf += '.';
                    if (MathUtil.intMod(nanoValue, 1000000) === 0) {
                        buf += ('' + (MathUtil.intDiv(nanoValue, 1000000) + 1000)).substring(1);
                    } else if (MathUtil.intMod(nanoValue, 1000) === 0) {
                        buf += ('' + (MathUtil.intDiv(nanoValue, 1000) + 1000000)).substring(1);
                    } else {
                        buf += ('' + (nanoValue + 1000000000)).substring(1);
                    }
                }
            }
            return buf;
        };

        LocalTime.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        LocalTime.prototype.format = function format(formatter) {
            requireNonNull(formatter, 'formatter');
            return formatter.format(this);
        };

        return LocalTime;
    }(Temporal);


    function _init$i() {
        LocalTime.HOURS = [];
        for (var hour = 0; hour < 24; hour++) {
            LocalTime.of(hour, 0, 0, 0);
        }

        LocalTime.MIN = LocalTime.HOURS[0];

        LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);

        LocalTime.MIDNIGHT = LocalTime.HOURS[0];

        LocalTime.NOON = LocalTime.HOURS[12];

        LocalTime.FROM = createTemporalQuery('LocalTime.FROM', function (temporal) {
            return LocalTime.from(temporal);
        });
    }

    LocalTime.HOURS_PER_DAY = 24;

    LocalTime.MINUTES_PER_HOUR = 60;

    LocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;

    LocalTime.SECONDS_PER_MINUTE = 60;

    LocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;

    LocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;

    LocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000;

    LocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000000;

    LocalTime.NANOS_PER_SECOND = 1000000000;

    LocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;

    LocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;

    LocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

    function _classCallCheck$W(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$v(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$v(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var NANOS_PER_MILLI = 1000000;

    var Instant = function (_Temporal) {
        _inherits$v(Instant, _Temporal);

        Instant.now = function now() {
            var clock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Clock.systemUTC();

            return clock.instant();
        };

        Instant.ofEpochSecond = function ofEpochSecond(epochSecond) {
            var nanoAdjustment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
            var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
            return Instant._create(secs, nos);
        };

        Instant.ofEpochMilli = function ofEpochMilli(epochMilli) {
            var secs = MathUtil.floorDiv(epochMilli, 1000);
            var mos = MathUtil.floorMod(epochMilli, 1000);
            return Instant._create(secs, mos * 1000000);
        };

        Instant.from = function from(temporal) {
            try {
                var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);
                var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
                return Instant.ofEpochSecond(instantSecs, nanoOfSecond);
            } catch (ex) {
                throw new DateTimeException('Unable to obtain Instant from TemporalAccessor: ' + temporal + ', type ' + (typeof temporal === 'undefined' ? 'undefined' : _typeof(temporal)), ex);
            }
        };

        Instant.parse = function parse(text) {
            return DateTimeFormatter.ISO_INSTANT.parse(text, Instant.FROM);
        };

        Instant._create = function _create(seconds, nanoOfSecond) {
            if (seconds === 0 && nanoOfSecond === 0) {
                return Instant.EPOCH;
            }
            return new Instant(seconds, nanoOfSecond);
        };

        Instant._validate = function _validate(seconds, nanoOfSecond) {
            if (seconds < Instant.MIN_SECONDS || seconds > Instant.MAX_SECONDS) {
                throw new DateTimeException('Instant exceeds minimum or maximum instant');
            }
            if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {
                throw new DateTimeException('Instant exceeds minimum or maximum instant');
            }
        };

        function Instant(seconds, nanoOfSecond) {
            _classCallCheck$W(this, Instant);

            var _this = _possibleConstructorReturn$v(this, _Temporal.call(this));

            Instant._validate(seconds, nanoOfSecond);
            _this._seconds = MathUtil.safeToInt(seconds);
            _this._nanos = MathUtil.safeToInt(nanoOfSecond);
            return _this;
        }

        Instant.prototype.isSupported = function isSupported(fieldOrUnit) {
            if (fieldOrUnit instanceof ChronoField) {
                return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;
            }
            if (fieldOrUnit instanceof ChronoUnit) {
                return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;
            }
            return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
        };

        Instant.prototype.range = function range(field) {
            return _Temporal.prototype.range.call(this, field);
        };

        Instant.prototype.get = function get(field) {
            return this.getLong(field);
        };

        Instant.prototype.getLong = function getLong(field) {
            if (field instanceof ChronoField) {
                switch (field) {
                    case ChronoField.NANO_OF_SECOND:
                        return this._nanos;
                    case ChronoField.MICRO_OF_SECOND:
                        return MathUtil.intDiv(this._nanos, 1000);
                    case ChronoField.MILLI_OF_SECOND:
                        return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
                    case ChronoField.INSTANT_SECONDS:
                        return this._seconds;
                }
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.getFrom(this);
        };

        Instant.prototype.epochSecond = function epochSecond() {
            return this._seconds;
        };

        Instant.prototype.nano = function nano() {
            return this._nanos;
        };

        Instant.prototype.with = function _with(adjusterOrField, newValue) {
            if (arguments.length === 1) {
                return this.withTemporalAdjuster(adjusterOrField);
            } else {
                return this.with2(adjusterOrField, newValue);
            }
        };

        Instant.prototype.withTemporalAdjuster = function withTemporalAdjuster(adjuster) {
            requireNonNull(adjuster, 'adjuster');
            return adjuster.adjustInto(this);
        };

        Instant.prototype.with2 = function with2(field, newValue) {
            requireNonNull(field, 'field');
            if (field instanceof ChronoField) {
                field.checkValidValue(newValue);
                switch (field) {
                    case ChronoField.MILLI_OF_SECOND:
                        {
                            var nval = newValue * NANOS_PER_MILLI;
                            return nval !== this._nanos ? Instant._create(this._seconds, nval) : this;
                        }
                    case ChronoField.MICRO_OF_SECOND:
                        {
                            var _nval = newValue * 1000;
                            return _nval !== this._nanos ? Instant._create(this._seconds, _nval) : this;
                        }
                    case ChronoField.NANO_OF_SECOND:
                        return newValue !== this._nanos ? Instant._create(this._seconds, newValue) : this;
                    case ChronoField.INSTANT_SECONDS:
                        return newValue !== this._seconds ? Instant._create(newValue, this._nanos) : this;
                }
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.adjustInto(this, newValue);
        };

        Instant.prototype.truncatedTo = function truncatedTo(unit) {
            requireNonNull(unit, 'unit');
            if (unit === ChronoUnit.NANOS) {
                return this;
            }
            var unitDur = unit.duration();
            if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
                throw new DateTimeException('Unit is too large to be used for truncation');
            }
            var dur = unitDur.toNanos();
            if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
                throw new DateTimeException('Unit must divide into a standard day without remainder');
            }
            var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;
            var result = MathUtil.intDiv(nod, dur) * dur;
            return this.plusNanos(result - nod);
        };

        Instant.prototype.plus = function plus(amount, unit) {
            if (arguments.length === 1) {
                return this.plus1(amount);
            } else {
                return this.plus2(amount, unit);
            }
        };

        Instant.prototype.plus1 = function plus1(amount) {
            requireNonNull(amount, 'amount');
            return amount.addTo(this);
        };

        Instant.prototype.plus2 = function plus2(amountToAdd, unit) {
            requireNonNull(amountToAdd, 'amountToAdd');
            requireNonNull(unit, 'unit');
            requireInstance(unit, TemporalUnit);
            if (unit instanceof ChronoUnit) {
                switch (unit) {
                    case ChronoUnit.NANOS:
                        return this.plusNanos(amountToAdd);
                    case ChronoUnit.MICROS:
                        return this._plus(MathUtil.intDiv(amountToAdd, 1000000), MathUtil.intMod(amountToAdd, 1000000) * 1000);
                    case ChronoUnit.MILLIS:
                        return this.plusMillis(amountToAdd);
                    case ChronoUnit.SECONDS:
                        return this.plusSeconds(amountToAdd);
                    case ChronoUnit.MINUTES:
                        return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));
                    case ChronoUnit.HOURS:
                        return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));
                    case ChronoUnit.HALF_DAYS:
                        return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));
                    case ChronoUnit.DAYS:
                        return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));
                }
                throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);
            }
            return unit.addTo(this, amountToAdd);
        };

        Instant.prototype.plusSeconds = function plusSeconds(secondsToAdd) {
            return this._plus(secondsToAdd, 0);
        };

        Instant.prototype.plusMillis = function plusMillis(millisToAdd) {
            return this._plus(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * NANOS_PER_MILLI);
        };

        Instant.prototype.plusNanos = function plusNanos(nanosToAdd) {
            return this._plus(0, nanosToAdd);
        };

        Instant.prototype._plus = function _plus(secondsToAdd, nanosToAdd) {
            if ((secondsToAdd | nanosToAdd) === 0) {
                return this;
            }
            var epochSec = this._seconds + secondsToAdd;
            epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);
            var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;
            return Instant.ofEpochSecond(epochSec, nanoAdjustment);
        };

        Instant.prototype.minus = function minus(amount, unit) {
            if (arguments.length === 1) {
                return this.minus1(amount);
            } else {
                return this.minus2(amount, unit);
            }
        };

        Instant.prototype.minus1 = function minus1(amount) {
            requireNonNull(amount, 'amount');
            return amount.subtractFrom(this);
        };

        Instant.prototype.minus2 = function minus2(amountToSubtract, unit) {
            return this.plus2(-1 * amountToSubtract, unit);
        };

        Instant.prototype.minusSeconds = function minusSeconds(secondsToSubtract) {
            return this.plusSeconds(secondsToSubtract * -1);
        };

        Instant.prototype.minusMillis = function minusMillis(millisToSubtract) {
            return this.plusMillis(-1 * millisToSubtract);
        };

        Instant.prototype.minusNanos = function minusNanos(nanosToSubtract) {
            return this.plusNanos(-1 * nanosToSubtract);
        };

        Instant.prototype.query = function query(_query) {
            requireNonNull(_query, 'query');
            if (_query === TemporalQueries.precision()) {
                return ChronoUnit.NANOS;
            }

            if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
                return null;
            }
            return _query.queryFrom(this);
        };

        Instant.prototype.adjustInto = function adjustInto(temporal) {
            requireNonNull(temporal, 'temporal');
            return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);
        };

        Instant.prototype.until = function until(endExclusive, unit) {
            requireNonNull(endExclusive, 'endExclusive');
            requireNonNull(unit, 'unit');
            var end = Instant.from(endExclusive);
            if (unit instanceof ChronoUnit) {
                switch (unit) {
                    case ChronoUnit.NANOS:
                        return this._nanosUntil(end);
                    case ChronoUnit.MICROS:
                        return MathUtil.intDiv(this._nanosUntil(end), 1000);
                    case ChronoUnit.MILLIS:
                        return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());
                    case ChronoUnit.SECONDS:
                        return this._secondsUntil(end);
                    case ChronoUnit.MINUTES:
                        return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);
                    case ChronoUnit.HOURS:
                        return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);
                    case ChronoUnit.HALF_DAYS:
                        return MathUtil.intDiv(this._secondsUntil(end), 12 * LocalTime.SECONDS_PER_HOUR);
                    case ChronoUnit.DAYS:
                        return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);
                }
                throw new UnsupportedTemporalTypeException('Unsupported unit: ' + unit);
            }
            return unit.between(this, end);
        };

        Instant.prototype._nanosUntil = function _nanosUntil(end) {
            var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
            var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);
            return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());
        };

        Instant.prototype._secondsUntil = function _secondsUntil(end) {
            var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
            var nanosDiff = end.nano() - this.nano();
            if (secsDiff > 0 && nanosDiff < 0) {
                secsDiff--;
            } else if (secsDiff < 0 && nanosDiff > 0) {
                secsDiff++;
            }
            return secsDiff;
        };

        Instant.prototype.atZone = function atZone(zone) {
            return ZonedDateTime.ofInstant(this, zone);
        };

        Instant.prototype.toEpochMilli = function toEpochMilli() {
            var millis = MathUtil.safeMultiply(this._seconds, 1000);
            return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
        };

        Instant.prototype.compareTo = function compareTo(otherInstant) {
            requireNonNull(otherInstant, 'otherInstant');
            requireInstance(otherInstant, Instant, 'otherInstant');
            var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);
            if (cmp !== 0) {
                return cmp;
            }
            return this._nanos - otherInstant._nanos;
        };

        Instant.prototype.isAfter = function isAfter(otherInstant) {
            return this.compareTo(otherInstant) > 0;
        };

        Instant.prototype.isBefore = function isBefore(otherInstant) {
            return this.compareTo(otherInstant) < 0;
        };

        Instant.prototype.equals = function equals(otherInstant) {
            if (this === otherInstant) {
                return true;
            }
            if (otherInstant instanceof Instant) {
                return this.epochSecond() === otherInstant.epochSecond() && this.nano() === otherInstant.nano();
            }
            return false;
        };

        Instant.prototype.hashCode = function hashCode() {
            return MathUtil.hashCode(this._seconds, this._nanos);
        };

        Instant.prototype.toString = function toString() {
            return DateTimeFormatter.ISO_INSTANT.format(this);
        };

        Instant.prototype.toJSON = function toJSON() {
            return this.toString();
        };

        return Instant;
    }(Temporal);


    function _init$j() {
        Instant.MIN_SECONDS = -31619119219200;
        Instant.MAX_SECONDS = 31494816403199;
        Instant.EPOCH = new Instant(0, 0);
        Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);
        Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);
        Instant.FROM = createTemporalQuery('Instant.FROM', function (temporal) {
            return Instant.from(temporal);
        });
    }

    function _possibleConstructorReturn$w(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$w(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    function _classCallCheck$X(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var Clock = function () {
        function Clock() {
            _classCallCheck$X(this, Clock);
        }

        Clock.systemUTC = function systemUTC() {
            return new SystemClock(ZoneOffset.UTC);
        };

        Clock.systemDefaultZone = function systemDefaultZone() {
            return new SystemClock(ZoneId.systemDefault());
        };

        Clock.system = function system(zone) {
            return new SystemClock(zone);
        };

        Clock.fixed = function fixed(fixedInstant, zoneId) {
            return new FixedClock(fixedInstant, zoneId);
        };

        Clock.offset = function offset(baseClock, duration) {
            return new OffsetClock(baseClock, duration);
        };

        Clock.prototype.millis = function millis() {
            abstractMethodFail('Clock.millis');
        };

        Clock.prototype.instant = function instant() {
            abstractMethodFail('Clock.instant');
        };

        Clock.prototype.zone = function zone() {
            abstractMethodFail('Clock.zone');
        };

        Clock.prototype.withZone = function withZone() {
            abstractMethodFail('Clock.withZone');
        };

        return Clock;
    }();

    var SystemClock = function (_Clock) {
        _inherits$w(SystemClock, _Clock);

        function SystemClock(zone) {
            _classCallCheck$X(this, SystemClock);

            requireNonNull(zone, 'zone');

            var _this = _possibleConstructorReturn$w(this, _Clock.call(this));

            _this._zone = zone;
            return _this;
        }

        SystemClock.prototype.zone = function zone() {
            return this._zone;
        };

        SystemClock.prototype.millis = function millis() {
            return new Date().getTime();
        };

        SystemClock.prototype.instant = function instant() {
            return Instant.ofEpochMilli(this.millis());
        };

        SystemClock.prototype.equals = function equals(obj) {
            if (obj instanceof SystemClock) {
                return this._zone.equals(obj._zone);
            }
            return false;
        };

        SystemClock.prototype.withZone = function withZone(zone) {
            if (zone.equals(this._zone)) {
                return this;
            }
            return new SystemClock(zone);
        };

        SystemClock.prototype.toString = function toString() {
            return 'SystemClock[' + this._zone.toString() + ']';
        };

        return SystemClock;
    }(Clock);

    var FixedClock = function (_Clock2) {
        _inherits$w(FixedClock, _Clock2);

        function FixedClock(fixedInstant, zoneId) {
            _classCallCheck$X(this, FixedClock);

            var _this2 = _possibleConstructorReturn$w(this, _Clock2.call(this));

            _this2._instant = fixedInstant;
            _this2._zoneId = zoneId;
            return _this2;
        }

        FixedClock.prototype.instant = function instant() {
            return this._instant;
        };

        FixedClock.prototype.millis = function millis() {
            return this._instant.toEpochMilli();
        };

        FixedClock.prototype.zone = function zone() {
            return this._zoneId;
        };

        FixedClock.prototype.toString = function toString() {
            return 'FixedClock[]';
        };

        FixedClock.prototype.equals = function equals(obj) {
            if (obj instanceof FixedClock) {
                return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);
            }
            return false;
        };

        FixedClock.prototype.withZone = function withZone(zone) {
            if (zone.equals(this._zoneId)) {
                return this;
            }
            return new FixedClock(this._instant, zone);
        };

        return FixedClock;
    }(Clock);

    var OffsetClock = function (_Clock3) {
        _inherits$w(OffsetClock, _Clock3);

        function OffsetClock(baseClock, offset) {
            _classCallCheck$X(this, OffsetClock);

            var _this3 = _possibleConstructorReturn$w(this, _Clock3.call(this));

            _this3._baseClock = baseClock;
            _this3._offset = offset;
            return _this3;
        }

        OffsetClock.prototype.zone = function zone() {
            return this._baseClock.zone();
        };

        OffsetClock.prototype.withZone = function withZone(zone) {
            if (zone.equals(this._baseClock.zone())) {
                return this;
            }
            return new OffsetClock(this._baseClock.withZone(zone), this._offset);
        };

        OffsetClock.prototype.millis = function millis() {
            return this._baseClock.millis() + this._offset.toMillis();
        };

        OffsetClock.prototype.instant = function instant() {
            return this._baseClock.instant().plus(this._offset);
        };

        OffsetClock.prototype.equals = function equals(obj) {
            if (obj instanceof OffsetClock) {
                return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);
            }
            return false;
        };

        OffsetClock.prototype.toString = function toString() {
            return 'OffsetClock[' + this._baseClock + ',' + this._offset + ']';
        };

        return OffsetClock;
    }(Clock);

    function _classCallCheck$Y(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var ZoneOffsetTransition = function () {
        ZoneOffsetTransition.of = function of(transition, offsetBefore, offsetAfter) {
            return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);
        };

        function ZoneOffsetTransition(transition, offsetBefore, offsetAfter) {
            _classCallCheck$Y(this, ZoneOffsetTransition);

            requireNonNull(transition, 'transition');
            requireNonNull(offsetBefore, 'offsetBefore');
            requireNonNull(offsetAfter, 'offsetAfter');
            if (offsetBefore.equals(offsetAfter)) {
                throw new IllegalArgumentException('Offsets must not be equal');
            }
            if (transition.nano() !== 0) {
                throw new IllegalArgumentException('Nano-of-second must be zero');
            }
            if (transition instanceof LocalDateTime) {
                this._transition = transition;
            } else {
                this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);
            }
            this._offsetBefore = offsetBefore;
            this._offsetAfter = offsetAfter;
        }

        ZoneOffsetTransition.prototype.instant = function instant() {
            return this._transition.toInstant(this._offsetBefore);
        };

        ZoneOffsetTransition.prototype.toEpochSecond = function toEpochSecond() {
            return this._transition.toEpochSecond(this._offsetBefore);
        };

        ZoneOffsetTransition.prototype.dateTimeBefore = function dateTimeBefore() {
            return this._transition;
        };

        ZoneOffsetTransition.prototype.dateTimeAfter = function dateTimeAfter() {
            return this._transition.plusSeconds(this.durationSeconds());
        };

        ZoneOffsetTransition.prototype.offsetBefore = function offsetBefore() {
            return this._offsetBefore;
        };

        ZoneOffsetTransition.prototype.offsetAfter = function offsetAfter() {
            return this._offsetAfter;
        };

        ZoneOffsetTransition.prototype.duration = function duration() {
            return Duration.ofSeconds(this.durationSeconds());
        };

        ZoneOffsetTransition.prototype.durationSeconds = function durationSeconds() {
            return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();
        };

        ZoneOffsetTransition.prototype.isGap = function isGap() {
            return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();
        };

        ZoneOffsetTransition.prototype.isOverlap = function isOverlap() {
            return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();
        };

        ZoneOffsetTransition.prototype.isValidOffset = function isValidOffset(offset) {
            return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);
        };

        ZoneOffsetTransition.prototype.validOffsets = function validOffsets() {
            if (this.isGap()) {
                return [];
            } else {
                return [this._offsetBefore, this._offsetAfter];
            }
        };

        ZoneOffsetTransition.prototype.compareTo = function compareTo(transition) {
            return this.instant().compareTo(transition.instant());
        };

        ZoneOffsetTransition.prototype.equals = function equals(other) {
            if (other === this) {
                return true;
            }
            if (other instanceof ZoneOffsetTransition) {
                var d = other;
                return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());
            }
            return false;
        };

        ZoneOffsetTransition.prototype.hashCode = function hashCode() {
            return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;
        };

        ZoneOffsetTransition.prototype.toString = function toString() {
            return 'Transition[' + (this.isGap() ? 'Gap' : 'Overlap') + ' at ' + this._transition.toString() + this._offsetBefore.toString() + ' to ' + this._offsetAfter + ']';
        };

        return ZoneOffsetTransition;
    }();

    /*
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
     * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
     */

    function _init$k() {
        TemporalQueries.ZONE_ID = createTemporalQuery('ZONE_ID', function (temporal) {
            return temporal.query(TemporalQueries.ZONE_ID);
        });

        TemporalQueries.CHRONO = createTemporalQuery('CHRONO', function (temporal) {
            return temporal.query(TemporalQueries.CHRONO);
        });

        TemporalQueries.PRECISION = createTemporalQuery('PRECISION', function (temporal) {
            return temporal.query(TemporalQueries.PRECISION);
        });

        TemporalQueries.OFFSET = createTemporalQuery('OFFSET', function (temporal) {
            if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {
                return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));
            }
            return null;
        });

        TemporalQueries.ZONE = createTemporalQuery('ZONE', function (temporal) {
            var zone = temporal.query(TemporalQueries.ZONE_ID);
            return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);
        });

        TemporalQueries.LOCAL_DATE = createTemporalQuery('LOCAL_DATE', function (temporal) {
            if (temporal.isSupported(ChronoField.EPOCH_DAY)) {
                return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));
            }
            return null;
        });

        TemporalQueries.LOCAL_TIME = createTemporalQuery('LOCAL_TIME', function (temporal) {
            if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {
                return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));
            }
            return null;
        });
    }

    function _classCallCheck$Z(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$x(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$x(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var SystemDefaultZoneRules = function (_ZoneRules) {
        _inherits$x(SystemDefaultZoneRules, _ZoneRules);

        function SystemDefaultZoneRules() {
            _classCallCheck$Z(this, SystemDefaultZoneRules);

            return _possibleConstructorReturn$x(this, _ZoneRules.apply(this, arguments));
        }

        SystemDefaultZoneRules.prototype.isFixedOffset = function isFixedOffset() {
            return false;
        };

        SystemDefaultZoneRules.prototype.offsetOfInstant = function offsetOfInstant(instant) {
            var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();
            return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
        };

        SystemDefaultZoneRules.prototype.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
            var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();
            return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
        };

        SystemDefaultZoneRules.prototype.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
            var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1000;
            var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();
            var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 60000;
            var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();
            return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);
        };

        SystemDefaultZoneRules.prototype.validOffsets = function validOffsets(localDateTime) {
            return [this.offsetOfLocalDateTime(localDateTime)];
        };

        SystemDefaultZoneRules.prototype.transition = function transition() {
            return null;
        };

        SystemDefaultZoneRules.prototype.standardOffset = function standardOffset(instant) {
            return this.offsetOfInstant(instant);
        };

        SystemDefaultZoneRules.prototype.daylightSavings = function daylightSavings() {
            this._throwNotSupported();
        };

        SystemDefaultZoneRules.prototype.isDaylightSavings = function isDaylightSavings() {
            this._throwNotSupported();
        };

        SystemDefaultZoneRules.prototype.isValidOffset = function isValidOffset(dateTime, offset) {
            return this.offsetOfLocalDateTime(dateTime).equals(offset);
        };

        SystemDefaultZoneRules.prototype.nextTransition = function nextTransition() {
            this._throwNotSupported();
        };

        SystemDefaultZoneRules.prototype.previousTransition = function previousTransition() {
            this._throwNotSupported();
        };

        SystemDefaultZoneRules.prototype.transitions = function transitions() {
            this._throwNotSupported();
        };

        SystemDefaultZoneRules.prototype.transitionRules = function transitionRules() {
            this._throwNotSupported();
        };

        SystemDefaultZoneRules.prototype._throwNotSupported = function _throwNotSupported() {
            throw new DateTimeException('not supported operation');
        };

        SystemDefaultZoneRules.prototype.equals = function equals(other) {
            if (this === other || other instanceof SystemDefaultZoneRules) {
                return true;
            } else {
                return false;
            }
        };

        SystemDefaultZoneRules.prototype.toString = function toString() {
            return 'SYSTEM';
        };

        return SystemDefaultZoneRules;
    }(ZoneRules);

    function _classCallCheck$_(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$y(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$y(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var SystemDefaultZoneId = function (_ZoneId) {
        _inherits$y(SystemDefaultZoneId, _ZoneId);

        function SystemDefaultZoneId() {
            _classCallCheck$_(this, SystemDefaultZoneId);

            var _this = _possibleConstructorReturn$y(this, _ZoneId.call(this));

            _this._rules = new SystemDefaultZoneRules();
            return _this;
        }

        SystemDefaultZoneId.prototype.rules = function rules() {
            return this._rules;
        };

        SystemDefaultZoneId.prototype.equals = function equals(other) {
            if (this === other) {
                return true;
            }
            return false;
        };

        SystemDefaultZoneId.prototype.id = function id() {
            return 'SYSTEM';
        };

        return SystemDefaultZoneId;
    }(ZoneId);

    function _classCallCheck$10(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var ZoneIdFactory = function () {
        function ZoneIdFactory() {
            _classCallCheck$10(this, ZoneIdFactory);
        }

        ZoneIdFactory.systemDefault = function systemDefault() {
            return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
        };

        ZoneIdFactory.getAvailableZoneIds = function getAvailableZoneIds() {
            return ZoneRulesProvider.getAvailableZoneIds();
        };

        ZoneIdFactory.of = function of(zoneId) {
            requireNonNull(zoneId, 'zoneId');
            if (zoneId === 'Z') {
                return ZoneOffset.UTC;
            }
            if (zoneId.length === 1) {
                throw new DateTimeException('Invalid zone: ' + zoneId);
            }
            if (StringUtil.startsWith(zoneId, '+') || StringUtil.startsWith(zoneId, '-')) {
                return ZoneOffset.of(zoneId);
            }
            if (zoneId === 'UTC' || zoneId === 'GMT' || zoneId === 'GMT0' || zoneId === 'UT') {
                return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());
            }
            if (StringUtil.startsWith(zoneId, 'UTC+') || StringUtil.startsWith(zoneId, 'GMT+') || StringUtil.startsWith(zoneId, 'UTC-') || StringUtil.startsWith(zoneId, 'GMT-')) {
                var offset = ZoneOffset.of(zoneId.substring(3));
                if (offset.totalSeconds() === 0) {
                    return new ZoneRegion(zoneId.substring(0, 3), offset.rules());
                }
                return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());
            }
            if (StringUtil.startsWith(zoneId, 'UT+') || StringUtil.startsWith(zoneId, 'UT-')) {
                var _offset = ZoneOffset.of(zoneId.substring(2));
                if (_offset.totalSeconds() === 0) {
                    return new ZoneRegion('UT', _offset.rules());
                }
                return new ZoneRegion('UT' + _offset.id(), _offset.rules());
            }

            if (zoneId === 'SYSTEM') {
                return ZoneId.systemDefault();
            }
            return ZoneRegion.ofId(zoneId);
        };

        ZoneIdFactory.ofOffset = function ofOffset(prefix, offset) {
            requireNonNull(prefix, 'prefix');
            requireNonNull(offset, 'offset');
            if (prefix.length === 0) {
                return offset;
            }
            if (prefix === 'GMT' || prefix === 'UTC' || prefix === 'UT') {
                if (offset.totalSeconds() === 0) {
                    return new ZoneRegion(prefix, offset.rules());
                }
                return new ZoneRegion(prefix + offset.id(), offset.rules());
            }
            throw new IllegalArgumentException('Invalid prefix, must be GMT, UTC or UT: ' + prefix);
        };

        ZoneIdFactory.from = function from(temporal) {
            requireNonNull(temporal, 'temporal');
            var obj = temporal.query(TemporalQueries.zone());
            if (obj == null) {
                throw new DateTimeException('Unable to obtain ZoneId from TemporalAccessor: ' + temporal + ', type ' + (temporal.constructor != null ? temporal.constructor.name : ''));
            }
            return obj;
        };

        return ZoneIdFactory;
    }();

    var SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;

    function _init$l() {
        SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();

        ZoneId.systemDefault = ZoneIdFactory.systemDefault;
        ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;
        ZoneId.of = ZoneIdFactory.of;
        ZoneId.ofOffset = ZoneIdFactory.ofOffset;
        ZoneId.from = ZoneIdFactory.from;
        ZoneOffset.from = ZoneIdFactory.from;

        ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
        ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);
    }

    /*
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
     */

    var isInit = false;

    function init() {

        if (isInit) {
            return;
        }

        isInit = true;

        _init$1();
        _init();
        _init$2();
        _init$3();
        _init$i();
        _init$8();
        _init$k();
        _init$4();
        _init$j();
        _init$g();
        _init$h();
        _init$d();
        _init$5();
        _init$c();
        _init$b();
        _init$6();
        _init$7();
        _init$f();
        _init$l();
        _init$e();
        _init$a();
        _init$9();
    }

    init();

    function _classCallCheck$11(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    var ToNativeJsConverter = function () {
        function ToNativeJsConverter(temporal, zone) {
            _classCallCheck$11(this, ToNativeJsConverter);

            var zonedDateTime = void 0;

            if (temporal instanceof LocalDate) {
                zone = zone == null ? ZoneId.systemDefault() : zone;
                zonedDateTime = temporal.atStartOfDay(zone);
            } else if (temporal instanceof LocalDateTime) {
                zone = zone == null ? ZoneId.systemDefault() : zone;
                zonedDateTime = temporal.atZone(zone);
            } else if (temporal instanceof ZonedDateTime) {
                if (zone == null) {
                    zonedDateTime = temporal;
                } else {
                    zonedDateTime = temporal.withZoneSameInstant(zone);
                }
            } else {
                throw new IllegalArgumentException('unsupported instance for convert operation:' + temporal);
            }

            this.instant = zonedDateTime.toInstant();
        }

        ToNativeJsConverter.prototype.toDate = function toDate() {
            return new Date(this.instant.toEpochMilli());
        };

        ToNativeJsConverter.prototype.toEpochMilli = function toEpochMilli() {
            return this.instant.toEpochMilli();
        };

        return ToNativeJsConverter;
    }();

    function convert(temporal, zone) {
        return new ToNativeJsConverter(temporal, zone);
    }

    function _classCallCheck$12(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _possibleConstructorReturn$z(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

    function _inherits$z(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var NativeJsTemporal = function (_TemporalAccessor) {
        _inherits$z(NativeJsTemporal, _TemporalAccessor);

        function NativeJsTemporal(date) {
            var zone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZoneId.systemDefault();

            _classCallCheck$12(this, NativeJsTemporal);

            var _this = _possibleConstructorReturn$z(this, _TemporalAccessor.call(this));

            _this._zone = zone;
            if (date instanceof Date) {
                _this._epochMilli = date.getTime();
                return _possibleConstructorReturn$z(_this);
            } else if (typeof date.toDate === 'function' && date.toDate() instanceof Date) {
                _this._epochMilli = date.toDate().getTime();
                return _possibleConstructorReturn$z(_this);
            }
            assert(false, 'date must be either a javascript date or a moment');
            return _this;
        }

        NativeJsTemporal.prototype.query = function query(_query) {
            requireNonNull(_query, 'query');
            if (_query === TemporalQueries.localDate()) {
                return LocalDate.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);
            } else if (_query === TemporalQueries.localTime()) {
                return LocalTime.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);
            } else if (_query === TemporalQueries.zone()) {
                return this._zone;
            }
            return _TemporalAccessor.prototype.query.call(this, _query);
        };

        NativeJsTemporal.prototype.get = function get(field) {
            return this.getLong(field);
        };

        NativeJsTemporal.prototype.getLong = function getLong(field) {
            requireNonNull(field, 'field');
            if (field instanceof ChronoField) {
                switch (field) {
                    case ChronoField.NANO_OF_SECOND:
                        return MathUtil.floorMod(this._epochMilli, 1000) * 1000000;
                    case ChronoField.INSTANT_SECONDS:
                        return MathUtil.floorDiv(this._epochMilli, 1000);
                }
                throw new UnsupportedTemporalTypeException('Unsupported field: ' + field);
            }
            return field.getFrom(this);
        };

        NativeJsTemporal.prototype.isSupported = function isSupported(field) {
            return field === ChronoField.INSTANT_SECONDS || field === ChronoField.NANO_OF_SECOND;
        };

        return NativeJsTemporal;
    }(TemporalAccessor);

    function nativeJs(date, zone) {
        return new NativeJsTemporal(date, zone);
    }

    function bindUse(jsJoda) {
        var used = [];

        return function use(fn) {
            if (!~used.indexOf(fn)) {
                fn(jsJoda);
                used.push(fn);
            }
            return jsJoda;
        };
    }

    /**
     * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
     * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
     */

    var _ = {
        assert: assert$1,
        DateTimeBuilder: DateTimeBuilder,
        DateTimeParseContext: DateTimeParseContext,
        DateTimePrintContext: DateTimePrintContext,
        MathUtil: MathUtil,
        StringUtil: StringUtil,
        StringBuilder: StringBuilder
    };

    var jsJodaExports = {
        _: _,
        convert: convert,
        nativeJs: nativeJs,
        ArithmeticException: ArithmeticException,
        DateTimeException: DateTimeException,
        DateTimeParseException: DateTimeParseException,
        IllegalArgumentException: IllegalArgumentException,
        IllegalStateException: IllegalStateException,
        UnsupportedTemporalTypeException: UnsupportedTemporalTypeException,
        NullPointerException: NullPointerException,
        Clock: Clock,
        DayOfWeek: DayOfWeek,
        Duration: Duration,
        Instant: Instant,
        LocalDate: LocalDate,
        LocalTime: LocalTime,
        LocalDateTime: LocalDateTime,
        Month: Month,
        MonthDay: MonthDay,
        Period: Period,
        Year: Year,
        YearConstants: YearConstants,
        YearMonth: YearMonth,
        ZonedDateTime: ZonedDateTime,
        ZoneOffset: ZoneOffset,
        ZoneId: ZoneId,
        ZoneRegion: ZoneRegion,
        ZoneOffsetTransition: ZoneOffsetTransition,
        ZoneRules: ZoneRules,
        ZoneRulesProvider: ZoneRulesProvider,
        ChronoLocalDate: ChronoLocalDate,
        ChronoLocalDateTime: ChronoLocalDateTime,
        ChronoZonedDateTime: ChronoZonedDateTime,
        IsoChronology: IsoChronology,
        ChronoField: ChronoField,
        ChronoUnit: ChronoUnit,
        IsoFields: IsoFields,
        Temporal: Temporal,
        TemporalAccessor: TemporalAccessor,
        TemporalAdjuster: TemporalAdjuster,
        TemporalAdjusters: TemporalAdjusters,
        TemporalAmount: TemporalAmount,
        TemporalField: TemporalField,
        TemporalQueries: TemporalQueries,
        TemporalQuery: TemporalQuery,
        TemporalUnit: TemporalUnit,
        ValueRange: ValueRange,
        DateTimeFormatter: DateTimeFormatter,
        DateTimeFormatterBuilder: DateTimeFormatterBuilder,
        DecimalStyle: DecimalStyle,
        ResolverStyle: ResolverStyle,
        SignStyle: SignStyle,
        TextStyle: TextStyle
    };

    var use = bindUse(jsJodaExports);
    jsJodaExports.use = use;

    exports._ = _;
    exports.use = use;
    exports.convert = convert;
    exports.nativeJs = nativeJs;
    exports.ArithmeticException = ArithmeticException;
    exports.DateTimeException = DateTimeException;
    exports.DateTimeParseException = DateTimeParseException;
    exports.IllegalArgumentException = IllegalArgumentException;
    exports.IllegalStateException = IllegalStateException;
    exports.UnsupportedTemporalTypeException = UnsupportedTemporalTypeException;
    exports.NullPointerException = NullPointerException;
    exports.Clock = Clock;
    exports.DayOfWeek = DayOfWeek;
    exports.Duration = Duration;
    exports.Instant = Instant;
    exports.LocalDate = LocalDate;
    exports.LocalTime = LocalTime;
    exports.LocalDateTime = LocalDateTime;
    exports.Month = Month;
    exports.MonthDay = MonthDay;
    exports.Period = Period;
    exports.Year = Year;
    exports.YearConstants = YearConstants;
    exports.YearMonth = YearMonth;
    exports.ZonedDateTime = ZonedDateTime;
    exports.ZoneOffset = ZoneOffset;
    exports.ZoneId = ZoneId;
    exports.ZoneRegion = ZoneRegion;
    exports.ZoneOffsetTransition = ZoneOffsetTransition;
    exports.ZoneRules = ZoneRules;
    exports.ZoneRulesProvider = ZoneRulesProvider;
    exports.ChronoLocalDate = ChronoLocalDate;
    exports.ChronoLocalDateTime = ChronoLocalDateTime;
    exports.ChronoZonedDateTime = ChronoZonedDateTime;
    exports.IsoChronology = IsoChronology;
    exports.ChronoField = ChronoField;
    exports.ChronoUnit = ChronoUnit;
    exports.IsoFields = IsoFields;
    exports.Temporal = Temporal;
    exports.TemporalAccessor = TemporalAccessor;
    exports.TemporalAdjuster = TemporalAdjuster;
    exports.TemporalAdjusters = TemporalAdjusters;
    exports.TemporalAmount = TemporalAmount;
    exports.TemporalField = TemporalField;
    exports.TemporalQueries = TemporalQueries;
    exports.TemporalQuery = TemporalQuery;
    exports.TemporalUnit = TemporalUnit;
    exports.ValueRange = ValueRange;
    exports.DateTimeFormatter = DateTimeFormatter;
    exports.DateTimeFormatterBuilder = DateTimeFormatterBuilder;
    exports.DecimalStyle = DecimalStyle;
    exports.ResolverStyle = ResolverStyle;
    exports.SignStyle = SignStyle;
    exports.TextStyle = TextStyle;

    Object.defineProperty(exports, '__esModule', { value: true });

})));


},{}],347:[function(require,module,exports){
(function (process,global){
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var ERROR = 'input is invalid type';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA256_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  ];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];

  var blocks = [];

  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (outputType, is224) {
    return function (message) {
      return new Sha256(is224, true).update(message)[outputType]();
    };
  };

  var createMethod = function (is224) {
    var method = createOutputMethod('hex', is224);
    if (NODE_JS) {
      method = nodeWrap(method, is224);
    }
    method.create = function () {
      return new Sha256(is224);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type, is224);
    }
    return method;
  };

  var nodeWrap = function (method, is224) {
    var crypto = eval("require('crypto')");
    var Buffer = eval("require('buffer').Buffer");
    var algorithm = is224 ? 'sha224' : 'sha256';
    var nodeMethod = function (message) {
      if (typeof message === 'string') {
        return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');
      } else {
        if (message === null || message === undefined) {
          throw new Error(ERROR);
        } else if (message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        }
      }
      if (Array.isArray(message) || ArrayBuffer.isView(message) ||
        message.constructor === Buffer) {
        return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');
      } else {
        return method(message);
      }
    };
    return nodeMethod;
  };

  var createHmacOutputMethod = function (outputType, is224) {
    return function (key, message) {
      return new HmacSha256(key, is224, true).update(message)[outputType]();
    };
  };

  var createHmacMethod = function (is224) {
    var method = createHmacOutputMethod('hex', is224);
    method.create = function (key) {
      return new HmacSha256(key, is224);
    };
    method.update = function (key, message) {
      return method.create(key).update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createHmacOutputMethod(type, is224);
    }
    return method;
  };

  function Sha256(is224, sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    if (is224) {
      this.h0 = 0xc1059ed8;
      this.h1 = 0x367cd507;
      this.h2 = 0x3070dd17;
      this.h3 = 0xf70e5939;
      this.h4 = 0xffc00b31;
      this.h5 = 0x68581511;
      this.h6 = 0x64f98fa7;
      this.h7 = 0xbefa4fa4;
    } else { // 256
      this.h0 = 0x6a09e667;
      this.h1 = 0xbb67ae85;
      this.h2 = 0x3c6ef372;
      this.h3 = 0xa54ff53a;
      this.h4 = 0x510e527f;
      this.h5 = 0x9b05688c;
      this.h6 = 0x1f83d9ab;
      this.h7 = 0x5be0cd19;
    }

    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
    this.is224 = is224;
  }

  Sha256.prototype.update = function (message) {
    if (this.finalized) {
      return;
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
      notString = true;
    }
    var code, index = 0, i, length = message.length, blocks = this.blocks;

    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        blocks[16] = blocks[1] = blocks[2] = blocks[3] =
          blocks[4] = blocks[5] = blocks[6] = blocks[7] =
          blocks[8] = blocks[9] = blocks[10] = blocks[11] =
          blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }

      if (notString) {
        for (i = this.start; index < length && i < 64; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }

      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.block = blocks[16];
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Sha256.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex;
    blocks[16] = this.block;
    blocks[i >> 2] |= EXTRA[i & 3];
    this.block = blocks[16];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[16] = blocks[1] = blocks[2] = blocks[3] =
        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;
    blocks[15] = this.bytes << 3;
    this.hash();
  };

  Sha256.prototype.hash = function () {
    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6,
      h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;

    for (j = 16; j < 64; ++j) {
      // rightrotate
      t1 = blocks[j - 15];
      s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
      t1 = blocks[j - 2];
      s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
      blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;
    }

    bc = b & c;
    for (j = 0; j < 64; j += 4) {
      if (this.first) {
        if (this.is224) {
          ab = 300032;
          t1 = blocks[0] - 1413257819;
          h = t1 - 150054599 << 0;
          d = t1 + 24177077 << 0;
        } else {
          ab = 704751109;
          t1 = blocks[0] - 210244248;
          h = t1 - 1521486534 << 0;
          d = t1 + 143694565 << 0;
        }
        this.first = false;
      } else {
        s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
        s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
        ab = a & b;
        maj = ab ^ (a & c) ^ bc;
        ch = (e & f) ^ (~e & g);
        t1 = h + s1 + ch + K[j] + blocks[j];
        t2 = s0 + maj;
        h = d + t1 << 0;
        d = t1 + t2 << 0;
      }
      s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));
      s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));
      da = d & a;
      maj = da ^ (d & b) ^ ab;
      ch = (h & e) ^ (~h & f);
      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
      t2 = s0 + maj;
      g = c + t1 << 0;
      c = t1 + t2 << 0;
      s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));
      s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));
      cd = c & d;
      maj = cd ^ (c & a) ^ da;
      ch = (g & h) ^ (~g & e);
      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
      t2 = s0 + maj;
      f = b + t1 << 0;
      b = t1 + t2 << 0;
      s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));
      s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));
      bc = b & c;
      maj = bc ^ (b & d) ^ cd;
      ch = (f & g) ^ (~f & h);
      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
      t2 = s0 + maj;
      e = a + t1 << 0;
      a = t1 + t2 << 0;
    }

    this.h0 = this.h0 + a << 0;
    this.h1 = this.h1 + b << 0;
    this.h2 = this.h2 + c << 0;
    this.h3 = this.h3 + d << 0;
    this.h4 = this.h4 + e << 0;
    this.h5 = this.h5 + f << 0;
    this.h6 = this.h6 + g << 0;
    this.h7 = this.h7 + h << 0;
  };

  Sha256.prototype.hex = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
      h6 = this.h6, h7 = this.h7;

    var hex = HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +
      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +
      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +
      HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +
      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +
      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +
      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +
      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +
      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +
      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +
      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +
      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +
      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
      HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +
      HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +
      HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +
      HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] +
      HEX_CHARS[(h5 >> 28) & 0x0F] + HEX_CHARS[(h5 >> 24) & 0x0F] +
      HEX_CHARS[(h5 >> 20) & 0x0F] + HEX_CHARS[(h5 >> 16) & 0x0F] +
      HEX_CHARS[(h5 >> 12) & 0x0F] + HEX_CHARS[(h5 >> 8) & 0x0F] +
      HEX_CHARS[(h5 >> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] +
      HEX_CHARS[(h6 >> 28) & 0x0F] + HEX_CHARS[(h6 >> 24) & 0x0F] +
      HEX_CHARS[(h6 >> 20) & 0x0F] + HEX_CHARS[(h6 >> 16) & 0x0F] +
      HEX_CHARS[(h6 >> 12) & 0x0F] + HEX_CHARS[(h6 >> 8) & 0x0F] +
      HEX_CHARS[(h6 >> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F];
    if (!this.is224) {
      hex += HEX_CHARS[(h7 >> 28) & 0x0F] + HEX_CHARS[(h7 >> 24) & 0x0F] +
        HEX_CHARS[(h7 >> 20) & 0x0F] + HEX_CHARS[(h7 >> 16) & 0x0F] +
        HEX_CHARS[(h7 >> 12) & 0x0F] + HEX_CHARS[(h7 >> 8) & 0x0F] +
        HEX_CHARS[(h7 >> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F];
    }
    return hex;
  };

  Sha256.prototype.toString = Sha256.prototype.hex;

  Sha256.prototype.digest = function () {
    this.finalize();

    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,
      h6 = this.h6, h7 = this.h7;

    var arr = [
      (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,
      (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,
      (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,
      (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,
      (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF,
      (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, h5 & 0xFF,
      (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, h6 & 0xFF
    ];
    if (!this.is224) {
      arr.push((h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, h7 & 0xFF);
    }
    return arr;
  };

  Sha256.prototype.array = Sha256.prototype.digest;

  Sha256.prototype.arrayBuffer = function () {
    this.finalize();

    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0);
    dataView.setUint32(4, this.h1);
    dataView.setUint32(8, this.h2);
    dataView.setUint32(12, this.h3);
    dataView.setUint32(16, this.h4);
    dataView.setUint32(20, this.h5);
    dataView.setUint32(24, this.h6);
    if (!this.is224) {
      dataView.setUint32(28, this.h7);
    }
    return buffer;
  };

  function HmacSha256(key, is224, sharedMemory) {
    var i, type = typeof key;
    if (type === 'string') {
      var bytes = [], length = key.length, index = 0, code;
      for (i = 0; i < length; ++i) {
        code = key.charCodeAt(i);
        if (code < 0x80) {
          bytes[index++] = code;
        } else if (code < 0x800) {
          bytes[index++] = (0xc0 | (code >> 6));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes[index++] = (0xe0 | (code >> 12));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));
          bytes[index++] = (0xf0 | (code >> 18));
          bytes[index++] = (0x80 | ((code >> 12) & 0x3f));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        }
      }
      key = bytes;
    } else {
      if (type === 'object') {
        if (key === null) {
          throw new Error(ERROR);
        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
          key = new Uint8Array(key);
        } else if (!Array.isArray(key)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
            throw new Error(ERROR);
          }
        }
      } else {
        throw new Error(ERROR);
      }
    }

    if (key.length > 64) {
      key = (new Sha256(is224, true)).update(key).array();
    }

    var oKeyPad = [], iKeyPad = [];
    for (i = 0; i < 64; ++i) {
      var b = key[i] || 0;
      oKeyPad[i] = 0x5c ^ b;
      iKeyPad[i] = 0x36 ^ b;
    }

    Sha256.call(this, is224, sharedMemory);

    this.update(iKeyPad);
    this.oKeyPad = oKeyPad;
    this.inner = true;
    this.sharedMemory = sharedMemory;
  }
  HmacSha256.prototype = new Sha256();

  HmacSha256.prototype.finalize = function () {
    Sha256.prototype.finalize.call(this);
    if (this.inner) {
      this.inner = false;
      var innerHash = this.array();
      Sha256.call(this, this.is224, this.sharedMemory);
      this.update(this.oKeyPad);
      this.update(innerHash);
      Sha256.prototype.finalize.call(this);
    }
  };

  var exports = createMethod();
  exports.sha256 = exports;
  exports.sha224 = createMethod(true);
  exports.sha256.hmac = createHmacMethod();
  exports.sha224.hmac = createHmacMethod(true);

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.sha256 = exports.sha256;
    root.sha224 = exports.sha224;
    if (AMD) {
      define(function () {
        return exports;
      });
    }
  }
})();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":117}],348:[function(require,module,exports){
(function (process,global){
/*
 * [js-sha512]{@link https://github.com/emn178/js-sha512}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA512_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA512_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA512_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [-2147483648, 8388608, 32768, 128];
  var SHIFT = [24, 16, 8, 0];
  var K = [
    0x428A2F98, 0xD728AE22, 0x71374491, 0x23EF65CD,
    0xB5C0FBCF, 0xEC4D3B2F, 0xE9B5DBA5, 0x8189DBBC,
    0x3956C25B, 0xF348B538, 0x59F111F1, 0xB605D019,
    0x923F82A4, 0xAF194F9B, 0xAB1C5ED5, 0xDA6D8118,
    0xD807AA98, 0xA3030242, 0x12835B01, 0x45706FBE,
    0x243185BE, 0x4EE4B28C, 0x550C7DC3, 0xD5FFB4E2,
    0x72BE5D74, 0xF27B896F, 0x80DEB1FE, 0x3B1696B1,
    0x9BDC06A7, 0x25C71235, 0xC19BF174, 0xCF692694,
    0xE49B69C1, 0x9EF14AD2, 0xEFBE4786, 0x384F25E3,
    0x0FC19DC6, 0x8B8CD5B5, 0x240CA1CC, 0x77AC9C65,
    0x2DE92C6F, 0x592B0275, 0x4A7484AA, 0x6EA6E483,
    0x5CB0A9DC, 0xBD41FBD4, 0x76F988DA, 0x831153B5,
    0x983E5152, 0xEE66DFAB, 0xA831C66D, 0x2DB43210,
    0xB00327C8, 0x98FB213F, 0xBF597FC7, 0xBEEF0EE4,
    0xC6E00BF3, 0x3DA88FC2, 0xD5A79147, 0x930AA725,
    0x06CA6351, 0xE003826F, 0x14292967, 0x0A0E6E70,
    0x27B70A85, 0x46D22FFC, 0x2E1B2138, 0x5C26C926,
    0x4D2C6DFC, 0x5AC42AED, 0x53380D13, 0x9D95B3DF,
    0x650A7354, 0x8BAF63DE, 0x766A0ABB, 0x3C77B2A8,
    0x81C2C92E, 0x47EDAEE6, 0x92722C85, 0x1482353B,
    0xA2BFE8A1, 0x4CF10364, 0xA81A664B, 0xBC423001,
    0xC24B8B70, 0xD0F89791, 0xC76C51A3, 0x0654BE30,
    0xD192E819, 0xD6EF5218, 0xD6990624, 0x5565A910,
    0xF40E3585, 0x5771202A, 0x106AA070, 0x32BBD1B8,
    0x19A4C116, 0xB8D2D0C8, 0x1E376C08, 0x5141AB53,
    0x2748774C, 0xDF8EEB99, 0x34B0BCB5, 0xE19B48A8,
    0x391C0CB3, 0xC5C95A63, 0x4ED8AA4A, 0xE3418ACB,
    0x5B9CCA4F, 0x7763E373, 0x682E6FF3, 0xD6B2B8A3,
    0x748F82EE, 0x5DEFB2FC, 0x78A5636F, 0x43172F60,
    0x84C87814, 0xA1F0AB72, 0x8CC70208, 0x1A6439EC,
    0x90BEFFFA, 0x23631E28, 0xA4506CEB, 0xDE82BDE9,
    0xBEF9A3F7, 0xB2C67915, 0xC67178F2, 0xE372532B,
    0xCA273ECE, 0xEA26619C, 0xD186B8C7, 0x21C0C207,
    0xEADA7DD6, 0xCDE0EB1E, 0xF57D4F7F, 0xEE6ED178,
    0x06F067AA, 0x72176FBA, 0x0A637DC5, 0xA2C898A6,
    0x113F9804, 0xBEF90DAE, 0x1B710B35, 0x131C471B,
    0x28DB77F5, 0x23047D84, 0x32CAAB7B, 0x40C72493,
    0x3C9EBE0A, 0x15C9BEBC, 0x431D67C4, 0x9C100D4C,
    0x4CC5D4BE, 0xCB3E42B6, 0x597F299C, 0xFC657E2A,
    0x5FCB6FAB, 0x3AD6FAEC, 0x6C44198C, 0x4A475817
  ];

  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];

  var blocks = [];

  if (root.JS_SHA512_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (outputType, bits) {
    return function (message) {
      return new Sha512(bits, true).update(message)[outputType]();
    };
  };

  var createMethod = function (bits) {
    var method = createOutputMethod('hex', bits);
    method.create = function () {
      return new Sha512(bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type, bits);
    }
    return method;
  };

  var createHmacOutputMethod = function (outputType, bits) {
    return function (key, message) {
      return new HmacSha512(key, bits, true).update(message)[outputType]();
    };
  };

  var createHmacMethod = function (bits) {
    var method = createHmacOutputMethod('hex', bits);
    method.create = function (key) {
      return new HmacSha512(key, bits);
    };
    method.update = function (key, message) {
      return method.create(key).update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createHmacOutputMethod(type, bits);
    }
    return method;
  };

  function Sha512(bits, sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] =
      blocks[5] = blocks[6] = blocks[7] = blocks[8] =
      blocks[9] = blocks[10] = blocks[11] = blocks[12] =
      blocks[13] = blocks[14] = blocks[15] = blocks[16] =
      blocks[17] = blocks[18] = blocks[19] = blocks[20] =
      blocks[21] = blocks[22] = blocks[23] = blocks[24] =
      blocks[25] = blocks[26] = blocks[27] = blocks[28] =
      blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
      this.blocks = blocks;
    } else {
      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }

    if (bits == 384) {
      this.h0h = 0xCBBB9D5D;
      this.h0l = 0xC1059ED8;
      this.h1h = 0x629A292A;
      this.h1l = 0x367CD507;
      this.h2h = 0x9159015A;
      this.h2l = 0x3070DD17;
      this.h3h = 0x152FECD8;
      this.h3l = 0xF70E5939;
      this.h4h = 0x67332667;
      this.h4l = 0xFFC00B31;
      this.h5h = 0x8EB44A87;
      this.h5l = 0x68581511;
      this.h6h = 0xDB0C2E0D;
      this.h6l = 0x64F98FA7;
      this.h7h = 0x47B5481D;
      this.h7l = 0xBEFA4FA4;
    } else if (bits == 256) {
      this.h0h = 0x22312194;
      this.h0l = 0xFC2BF72C;
      this.h1h = 0x9F555FA3;
      this.h1l = 0xC84C64C2;
      this.h2h = 0x2393B86B;
      this.h2l = 0x6F53B151;
      this.h3h = 0x96387719;
      this.h3l = 0x5940EABD;
      this.h4h = 0x96283EE2;
      this.h4l = 0xA88EFFE3;
      this.h5h = 0xBE5E1E25;
      this.h5l = 0x53863992;
      this.h6h = 0x2B0199FC;
      this.h6l = 0x2C85B8AA;
      this.h7h = 0x0EB72DDC;
      this.h7l = 0x81C52CA2;
    } else if (bits == 224) {
      this.h0h = 0x8C3D37C8;
      this.h0l = 0x19544DA2;
      this.h1h = 0x73E19966;
      this.h1l = 0x89DCD4D6;
      this.h2h = 0x1DFAB7AE;
      this.h2l = 0x32FF9C82;
      this.h3h = 0x679DD514;
      this.h3l = 0x582F9FCF;
      this.h4h = 0x0F6D2B69;
      this.h4l = 0x7BD44DA8;
      this.h5h = 0x77E36F73;
      this.h5l = 0x04C48942;
      this.h6h = 0x3F9D85A8;
      this.h6l = 0x6A1D36C8;
      this.h7h = 0x1112E6AD;
      this.h7l = 0x91D692A1;
    } else { // 512
      this.h0h = 0x6A09E667;
      this.h0l = 0xF3BCC908;
      this.h1h = 0xBB67AE85;
      this.h1l = 0x84CAA73B;
      this.h2h = 0x3C6EF372;
      this.h2l = 0xFE94F82B;
      this.h3h = 0xA54FF53A;
      this.h3l = 0x5F1D36F1;
      this.h4h = 0x510E527F;
      this.h4l = 0xADE682D1;
      this.h5h = 0x9B05688C;
      this.h5l = 0x2B3E6C1F;
      this.h6h = 0x1F83D9AB;
      this.h6l = 0xFB41BD6B;
      this.h7h = 0x5BE0CD19;
      this.h7l = 0x137E2179;
    }
    this.bits = bits;

    this.block = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
  }

  Sha512.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var code, index = 0, i, length = message.length, blocks = this.blocks;

    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = this.block;
        blocks[1] = blocks[2] = blocks[3] = blocks[4] =
        blocks[5] = blocks[6] = blocks[7] = blocks[8] =
        blocks[9] = blocks[10] = blocks[11] = blocks[12] =
        blocks[13] = blocks[14] = blocks[15] = blocks[16] =
        blocks[17] = blocks[18] = blocks[19] = blocks[20] =
        blocks[21] = blocks[22] = blocks[23] = blocks[24] =
        blocks[25] = blocks[26] = blocks[27] = blocks[28] =
        blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
      }

      if(notString) {
        for (i = this.start; index < length && i < 128; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < 128; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }

      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 128) {
        this.block = blocks[32];
        this.start = i - 128;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };

  Sha512.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex;
    blocks[32] = this.block;
    blocks[i >> 2] |= EXTRA[i & 3];
    this.block = blocks[32];
    if (i >= 112) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = this.block;
      blocks[1] = blocks[2] = blocks[3] = blocks[4] =
      blocks[5] = blocks[6] = blocks[7] = blocks[8] =
      blocks[9] = blocks[10] = blocks[11] = blocks[12] =
      blocks[13] = blocks[14] = blocks[15] = blocks[16] =
      blocks[17] = blocks[18] = blocks[19] = blocks[20] =
      blocks[21] = blocks[22] = blocks[23] = blocks[24] =
      blocks[25] = blocks[26] = blocks[27] = blocks[28] =
      blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
    }
    blocks[30] = this.hBytes << 3 | this.bytes >>> 29;
    blocks[31] = this.bytes << 3;
    this.hash();
  };

  Sha512.prototype.hash = function () {
    var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l,
      h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l,
      h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l,
      h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l,
      blocks = this.blocks, j, s0h, s0l, s1h, s1l, c1, c2, c3, c4,
      abh, abl, dah, dal, cdh, cdl, bch, bcl,
      majh, majl, t1h, t1l, t2h, t2l, chh, chl;

    for (j = 32; j < 160; j += 2) {
      t1h = blocks[j - 30];
      t1l = blocks[j - 29];
      s0h = ((t1h >>> 1) | (t1l << 31)) ^ ((t1h >>> 8) | (t1l << 24)) ^ (t1h >>> 7);
      s0l = ((t1l >>> 1) | (t1h << 31)) ^ ((t1l >>> 8) | (t1h << 24)) ^ ((t1l >>> 7) | t1h << 25);

      t1h = blocks[j - 4];
      t1l = blocks[j - 3];
      s1h = ((t1h >>> 19) | (t1l << 13)) ^ ((t1l >>> 29) | (t1h << 3)) ^ (t1h >>> 6);
      s1l = ((t1l >>> 19) | (t1h << 13)) ^ ((t1h >>> 29) | (t1l << 3)) ^ ((t1l >>> 6) | t1h << 26);

      t1h = blocks[j - 32];
      t1l = blocks[j - 31];
      t2h = blocks[j - 14];
      t2l = blocks[j - 13];

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (s0l & 0xFFFF) + (s1l & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (s0h & 0xFFFF) + (s1h & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);

      blocks[j] = (c4 << 16) | (c3 & 0xFFFF);
      blocks[j + 1] = (c2 << 16) | (c1 & 0xFFFF);
    }

    var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
    bch = bh & ch;
    bcl = bl & cl;
    for (j = 0; j < 160; j += 8) {
      s0h = ((ah >>> 28) | (al << 4)) ^ ((al >>> 2) | (ah << 30)) ^ ((al >>> 7) | (ah << 25));
      s0l = ((al >>> 28) | (ah << 4)) ^ ((ah >>> 2) | (al << 30)) ^ ((ah >>> 7) | (al << 25));

      s1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((el >>> 9) | (eh << 23));
      s1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((eh >>> 9) | (el << 23));

      abh = ah & bh;
      abl = al & bl;
      majh = abh ^ (ah & ch) ^ bch;
      majl = abl ^ (al & cl) ^ bcl;

      chh = (eh & fh) ^ (~eh & gh);
      chl = (el & fl) ^ (~el & gl);

      t1h = blocks[j];
      t1l = blocks[j + 1];
      t2h = K[j];
      t2l = K[j + 1];

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (hl & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (hh & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);

      t1h = (c4 << 16) | (c3 & 0xFFFF);
      t1l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
      c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
      c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
      c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);

      t2h = (c4 << 16) | (c3 & 0xFFFF);
      t2l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (dl & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (dh & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      hh = (c4 << 16) | (c3 & 0xFFFF);
      hl = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      dh = (c4 << 16) | (c3 & 0xFFFF);
      dl = (c2 << 16) | (c1 & 0xFFFF);

      s0h = ((dh >>> 28) | (dl << 4)) ^ ((dl >>> 2) | (dh << 30)) ^ ((dl >>> 7) | (dh << 25));
      s0l = ((dl >>> 28) | (dh << 4)) ^ ((dh >>> 2) | (dl << 30)) ^ ((dh >>> 7) | (dl << 25));

      s1h = ((hh >>> 14) | (hl << 18)) ^ ((hh >>> 18) | (hl << 14)) ^ ((hl >>> 9) | (hh << 23));
      s1l = ((hl >>> 14) | (hh << 18)) ^ ((hl >>> 18) | (hh << 14)) ^ ((hh >>> 9) | (hl << 23));

      dah = dh & ah;
      dal = dl & al;
      majh = dah ^ (dh & bh) ^ abh;
      majl = dal ^ (dl & bl) ^ abl;

      chh = (hh & eh) ^ (~hh & fh);
      chl = (hl & el) ^ (~hl & fl);

      t1h = blocks[j + 2];
      t1l = blocks[j + 3];
      t2h = K[j + 2];
      t2l = K[j + 3];

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (gl & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (gh & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);

      t1h = (c4 << 16) | (c3 & 0xFFFF);
      t1l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
      c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
      c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
      c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);

      t2h = (c4 << 16) | (c3 & 0xFFFF);
      t2l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (cl & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (ch & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      gh = (c4 << 16) | (c3 & 0xFFFF);
      gl = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      ch = (c4 << 16) | (c3 & 0xFFFF);
      cl = (c2 << 16) | (c1 & 0xFFFF);

      s0h = ((ch >>> 28) | (cl << 4)) ^ ((cl >>> 2) | (ch << 30)) ^ ((cl >>> 7) | (ch << 25));
      s0l = ((cl >>> 28) | (ch << 4)) ^ ((ch >>> 2) | (cl << 30)) ^ ((ch >>> 7) | (cl << 25));

      s1h = ((gh >>> 14) | (gl << 18)) ^ ((gh >>> 18) | (gl << 14)) ^ ((gl >>> 9) | (gh << 23));
      s1l = ((gl >>> 14) | (gh << 18)) ^ ((gl >>> 18) | (gh << 14)) ^ ((gh >>> 9) | (gl << 23));

      cdh = ch & dh;
      cdl = cl & dl;
      majh = cdh ^ (ch & ah) ^ dah;
      majl = cdl ^ (cl & al) ^ dal;

      chh = (gh & hh) ^ (~gh & eh);
      chl = (gl & hl) ^ (~gl & el);

      t1h = blocks[j + 4];
      t1l = blocks[j + 5];
      t2h = K[j + 4];
      t2l = K[j + 5];

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (fl & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (fh & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);

      t1h = (c4 << 16) | (c3 & 0xFFFF);
      t1l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
      c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
      c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
      c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);

      t2h = (c4 << 16) | (c3 & 0xFFFF);
      t2l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (bl & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (bh & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      fh = (c4 << 16) | (c3 & 0xFFFF);
      fl = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      bh = (c4 << 16) | (c3 & 0xFFFF);
      bl = (c2 << 16) | (c1 & 0xFFFF);

      s0h = ((bh >>> 28) | (bl << 4)) ^ ((bl >>> 2) | (bh << 30)) ^ ((bl >>> 7) | (bh << 25));
      s0l = ((bl >>> 28) | (bh << 4)) ^ ((bh >>> 2) | (bl << 30)) ^ ((bh >>> 7) | (bl << 25));

      s1h = ((fh >>> 14) | (fl << 18)) ^ ((fh >>> 18) | (fl << 14)) ^ ((fl >>> 9) | (fh << 23));
      s1l = ((fl >>> 14) | (fh << 18)) ^ ((fl >>> 18) | (fh << 14)) ^ ((fh >>> 9) | (fl << 23));

      bch = bh & ch;
      bcl = bl & cl;
      majh = bch ^ (bh & dh) ^ cdh;
      majl = bcl ^ (bl & dl) ^ cdl;

      chh = (fh & gh) ^ (~fh & hh);
      chl = (fl & gl) ^ (~fl & hl);

      t1h = blocks[j + 6];
      t1l = blocks[j + 7];
      t2h = K[j + 6];
      t2l = K[j + 7];

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF) + (chl & 0xFFFF) + (s1l & 0xFFFF) + (el & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (chh & 0xFFFF) + (s1h & 0xFFFF) + (eh & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);

      t1h = (c4 << 16) | (c3 & 0xFFFF);
      t1l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (majl & 0xFFFF) + (s0l & 0xFFFF);
      c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
      c3 = (majh & 0xFFFF) + (s0h & 0xFFFF) + (c2 >>> 16);
      c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);

      t2h = (c4 << 16) | (c3 & 0xFFFF);
      t2l = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (al & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (ah & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      eh = (c4 << 16) | (c3 & 0xFFFF);
      el = (c2 << 16) | (c1 & 0xFFFF);

      c1 = (t2l & 0xFFFF) + (t1l & 0xFFFF);
      c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
      c3 = (t2h & 0xFFFF) + (t1h & 0xFFFF) + (c2 >>> 16);
      c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);

      ah = (c4 << 16) | (c3 & 0xFFFF);
      al = (c2 << 16) | (c1 & 0xFFFF);
    }

    c1 = (h0l & 0xFFFF) + (al & 0xFFFF);
    c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
    c3 = (h0h & 0xFFFF) + (ah & 0xFFFF) + (c2 >>> 16);
    c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);

    this.h0h = (c4 << 16) | (c3 & 0xFFFF);
    this.h0l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h1l & 0xFFFF) + (bl & 0xFFFF);
    c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
    c3 = (h1h & 0xFFFF) + (bh & 0xFFFF) + (c2 >>> 16);
    c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);

    this.h1h = (c4 << 16) | (c3 & 0xFFFF);
    this.h1l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h2l & 0xFFFF) + (cl & 0xFFFF);
    c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
    c3 = (h2h & 0xFFFF) + (ch & 0xFFFF) + (c2 >>> 16);
    c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);

    this.h2h = (c4 << 16) | (c3 & 0xFFFF);
    this.h2l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h3l & 0xFFFF) + (dl & 0xFFFF);
    c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
    c3 = (h3h & 0xFFFF) + (dh & 0xFFFF) + (c2 >>> 16);
    c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);

    this.h3h = (c4 << 16) | (c3 & 0xFFFF);
    this.h3l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h4l & 0xFFFF) + (el & 0xFFFF);
    c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
    c3 = (h4h & 0xFFFF) + (eh & 0xFFFF) + (c2 >>> 16);
    c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);

    this.h4h = (c4 << 16) | (c3 & 0xFFFF);
    this.h4l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h5l & 0xFFFF) + (fl & 0xFFFF);
    c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
    c3 = (h5h & 0xFFFF) + (fh & 0xFFFF) + (c2 >>> 16);
    c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);

    this.h5h = (c4 << 16) | (c3 & 0xFFFF);
    this.h5l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h6l & 0xFFFF) + (gl & 0xFFFF);
    c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
    c3 = (h6h & 0xFFFF) + (gh & 0xFFFF) + (c2 >>> 16);
    c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);

    this.h6h = (c4 << 16) | (c3 & 0xFFFF);
    this.h6l = (c2 << 16) | (c1 & 0xFFFF);

    c1 = (h7l & 0xFFFF) + (hl & 0xFFFF);
    c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
    c3 = (h7h & 0xFFFF) + (hh & 0xFFFF) + (c2 >>> 16);
    c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);

    this.h7h = (c4 << 16) | (c3 & 0xFFFF);
    this.h7l = (c2 << 16) | (c1 & 0xFFFF);
  };

  Sha512.prototype.hex = function () {
    this.finalize();

    var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l,
      h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l,
      h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l,
      h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l,
      bits = this.bits;

    var hex = HEX_CHARS[(h0h >> 28) & 0x0F] + HEX_CHARS[(h0h >> 24) & 0x0F] +
      HEX_CHARS[(h0h >> 20) & 0x0F] + HEX_CHARS[(h0h >> 16) & 0x0F] +
      HEX_CHARS[(h0h >> 12) & 0x0F] + HEX_CHARS[(h0h >> 8) & 0x0F] +
      HEX_CHARS[(h0h >> 4) & 0x0F] + HEX_CHARS[h0h & 0x0F] +
      HEX_CHARS[(h0l >> 28) & 0x0F] + HEX_CHARS[(h0l >> 24) & 0x0F] +
      HEX_CHARS[(h0l >> 20) & 0x0F] + HEX_CHARS[(h0l >> 16) & 0x0F] +
      HEX_CHARS[(h0l >> 12) & 0x0F] + HEX_CHARS[(h0l >> 8) & 0x0F] +
      HEX_CHARS[(h0l >> 4) & 0x0F] + HEX_CHARS[h0l & 0x0F] +
      HEX_CHARS[(h1h >> 28) & 0x0F] + HEX_CHARS[(h1h >> 24) & 0x0F] +
      HEX_CHARS[(h1h >> 20) & 0x0F] + HEX_CHARS[(h1h >> 16) & 0x0F] +
      HEX_CHARS[(h1h >> 12) & 0x0F] + HEX_CHARS[(h1h >> 8) & 0x0F] +
      HEX_CHARS[(h1h >> 4) & 0x0F] + HEX_CHARS[h1h & 0x0F] +
      HEX_CHARS[(h1l >> 28) & 0x0F] + HEX_CHARS[(h1l >> 24) & 0x0F] +
      HEX_CHARS[(h1l >> 20) & 0x0F] + HEX_CHARS[(h1l >> 16) & 0x0F] +
      HEX_CHARS[(h1l >> 12) & 0x0F] + HEX_CHARS[(h1l >> 8) & 0x0F] +
      HEX_CHARS[(h1l >> 4) & 0x0F] + HEX_CHARS[h1l & 0x0F] +
      HEX_CHARS[(h2h >> 28) & 0x0F] + HEX_CHARS[(h2h >> 24) & 0x0F] +
      HEX_CHARS[(h2h >> 20) & 0x0F] + HEX_CHARS[(h2h >> 16) & 0x0F] +
      HEX_CHARS[(h2h >> 12) & 0x0F] + HEX_CHARS[(h2h >> 8) & 0x0F] +
      HEX_CHARS[(h2h >> 4) & 0x0F] + HEX_CHARS[h2h & 0x0F] +
      HEX_CHARS[(h2l >> 28) & 0x0F] + HEX_CHARS[(h2l >> 24) & 0x0F] +
      HEX_CHARS[(h2l >> 20) & 0x0F] + HEX_CHARS[(h2l >> 16) & 0x0F] +
      HEX_CHARS[(h2l >> 12) & 0x0F] + HEX_CHARS[(h2l >> 8) & 0x0F] +
      HEX_CHARS[(h2l >> 4) & 0x0F] + HEX_CHARS[h2l & 0x0F] +
      HEX_CHARS[(h3h >> 28) & 0x0F] + HEX_CHARS[(h3h >> 24) & 0x0F] +
      HEX_CHARS[(h3h >> 20) & 0x0F] + HEX_CHARS[(h3h >> 16) & 0x0F] +
      HEX_CHARS[(h3h >> 12) & 0x0F] + HEX_CHARS[(h3h >> 8) & 0x0F] +
      HEX_CHARS[(h3h >> 4) & 0x0F] + HEX_CHARS[h3h & 0x0F];
    if (bits >= 256) {
      hex += HEX_CHARS[(h3l >> 28) & 0x0F] + HEX_CHARS[(h3l >> 24) & 0x0F] +
        HEX_CHARS[(h3l >> 20) & 0x0F] + HEX_CHARS[(h3l >> 16) & 0x0F] +
        HEX_CHARS[(h3l >> 12) & 0x0F] + HEX_CHARS[(h3l >> 8) & 0x0F] +
        HEX_CHARS[(h3l >> 4) & 0x0F] + HEX_CHARS[h3l & 0x0F];
    }
    if (bits >= 384) {
      hex += HEX_CHARS[(h4h >> 28) & 0x0F] + HEX_CHARS[(h4h >> 24) & 0x0F] +
        HEX_CHARS[(h4h >> 20) & 0x0F] + HEX_CHARS[(h4h >> 16) & 0x0F] +
        HEX_CHARS[(h4h >> 12) & 0x0F] + HEX_CHARS[(h4h >> 8) & 0x0F] +
        HEX_CHARS[(h4h >> 4) & 0x0F] + HEX_CHARS[h4h & 0x0F] +
        HEX_CHARS[(h4l >> 28) & 0x0F] + HEX_CHARS[(h4l >> 24) & 0x0F] +
        HEX_CHARS[(h4l >> 20) & 0x0F] + HEX_CHARS[(h4l >> 16) & 0x0F] +
        HEX_CHARS[(h4l >> 12) & 0x0F] + HEX_CHARS[(h4l >> 8) & 0x0F] +
        HEX_CHARS[(h4l >> 4) & 0x0F] + HEX_CHARS[h4l & 0x0F] +
        HEX_CHARS[(h5h >> 28) & 0x0F] + HEX_CHARS[(h5h >> 24) & 0x0F] +
        HEX_CHARS[(h5h >> 20) & 0x0F] + HEX_CHARS[(h5h >> 16) & 0x0F] +
        HEX_CHARS[(h5h >> 12) & 0x0F] + HEX_CHARS[(h5h >> 8) & 0x0F] +
        HEX_CHARS[(h5h >> 4) & 0x0F] + HEX_CHARS[h5h & 0x0F] +
        HEX_CHARS[(h5l >> 28) & 0x0F] + HEX_CHARS[(h5l >> 24) & 0x0F] +
        HEX_CHARS[(h5l >> 20) & 0x0F] + HEX_CHARS[(h5l >> 16) & 0x0F] +
        HEX_CHARS[(h5l >> 12) & 0x0F] + HEX_CHARS[(h5l >> 8) & 0x0F] +
        HEX_CHARS[(h5l >> 4) & 0x0F] + HEX_CHARS[h5l & 0x0F];
    }
    if (bits == 512) {
      hex += HEX_CHARS[(h6h >> 28) & 0x0F] + HEX_CHARS[(h6h >> 24) & 0x0F] +
        HEX_CHARS[(h6h >> 20) & 0x0F] + HEX_CHARS[(h6h >> 16) & 0x0F] +
        HEX_CHARS[(h6h >> 12) & 0x0F] + HEX_CHARS[(h6h >> 8) & 0x0F] +
        HEX_CHARS[(h6h >> 4) & 0x0F] + HEX_CHARS[h6h & 0x0F] +
        HEX_CHARS[(h6l >> 28) & 0x0F] + HEX_CHARS[(h6l >> 24) & 0x0F] +
        HEX_CHARS[(h6l >> 20) & 0x0F] + HEX_CHARS[(h6l >> 16) & 0x0F] +
        HEX_CHARS[(h6l >> 12) & 0x0F] + HEX_CHARS[(h6l >> 8) & 0x0F] +
        HEX_CHARS[(h6l >> 4) & 0x0F] + HEX_CHARS[h6l & 0x0F] +
        HEX_CHARS[(h7h >> 28) & 0x0F] + HEX_CHARS[(h7h >> 24) & 0x0F] +
        HEX_CHARS[(h7h >> 20) & 0x0F] + HEX_CHARS[(h7h >> 16) & 0x0F] +
        HEX_CHARS[(h7h >> 12) & 0x0F] + HEX_CHARS[(h7h >> 8) & 0x0F] +
        HEX_CHARS[(h7h >> 4) & 0x0F] + HEX_CHARS[h7h & 0x0F] +
        HEX_CHARS[(h7l >> 28) & 0x0F] + HEX_CHARS[(h7l >> 24) & 0x0F] +
        HEX_CHARS[(h7l >> 20) & 0x0F] + HEX_CHARS[(h7l >> 16) & 0x0F] +
        HEX_CHARS[(h7l >> 12) & 0x0F] + HEX_CHARS[(h7l >> 8) & 0x0F] +
        HEX_CHARS[(h7l >> 4) & 0x0F] + HEX_CHARS[h7l & 0x0F];
    }
    return hex;
  };

  Sha512.prototype.toString = Sha512.prototype.hex;

  Sha512.prototype.digest = function () {
    this.finalize();

    var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l,
      h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l,
      h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l,
      h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l,
      bits = this.bits;

    var arr = [
      (h0h >> 24) & 0xFF, (h0h >> 16) & 0xFF, (h0h >> 8) & 0xFF, h0h & 0xFF,
      (h0l >> 24) & 0xFF, (h0l >> 16) & 0xFF, (h0l >> 8) & 0xFF, h0l & 0xFF,
      (h1h >> 24) & 0xFF, (h1h >> 16) & 0xFF, (h1h >> 8) & 0xFF, h1h & 0xFF,
      (h1l >> 24) & 0xFF, (h1l >> 16) & 0xFF, (h1l >> 8) & 0xFF, h1l & 0xFF,
      (h2h >> 24) & 0xFF, (h2h >> 16) & 0xFF, (h2h >> 8) & 0xFF, h2h & 0xFF,
      (h2l >> 24) & 0xFF, (h2l >> 16) & 0xFF, (h2l >> 8) & 0xFF, h2l & 0xFF,
      (h3h >> 24) & 0xFF, (h3h >> 16) & 0xFF, (h3h >> 8) & 0xFF, h3h & 0xFF
    ];

    if (bits >= 256) {
      arr.push((h3l >> 24) & 0xFF, (h3l >> 16) & 0xFF, (h3l >> 8) & 0xFF, h3l & 0xFF);
    }
    if (bits >= 384) {
      arr.push(
        (h4h >> 24) & 0xFF, (h4h >> 16) & 0xFF, (h4h >> 8) & 0xFF, h4h & 0xFF,
        (h4l >> 24) & 0xFF, (h4l >> 16) & 0xFF, (h4l >> 8) & 0xFF, h4l & 0xFF,
        (h5h >> 24) & 0xFF, (h5h >> 16) & 0xFF, (h5h >> 8) & 0xFF, h5h & 0xFF,
        (h5l >> 24) & 0xFF, (h5l >> 16) & 0xFF, (h5l >> 8) & 0xFF, h5l & 0xFF
      );
    }
    if (bits == 512) {
      arr.push(
        (h6h >> 24) & 0xFF, (h6h >> 16) & 0xFF, (h6h >> 8) & 0xFF, h6h & 0xFF,
        (h6l >> 24) & 0xFF, (h6l >> 16) & 0xFF, (h6l >> 8) & 0xFF, h6l & 0xFF,
        (h7h >> 24) & 0xFF, (h7h >> 16) & 0xFF, (h7h >> 8) & 0xFF, h7h & 0xFF,
        (h7l >> 24) & 0xFF, (h7l >> 16) & 0xFF, (h7l >> 8) & 0xFF, h7l & 0xFF
      );
    }
    return arr;
  };

  Sha512.prototype.array = Sha512.prototype.digest;

  Sha512.prototype.arrayBuffer = function () {
    this.finalize();

    var bits = this.bits;
    var buffer = new ArrayBuffer(bits / 8);
    var dataView = new DataView(buffer);
    dataView.setUint32(0, this.h0h);
    dataView.setUint32(4, this.h0l);
    dataView.setUint32(8, this.h1h);
    dataView.setUint32(12, this.h1l);
    dataView.setUint32(16, this.h2h);
    dataView.setUint32(20, this.h2l);
    dataView.setUint32(24, this.h3h);

    if (bits >= 256) {
      dataView.setUint32(28, this.h3l);
    }
    if (bits >= 384) {
      dataView.setUint32(32, this.h4h);
      dataView.setUint32(36, this.h4l);
      dataView.setUint32(40, this.h5h);
      dataView.setUint32(44, this.h5l);
    }
    if (bits == 512) {
      dataView.setUint32(48, this.h6h);
      dataView.setUint32(52, this.h6l);
      dataView.setUint32(56, this.h7h);
      dataView.setUint32(60, this.h7l);
    }
    return buffer;
  };

  Sha512.prototype.clone = function () {
    var hash = new Sha512(this.bits, false);
    this.copyTo(hash);
    return hash;
  };

  Sha512.prototype.copyTo = function (hash) {
    var i = 0, attrs = [
      'h0h', 'h0l', 'h1h', 'h1l', 'h2h', 'h2l', 'h3h', 'h3l', 'h4h', 'h4l', 'h5h', 'h5l', 'h6h', 'h6l', 'h7h', 'h7l',
      'start', 'bytes', 'hBytes', 'finalized', 'hashed', 'lastByteIndex'
    ];
    for (i = 0; i < attrs.length; ++i) {
      hash[attrs[i]] = this[attrs[i]];
    }
    for (i = 0; i < this.blocks.length; ++i) {
      hash.blocks[i] = this.blocks[i];
    }
  };

  function HmacSha512(key, bits, sharedMemory) {
    var notString, type = typeof key;
    if (type !== 'string') {
      if (type === 'object') {
        if (key === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
          key = new Uint8Array(key);
        } else if (!Array.isArray(key)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var length = key.length;
    if (!notString) {
      var bytes = [], length = key.length, index = 0, code;
      for (var i = 0; i < length; ++i) {
        code = key.charCodeAt(i);
        if (code < 0x80) {
          bytes[index++] = code;
        } else if (code < 0x800) {
          bytes[index++] = (0xc0 | (code >> 6));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes[index++] = (0xe0 | (code >> 12));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));
          bytes[index++] = (0xf0 | (code >> 18));
          bytes[index++] = (0x80 | ((code >> 12) & 0x3f));
          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));
          bytes[index++] = (0x80 | (code & 0x3f));
        }
      }
      key = bytes;
    }

    if (key.length > 128) {
      key = (new Sha512(bits, true)).update(key).array();
    }

    var oKeyPad = [], iKeyPad = [];
    for (var i = 0; i < 128; ++i) {
      var b = key[i] || 0;
      oKeyPad[i] = 0x5c ^ b;
      iKeyPad[i] = 0x36 ^ b;
    }

    Sha512.call(this, bits, sharedMemory);

    this.update(iKeyPad);
    this.oKeyPad = oKeyPad;
    this.inner = true;
    this.sharedMemory = sharedMemory;
  }
  HmacSha512.prototype = new Sha512();

  HmacSha512.prototype.finalize = function () {
    Sha512.prototype.finalize.call(this);
    if (this.inner) {
      this.inner = false;
      var innerHash = this.array();
      Sha512.call(this, this.bits, this.sharedMemory);
      this.update(this.oKeyPad);
      this.update(innerHash);
      Sha512.prototype.finalize.call(this);
    }
  };

  HmacSha512.prototype.clone = function () {
    var hash = new HmacSha512([], this.bits, false);
    this.copyTo(hash);
    hash.inner = this.inner;
    for (var i = 0; i < this.oKeyPad.length; ++i) {
      hash.oKeyPad[i] = this.oKeyPad[i];
    }
    return hash;
  };

  var exports = createMethod(512);
  exports.sha512 = exports;
  exports.sha384 = createMethod(384);
  exports.sha512_256 = createMethod(256);
  exports.sha512_224 = createMethod(224);
  exports.sha512.hmac = createHmacMethod(512);
  exports.sha384.hmac = createHmacMethod(384);
  exports.sha512_256.hmac = createHmacMethod(256);
  exports.sha512_224.hmac = createHmacMethod(224);

  if (COMMON_JS) {
    module.exports = exports;
  } else {
    root.sha512 = exports.sha512;
    root.sha384 = exports.sha384;
    root.sha512_256 = exports.sha512_256;
    root.sha512_224 = exports.sha512_224;
    if (AMD) {
      define(function () {
        return exports;
      });
    }
  }
})();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":117}],349:[function(require,module,exports){
module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};

},{}],350:[function(require,module,exports){
(function (global){
"use strict";

// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof global !== 'undefined') { return global; }
	throw new Error('unable to locate global object');
}

var global = getGlobal();

module.exports = exports = global.fetch;

// Needed for TypeScript and Webpack.
exports.default = global.fetch.bind(global);

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],351:[function(require,module,exports){
arguments[4][141][0].apply(exports,arguments)
},{"buffer":47,"dup":141,"hash-base":343,"inherits":345}],352:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("./Subject");
var Subscription_1 = require("./Subscription");
var AsyncSubject = (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject_1.Subject));
exports.AsyncSubject = AsyncSubject;

},{"./Subject":361,"./Subscription":364}],353:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("./Subject");
var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));
exports.BehaviorSubject = BehaviorSubject;

},{"./Subject":361,"./util/ObjectUnsubscribedError":522}],354:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("./Subscriber");
var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;

},{"./Subscriber":363}],355:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var empty_1 = require("./observable/empty");
var of_1 = require("./observable/of");
var throwError_1 = require("./observable/throwError");
var NotificationKind;
(function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return of_1.of(this.value);
            case 'E':
                return throwError_1.throwError(this.error);
            case 'C':
                return empty_1.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;

},{"./observable/empty":373,"./observable/of":384,"./observable/throwError":390}],356:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var canReportError_1 = require("./util/canReportError");
var toSubscriber_1 = require("./util/toSubscriber");
var observable_1 = require("./symbol/observable");
var pipe_1 = require("./util/pipe");
var config_1 = require("./config");
var Observable = (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config_1.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError_1.canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config_1.config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}

},{"./config":365,"./symbol/observable":517,"./util/canReportError":525,"./util/pipe":541,"./util/toSubscriber":548}],357:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = require("./config");
var hostReportError_1 = require("./util/hostReportError");
exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError_1.hostReportError(err);
        }
    },
    complete: function () { }
};

},{"./config":365,"./util/hostReportError":526}],358:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("./Subscriber");
var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;

},{"./Subscriber":363}],359:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("./Subject");
var queue_1 = require("./scheduler/queue");
var Subscription_1 = require("./Subscription");
var observeOn_1 = require("./operators/observeOn");
var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
var SubjectSubscription_1 = require("./SubjectSubscription");
var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

},{"./Subject":361,"./SubjectSubscription":362,"./Subscription":364,"./operators/observeOn":444,"./scheduler/queue":515,"./util/ObjectUnsubscribedError":522}],360:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;

},{}],361:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("./Observable");
var Subscriber_1 = require("./Subscriber");
var Subscription_1 = require("./Subscription");
var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
var SubjectSubscription_1 = require("./SubjectSubscription");
var rxSubscriber_1 = require("../internal/symbol/rxSubscriber");
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;

},{"../internal/symbol/rxSubscriber":518,"./Observable":356,"./SubjectSubscription":362,"./Subscriber":363,"./Subscription":364,"./util/ObjectUnsubscribedError":522}],362:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("./Subscription");
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;

},{"./Subscription":364}],363:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isFunction_1 = require("./util/isFunction");
var Observer_1 = require("./Observer");
var Subscription_1 = require("./Subscription");
var rxSubscriber_1 = require("../internal/symbol/rxSubscriber");
var config_1 = require("./config");
var hostReportError_1 = require("./util/hostReportError");
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config_1.config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError_1.hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError_1.hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError_1.hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError_1.hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
exports.SafeSubscriber = SafeSubscriber;

},{"../internal/symbol/rxSubscriber":518,"./Observer":357,"./Subscription":364,"./config":365,"./util/hostReportError":526,"./util/isFunction":531}],364:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("./util/isArray");
var isObject_1 = require("./util/isObject");
var isFunction_1 = require("./util/isFunction");
var UnsubscriptionError_1 = require("./util/UnsubscriptionError");
var Subscription = (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}

},{"./util/UnsubscriptionError":524,"./util/isArray":528,"./util/isFunction":531,"./util/isObject":535}],365:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _enable_super_gross_mode_that_will_cause_bad_things = false;
exports.config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = new Error();
            console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

},{}],366:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var Observable_1 = require("../Observable");
var Subscriber_1 = require("../Subscriber");
var Subscription_1 = require("../Subscription");
var refCount_1 = require("../operators/refCount");
var ConnectableObservable = (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
    };
    return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = (function () {
    var connectableProto = ConnectableObservable.prototype;
    return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
    };
})();
var ConnectableSubscriber = (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Observable":356,"../Subject":361,"../Subscriber":363,"../Subscription":364,"../operators/refCount":455}],367:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var asap_1 = require("../scheduler/asap");
var isNumeric_1 = require("../util/isNumeric");
var SubscribeOnObservable = (function (_super) {
    __extends(SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) { delayTime = 0; }
        if (scheduler === void 0) { scheduler = asap_1.asap; }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = asap_1.asap;
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) { delay = 0; }
        if (scheduler === void 0) { scheduler = asap_1.asap; }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable_1.Observable));
exports.SubscribeOnObservable = SubscribeOnObservable;

},{"../Observable":356,"../scheduler/asap":513,"../util/isNumeric":534}],368:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var AsyncSubject_1 = require("../AsyncSubject");
var map_1 = require("../operators/map");
var canReportError_1 = require("../util/canReportError");
var isArray_1 = require("../util/isArray");
var isScheduler_1 = require("../util/isScheduler");
function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = this;
        var subject;
        var params = {
            context: context,
            subject: subject,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
        };
        return new Observable_1.Observable(function (subscriber) {
            if (!scheduler) {
                if (!subject) {
                    subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError_1.canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                var state = {
                    args: args, subscriber: subscriber, params: params,
                };
                return scheduler.schedule(dispatch, 0, state);
            }
        });
    };
}
exports.bindCallback = bindCallback;
function dispatch(state) {
    var _this = this;
    var self = this;
    var args = state.args, subscriber = state.subscriber, params = state.params;
    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            subject.error(err);
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
    var value = state.value, subject = state.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(state) {
    var err = state.err, subject = state.subject;
    subject.error(err);
}

},{"../AsyncSubject":352,"../Observable":356,"../operators/map":433,"../util/canReportError":525,"../util/isArray":528,"../util/isScheduler":538}],369:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var AsyncSubject_1 = require("../AsyncSubject");
var map_1 = require("../operators/map");
var canReportError_1 = require("../util/canReportError");
var isScheduler_1 = require("../util/isScheduler");
var isArray_1 = require("../util/isArray");
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var params = {
            subject: undefined,
            args: args,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
            context: this,
        };
        return new Observable_1.Observable(function (subscriber) {
            var context = params.context;
            var subject = params.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = params.subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                            return;
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError_1.canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });
            }
        });
    };
}
exports.bindNodeCallback = bindNodeCallback;
function dispatch(state) {
    var _this = this;
    var params = state.params, subscriber = state.subscriber, context = state.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var err = innerArgs.shift();
            if (err) {
                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
            }
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
            }
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}

},{"../AsyncSubject":352,"../Observable":356,"../operators/map":433,"../util/canReportError":525,"../util/isArray":528,"../util/isScheduler":538}],370:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isScheduler_1 = require("../util/isScheduler");
var isArray_1 = require("../util/isArray");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
var fromArray_1 = require("./fromArray");
var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return fromArray_1.fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;

},{"../OuterSubscriber":358,"../util/isArray":528,"../util/isScheduler":538,"../util/subscribeToResult":547,"./fromArray":376}],371:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var of_1 = require("./of");
var concatAll_1 = require("../operators/concatAll");
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
}
exports.concat = concat;

},{"../operators/concatAll":405,"./of":384}],372:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var from_1 = require("./from");
var empty_1 = require("./empty");
function defer(observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? from_1.from(input) : empty_1.empty();
        return source.subscribe(subscriber);
    });
}
exports.defer = defer;

},{"../Observable":356,"./empty":373,"./from":375}],373:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
}
exports.empty = empty;
function emptyScheduled(scheduler) {
    return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}

},{"../Observable":356}],374:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isArray_1 = require("../util/isArray");
var map_1 = require("../operators/map");
var isObject_1 = require("../util/isObject");
var from_1 = require("./from");
function forkJoin() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 1) {
        var first_1 = sources[0];
        if (isArray_1.isArray(first_1)) {
            return forkJoinInternal(first_1, null);
        }
        if (isObject_1.isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
            var keys = Object.keys(first_1);
            return forkJoinInternal(keys.map(function (key) { return first_1[key]; }), keys);
        }
    }
    if (typeof sources[sources.length - 1] === 'function') {
        var resultSelector_1 = sources.pop();
        sources = (sources.length === 1 && isArray_1.isArray(sources[0])) ? sources[0] : sources;
        return forkJoinInternal(sources, null).pipe(map_1.map(function (args) { return resultSelector_1.apply(void 0, args); }));
    }
    return forkJoinInternal(sources, null);
}
exports.forkJoin = forkJoin;
function forkJoinInternal(sources, keys) {
    return new Observable_1.Observable(function (subscriber) {
        var len = sources.length;
        if (len === 0) {
            subscriber.complete();
            return;
        }
        var values = new Array(len);
        var completed = 0;
        var emitted = 0;
        var _loop_1 = function (i) {
            var source = from_1.from(sources[i]);
            var hasValue = false;
            subscriber.add(source.subscribe({
                next: function (value) {
                    if (!hasValue) {
                        hasValue = true;
                        emitted++;
                    }
                    values[i] = value;
                },
                error: function (err) { return subscriber.error(err); },
                complete: function () {
                    completed++;
                    if (completed === len || !hasValue) {
                        if (emitted === len) {
                            subscriber.next(keys ?
                                keys.reduce(function (result, key, i) { return (result[key] = values[i], result); }, {}) :
                                values);
                        }
                        subscriber.complete();
                    }
                }
            }));
        };
        for (var i = 0; i < len; i++) {
            _loop_1(i);
        }
    });
}

},{"../Observable":356,"../operators/map":433,"../util/isArray":528,"../util/isObject":535,"./from":375}],375:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var subscribeTo_1 = require("../util/subscribeTo");
var scheduled_1 = require("../scheduled/scheduled");
function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable_1.Observable) {
            return input;
        }
        return new Observable_1.Observable(subscribeTo_1.subscribeTo(input));
    }
    else {
        return scheduled_1.scheduled(input, scheduler);
    }
}
exports.from = from;

},{"../Observable":356,"../scheduled/scheduled":501,"../util/subscribeTo":542}],376:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var subscribeToArray_1 = require("../util/subscribeToArray");
var scheduleArray_1 = require("../scheduled/scheduleArray");
function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToArray_1.subscribeToArray(input));
    }
    else {
        return scheduleArray_1.scheduleArray(input, scheduler);
    }
}
exports.fromArray = fromArray;

},{"../Observable":356,"../scheduled/scheduleArray":497,"../util/subscribeToArray":543}],377:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isArray_1 = require("../util/isArray");
var isFunction_1 = require("../util/isFunction");
var map_1 = require("../operators/map");
var toString = (function () { return Object.prototype.toString; })();
function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
exports.fromEvent = fromEvent;
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}

},{"../Observable":356,"../operators/map":433,"../util/isArray":528,"../util/isFunction":531}],378:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isArray_1 = require("../util/isArray");
var isFunction_1 = require("../util/isFunction");
var map_1 = require("../operators/map");
function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        var handler = function () {
            var e = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
            }
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue;
        try {
            retValue = addHandler(handler);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!isFunction_1.isFunction(removeHandler)) {
            return undefined;
        }
        return function () { return removeHandler(handler, retValue); };
    });
}
exports.fromEventPattern = fromEventPattern;

},{"../Observable":356,"../operators/map":433,"../util/isArray":528,"../util/isFunction":531}],379:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var identity_1 = require("../util/identity");
var isScheduler_1 = require("../util/isScheduler");
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState;
    if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || identity_1.identity;
        scheduler = options.scheduler;
    }
    else if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrObservable;
    }
    else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
    }
    return new Observable_1.Observable(function (subscriber) {
        var state = initialState;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state
            });
        }
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
        } while (true);
        return undefined;
    });
}
exports.generate = generate;
function dispatch(state) {
    var subscriber = state.subscriber, condition = state.condition;
    if (subscriber.closed) {
        return undefined;
    }
    if (state.needIterate) {
        try {
            state.state = state.iterate(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
    }
    else {
        state.needIterate = true;
    }
    if (condition) {
        var conditionResult = void 0;
        try {
            conditionResult = condition(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!conditionResult) {
            subscriber.complete();
            return undefined;
        }
        if (subscriber.closed) {
            return undefined;
        }
    }
    var value;
    try {
        value = state.resultSelector(state.state);
    }
    catch (err) {
        subscriber.error(err);
        return undefined;
    }
    if (subscriber.closed) {
        return undefined;
    }
    subscriber.next(value);
    if (subscriber.closed) {
        return undefined;
    }
    return this.schedule(state);
}

},{"../Observable":356,"../util/identity":527,"../util/isScheduler":538}],380:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var defer_1 = require("./defer");
var empty_1 = require("./empty");
function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) { trueResult = empty_1.EMPTY; }
    if (falseResult === void 0) { falseResult = empty_1.EMPTY; }
    return defer_1.defer(function () { return condition() ? trueResult : falseResult; });
}
exports.iif = iif;

},{"./defer":372,"./empty":373}],381:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var async_1 = require("../scheduler/async");
var isNumeric_1 = require("../util/isNumeric");
function interval(period, scheduler) {
    if (period === void 0) { period = 0; }
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (!isNumeric_1.isNumeric(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = async_1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
exports.interval = interval;
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}

},{"../Observable":356,"../scheduler/async":514,"../util/isNumeric":534}],382:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isScheduler_1 = require("../util/isScheduler");
var mergeAll_1 = require("../operators/mergeAll");
var fromArray_1 = require("./fromArray");
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return mergeAll_1.mergeAll(concurrent)(fromArray_1.fromArray(observables, scheduler));
}
exports.merge = merge;

},{"../Observable":356,"../operators/mergeAll":438,"../util/isScheduler":538,"./fromArray":376}],383:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var noop_1 = require("../util/noop");
exports.NEVER = new Observable_1.Observable(noop_1.noop);
function never() {
    return exports.NEVER;
}
exports.never = never;

},{"../Observable":356,"../util/noop":539}],384:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isScheduler_1 = require("../util/isScheduler");
var fromArray_1 = require("./fromArray");
var scheduleArray_1 = require("../scheduled/scheduleArray");
function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        args.pop();
        return scheduleArray_1.scheduleArray(args, scheduler);
    }
    else {
        return fromArray_1.fromArray(args);
    }
}
exports.of = of;

},{"../scheduled/scheduleArray":497,"../util/isScheduler":538,"./fromArray":376}],385:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var from_1 = require("./from");
var isArray_1 = require("../util/isArray");
var empty_1 = require("./empty");
function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 0) {
        return empty_1.EMPTY;
    }
    var first = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && isArray_1.isArray(first)) {
        return onErrorResumeNext.apply(void 0, first);
    }
    return new Observable_1.Observable(function (subscriber) {
        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
        return from_1.from(first).subscribe({
            next: function (value) { subscriber.next(value); },
            error: subNext,
            complete: subNext,
        });
    });
}
exports.onErrorResumeNext = onErrorResumeNext;

},{"../Observable":356,"../util/isArray":528,"./empty":373,"./from":375}],386:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
function pairs(obj, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];
                if (obj.hasOwnProperty(key)) {
                    subscriber.next([key, obj[key]]);
                }
            }
            subscriber.complete();
        });
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            var subscription = new Subscription_1.Subscription();
            subscription.add(scheduler.schedule(dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
            return subscription;
        });
    }
}
exports.pairs = pairs;
function dispatch(state) {
    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
    if (!subscriber.closed) {
        if (index < keys.length) {
            var key = keys[index];
            subscriber.next([key, obj[key]]);
            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
        }
        else {
            subscriber.complete();
        }
    }
}
exports.dispatch = dispatch;

},{"../Observable":356,"../Subscription":364}],387:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var not_1 = require("../util/not");
var subscribeTo_1 = require("../util/subscribeTo");
var filter_1 = require("../operators/filter");
var Observable_1 = require("../Observable");
function partition(source, predicate, thisArg) {
    return [
        filter_1.filter(predicate, thisArg)(new Observable_1.Observable(subscribeTo_1.subscribeTo(source))),
        filter_1.filter(not_1.not(predicate, thisArg))(new Observable_1.Observable(subscribeTo_1.subscribeTo(source)))
    ];
}
exports.partition = partition;

},{"../Observable":356,"../operators/filter":424,"../util/not":540,"../util/subscribeTo":542}],388:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("../util/isArray");
var fromArray_1 = require("./fromArray");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
        if (isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return fromArray_1.fromArray(observables, undefined).lift(new RaceOperator());
}
exports.race = race;
var RaceOperator = (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
exports.RaceOperator = RaceOperator;
var RaceSubscriber = (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.RaceSubscriber = RaceSubscriber;

},{"../OuterSubscriber":358,"../util/isArray":528,"../util/subscribeToResult":547,"./fromArray":376}],389:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
function range(start, count, scheduler) {
    if (start === void 0) { start = 0; }
    return new Observable_1.Observable(function (subscriber) {
        if (count === undefined) {
            count = start;
            start = 0;
        }
        var index = 0;
        var current = start;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        }
        else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(current++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
        return undefined;
    });
}
exports.range = range;
function dispatch(state) {
    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
    if (index >= count) {
        subscriber.complete();
        return;
    }
    subscriber.next(start);
    if (subscriber.closed) {
        return;
    }
    state.index = index + 1;
    state.start = start + 1;
    this.schedule(state);
}
exports.dispatch = dispatch;

},{"../Observable":356}],390:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
exports.throwError = throwError;
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}

},{"../Observable":356}],391:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var async_1 = require("../scheduler/async");
var isNumeric_1 = require("../util/isNumeric");
var isScheduler_1 = require("../util/isScheduler");
function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) { dueTime = 0; }
    var period = -1;
    if (isNumeric_1.isNumeric(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (isScheduler_1.isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!isScheduler_1.isScheduler(scheduler)) {
        scheduler = async_1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        var due = isNumeric_1.isNumeric(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
exports.timer = timer;
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}

},{"../Observable":356,"../scheduler/async":514,"../util/isNumeric":534,"../util/isScheduler":538}],392:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var from_1 = require("./from");
var empty_1 = require("./empty");
function using(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var resource;
        try {
            resource = resourceFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var result;
        try {
            result = observableFactory(resource);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = result ? from_1.from(result) : empty_1.EMPTY;
        var subscription = source.subscribe(subscriber);
        return function () {
            subscription.unsubscribe();
            if (resource) {
                resource.unsubscribe();
            }
        };
    });
}
exports.using = using;

},{"../Observable":356,"./empty":373,"./from":375}],393:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var fromArray_1 = require("./fromArray");
var isArray_1 = require("../util/isArray");
var Subscriber_1 = require("../Subscriber");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
var iterator_1 = require("../../internal/symbol/iterator");
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === 'function') {
        observables.pop();
    }
    return fromArray_1.fromArray(observables, undefined).lift(new ZipOperator(resultSelector));
}
exports.zip = zip;
var ZipOperator = (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());
exports.ZipOperator = ZipOperator;
var ZipSubscriber = (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) { values = Object.create(null); }
        var _this = _super.call(this, destination) || this;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
        _this.values = values;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator_1.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator.subscribe(iterator, i));
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber));
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber));

},{"../../internal/symbol/iterator":516,"../OuterSubscriber":358,"../Subscriber":363,"../util/isArray":528,"../util/subscribeToResult":547,"./fromArray":376}],394:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function audit(durationSelector) {
    return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
    };
}
exports.audit = audit;
var AuditOperator = (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
var AuditSubscriber = (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = void 0;
            try {
                var durationSelector = this.durationSelector;
                duration = durationSelector(value);
            }
            catch (err) {
                return this.destination.error(err);
            }
            var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);
            if (!innerSubscription || innerSubscription.closed) {
                this.clearThrottle();
            }
            else {
                this.add(this.throttled = innerSubscription);
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../util/subscribeToResult":547}],395:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var audit_1 = require("./audit");
var timer_1 = require("../observable/timer");
function auditTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });
}
exports.auditTime = auditTime;

},{"../observable/timer":391,"../scheduler/async":514,"./audit":394}],396:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function buffer(closingNotifier) {
    return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
    };
}
exports.buffer = buffer;
var BufferOperator = (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
var BufferSubscriber = (function (_super) {
    __extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(subscribeToResult_1.subscribeToResult(_this, closingNotifier));
        return _this;
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../util/subscribeToResult":547}],397:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) { startBufferEvery = null; }
    return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
    };
}
exports.bufferCount = bufferCount;
var BufferCountOperator = (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
var BufferCountSubscriber = (function (_super) {
    __extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber_1.Subscriber));
var BufferSkipCountSubscriber = (function (_super) {
    __extends(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],398:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var Subscriber_1 = require("../Subscriber");
var isScheduler_1 = require("../util/isScheduler");
function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = async_1.async;
    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    };
}
exports.bufferTime = bufferTime;
var BufferTimeOperator = (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
var BufferTimeSubscriber = (function (_super) {
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}

},{"../Subscriber":363,"../scheduler/async":514,"../util/isScheduler":538}],399:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("../Subscription");
var subscribeToResult_1 = require("../util/subscribeToResult");
var OuterSubscriber_1 = require("../OuterSubscriber");
function bufferToggle(openings, closingSelector) {
    return function bufferToggleOperatorFunction(source) {
        return source.lift(new BufferToggleOperator(openings, closingSelector));
    };
}
exports.bufferToggle = bufferToggle;
var BufferToggleOperator = (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
var BufferToggleSubscriber = (function (_super) {
    __extends(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult_1.subscribeToResult(_this, openings));
        return _this;
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_1 = contexts.shift();
            context_1.subscription.unsubscribe();
            context_1.buffer = null;
            context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            this.destination.next(context_2.buffer);
            context_2.subscription.unsubscribe();
            context_2.buffer = null;
            context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription_1.Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../Subscription":364,"../util/subscribeToResult":547}],400:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("../Subscription");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function bufferWhen(closingSelector) {
    return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
    };
}
exports.bufferWhen = bufferWhen;
var BufferWhenOperator = (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
var BufferWhenSubscriber = (function (_super) {
    __extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (err) {
            return this.error(err);
        }
        closingSubscription = new Subscription_1.Subscription();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
        this.subscribing = false;
    };
    return BufferWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../Subscription":364,"../util/subscribeToResult":547}],401:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var InnerSubscriber_1 = require("../InnerSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
exports.catchError = catchError;
var CatchOperator = (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(this, undefined, undefined);
            this.add(innerSubscriber);
            var innerSubscription = subscribeToResult_1.subscribeToResult(this, result, undefined, undefined, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                this.add(innerSubscription);
            }
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../InnerSubscriber":354,"../OuterSubscriber":358,"../util/subscribeToResult":547}],402:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var combineLatest_1 = require("../observable/combineLatest");
function combineAll(project) {
    return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };
}
exports.combineAll = combineAll;

},{"../observable/combineLatest":370}],403:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("../util/isArray");
var combineLatest_1 = require("../observable/combineLatest");
var from_1 = require("../observable/from");
var none = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call(from_1.from([source].concat(observables)), new combineLatest_1.CombineLatestOperator(project)); };
}
exports.combineLatest = combineLatest;

},{"../observable/combineLatest":370,"../observable/from":375,"../util/isArray":528}],404:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_1 = require("../observable/concat");
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };
}
exports.concat = concat;

},{"../observable/concat":371}],405:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeAll_1 = require("./mergeAll");
function concatAll() {
    return mergeAll_1.mergeAll(1);
}
exports.concatAll = concatAll;

},{"./mergeAll":438}],406:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = require("./mergeMap");
function concatMap(project, resultSelector) {
    return mergeMap_1.mergeMap(project, resultSelector, 1);
}
exports.concatMap = concatMap;

},{"./mergeMap":439}],407:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concatMap_1 = require("./concatMap");
function concatMapTo(innerObservable, resultSelector) {
    return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);
}
exports.concatMapTo = concatMapTo;

},{"./concatMap":406}],408:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function count(predicate) {
    return function (source) { return source.lift(new CountOperator(predicate, source)); };
}
exports.count = count;
var CountOperator = (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
var CountSubscriber = (function (_super) {
    __extends(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],409:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function debounce(durationSelector) {
    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };
}
exports.debounce = debounce;
var DebounceOperator = (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
var DebounceSubscriber = (function (_super) {
    __extends(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        _this.durationSubscription = null;
        return _this;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = subscribeToResult_1.subscribeToResult(this, duration);
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../util/subscribeToResult":547}],410:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var async_1 = require("../scheduler/async");
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
var DebounceTimeSubscriber = (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}

},{"../Subscriber":363,"../scheduler/async":514}],411:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) { defaultValue = null; }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
exports.defaultIfEmpty = defaultIfEmpty;
var DefaultIfEmptyOperator = (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],412:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var isDate_1 = require("../util/isDate");
var Subscriber_1 = require("../Subscriber");
var Notification_1 = require("../Notification");
function delay(delay, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
exports.delay = delay;
var DelayOperator = (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var DelaySubscriber = (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber));
var DelayMessage = (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());

},{"../Notification":355,"../Subscriber":363,"../scheduler/async":514,"../util/isDate":530}],413:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Observable_1 = require("../Observable");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return function (source) {
            return new SubscriptionDelayObservable(source, subscriptionDelay)
                .lift(new DelayWhenOperator(delayDurationSelector));
        };
    }
    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
}
exports.delayWhen = delayWhen;
var DelayWhenOperator = (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
var DelayWhenSubscriber = (function (_super) {
    __extends(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        var index = this.index++;
        try {
            var delayNotifier = this.delayDurationSelector(value, index);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            var destination = this.destination;
            destination.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
var SubscriptionDelayObservable = (function (_super) {
    __extends(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable_1.Observable));
var SubscriptionDelaySubscriber = (function (_super) {
    __extends(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.unsubscribe();
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber_1.Subscriber));

},{"../Observable":356,"../OuterSubscriber":358,"../Subscriber":363,"../util/subscribeToResult":547}],414:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function dematerialize() {
    return function dematerializeOperatorFunction(source) {
        return source.lift(new DeMaterializeOperator());
    };
}
exports.dematerialize = dematerialize;
var DeMaterializeOperator = (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
var DeMaterializeSubscriber = (function (_super) {
    __extends(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],415:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function distinct(keySelector, flushes) {
    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
}
exports.distinct = distinct;
var DistinctOperator = (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
var DistinctSubscriber = (function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
            _this.add(subscribeToResult_1.subscribeToResult(_this, flushes));
        }
        return _this;
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.DistinctSubscriber = DistinctSubscriber;

},{"../OuterSubscriber":358,"../util/subscribeToResult":547}],416:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var key;
        try {
            var keySelector = this.keySelector;
            key = keySelector ? keySelector(value) : value;
        }
        catch (err) {
            return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
            try {
                var compare = this.compare;
                result = compare(this.key, key);
            }
            catch (err) {
                return this.destination.error(err);
            }
        }
        else {
            this.hasKey = true;
        }
        if (!result) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],417:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var distinctUntilChanged_1 = require("./distinctUntilChanged");
function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
}
exports.distinctUntilKeyChanged = distinctUntilKeyChanged;

},{"./distinctUntilChanged":416}],418:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
var filter_1 = require("./filter");
var throwIfEmpty_1 = require("./throwIfEmpty");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var take_1 = require("./take");
function elementAt(index, defaultValue) {
    if (index < 0) {
        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
    }
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(filter_1.filter(function (v, i) { return i === index; }), take_1.take(1), hasDefaultValue
        ? defaultIfEmpty_1.defaultIfEmpty(defaultValue)
        : throwIfEmpty_1.throwIfEmpty(function () { return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError(); })); };
}
exports.elementAt = elementAt;

},{"../util/ArgumentOutOfRangeError":519,"./defaultIfEmpty":411,"./filter":424,"./take":476,"./throwIfEmpty":483}],419:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_1 = require("../observable/concat");
var of_1 = require("../observable/of");
function endWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    return function (source) { return concat_1.concat(source, of_1.of.apply(void 0, array)); };
}
exports.endWith = endWith;

},{"../observable/concat":371,"../observable/of":384}],420:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function every(predicate, thisArg) {
    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };
}
exports.every = every;
var EveryOperator = (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
var EverySubscriber = (function (_super) {
    __extends(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],421:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function exhaust() {
    return function (source) { return source.lift(new SwitchFirstOperator()); };
}
exports.exhaust = exhaust;
var SwitchFirstOperator = (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
var SwitchFirstSubscriber = (function (_super) {
    __extends(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../util/subscribeToResult":547}],422:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var InnerSubscriber_1 = require("../InnerSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
var map_1 = require("./map");
var from_1 = require("../observable/from");
function exhaustMap(project, resultSelector) {
    if (resultSelector) {
        return function (source) { return source.pipe(exhaustMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) {
        return source.lift(new ExhaustMapOperator(project));
    };
}
exports.exhaustMap = exhaustMap;
var ExhaustMapOperator = (function () {
    function ExhaustMapOperator(project) {
        this.project = project;
    }
    ExhaustMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhaustMapOperator;
}());
var ExhaustMapSubscriber = (function (_super) {
    __extends(ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.hasSubscription = true;
        this._innerSub(result, value, index);
    };
    ExhaustMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(this, value, index);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = subscribeToResult_1.subscribeToResult(this, result, undefined, undefined, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../InnerSubscriber":354,"../OuterSubscriber":358,"../observable/from":375,"../util/subscribeToResult":547,"./map":433}],423:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (scheduler === void 0) { scheduler = undefined; }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
}
exports.expand = expand;
var ExpandOperator = (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());
exports.ExpandOperator = ExpandOperator;
var ExpandSubscriber = (function (_super) {
    __extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            _this.buffer = [];
        }
        return _this;
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            try {
                var project = this.project;
                var result = project(value, index);
                if (!this.scheduler) {
                    this.subscribeToProjection(result, value, index);
                }
                else {
                    var state = { subscriber: this, result: result, value: value, index: index };
                    var destination_1 = this.destination;
                    destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
                }
            }
            catch (e) {
                destination.error(e);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        var destination = this.destination;
        destination.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.ExpandSubscriber = ExpandSubscriber;

},{"../OuterSubscriber":358,"../util/subscribeToResult":547}],424:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
exports.filter = filter;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],425:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Subscription_1 = require("../Subscription");
function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
exports.finalize = finalize;
var FinallyOperator = (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var FinallySubscriber = (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription_1.Subscription(callback));
        return _this;
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363,"../Subscription":364}],426:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };
}
exports.find = find;
var FindValueOperator = (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());
exports.FindValueOperator = FindValueOperator;
var FindValueSubscriber = (function (_super) {
    __extends(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber_1.Subscriber));
exports.FindValueSubscriber = FindValueSubscriber;

},{"../Subscriber":363}],427:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var find_1 = require("../operators/find");
function findIndex(predicate, thisArg) {
    return function (source) { return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg)); };
}
exports.findIndex = findIndex;

},{"../operators/find":426}],428:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = require("../util/EmptyError");
var filter_1 = require("./filter");
var take_1 = require("./take");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var throwIfEmpty_1 = require("./throwIfEmpty");
var identity_1 = require("../util/identity");
function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); })); };
}
exports.first = first;

},{"../util/EmptyError":520,"../util/identity":527,"./defaultIfEmpty":411,"./filter":424,"./take":476,"./throwIfEmpty":483}],429:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Subscription_1 = require("../Subscription");
var Observable_1 = require("../Observable");
var Subject_1 = require("../Subject");
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
exports.groupBy = groupBy;
var GroupByOperator = (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
var GroupBySubscriber = (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1.Subscriber));
var GroupDurationSubscriber = (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber_1.Subscriber));
var GroupedObservable = (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1.Observable));
exports.GroupedObservable = GroupedObservable;
var InnerRefCountSubscription = (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1.Subscription));

},{"../Observable":356,"../Subject":361,"../Subscriber":363,"../Subscription":364}],430:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
exports.ignoreElements = ignoreElements;
var IgnoreElementsOperator = (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
var IgnoreElementsSubscriber = (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],431:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function isEmpty() {
    return function (source) { return source.lift(new IsEmptyOperator()); };
}
exports.isEmpty = isEmpty;
var IsEmptyOperator = (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
var IsEmptySubscriber = (function (_super) {
    __extends(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],432:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = require("../util/EmptyError");
var filter_1 = require("./filter");
var takeLast_1 = require("./takeLast");
var throwIfEmpty_1 = require("./throwIfEmpty");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var identity_1 = require("../util/identity");
function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); })); };
}
exports.last = last;

},{"../util/EmptyError":520,"../util/identity":527,"./defaultIfEmpty":411,"./filter":424,"./takeLast":477,"./throwIfEmpty":483}],433:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],434:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
exports.mapTo = mapTo;
var MapToOperator = (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],435:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Notification_1 = require("../Notification");
function materialize() {
    return function materializeOperatorFunction(source) {
        return source.lift(new MaterializeOperator());
    };
}
exports.materialize = materialize;
var MaterializeOperator = (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
var MaterializeSubscriber = (function (_super) {
    __extends(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification_1.Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber_1.Subscriber));

},{"../Notification":355,"../Subscriber":363}],436:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reduce_1 = require("./reduce");
function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
        : function (x, y) { return x > y ? x : y; };
    return reduce_1.reduce(max);
}
exports.max = max;

},{"./reduce":454}],437:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var merge_1 = require("../observable/merge");
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };
}
exports.merge = merge;

},{"../observable/merge":382}],438:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = require("./mergeMap");
var identity_1 = require("../util/identity");
function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
}
exports.mergeAll = mergeAll;

},{"../util/identity":527,"./mergeMap":439}],439:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var subscribeToResult_1 = require("../util/subscribeToResult");
var OuterSubscriber_1 = require("../OuterSubscriber");
var InnerSubscriber_1 = require("../InnerSubscriber");
var map_1 = require("./map");
var from_1 = require("../observable/from");
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
exports.mergeMap = mergeMap;
var MergeMapOperator = (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
exports.MergeMapOperator = MergeMapOperator;
var MergeMapSubscriber = (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(this, value, index);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = subscribeToResult_1.subscribeToResult(this, ish, undefined, undefined, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapSubscriber = MergeMapSubscriber;

},{"../InnerSubscriber":354,"../OuterSubscriber":358,"../observable/from":375,"../util/subscribeToResult":547,"./map":433}],440:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = require("./mergeMap");
function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'function') {
        return mergeMap_1.mergeMap(function () { return innerObservable; }, resultSelector, concurrent);
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return mergeMap_1.mergeMap(function () { return innerObservable; }, concurrent);
}
exports.mergeMapTo = mergeMapTo;

},{"./mergeMap":439}],441:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var subscribeToResult_1 = require("../util/subscribeToResult");
var OuterSubscriber_1 = require("../OuterSubscriber");
var InnerSubscriber_1 = require("../InnerSubscriber");
function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };
}
exports.mergeScan = mergeScan;
var MergeScanOperator = (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());
exports.MergeScanOperator = MergeScanOperator;
var MergeScanSubscriber = (function (_super) {
    __extends(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var destination = this.destination;
            var ish = void 0;
            try {
                var accumulator = this.accumulator;
                ish = accumulator(this.acc, value, index);
            }
            catch (e) {
                return destination.error(e);
            }
            this.active++;
            this._innerSub(ish, value, index);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(this, value, index);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = subscribeToResult_1.subscribeToResult(this, ish, undefined, undefined, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        var destination = this.destination;
        destination.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeScanSubscriber = MergeScanSubscriber;

},{"../InnerSubscriber":354,"../OuterSubscriber":358,"../util/subscribeToResult":547}],442:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reduce_1 = require("./reduce");
function min(comparer) {
    var min = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
        : function (x, y) { return x < y ? x : y; };
    return reduce_1.reduce(min);
}
exports.min = min;

},{"./reduce":454}],443:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ConnectableObservable_1 = require("../observable/ConnectableObservable");
function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
exports.multicast = multicast;
var MulticastOperator = (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());
exports.MulticastOperator = MulticastOperator;

},{"../observable/ConnectableObservable":366}],444:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Notification_1 = require("../Notification");
function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;

},{"../Notification":355,"../Subscriber":363}],445:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var from_1 = require("../observable/from");
var isArray_1 = require("../util/isArray");
var OuterSubscriber_1 = require("../OuterSubscriber");
var InnerSubscriber_1 = require("../InnerSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };
}
exports.onErrorResumeNext = onErrorResumeNext;
function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    var source = null;
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return from_1.from(source, null).lift(new OnErrorResumeNextOperator(nextSources));
}
exports.onErrorResumeNextStatic = onErrorResumeNextStatic;
var OnErrorResumeNextOperator = (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = (function (_super) {
    __extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (!!next) {
            var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(this, undefined, undefined);
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = subscribeToResult_1.subscribeToResult(this, next, undefined, undefined, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
            }
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../InnerSubscriber":354,"../OuterSubscriber":358,"../observable/from":375,"../util/isArray":528,"../util/subscribeToResult":547}],446:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
exports.pairwise = pairwise;
var PairwiseOperator = (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var PairwiseSubscriber = (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        var pair;
        if (this.hasPrev) {
            pair = [this.prev, value];
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
            this.destination.next(pair);
        }
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],447:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var not_1 = require("../util/not");
var filter_1 = require("./filter");
function partition(predicate, thisArg) {
    return function (source) { return [
        filter_1.filter(predicate, thisArg)(source),
        filter_1.filter(not_1.not(predicate, thisArg))(source)
    ]; };
}
exports.partition = partition;

},{"../util/not":540,"./filter":424}],448:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = require("./map");
function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return function (source) { return map_1.map(plucker(properties, length))(source); };
}
exports.pluck = pluck;
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp[props[i]];
            if (typeof p !== 'undefined') {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}

},{"./map":433}],449:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var multicast_1 = require("./multicast");
function publish(selector) {
    return selector ?
        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :
        multicast_1.multicast(new Subject_1.Subject());
}
exports.publish = publish;

},{"../Subject":361,"./multicast":443}],450:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BehaviorSubject_1 = require("../BehaviorSubject");
var multicast_1 = require("./multicast");
function publishBehavior(value) {
    return function (source) { return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source); };
}
exports.publishBehavior = publishBehavior;

},{"../BehaviorSubject":353,"./multicast":443}],451:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncSubject_1 = require("../AsyncSubject");
var multicast_1 = require("./multicast");
function publishLast() {
    return function (source) { return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source); };
}
exports.publishLast = publishLast;

},{"../AsyncSubject":352,"./multicast":443}],452:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReplaySubject_1 = require("../ReplaySubject");
var multicast_1 = require("./multicast");
function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
    }
    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
    var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
    return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };
}
exports.publishReplay = publishReplay;

},{"../ReplaySubject":359,"./multicast":443}],453:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("../util/isArray");
var race_1 = require("../observable/race");
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function raceOperatorFunction(source) {
        if (observables.length === 1 && isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));
    };
}
exports.race = race;

},{"../observable/race":388,"../util/isArray":528}],454:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var scan_1 = require("./scan");
var takeLast_1 = require("./takeLast");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var pipe_1 = require("../util/pipe");
function reduce(accumulator, seed) {
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return pipe_1.pipe(scan_1.scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast_1.takeLast(1))(source);
    };
}
exports.reduce = reduce;

},{"../util/pipe":541,"./defaultIfEmpty":411,"./scan":462,"./takeLast":477}],455:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
exports.refCount = refCount;
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],456:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var empty_1 = require("../observable/empty");
function repeat(count) {
    if (count === void 0) { count = -1; }
    return function (source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else if (count < 0) {
            return source.lift(new RepeatOperator(-1, source));
        }
        else {
            return source.lift(new RepeatOperator(count - 1, source));
        }
    };
}
exports.repeat = repeat;
var RepeatOperator = (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
var RepeatSubscriber = (function (_super) {
    __extends(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363,"../observable/empty":373}],457:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function repeatWhen(notifier) {
    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };
}
exports.repeatWhen = repeatWhen;
var RepeatWhenOperator = (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
var RepeatWhenSubscriber = (function (_super) {
    __extends(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next();
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject_1.Subject();
        var retries;
        try {
            var notifier = this.notifier;
            retries = notifier(this.notifications);
        }
        catch (e) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
    };
    return RepeatWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../Subject":361,"../util/subscribeToResult":547}],458:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function retry(count) {
    if (count === void 0) { count = -1; }
    return function (source) { return source.lift(new RetryOperator(count, source)); };
}
exports.retry = retry;
var RetryOperator = (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
var RetrySubscriber = (function (_super) {
    __extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],459:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function retryWhen(notifier) {
    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };
}
exports.retryWhen = retryWhen;
var RetryWhenOperator = (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
var RetryWhenSubscriber = (function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject_1.Subject();
                try {
                    var notifier = this.notifier;
                    retries = notifier(errors);
                }
                catch (e) {
                    return _super.prototype.error.call(this, e);
                }
                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
            }
            else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../Subject":361,"../util/subscribeToResult":547}],460:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function sample(notifier) {
    return function (source) { return source.lift(new SampleOperator(notifier)); };
}
exports.sample = sample;
var SampleOperator = (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));
        return subscription;
    };
    return SampleOperator;
}());
var SampleSubscriber = (function (_super) {
    __extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../util/subscribeToResult":547}],461:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var async_1 = require("../scheduler/async");
function sampleTime(period, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };
}
exports.sampleTime = sampleTime;
var SampleTimeOperator = (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
var SampleTimeSubscriber = (function (_super) {
    __extends(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
        return _this;
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}

},{"../Subscriber":363,"../scheduler/async":514}],462:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
exports.scan = scan;
var ScanOperator = (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],463:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function sequenceEqual(compareTo, comparator) {
    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparator)); };
}
exports.sequenceEqual = sequenceEqual;
var SequenceEqualOperator = (function () {
    function SequenceEqualOperator(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
    };
    return SequenceEqualOperator;
}());
exports.SequenceEqualOperator = SequenceEqualOperator;
var SequenceEqualSubscriber = (function (_super) {
    __extends(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
        this.unsubscribe();
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            try {
                areEqual = comparator ? comparator(a, b) : a === b;
            }
            catch (e) {
                this.destination.error(e);
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype.completeB = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber_1.Subscriber));
exports.SequenceEqualSubscriber = SequenceEqualSubscriber;
var SequenceEqualCompareToSubscriber = (function (_super) {
    __extends(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
        this.unsubscribe();
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent.completeB();
        this.unsubscribe();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],464:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var multicast_1 = require("./multicast");
var refCount_1 = require("./refCount");
var Subject_1 = require("../Subject");
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
function share() {
    return function (source) { return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source)); };
}
exports.share = share;

},{"../Subject":361,"./multicast":443,"./refCount":455}],465:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReplaySubject_1 = require("../ReplaySubject");
function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var config;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        config = configOrBufferSize;
    }
    else {
        config = {
            bufferSize: configOrBufferSize,
            windowTime: windowTime,
            refCount: false,
            scheduler: scheduler
        };
    }
    return function (source) { return source.lift(shareReplayOperator(config)); };
}
exports.shareReplay = shareReplay;
function shareReplayOperator(_a) {
    var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        if (!subject || hasError) {
            hasError = false;
            subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
            subscription = source.subscribe({
                next: function (value) { subject.next(value); },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subscription = undefined;
                    subject.complete();
                },
            });
        }
        var innerSub = subject.subscribe(this);
        this.add(function () {
            refCount--;
            innerSub.unsubscribe();
            if (subscription && !isComplete && useRefCount && refCount === 0) {
                subscription.unsubscribe();
                subscription = undefined;
                subject = undefined;
            }
        });
    };
}

},{"../ReplaySubject":359}],466:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var EmptyError_1 = require("../util/EmptyError");
function single(predicate) {
    return function (source) { return source.lift(new SingleOperator(predicate, source)); };
}
exports.single = single;
var SingleOperator = (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
var SingleSubscriber = (function (_super) {
    __extends(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363,"../util/EmptyError":520}],467:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
exports.skip = skip;
var SkipOperator = (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
var SkipSubscriber = (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],468:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
function skipLast(count) {
    return function (source) { return source.lift(new SkipLastOperator(count)); };
}
exports.skipLast = skipLast;
var SkipLastOperator = (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            return source.subscribe(new Subscriber_1.Subscriber(subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
var SkipLastSubscriber = (function (_super) {
    __extends(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363,"../util/ArgumentOutOfRangeError":519}],469:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var InnerSubscriber_1 = require("../InnerSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
exports.skipUntil = skipUntil;
var SkipUntilOperator = (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator;
}());
var SkipUntilSubscriber = (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(_this, undefined, undefined);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        var innerSubscription = subscribeToResult_1.subscribeToResult(_this, notifier, undefined, undefined, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            _this.add(innerSubscription);
            _this.innerSubscription = innerSubscription;
        }
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
    };
    return SkipUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../InnerSubscriber":354,"../OuterSubscriber":358,"../util/subscribeToResult":547}],470:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
exports.skipWhile = skipWhile;
var SkipWhileOperator = (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var SkipWhileSubscriber = (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],471:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_1 = require("../observable/concat");
var isScheduler_1 = require("../util/isScheduler");
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
        return function (source) { return concat_1.concat(array, source, scheduler); };
    }
    else {
        return function (source) { return concat_1.concat(array, source); };
    }
}
exports.startWith = startWith;

},{"../observable/concat":371,"../util/isScheduler":538}],472:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SubscribeOnObservable_1 = require("../observable/SubscribeOnObservable");
function subscribeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function subscribeOnOperatorFunction(source) {
        return source.lift(new SubscribeOnOperator(scheduler, delay));
    };
}
exports.subscribeOn = subscribeOn;
var SubscribeOnOperator = (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());

},{"../observable/SubscribeOnObservable":367}],473:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var switchMap_1 = require("./switchMap");
var identity_1 = require("../util/identity");
function switchAll() {
    return switchMap_1.switchMap(identity_1.identity);
}
exports.switchAll = switchAll;

},{"../util/identity":527,"./switchMap":474}],474:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var InnerSubscriber_1 = require("../InnerSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
var map_1 = require("./map");
var from_1 = require("../observable/from");
function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
exports.switchMap = switchMap;
var SwitchMapOperator = (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(this, value, index);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, undefined, undefined, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
            destination.add(this.innerSubscription);
        }
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../InnerSubscriber":354,"../OuterSubscriber":358,"../observable/from":375,"../util/subscribeToResult":547,"./map":433}],475:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var switchMap_1 = require("./switchMap");
function switchMapTo(innerObservable, resultSelector) {
    return resultSelector ? switchMap_1.switchMap(function () { return innerObservable; }, resultSelector) : switchMap_1.switchMap(function () { return innerObservable; });
}
exports.switchMapTo = switchMapTo;

},{"./switchMap":474}],476:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
var empty_1 = require("../observable/empty");
function take(count) {
    return function (source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
exports.take = take;
var TakeOperator = (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363,"../observable/empty":373,"../util/ArgumentOutOfRangeError":519}],477:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
var empty_1 = require("../observable/empty");
function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
exports.takeLast = takeLast;
var TakeLastOperator = (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363,"../observable/empty":373,"../util/ArgumentOutOfRangeError":519}],478:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = subscribeToResult_1.subscribeToResult(takeUntilSubscriber, this.notifier);
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../util/subscribeToResult":547}],479:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function takeWhile(predicate, inclusive) {
    if (inclusive === void 0) { inclusive = false; }
    return function (source) {
        return source.lift(new TakeWhileOperator(predicate, inclusive));
    };
}
exports.takeWhile = takeWhile;
var TakeWhileOperator = (function () {
    function TakeWhileOperator(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
    };
    return TakeWhileOperator;
}());
var TakeWhileSubscriber = (function (_super) {
    __extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            if (this.inclusive) {
                destination.next(value);
            }
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363}],480:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var noop_1 = require("../util/noop");
var isFunction_1 = require("../util/isFunction");
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
exports.tap = tap;
var DoOperator = (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = (function (_super) {
    __extends(TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop_1.noop;
        _this._tapError = noop_1.noop;
        _this._tapComplete = noop_1.noop;
        _this._tapError = error || noop_1.noop;
        _this._tapComplete = complete || noop_1.noop;
        if (isFunction_1.isFunction(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || noop_1.noop;
            _this._tapError = observerOrNext.error || noop_1.noop;
            _this._tapComplete = observerOrNext.complete || noop_1.noop;
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":363,"../util/isFunction":531,"../util/noop":539}],481:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
exports.defaultThrottleConfig = {
    leading: true,
    trailing: false
};
function throttle(durationSelector, config) {
    if (config === void 0) { config = exports.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
}
exports.throttle = throttle;
var ThrottleOperator = (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var ThrottleSubscriber = (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = null;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
            this.add(this._throttled = subscribeToResult_1.subscribeToResult(this, duration));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = null;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../util/subscribeToResult":547}],482:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var async_1 = require("../scheduler/async");
var throttle_1 = require("./throttle");
function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
exports.throttleTime = throttleTime;
var ThrottleTimeOperator = (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var ThrottleTimeSubscriber = (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
            else if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

},{"../Subscriber":363,"../scheduler/async":514,"./throttle":481}],483:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = require("../util/EmptyError");
var Subscriber_1 = require("../Subscriber");
function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) { errorFactory = defaultErrorFactory; }
    return function (source) {
        return source.lift(new ThrowIfEmptyOperator(errorFactory));
    };
}
exports.throwIfEmpty = throwIfEmpty;
var ThrowIfEmptyOperator = (function () {
    function ThrowIfEmptyOperator(errorFactory) {
        this.errorFactory = errorFactory;
    }
    ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
    };
    return ThrowIfEmptyOperator;
}());
var ThrowIfEmptySubscriber = (function (_super) {
    __extends(ThrowIfEmptySubscriber, _super);
    function ThrowIfEmptySubscriber(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
    }
    ThrowIfEmptySubscriber.prototype._next = function (value) {
        this.hasValue = true;
        this.destination.next(value);
    };
    ThrowIfEmptySubscriber.prototype._complete = function () {
        if (!this.hasValue) {
            var err = void 0;
            try {
                err = this.errorFactory();
            }
            catch (e) {
                err = e;
            }
            this.destination.error(err);
        }
        else {
            return this.destination.complete();
        }
    };
    return ThrowIfEmptySubscriber;
}(Subscriber_1.Subscriber));
function defaultErrorFactory() {
    return new EmptyError_1.EmptyError();
}

},{"../Subscriber":363,"../util/EmptyError":520}],484:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var scan_1 = require("./scan");
var defer_1 = require("../observable/defer");
var map_1 = require("./map");
function timeInterval(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return defer_1.defer(function () {
        return source.pipe(scan_1.scan(function (_a, value) {
            var current = _a.current;
            return ({ value: value, current: scheduler.now(), last: current });
        }, { current: scheduler.now(), value: undefined, last: undefined }), map_1.map(function (_a) {
            var current = _a.current, last = _a.last, value = _a.value;
            return new TimeInterval(value, current - last);
        }));
    }); };
}
exports.timeInterval = timeInterval;
var TimeInterval = (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());
exports.TimeInterval = TimeInterval;

},{"../observable/defer":372,"../scheduler/async":514,"./map":433,"./scan":462}],485:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var TimeoutError_1 = require("../util/TimeoutError");
var timeoutWith_1 = require("./timeoutWith");
var throwError_1 = require("../observable/throwError");
function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return timeoutWith_1.timeoutWith(due, throwError_1.throwError(new TimeoutError_1.TimeoutError()), scheduler);
}
exports.timeout = timeout;

},{"../observable/throwError":390,"../scheduler/async":514,"../util/TimeoutError":523,"./timeoutWith":486}],486:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var isDate_1 = require("../util/isDate");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) {
        var absoluteTimeout = isDate_1.isDate(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
}
exports.timeoutWith = timeoutWith;
var TimeoutWithOperator = (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
var TimeoutWithSubscriber = (function (_super) {
    __extends(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.action = null;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../scheduler/async":514,"../util/isDate":530,"../util/subscribeToResult":547}],487:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var map_1 = require("./map");
function timestamp(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return map_1.map(function (value) { return new Timestamp(value, scheduler.now()); });
}
exports.timestamp = timestamp;
var Timestamp = (function () {
    function Timestamp(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    return Timestamp;
}());
exports.Timestamp = Timestamp;

},{"../scheduler/async":514,"./map":433}],488:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reduce_1 = require("./reduce");
function toArrayReducer(arr, item, index) {
    if (index === 0) {
        return [item];
    }
    arr.push(item);
    return arr;
}
function toArray() {
    return reduce_1.reduce(toArrayReducer, []);
}
exports.toArray = toArray;

},{"./reduce":454}],489:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function window(windowBoundaries) {
    return function windowOperatorFunction(source) {
        return source.lift(new WindowOperator(windowBoundaries));
    };
}
exports.window = window;
var WindowOperator = (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject_1.Subject();
        destination.next(_this.window);
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject_1.Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../Subject":361,"../util/subscribeToResult":547}],490:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Subject_1 = require("../Subject");
function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) { startWindowEvery = 0; }
    return function windowCountOperatorFunction(source) {
        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
    };
}
exports.windowCount = windowCount;
var WindowCountOperator = (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
var WindowCountSubscriber = (function (_super) {
    __extends(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject_1.Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject_1.Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subject":361,"../Subscriber":363}],491:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var async_1 = require("../scheduler/async");
var Subscriber_1 = require("../Subscriber");
var isNumeric_1 = require("../util/isNumeric");
var isScheduler_1 = require("../util/isScheduler");
function windowTime(windowTimeSpan) {
    var scheduler = async_1.async;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (isScheduler_1.isScheduler(arguments[3])) {
        scheduler = arguments[3];
    }
    if (isScheduler_1.isScheduler(arguments[2])) {
        scheduler = arguments[2];
    }
    else if (isNumeric_1.isNumeric(arguments[2])) {
        maxWindowSize = arguments[2];
    }
    if (isScheduler_1.isScheduler(arguments[1])) {
        scheduler = arguments[1];
    }
    else if (isNumeric_1.isNumeric(arguments[1])) {
        windowCreationInterval = arguments[1];
    }
    return function windowTimeOperatorFunction(source) {
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    };
}
exports.windowTime = windowTime;
var WindowTimeOperator = (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = (function (_super) {
    __extends(CountedSubject, _super);
    function CountedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject_1.Subject));
var WindowTimeSubscriber = (function (_super) {
    __extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: _this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}

},{"../Subject":361,"../Subscriber":363,"../scheduler/async":514,"../util/isNumeric":534,"../util/isScheduler":538}],492:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var Subscription_1 = require("../Subscription");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function windowToggle(openings, closingSelector) {
    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };
}
exports.windowToggle = windowToggle;
var WindowToggleOperator = (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
var WindowToggleSubscriber = (function (_super) {
    __extends(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult_1.subscribeToResult(_this, openings, openings));
        return _this;
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingNotifier = void 0;
            try {
                var closingSelector = this.closingSelector;
                closingNotifier = closingSelector(innerValue);
            }
            catch (e) {
                return this.error(e);
            }
            var window_1 = new Subject_1.Subject();
            var subscription = new Subscription_1.Subscription();
            var context_4 = { window: window_1, subscription: subscription };
            this.contexts.push(context_4);
            var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context_4);
            if (innerSubscription.closed) {
                this.closeWindow(this.contexts.length - 1);
            }
            else {
                innerSubscription.context = context_4;
                subscription.add(innerSubscription);
            }
            this.destination.next(window_1);
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../Subject":361,"../Subscription":364,"../util/subscribeToResult":547}],493:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function windowWhen(closingSelector) {
    return function windowWhenOperatorFunction(source) {
        return source.lift(new WindowOperator(closingSelector));
    };
}
exports.windowWhen = windowWhen;
var WindowOperator = (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) { innerSub = null; }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject_1.Subject();
        this.destination.next(window);
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (e) {
            this.destination.error(e);
            this.window.error(e);
            return;
        }
        this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../Subject":361,"../util/subscribeToResult":547}],494:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var WithLatestFromSubscriber = (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(subscribeToResult_1.subscribeToResult(_this, observable, observable, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":358,"../util/subscribeToResult":547}],495:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var zip_1 = require("../observable/zip");
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function zipOperatorFunction(source) {
        return source.lift.call(zip_1.zip.apply(void 0, [source].concat(observables)));
    };
}
exports.zip = zip;

},{"../observable/zip":393}],496:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var zip_1 = require("../observable/zip");
function zipAll(project) {
    return function (source) { return source.lift(new zip_1.ZipOperator(project)); };
}
exports.zipAll = zipAll;

},{"../observable/zip":393}],497:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
function scheduleArray(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        var i = 0;
        sub.add(scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
                sub.add(this.schedule());
            }
        }));
        return sub;
    });
}
exports.scheduleArray = scheduleArray;

},{"../Observable":356,"../Subscription":364}],498:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
var iterator_1 = require("../symbol/iterator");
function scheduleIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        var iterator;
        sub.add(function () {
            if (iterator && typeof iterator.return === 'function') {
                iterator.return();
            }
        });
        sub.add(scheduler.schedule(function () {
            iterator = input[iterator_1.iterator]();
            sub.add(scheduler.schedule(function () {
                if (subscriber.closed) {
                    return;
                }
                var value;
                var done;
                try {
                    var result = iterator.next();
                    value = result.value;
                    done = result.done;
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                    this.schedule();
                }
            }));
        }));
        return sub;
    });
}
exports.scheduleIterable = scheduleIterable;

},{"../Observable":356,"../Subscription":364,"../symbol/iterator":516}],499:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
var observable_1 = require("../symbol/observable");
function scheduleObservable(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function () {
            var observable = input[observable_1.observable]();
            sub.add(observable.subscribe({
                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
            }));
        }));
        return sub;
    });
}
exports.scheduleObservable = scheduleObservable;

},{"../Observable":356,"../Subscription":364,"../symbol/observable":517}],500:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
function schedulePromise(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function () { return input.then(function (value) {
            sub.add(scheduler.schedule(function () {
                subscriber.next(value);
                sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
            }));
        }, function (err) {
            sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
        }); }));
        return sub;
    });
}
exports.schedulePromise = schedulePromise;

},{"../Observable":356,"../Subscription":364}],501:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var scheduleObservable_1 = require("./scheduleObservable");
var schedulePromise_1 = require("./schedulePromise");
var scheduleArray_1 = require("./scheduleArray");
var scheduleIterable_1 = require("./scheduleIterable");
var isInteropObservable_1 = require("../util/isInteropObservable");
var isPromise_1 = require("../util/isPromise");
var isArrayLike_1 = require("../util/isArrayLike");
var isIterable_1 = require("../util/isIterable");
function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
            return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        else if (isPromise_1.isPromise(input)) {
            return schedulePromise_1.schedulePromise(input, scheduler);
        }
        else if (isArrayLike_1.isArrayLike(input)) {
            return scheduleArray_1.scheduleArray(input, scheduler);
        }
        else if (isIterable_1.isIterable(input) || typeof input === 'string') {
            return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
exports.scheduled = scheduled;

},{"../util/isArrayLike":529,"../util/isInteropObservable":532,"../util/isIterable":533,"../util/isPromise":537,"./scheduleArray":497,"./scheduleIterable":498,"./scheduleObservable":499,"./schedulePromise":500}],502:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("../Subscription");
var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;

},{"../Subscription":364}],503:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var AnimationFrameAction = (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction_1.AsyncAction));
exports.AnimationFrameAction = AnimationFrameAction;

},{"./AsyncAction":507}],504:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = require("./AsyncScheduler");
var AnimationFrameScheduler = (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AnimationFrameScheduler = AnimationFrameScheduler;

},{"./AsyncScheduler":508}],505:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Immediate_1 = require("../util/Immediate");
var AsyncAction_1 = require("./AsyncAction");
var AsapAction = (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            Immediate_1.Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(AsyncAction_1.AsyncAction));
exports.AsapAction = AsapAction;

},{"../util/Immediate":521,"./AsyncAction":507}],506:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = require("./AsyncScheduler");
var AsapScheduler = (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AsapScheduler = AsapScheduler;

},{"./AsyncScheduler":508}],507:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Action_1 = require("./Action");
var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;

},{"./Action":502}],508:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Scheduler_1 = require("../Scheduler");
var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler_1.Scheduler.now; }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;

},{"../Scheduler":360}],509:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;

},{"./AsyncAction":507}],510:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = require("./AsyncScheduler");
var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;

},{"./AsyncScheduler":508}],511:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var AsyncScheduler_1 = require("./AsyncScheduler");
var VirtualTimeScheduler = (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.VirtualTimeScheduler = VirtualTimeScheduler;
var VirtualAction = (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) { index = scheduler.index += 1; }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction_1.AsyncAction));
exports.VirtualAction = VirtualAction;

},{"./AsyncAction":507,"./AsyncScheduler":508}],512:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AnimationFrameAction_1 = require("./AnimationFrameAction");
var AnimationFrameScheduler_1 = require("./AnimationFrameScheduler");
exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);

},{"./AnimationFrameAction":503,"./AnimationFrameScheduler":504}],513:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AsapAction_1 = require("./AsapAction");
var AsapScheduler_1 = require("./AsapScheduler");
exports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);

},{"./AsapAction":505,"./AsapScheduler":506}],514:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var AsyncScheduler_1 = require("./AsyncScheduler");
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);

},{"./AsyncAction":507,"./AsyncScheduler":508}],515:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var QueueAction_1 = require("./QueueAction");
var QueueScheduler_1 = require("./QueueScheduler");
exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);

},{"./QueueAction":509,"./QueueScheduler":510}],516:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
exports.getSymbolIterator = getSymbolIterator;
exports.iterator = getSymbolIterator();
exports.$$iterator = exports.iterator;

},{}],517:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.observable = (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();

},{}],518:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rxSubscriber = (function () {
    return typeof Symbol === 'function'
        ? Symbol('rxSubscriber')
        : '@@rxSubscriber_' + Math.random();
})();
exports.$$rxSubscriber = exports.rxSubscriber;

},{}],519:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgumentOutOfRangeErrorImpl = (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

},{}],520:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyErrorImpl = (function () {
    function EmptyErrorImpl() {
        Error.call(this);
        this.message = 'no elements in sequence';
        this.name = 'EmptyError';
        return this;
    }
    EmptyErrorImpl.prototype = Object.create(Error.prototype);
    return EmptyErrorImpl;
})();
exports.EmptyError = EmptyErrorImpl;

},{}],521:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nextHandle = 1;
var RESOLVED = (function () { return Promise.resolve(); })();
var activeHandles = {};
function findAndClearHandle(handle) {
    if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
    }
    return false;
}
exports.Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function () { return findAndClearHandle(handle) && cb(); });
        return handle;
    },
    clearImmediate: function (handle) {
        findAndClearHandle(handle);
    },
};
exports.TestTools = {
    pending: function () {
        return Object.keys(activeHandles).length;
    }
};

},{}],522:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ObjectUnsubscribedErrorImpl = (function () {
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl;
})();
exports.ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

},{}],523:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TimeoutErrorImpl = (function () {
    function TimeoutErrorImpl() {
        Error.call(this);
        this.message = 'Timeout has occurred';
        this.name = 'TimeoutError';
        return this;
    }
    TimeoutErrorImpl.prototype = Object.create(Error.prototype);
    return TimeoutErrorImpl;
})();
exports.TimeoutError = TimeoutErrorImpl;

},{}],524:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnsubscriptionErrorImpl = (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
exports.UnsubscriptionError = UnsubscriptionErrorImpl;

},{}],525:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber_1.Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}
exports.canReportError = canReportError;

},{"../Subscriber":363}],526:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}
exports.hostReportError = hostReportError;

},{}],527:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function identity(x) {
    return x;
}
exports.identity = identity;

},{}],528:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArray = (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();

},{}],529:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

},{}],530:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;

},{}],531:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;

},{}],532:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var observable_1 = require("../symbol/observable");
function isInteropObservable(input) {
    return input && typeof input[observable_1.observable] === 'function';
}
exports.isInteropObservable = isInteropObservable;

},{"../symbol/observable":517}],533:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var iterator_1 = require("../symbol/iterator");
function isIterable(input) {
    return input && typeof input[iterator_1.iterator] === 'function';
}
exports.isIterable = isIterable;

},{"../symbol/iterator":516}],534:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("./isArray");
function isNumeric(val) {
    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;

},{"./isArray":528}],535:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isObject(x) {
    return x !== null && typeof x === 'object';
}
exports.isObject = isObject;

},{}],536:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
function isObservable(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
}
exports.isObservable = isObservable;

},{"../Observable":356}],537:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;

},{}],538:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;

},{}],539:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function noop() { }
exports.noop = noop;

},{}],540:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}
exports.not = not;

},{}],541:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var identity_1 = require("./identity");
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
function pipeFromArray(fns) {
    if (fns.length === 0) {
        return identity_1.identity;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;

},{"./identity":527}],542:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var subscribeToArray_1 = require("./subscribeToArray");
var subscribeToPromise_1 = require("./subscribeToPromise");
var subscribeToIterable_1 = require("./subscribeToIterable");
var subscribeToObservable_1 = require("./subscribeToObservable");
var isArrayLike_1 = require("./isArrayLike");
var isPromise_1 = require("./isPromise");
var isObject_1 = require("./isObject");
var iterator_1 = require("../symbol/iterator");
var observable_1 = require("../symbol/observable");
exports.subscribeTo = function (result) {
    if (!!result && typeof result[observable_1.observable] === 'function') {
        return subscribeToObservable_1.subscribeToObservable(result);
    }
    else if (isArrayLike_1.isArrayLike(result)) {
        return subscribeToArray_1.subscribeToArray(result);
    }
    else if (isPromise_1.isPromise(result)) {
        return subscribeToPromise_1.subscribeToPromise(result);
    }
    else if (!!result && typeof result[iterator_1.iterator] === 'function') {
        return subscribeToIterable_1.subscribeToIterable(result);
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};

},{"../symbol/iterator":516,"../symbol/observable":517,"./isArrayLike":529,"./isObject":535,"./isPromise":537,"./subscribeToArray":543,"./subscribeToIterable":544,"./subscribeToObservable":545,"./subscribeToPromise":546}],543:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeToArray = function (array) { return function (subscriber) {
    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
        subscriber.next(array[i]);
    }
    subscriber.complete();
}; };

},{}],544:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var iterator_1 = require("../symbol/iterator");
exports.subscribeToIterable = function (iterable) { return function (subscriber) {
    var iterator = iterable[iterator_1.iterator]();
    do {
        var item = iterator.next();
        if (item.done) {
            subscriber.complete();
            break;
        }
        subscriber.next(item.value);
        if (subscriber.closed) {
            break;
        }
    } while (true);
    if (typeof iterator.return === 'function') {
        subscriber.add(function () {
            if (iterator.return) {
                iterator.return();
            }
        });
    }
    return subscriber;
}; };

},{"../symbol/iterator":516}],545:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var observable_1 = require("../symbol/observable");
exports.subscribeToObservable = function (obj) { return function (subscriber) {
    var obs = obj[observable_1.observable]();
    if (typeof obs.subscribe !== 'function') {
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
    }
    else {
        return obs.subscribe(subscriber);
    }
}; };

},{"../symbol/observable":517}],546:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var hostReportError_1 = require("./hostReportError");
exports.subscribeToPromise = function (promise) { return function (subscriber) {
    promise.then(function (value) {
        if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
        }
    }, function (err) { return subscriber.error(err); })
        .then(null, hostReportError_1.hostReportError);
    return subscriber;
}; };

},{"./hostReportError":526}],547:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var InnerSubscriber_1 = require("../InnerSubscriber");
var subscribeTo_1 = require("./subscribeTo");
var Observable_1 = require("../Observable");
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
    if (innerSubscriber === void 0) { innerSubscriber = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex); }
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof Observable_1.Observable) {
        return result.subscribe(innerSubscriber);
    }
    return subscribeTo_1.subscribeTo(result)(innerSubscriber);
}
exports.subscribeToResult = subscribeToResult;

},{"../InnerSubscriber":354,"../Observable":356,"./subscribeTo":542}],548:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var rxSubscriber_1 = require("../symbol/rxSubscriber");
var Observer_1 = require("../Observer");
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;

},{"../Observer":357,"../Subscriber":363,"../symbol/rxSubscriber":518}],549:[function(require,module,exports){
arguments[4][142][0].apply(exports,arguments)
},{"buffer":47,"dup":142}],550:[function(require,module,exports){
(function (Buffer){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Convert_1 = require("../format/Convert");
const KeyPair_1 = require("./KeyPair");
const utility = require("./Utilities");
const crypto = require("crypto");
const CryptoJS = require("crypto-js");
class Crypto {
    /**
     * Encrypt data
     * @param {string} data
     * @param {string} salt
     * @param {string} password
     */
    static encrypt(data, password) {
        const salt = CryptoJS.lib.WordArray.random(16);
        // generate password based key
        const key = CryptoJS.PBKDF2(password, salt, {
            keySize: 8,
            iterations: 1024,
        });
        // encrypt using random IV
        const iv = CryptoJS.lib.WordArray.random(16);
        const encrypted = CryptoJS.AES.encrypt(data, key, {
            iv: iv,
            padding: CryptoJS.pad.Pkcs7,
            mode: CryptoJS.mode.CBC,
        });
        // salt (16 bytes) + iv (16 bytes)
        // prepend them to the ciphertext for use in decryption
        return salt.toString() + iv.toString() + encrypted.toString();
    }
    /**
     * Decrypt data
     * @param {string} data
     * @param {string} salt
     * @param {string} password
     */
    static decrypt(data, password) {
        const salt = CryptoJS.enc.Hex.parse(data.substr(0, 32));
        const iv = CryptoJS.enc.Hex.parse(data.substr(32, 32));
        const encrypted = data.substring(64);
        // generate password based key
        const key = CryptoJS.PBKDF2(password, salt, {
            keySize: 8,
            iterations: 1024,
        });
        // decrypt using custom IV
        const decrypted = CryptoJS.AES.decrypt(encrypted, key, {
            iv: iv,
            padding: CryptoJS.pad.Pkcs7,
            mode: CryptoJS.mode.CBC,
        });
        return decrypted.toString(CryptoJS.enc.Utf8);
    }
}
exports.Crypto = Crypto;
Crypto.AES_ALGO = 'aes-256-gcm';
/***
 * Encode a message, separated from encode() to help testing
 *
 * @param {string} senderPriv - A sender private key
 * @param {string} recipientPub - A recipient public key
 * @param {string} msg - A text message
 * @param {Uint8Array} iv - An initialization vector
 * @param {Uint8Array} salt - A salt
 * @return {string} - The encoded message
 */
Crypto._encode = (senderPriv, recipientPub, msg, iv) => {
    // Errors
    if (!senderPriv || !recipientPub || !msg || !iv) {
        throw new Error('Missing argument !');
    }
    // Processing
    const keyPair = KeyPair_1.KeyPair.createKeyPairFromPrivateKeyString(senderPriv);
    const encKey = Buffer.from(utility.catapult_crypto.deriveSharedKey(keyPair.privateKey, Convert_1.Convert.hexToUint8(recipientPub)), 32);
    const encIv = Buffer.from(iv);
    const cipher = crypto.createCipheriv(Crypto.AES_ALGO, encKey, encIv);
    const encrypted = Buffer.concat([cipher.update(Buffer.from(Convert_1.Convert.hexToUint8(msg))), cipher.final()]);
    const tag = cipher.getAuthTag();
    // Result
    const result = tag.toString('hex') + encIv.toString('hex') + encrypted.toString('hex');
    return result;
};
/**
 * Encode a message using AES-GCM algorithm
 *
 * @param {string} senderPriv - A sender private key
 * @param {string} recipientPub - A recipient public key
 * @param {string} msg - A text message
 * @param {boolean} isHexString - Is payload string a hexadecimal string (default = false)
 * @return {string} - The encoded message
 */
Crypto.encode = (senderPriv, recipientPub, msg, isHexString = false) => {
    // Errors
    if (!senderPriv || !recipientPub || !msg) {
        throw new Error('Missing argument !');
    }
    // Processing
    const iv = Crypto.randomBytes(12);
    const encoded = Crypto._encode(senderPriv, recipientPub, isHexString ? msg : Convert_1.Convert.utf8ToHex(msg), iv);
    // Result
    return encoded;
};
/**
 * Decode an encrypted message payload
 *
 * @param {string} recipientPrivate - A recipient private key
 * @param {string} senderPublic - A sender public key
 * @param {Uint8Array} payload - An encrypted message payload in bytes
 * @param {Uint8Array} tagAndIv - 16-bytes AES auth tag and 12-byte AES initialization vector
 * @return {string} - The decoded payload as hex
 */
Crypto._decode = (recipientPrivate, senderPublic, payload, tagAndIv) => {
    // Error
    if (!recipientPrivate || !senderPublic || !payload) {
        throw new Error('Missing argument !');
    }
    // Processing
    const keyPair = KeyPair_1.KeyPair.createKeyPairFromPrivateKeyString(recipientPrivate);
    const encKey = Buffer.from(utility.catapult_crypto.deriveSharedKey(keyPair.privateKey, Convert_1.Convert.hexToUint8(senderPublic)), 32);
    const encIv = Buffer.from(new Uint8Array(tagAndIv.buffer, 16, 12));
    const encTag = Buffer.from(new Uint8Array(tagAndIv.buffer, 0, 16));
    const cipher = crypto.createDecipheriv(Crypto.AES_ALGO, encKey, encIv);
    cipher.setAuthTag(encTag);
    const decrypted = Buffer.concat([cipher.update(Buffer.from(payload)), cipher.final()]);
    // Result
    return decrypted.toString('hex');
};
/**
 * Decode an encrypted (AES-GCM algorithm) message payload
 *
 * @param {string} recipientPrivate - A recipient private key
 * @param {string} senderPublic - A sender public key
 * @param {string} payload - An encrypted message payload
 * @return {string} - The decoded payload as hex
 */
Crypto.decode = (recipientPrivate, senderPublic, payload) => {
    // Error
    if (!recipientPrivate || !senderPublic || !payload) {
        throw new Error('Missing argument !');
    }
    // Processing
    const binPayload = Convert_1.Convert.hexToUint8(payload);
    const payloadBuffer = new Uint8Array(binPayload.buffer, 16 + 12); //tag + iv
    const tagAndIv = new Uint8Array(binPayload.buffer, 0, 16 + 12);
    try {
        const decoded = Crypto._decode(recipientPrivate, senderPublic, payloadBuffer, tagAndIv);
        return decoded.toUpperCase();
    }
    catch (_a) {
        // To return empty string rather than error throwing if authentication failed
        return '';
    }
};
/**
 * Generate random bytes by length
 * @param {number} length - The length of the random bytes
 *
 * @return {Uint8Array}
 */
Crypto.randomBytes = (length) => {
    return crypto.randomBytes(length);
};

}).call(this,require("buffer").Buffer)
},{"../format/Convert":558,"./KeyPair":551,"./Utilities":554,"buffer":47,"crypto":55,"crypto-js":316}],551:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nacl = require("tweetnacl");
const format_1 = require("../format");
const Utility = require("./Utilities");
class KeyPair {
    /**
     * Creates a key pair from a private key string.
     * @param {string} privateKeyString A hex encoded private key string.
     * @returns {module:crypto/keyPair~KeyPair} The key pair.
     */
    static createKeyPairFromPrivateKeyString(privateKeyString) {
        const privateKey = format_1.Convert.hexToUint8(privateKeyString);
        if (Utility.Key_Size !== privateKey.length) {
            throw Error(`private key has unexpected size: ${privateKey.length}`);
        }
        const { publicKey } = nacl.sign.keyPair.fromSeed(privateKey);
        return { privateKey, publicKey };
    }
    /**
     * Signs a data buffer with a key pair.
     * @param {module:crypto/keyPair~KeyPair} keyPair The key pair to use for signing.
     * @param {Uint8Array} data The data to sign.
     * @returns {Uint8Array} The signature.
     */
    static sign(keyPair, data) {
        const secretKey = new Uint8Array(64);
        secretKey.set(keyPair.privateKey);
        secretKey.set(keyPair.publicKey, 32);
        return nacl.sign.detached(data, secretKey);
    }
    /**
     * Verifies a signature.
     * @param {Uint8Array} publicKey The public key to use for verification.
     * @param {Uint8Array} data The data to verify.
     * @param {Uint8Array} signature The signature to verify.
     * @returns {boolean} true if the signature is verifiable, false otherwise.
     */
    static verify(publicKey, data, signature) {
        return nacl.sign.detached.verify(data, signature, publicKey);
    }
}
exports.KeyPair = KeyPair;

},{"../format":565,"./Utilities":554,"tweetnacl":1160}],552:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SHA3Hasher_1 = require("./SHA3Hasher");
class MerkleHashBuilder {
    /**
     * Constructor
     * @param length Hash size
     */
    constructor(
    /**
     * Length of produced merkle hash in bytes.
     *
     * @var {number}
     */
    length) {
        this.length = length;
        /**
         * The list of hashes used to calculate root hash.
         *
         * @var {Uint8Array}
         */
        this.hashes = new Array();
    }
    /**
     * Hash inner transactions
     *
     * @internal
     * @param hashes Inner transaction hashes
     * @return {Uint8Array}
     */
    hash(hashes) {
        const hasher = SHA3Hasher_1.SHA3Hasher.createHasher(this.length);
        hasher.reset();
        hashes.forEach((hashVal) => {
            hasher.update(hashVal);
        });
        const hash = new Uint8Array(this.length);
        hasher.finalize(hash);
        return hash;
    }
    /**
     * Get root hash of Merkle Tree
     *
     * @internal
     * @param {Uint8Array[]} hashes Inner transaction hashes
     * @return {Uint8Array}
     */
    calculateRootHash(hashes) {
        if (hashes.length === 0) {
            return new Uint8Array(this.length);
        }
        let numRemainingHashes = hashes.length;
        while (numRemainingHashes > 1) {
            for (let i = 0; i < numRemainingHashes; i += 2) {
                if (i + 1 < numRemainingHashes) {
                    hashes.splice(i / 2, 0, this.hash([hashes[i], hashes[i + 1]]));
                    continue;
                }
                // if there is an odd number of hashes, duplicate the last one
                hashes.splice(i / 2, 0, this.hash([hashes[i], hashes[i]]));
                ++numRemainingHashes;
            }
            numRemainingHashes /= 2;
        }
        return hashes[0];
    }
    /**
     * Get root hash of Merkle tree
     *
     * @return {Uint8Array}
     */
    getRootHash() {
        return this.calculateRootHash(this.hashes);
    }
    /**
     * Update hashes array (add hash)
     *
     * @param hash Inner transaction hash buffer
     * @return {MerkleHashBuilder}
     */
    update(hash) {
        this.hashes.push(hash);
        return this;
    }
}
exports.MerkleHashBuilder = MerkleHashBuilder;

},{"./SHA3Hasher":553}],553:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const js_sha3_1 = require("js-sha3");
const format_1 = require("../format");
class SHA3Hasher {
}
exports.SHA3Hasher = SHA3Hasher;
/**
 * Calculates the hash of data.
 * @param {Uint8Array} dest The computed hash destination.
 * @param {Uint8Array} data The data to hash.
 * @param {number} length The hash length in bytes.
 */
SHA3Hasher.func = (dest, data, length) => {
    const hasher = SHA3Hasher.getHasher(length);
    const hash = hasher.arrayBuffer(data);
    format_1.RawArray.copy(dest, format_1.RawArray.uint8View(hash));
};
/**
 * Creates a hasher object.
 * @param {number} length The hash length in bytes.
 * @returns {object} The hasher.
 */
SHA3Hasher.createHasher = (length = 64) => {
    let hash;
    return {
        reset: () => {
            hash = SHA3Hasher.getHasher(length).create();
        },
        update: (data) => {
            if (data instanceof Uint8Array) {
                hash.update(data);
            }
            else if ('string' === typeof data) {
                hash.update(format_1.Convert.hexToUint8(data));
            }
            else {
                throw Error('unsupported data type');
            }
        },
        finalize: (result) => {
            format_1.RawArray.copy(result, format_1.RawArray.uint8View(hash.arrayBuffer()));
        },
    };
};
/**
 * Get a hasher instance.
 * @param {numeric} length The hash length in bytes.
 * @returns {object} The hasher.
 */
SHA3Hasher.getHasher = (length = 64) => {
    return {
        32: js_sha3_1.sha3_256,
        64: js_sha3_1.sha3_512,
    }[length];
};

},{"../format":565,"js-sha3":"/node_modules/js-sha3"}],554:[function(require,module,exports){
(function (Buffer){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const format_1 = require("../format");
const nacl = require("./nacl_catapult");
const CryptoJS = require("crypto-js");
const hkdf = require("futoin-hkdf");
const js_sha512_1 = require("js-sha512");
exports.Key_Size = 32;
exports.Signature_Size = 64;
exports.Half_Signature_Size = exports.Signature_Size / 2;
exports.Hash_Size = 64;
exports.Half_Hash_Size = exports.Hash_Size / 2;
/**
 * Convert an Uint8Array to WordArray
 *
 * @param {Uint8Array} ua - An Uint8Array
 * @param {number} uaLength - The Uint8Array length
 *
 * @return {WordArray}
 */
exports.ua2words = (ua, uaLength) => {
    const temp = [];
    for (let i = 0; i < uaLength; i += 4) {
        const x = ua[i] * 0x1000000 + (ua[i + 1] || 0) * 0x10000 + (ua[i + 2] || 0) * 0x100 + (ua[i + 3] || 0);
        temp.push(x > 0x7fffffff ? x - 0x100000000 : x);
    }
    return CryptoJS.lib.WordArray.create(temp, uaLength);
};
/**
 * Convert a wordArray to Uint8Array
 *
 * @param {Uint8Array} destUa - A destination Uint8Array
 * @param {WordArray} cryptoWords - A wordArray
 *
 * @return {Uint8Array}
 */
exports.words2ua = (destUa, cryptoWords) => {
    for (let i = 0; i < destUa.length; i += 4) {
        let v = cryptoWords.words[i / 4];
        if (v < 0) {
            v += 0x100000000;
        }
        destUa[i] = v >>> 24;
        destUa[i + 1] = (v >>> 16) & 0xff;
        destUa[i + 2] = (v >>> 8) & 0xff;
        destUa[i + 3] = v & 0xff;
    }
    return destUa;
};
// custom catapult crypto functions
exports.catapult_crypto = (() => {
    function clamp(d) {
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
    }
    function prepareForScalarMult(sk) {
        const d = new Uint8Array(64);
        const hash = js_sha512_1.sha512.arrayBuffer(sk);
        format_1.RawArray.copy(d, format_1.RawArray.uint8View(hash), 32);
        clamp(d);
        return d;
    }
    return {
        deriveSharedKey: (privateKey, publicKey) => {
            const sharedSecret = exports.catapult_crypto.deriveSharedSecret(privateKey, publicKey);
            const info = 'catapult';
            const hash = 'SHA-256';
            return hkdf(sharedSecret, 32, { salt: Buffer.from(new Uint8Array(32)), info, hash });
        },
        deriveSharedSecret: (privateKey, publicKey) => {
            const c = nacl;
            const d = prepareForScalarMult(privateKey);
            // sharedKey = pack(p = d (derived from privateKey) * q (derived from publicKey))
            const q = [c.gf(), c.gf(), c.gf(), c.gf()];
            const p = [c.gf(), c.gf(), c.gf(), c.gf()];
            const sharedSecret = new Uint8Array(exports.Key_Size);
            c.unpack(q, publicKey);
            c.scalarmult(p, q, d);
            c.pack(sharedSecret, p);
            return sharedSecret;
        },
    };
})();

}).call(this,require("buffer").Buffer)
},{"../format":565,"./nacl_catapult":556,"buffer":47,"crypto-js":316,"futoin-hkdf":342,"js-sha512":348}],555:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./Crypto"));
__export(require("./KeyPair"));
__export(require("./SHA3Hasher"));
__export(require("./nacl_catapult"));
__export(require("./MerkleHashBuilder"));

},{"./Crypto":550,"./KeyPair":551,"./MerkleHashBuilder":552,"./SHA3Hasher":553,"./nacl_catapult":556}],556:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// README: This is copied from tweeetnacl/nacl.fast.js and is updated to export custom hash functions.
// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/
/* eslint-disable */
const _0 = new Uint8Array(16);
const _9 = new Uint8Array(32);
_9[0] = 9;
exports.gf = (init) => {
    let i;
    const r = new Float64Array(16);
    if (init) {
        for (i = 0; i < init.length; i++) {
            r[i] = init[i];
        }
    }
    return r;
};
const gf0 = exports.gf(), gf1 = exports.gf([1]), _121665 = exports.gf([0xdb41, 1]), D = exports.gf([
    0x78a3,
    0x1359,
    0x4dca,
    0x75eb,
    0xd8ab,
    0x4141,
    0x0a4d,
    0x0070,
    0xe898,
    0x7779,
    0x4079,
    0x8cc7,
    0xfe73,
    0x2b6f,
    0x6cee,
    0x5203,
]), D2 = exports.gf([
    0xf159,
    0x26b2,
    0x9b94,
    0xebd6,
    0xb156,
    0x8283,
    0x149a,
    0x00e0,
    0xd130,
    0xeef3,
    0x80f2,
    0x198e,
    0xfce7,
    0x56df,
    0xd9dc,
    0x2406,
]), X = exports.gf([
    0xd51a,
    0x8f25,
    0x2d60,
    0xc956,
    0xa7b2,
    0x9525,
    0xc760,
    0x692c,
    0xdc5c,
    0xfdd6,
    0xe231,
    0xc0a4,
    0x53fe,
    0xcd6e,
    0x36d3,
    0x2169,
]), Y = exports.gf([
    0x6658,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
]), I = exports.gf([
    0xa0b0,
    0x4a0e,
    0x1b27,
    0xc4ee,
    0xe478,
    0xad2f,
    0x1806,
    0x2f43,
    0xd7a7,
    0x3dfb,
    0x0099,
    0x2b4d,
    0xdf0b,
    0x4fc1,
    0x2480,
    0x2b83,
]);
const L = new Float64Array([
    0xed,
    0xd3,
    0xf5,
    0x5c,
    0x1a,
    0x63,
    0x12,
    0x58,
    0xd6,
    0x9c,
    0xf7,
    0xa2,
    0xde,
    0xf9,
    0xde,
    0x14,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0x10,
]);
const A = (o, a, b) => {
    for (let i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
    }
};
const Z = (o, a, b) => {
    for (let i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
    }
};
const M = (o, a, b) => {
    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0;
    const b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    // t15 left as is
    // first car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    // second car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
};
const S = (o, a) => {
    M(o, a, a);
};
const vn = (x, xi, y, yi, n) => {
    let i, d = 0;
    for (i = 0; i < n; i++) {
        d |= x[xi + i] ^ y[yi + i];
    }
    return (1 & ((d - 1) >>> 8)) - 1;
};
const pow2523 = (o, i) => {
    const c = exports.gf();
    let a;
    for (a = 0; a < 16; a++) {
        c[a] = i[a];
    }
    for (a = 250; a >= 0; a--) {
        S(c, c);
        if (a !== 1) {
            M(c, c, i);
        }
    }
    for (a = 0; a < 16; a++) {
        o[a] = c[a];
    }
};
const inv25519 = (o, i) => {
    const c = exports.gf();
    let a;
    for (a = 0; a < 16; a++) {
        c[a] = i[a];
    }
    for (a = 253; a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4) {
            M(c, c, i);
        }
    }
    for (a = 0; a < 16; a++) {
        o[a] = c[a];
    }
};
const set25519 = (r, a) => {
    let i;
    for (i = 0; i < 16; i++) {
        r[i] = a[i] | 0;
    }
};
const car25519 = (o) => {
    let i, v, c = 1;
    for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
};
const sel25519 = (p, q, b) => {
    let t, 
    // eslint-disable-next-line prefer-const
    c = ~(b - 1);
    for (let i = 0; i < 16; i++) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
    }
};
const pack25519 = (o, n) => {
    let i, j, b;
    const m = exports.gf(), t = exports.gf();
    for (i = 0; i < 16; i++) {
        t[i] = n[i];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for (j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;
        for (i = 1; i < 15; i++) {
            m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1);
            m[i - 1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1);
        b = (m[15] >> 16) & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
    }
    for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
    }
};
const cswap = (p, q, b) => {
    let i;
    for (i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
    }
};
const neq25519 = (a, b) => {
    const c = new Uint8Array(32), d = new Uint8Array(32);
    pack25519(c, a);
    pack25519(d, b);
    return exports.crypto_verify_32(c, 0, d, 0);
};
const par25519 = (a) => {
    const d = new Uint8Array(32);
    pack25519(d, a);
    return d[0] & 1;
};
const unpack25519 = (o, n) => {
    let i;
    for (i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    }
    o[15] &= 0x7fff;
};
exports.crypto_verify_32 = (x, xi, y, yi) => {
    return vn(x, xi, y, yi, 32);
};
exports.add = (p, q) => {
    const a = exports.gf(), b = exports.gf(), c = exports.gf(), d = exports.gf(), e = exports.gf(), f = exports.gf(), g = exports.gf(), h = exports.gf(), t = exports.gf();
    Z(a, p[1], p[0]);
    Z(t, q[1], q[0]);
    M(a, a, t);
    A(b, p[0], p[1]);
    A(t, q[0], q[1]);
    M(b, b, t);
    M(c, p[3], q[3]);
    M(c, c, D2);
    M(d, p[2], q[2]);
    A(d, d, d);
    Z(e, b, a);
    Z(f, d, c);
    A(g, d, c);
    A(h, b, a);
    M(p[0], e, f);
    M(p[1], h, g);
    M(p[2], g, f);
    M(p[3], e, h);
};
exports.pack = (r, p) => {
    const tx = exports.gf(), ty = exports.gf(), zi = exports.gf();
    inv25519(zi, p[2]);
    M(tx, p[0], zi);
    M(ty, p[1], zi);
    pack25519(r, ty);
    r[31] ^= par25519(tx) << 7;
};
exports.scalarmult = (p, q, s) => {
    let b, i;
    set25519(p[0], gf0);
    set25519(p[1], gf1);
    set25519(p[2], gf1);
    set25519(p[3], gf0);
    for (i = 255; i >= 0; --i) {
        b = (s[(i / 8) | 0] >> (i & 7)) & 1;
        cswap(p, q, b);
        exports.add(q, p);
        exports.add(p, p);
        cswap(p, q, b);
    }
};
exports.unpack = (r, p) => {
    const t = exports.gf(), chk = exports.gf(), num = exports.gf(), den = exports.gf(), den2 = exports.gf(), den4 = exports.gf(), den6 = exports.gf();
    set25519(r[2], gf1);
    unpack25519(r[1], p);
    // num = u = y^2 - 1
    // den = v = d * y^2 + 1
    S(num, r[1]);
    M(den, num, D);
    Z(num, num, r[2]);
    A(den, r[2], den);
    // r[0] = x = sqrt(u / v)
    S(den2, den);
    S(den4, den2);
    M(den6, den4, den2);
    M(t, den6, num);
    M(t, t, den);
    pow2523(t, t);
    M(t, t, num);
    M(t, t, den);
    M(t, t, den);
    M(r[0], t, den);
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) {
        M(r[0], r[0], I);
    }
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) {
        return -1;
    }
    if (par25519(r[0]) !== p[31] >> 7) {
        Z(r[0], gf0, r[0]);
    }
    M(r[3], r[0], r[1]);
    return 0;
};

},{}],557:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utilities = require("./Utilities");
class Base32 {
}
exports.Base32 = Base32;
/**
 * Base32 encodes a binary buffer.
 * @param {Uint8Array} data The binary data to encode.
 * @returns {string} The base32 encoded string corresponding to the input data.
 */
Base32.Base32Encode = (data) => {
    if (0 !== data.length % utilities.Decoded_Block_Size) {
        throw Error(`decoded size must be multiple of ${utilities.Decoded_Block_Size}`);
    }
    const output = new Array((data.length / utilities.Decoded_Block_Size) * utilities.Encoded_Block_Size);
    for (let i = 0; i < data.length / utilities.Decoded_Block_Size; ++i) {
        utilities.encodeBlock(data, i * utilities.Decoded_Block_Size, output, i * utilities.Encoded_Block_Size);
    }
    return output.join('');
};
/**
 * Base32 decodes a base32 encoded string.
 * @param {string} encoded The base32 encoded string to decode.
 * @returns {Uint8Array} The binary data corresponding to the input string.
 */
Base32.Base32Decode = (encoded) => {
    if (0 !== encoded.length % utilities.Encoded_Block_Size) {
        throw Error(`encoded size must be multiple of ${utilities.Encoded_Block_Size}`);
    }
    const output = new Uint8Array((encoded.length / utilities.Encoded_Block_Size) * utilities.Decoded_Block_Size);
    for (let i = 0; i < encoded.length / utilities.Encoded_Block_Size; ++i) {
        utilities.decodeBlock(encoded, i * utilities.Encoded_Block_Size, output, i * utilities.Decoded_Block_Size);
    }
    return output;
};

},{"./Utilities":564}],558:[function(require,module,exports){
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const utf8_1 = require("utf8");
const utilities = require("./Utilities");
class Convert {
    /**
     * Generate xor for two byte arrays and return in hex string
     * @param value1 - Value 1 bytes
     * @param value2  - Value 2 bytes
     * @return {string} - delta value in Hex
     */
    static xor(value1, value2) {
        const buffer1 = Buffer.from(value1.buffer);
        const buffer2 = Buffer.from(value2.buffer);
        const length = Math.max(buffer1.length, buffer2.length);
        const delta = [];
        for (let i = 0; i < length; ++i) {
            const xorBuffer = buffer1[i] ^ buffer2[i];
            delta.push(xorBuffer);
        }
        return Convert.uint8ToHex(Uint8Array.from(delta));
    }
    /**
     * It splits the number's bytes into a an array.
     * @param number the number
     * @param arraySize the expected size of the array.
     */
    static numberToUint8Array(number, arraySize) {
        const uint8Array = new Uint8Array(arraySize);
        for (let index = 0; index < uint8Array.length; index++) {
            const byte = number & 0xff;
            uint8Array[index] = byte;
            number = (number - byte) / 256;
        }
        return uint8Array;
    }
    /**
     * It creates a number from the bytes in the array.
     * @param array the number from the bytes.
     */
    static uintArray8ToNumber(array) {
        let value = 0;
        for (let index = 0; index < array.length; index++) {
            value += array[index] << (index * 8);
        }
        return value >>> 0;
    }
}
exports.Convert = Convert;
/**
 * Decodes two hex characters into a byte.
 * @param {string} char1 The first hex digit.
 * @param {string} char2 The second hex digit.
 * @returns {number} The decoded byte.
 */
Convert.toByte = (char1, char2) => {
    const byte = utilities.tryParseByte(char1, char2);
    if (undefined === byte) {
        throw Error(`unrecognized hex char`);
    }
    return byte;
};
/**
 * Determines whether or not a string is a hex string.
 * @param {string} input The string to test.
 * @returns {boolean} true if the input is a hex string, false otherwise.
 */
Convert.isHexString = (input) => {
    if (0 !== input.length % 2) {
        return false;
    }
    for (let i = 0; i < input.length; i += 2) {
        if (undefined === utilities.tryParseByte(input[i], input[i + 1])) {
            return false;
        }
    }
    return true;
};
/**
 * Converts a hex string to a uint8 array.
 * @param {string} input A hex encoded string.
 * @returns {Uint8Array} A uint8 array corresponding to the input.
 */
Convert.hexToUint8 = (input) => {
    if (0 !== input.length % 2) {
        throw Error(`hex string has unexpected size '${input.length}'`);
    }
    const output = new Uint8Array(input.length / 2);
    for (let i = 0; i < input.length; i += 2) {
        output[i / 2] = Convert.toByte(input[i], input[i + 1]);
    }
    return output;
};
/**
 * Reversed convertion hex string to a uint8 array.
 * @param {string} input A hex encoded string.
 * @returns {Uint8Array} A uint8 array corresponding to the input.
 */
Convert.hexToUint8Reverse = (input) => {
    if (0 !== input.length % 2) {
        throw Error(`hex string has unexpected size '${input.length}'`);
    }
    const output = new Uint8Array(input.length / 2);
    for (let i = 0; i < input.length; i += 2) {
        output[output.length - 1 - i / 2] = Convert.toByte(input[i], input[i + 1]);
    }
    return output;
};
/**
 * Converts a uint8 array to a hex string.
 * @param {Uint8Array} input A uint8 array.
 * @returns {string} A hex encoded string corresponding to the input.
 */
Convert.uint8ToHex = (input) => {
    let s = '';
    for (const byte of input) {
        s += utilities.Nibble_To_Char_Map[byte >> 4];
        s += utilities.Nibble_To_Char_Map[byte & 0x0f];
    }
    return s;
};
/**
 * Converts a uint8 array to a uint32 array.
 * @param {Uint8Array} input A uint8 array.
 * @returns {Uint32Array} A uint32 array created from the input.
 */
Convert.uint8ToUint32 = (input) => new Uint32Array(input.buffer);
/**
 * Converts a uint32 array to a uint8 array.
 * @param {Uint32Array} input A uint32 array.
 * @returns {Uint8Array} A uint8 array created from the input.
 */
Convert.uint32ToUint8 = (input) => new Uint8Array(input.buffer);
/** Converts an unsigned byte to a signed byte with the same binary representation.
 * @param {number} input An unsigned byte.
 * @returns {number} A signed byte with the same binary representation as the input.
 *
 */
Convert.uint8ToInt8 = (input) => {
    if (0xff < input) {
        throw Error(`input '${input}' is out of range`);
    }
    return (input << 24) >> 24;
};
/** Converts a signed byte to an unsigned byte with the same binary representation.
 * @param {number} input A signed byte.
 * @returns {number} An unsigned byte with the same binary representation as the input.
 */
Convert.int8ToUint8 = (input) => {
    if (127 < input || -128 > input) {
        throw Error(`input '${input}' is out of range`);
    }
    return input & 0xff;
};
/**
 * Converts a raw javascript string into a string of single byte characters using utf8 encoding.
 * This makes it easier to perform other encoding operations on the string.
 * @param {string} input - A raw string
 * @return {string} - UTF-8 string
 */
Convert.rstr2utf8 = (input) => {
    let output = '';
    for (let n = 0; n < input.length; n++) {
        const c = input.charCodeAt(n);
        if (128 > c) {
            output += String.fromCharCode(c);
        }
        else if (127 < c && 2048 > c) {
            output += String.fromCharCode((c >> 6) | 192);
            output += String.fromCharCode((c & 63) | 128);
        }
        else {
            output += String.fromCharCode((c >> 12) | 224);
            output += String.fromCharCode(((c >> 6) & 63) | 128);
            output += String.fromCharCode((c & 63) | 128);
        }
    }
    return output;
};
/**
 * Convert UTF-8 to hex
 * @param {string} input - An UTF-8 string
 * @return {string}
 */
Convert.utf8ToHex = (input) => {
    return Buffer.from(input, 'utf-8').toString('hex').toUpperCase();
};
/**
 * Convert UTF-8 string to Uint8Array
 * @param {string} input - An string with UTF-8 encoding
 * @return {Uint8Array}
 */
Convert.utf8ToUint8 = (input) => {
    const hex = Convert.utf8ToHex(Convert.rstr2utf8(input));
    return Convert.hexToUint8(hex);
};
/**
 * Convert Uint8Array to string with UTF-8 encoding
 * @param {Uint8Array} input - An UTF-8 string
 * @return {string}
 */
Convert.uint8ToUtf8 = (input) => {
    // return new TextDecoder().decode(input);
    const hex = Convert.uint8ToHex(input);
    return Convert.decodeHex(hex);
};
/**
 * decode hex to uft8 string
 * @param hex - Hex input
 * @returns {string}
 */
Convert.decodeHex = (hex) => {
    let str = '';
    for (let i = 0; i < hex.length; i += 2) {
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    }
    try {
        return utf8_1.decode(str);
    }
    catch (e) {
        return str;
    }
};

}).call(this,require("buffer").Buffer)
},{"./Utilities":564,"buffer":47,"utf8":1159}],559:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const js_sha3_1 = require("js-sha3");
const utilities = require("./Utilities");
class IdGenerator {
}
exports.IdGenerator = IdGenerator;
/**
 * Generates a mosaic id given a nonce and a address.
 * @param {object} nonce The mosaic nonce.
 * @param {object} ownerAddress The address.
 * @returns {module:coders/uint64~uint64} The mosaic id.
 */
IdGenerator.generateMosaicId = (nonce, ownerAddress) => {
    const hash = js_sha3_1.sha3_256.create();
    hash.update(nonce);
    hash.update(ownerAddress);
    const result = new Uint32Array(hash.arrayBuffer());
    return [result[0], result[1] & 0x7fffffff];
};
/**
 * Parses a unified namespace name into a path.
 * @param {string} name The unified namespace name.
 * @returns {array<module:coders/uint64~uint64>} The namespace path.
 */
IdGenerator.generateNamespacePath = (name) => {
    if (0 >= name.length) {
        utilities.throwInvalidFqn('having zero length', name);
    }
    let namespaceId = utilities.idGeneratorConst.namespace_base_id;
    const path = [];
    const start = utilities.split(name, (substringStart, size) => {
        namespaceId = utilities.generateNamespaceId(namespaceId, utilities.extractPartName(name, substringStart, size));
        utilities.append(path, namespaceId);
    });
    namespaceId = utilities.generateNamespaceId(namespaceId, utilities.extractPartName(name, start, name.length - start));
    utilities.append(path, namespaceId);
    return path;
};

},{"./Utilities":564,"js-sha3":"/node_modules/js-sha3"}],560:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const js_sha3_1 = require("js-sha3");
const UInt64_1 = require("../../model/UInt64");
class KeyGenerator {
    /**
     * Generate UInt64 from a string
     * @param {string} input Input string
     * @returns {UInt64} Deterministic uint64 value for the given string
     */
    static generateUInt64Key(input) {
        if (input.length === 0) {
            throw Error(`Input must not be empty`);
        }
        const buf = js_sha3_1.sha3_256.arrayBuffer(input);
        const result = new Uint32Array(buf);
        return new UInt64_1.UInt64([result[0], (result[1] | 0x80000000) >>> 0]);
    }
}
exports.KeyGenerator = KeyGenerator;

},{"../../model/UInt64":609,"js-sha3":"/node_modules/js-sha3"}],561:[function(require,module,exports){
(function (Buffer){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const js_sha3_1 = require("js-sha3");
const ripemd160 = require("ripemd160");
const Base32_1 = require("./Base32");
const Convert_1 = require("./Convert");
const RawArray_1 = require("./RawArray");
class RawAddress {
}
exports.RawAddress = RawAddress;
RawAddress.constants = {
    sizes: {
        ripemd160: 20,
        addressDecoded: 24,
        addressEncoded: 39,
        key: 32,
        checksum: 3,
    },
};
/**
 * Converts an encoded address string to a decoded address.
 * @param {string} encoded The encoded address string.
 * @returns {Uint8Array} The decoded address corresponding to the input.
 */
RawAddress.stringToAddress = (encoded) => {
    if (RawAddress.constants.sizes.addressEncoded !== encoded.length) {
        throw Error(`${encoded} does not represent a valid encoded address`);
    }
    return Base32_1.Base32.Base32Decode(`${encoded}A`).subarray(0, RawAddress.constants.sizes.addressDecoded);
};
/**
 * Format a namespaceId *alias* into a valid recipient field value.
 * @param {Uint8Array} namespaceId The namespaceId
 * @param {networkType} the network type serialized in the output.
 * @returns {Uint8Array} The padded notation of the alias
 */
RawAddress.aliasToRecipient = (namespaceId, networkType) => {
    // 0x91 | namespaceId on 8 bytes | 15 bytes 0-pad = 24 bytes
    const padded = new Uint8Array(1 + 8 + 15);
    padded.set([networkType.valueOf() | 0x01], 0);
    padded.set(namespaceId.reverse(), 1);
    padded.set(Convert_1.Convert.hexToUint8('00'.repeat(15)), 9);
    return padded;
};
/**
 * Converts a decoded address to an encoded address string.
 * @param {Uint8Array} decoded The decoded address.
 * @returns {string} The encoded address string corresponding to the input.
 */
RawAddress.addressToString = (decoded) => {
    if (RawAddress.constants.sizes.addressDecoded !== decoded.length) {
        throw Error(`${Convert_1.Convert.uint8ToHex(decoded)} does not represent a valid decoded address`);
    }
    const padded = new Uint8Array(RawAddress.constants.sizes.addressDecoded + 1);
    padded.set(decoded);
    return Base32_1.Base32.Base32Encode(padded).slice(0, -1);
};
/**
 * Converts a public key to a decoded address for a specific network.
 * @param {Uint8Array} publicKey The public key.
 * @param {NetworkType} networkType The network identifier.
 * @returns {Uint8Array} The decoded address corresponding to the inputs.
 */
RawAddress.publicKeyToAddress = (publicKey, networkType) => {
    // step 1: sha3 hash of the public key
    const publicKeyHash = js_sha3_1.sha3_256.arrayBuffer(publicKey);
    // step 2: ripemd160 hash of (1)
    const ripemdHash = new ripemd160().update(new Buffer(publicKeyHash)).digest();
    // step 3: add network identifier byte in front of (2)
    const decodedAddress = new Uint8Array(RawAddress.constants.sizes.addressDecoded);
    decodedAddress[0] = networkType;
    RawArray_1.RawArray.copy(decodedAddress, ripemdHash, RawAddress.constants.sizes.ripemd160, 1);
    // step 4: concatenate (3) and the checksum of (3)
    const hash = js_sha3_1.sha3_256.arrayBuffer(decodedAddress.subarray(0, RawAddress.constants.sizes.ripemd160 + 1));
    RawArray_1.RawArray.copy(decodedAddress, RawArray_1.RawArray.uint8View(hash), RawAddress.constants.sizes.checksum, RawAddress.constants.sizes.ripemd160 + 1);
    return decodedAddress;
};
/**
 * Determines the validity of a decoded address.
 * @param {Uint8Array} decoded The decoded address.
 * @returns {boolean} true if the decoded address is valid, false otherwise.
 */
RawAddress.isValidAddress = (decoded) => {
    if (RawAddress.constants.sizes.addressDecoded !== decoded.length) {
        return false;
    }
    const hash = js_sha3_1.sha3_256.create();
    const checksumBegin = RawAddress.constants.sizes.addressDecoded - RawAddress.constants.sizes.checksum;
    hash.update(decoded.subarray(0, checksumBegin));
    const checksum = new Uint8Array(RawAddress.constants.sizes.checksum);
    RawArray_1.RawArray.copy(checksum, RawArray_1.RawArray.uint8View(hash.arrayBuffer()), RawAddress.constants.sizes.checksum);
    return RawArray_1.RawArray.deepEqual(checksum, decoded.subarray(checksumBegin));
};

}).call(this,require("buffer").Buffer)
},{"./Base32":557,"./Convert":558,"./RawArray":562,"buffer":47,"js-sha3":"/node_modules/js-sha3","ripemd160":351}],562:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class RawArray {
}
exports.RawArray = RawArray;
/**
 * Creates a Uint8Array view on top of input.
 * @param {ArrayBuffer|Uint8Array} input The input array.
 * @returns {Uint8Array} A Uint8Array view on top of input.
 */
RawArray.uint8View = (input) => {
    if (ArrayBuffer === input.constructor) {
        return new Uint8Array(input);
    }
    else if (Uint8Array === input.constructor) {
        return input;
    }
    throw Error('unsupported type passed to uint8View');
};
/**
 * Copies elements from a source array to a destination array.
 * @param {Array} dest The destination array.
 * @param {Array} src The source array.
 * @param {number} [numElementsToCopy=undefined] The number of elements to copy.
 * @param {number} [destOffset=0] The first index of the destination to write.
 * @param {number} [srcOffset=0] The first index of the source to read.
 */
RawArray.copy = (dest, src, numElementsToCopy, destOffset = 0, srcOffset = 0) => {
    const length = undefined === numElementsToCopy ? dest.length : numElementsToCopy;
    for (let i = 0; i < length; ++i) {
        dest[destOffset + i] = src[srcOffset + i];
    }
};
/**
 * Determines whether or not an array is zero-filled.
 * @param {Array} array The array to check.
 * @returns {boolean} true if the array is zero-filled, false otherwise.
 */
RawArray.isZeroFilled = (array) => array.every((value) => 0 === value);
/**
 * Deeply checks the equality of two arrays.
 * @param {Array} lhs First array to compare.
 * @param {Array} rhs Second array to compare.
 * @param {number} [numElementsToCompare=undefined] The number of elements to compare.
 * @returns {boolean} true if all compared elements are equal, false otherwise.
 */
RawArray.deepEqual = (lhs, rhs, numElementsToCompare) => {
    let length = numElementsToCompare;
    if (undefined === length) {
        if (lhs.length !== rhs.length) {
            return false;
        }
        length = lhs.length;
    }
    if (length > lhs.length || length > rhs.length) {
        return false;
    }
    for (let i = 0; i < length; ++i) {
        if (lhs[i] !== rhs[i]) {
            return false;
        }
    }
    return true;
};

},{}],563:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Convert_1 = require("./Convert");
class RawUInt64 {
}
exports.RawUInt64 = RawUInt64;
RawUInt64.readUint32At = (bytes, i) => (bytes[i] + (bytes[i + 1] << 8) + (bytes[i + 2] << 16) + (bytes[i + 3] << 24)) >>> 0;
/**
 * An exact uint64 representation composed of two 32bit values.
 * @typedef {Array} uint64
 * @property {number} 0 The low 32bit value.
 * @property {number} 1 The high 32bit value.
 */
/**
 * Tries to compact a uint64 into a simple numeric.
 * @param {module:coders/uint64~uint64} uint64 A uint64 value.
 * @returns {number|module:coders/uint64~uint64}
 * A numeric if the uint64 is no greater than Number.MAX_SAFE_INTEGER or the original uint64 value otherwise.
 */
RawUInt64.compact = (uint64) => {
    const low = uint64[0];
    const high = uint64[1];
    // don't compact if the value is >= 2^53
    if (0x00200000 <= high) {
        return uint64;
    }
    // multiply because javascript bit operations operate on 32bit values
    return high * 0x100000000 + low;
};
/**
 * Converts a numeric unsigned integer into a uint64.
 * @param {number} number The unsigned integer.
 * @returns {module:coders/uint64~uint64} The uint64 representation of the input.
 */
RawUInt64.fromUint = (number) => {
    const value = [(number & 0xffffffff) >>> 0, (number / 0x100000000) >>> 0];
    return value;
};
/**
 * Converts a (64bit) uint8 array into a uint64.
 * @param {Uint8Array} uint8Array A uint8 array.
 * @returns {module:coders/uint64~uint64} The uint64 representation of the input.
 */
RawUInt64.fromBytes = (uint8Array) => {
    if (8 !== uint8Array.length) {
        throw Error(`byte array has unexpected size '${uint8Array.length}'`);
    }
    return [RawUInt64.readUint32At(uint8Array, 0), RawUInt64.readUint32At(uint8Array, 4)];
};
/**
 * Converts a (32bit) uint8 array into a uint64.
 * @param {Uint8Array} uint8Array A uint8 array.
 * @returns {module:coders/uint64~uint64} The uint64 representation of the input.
 */
RawUInt64.fromBytes32 = (uint8Array) => {
    if (4 !== uint8Array.length) {
        throw Error(`byte array has unexpected size '${uint8Array.length}'`);
    }
    return [RawUInt64.readUint32At(uint8Array, 0), 0];
};
/**
 * Parses a hex string into a uint64.
 * @param {string} input A hex encoded string.
 * @returns {module:coders/uint64~uint64} The uint64 representation of the input.
 */
RawUInt64.fromHex = (input) => {
    if (16 !== input.length) {
        throw Error(`hex string has unexpected size '${input.length}'`);
    }
    let hexString = input;
    if (16 > hexString.length) {
        hexString = '0'.repeat(16 - hexString.length) + hexString;
    }
    const uint8Array = Convert_1.Convert.hexToUint8(hexString);
    const view = new DataView(uint8Array.buffer);
    return [view.getUint32(4), view.getUint32(0)];
};
/**
 * Converts a uint64 into a hex string.
 * @param {module:coders/uint64~uint64} uint64 A uint64 value.
 * @returns {string} A hex encoded string representing the uint64.
 */
RawUInt64.toHex = (uint64) => {
    const uint32Array = new Uint32Array(uint64);
    const uint8Array = Convert_1.Convert.uint32ToUint8(uint32Array).reverse();
    return Convert_1.Convert.uint8ToHex(uint8Array);
};
/**
 * Returns true if a uint64 is zero.
 * @param {module:coders/uint64~uint64} uint64 A uint64 value.
 * @returns {boolean} true if the value is zero.
 */
RawUInt64.isZero = (uint64) => 0 === uint64[0] && 0 === uint64[1];

},{"./Convert":558}],564:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const js_sha3_1 = require("js-sha3");
exports.createBuilder = () => {
    const map = {};
    return {
        map,
        /**
         * Adds a range mapping to the map.
         * @param {string} start The start character.
         * @param {string} end The end character.
         * @param {number} base The value corresponding to the start character.
         * @memberof module:utils/charMapping~CharacterMapBuilder
         * @instance
         */
        addRange: (start, end, base) => {
            const startCode = start.charCodeAt(0);
            const endCode = end.charCodeAt(0);
            for (let code = startCode; code <= endCode; ++code) {
                map[String.fromCharCode(code)] = code - startCode + base;
            }
        },
    };
};
const Char_To_Nibble_Map = () => {
    const builder = exports.createBuilder();
    builder.addRange('0', '9', 0);
    builder.addRange('a', 'f', 10);
    builder.addRange('A', 'F', 10);
    return builder.map;
};
const Char_To_Digit_Map = () => {
    const builder = exports.createBuilder();
    builder.addRange('0', '9', 0);
    return builder.map;
};
exports.Nibble_To_Char_Map = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];
exports.Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
exports.Decoded_Block_Size = 5;
exports.Encoded_Block_Size = 8;
exports.tryParseByte = (char1, char2) => {
    const charMap = Char_To_Nibble_Map();
    const nibble1 = charMap[char1];
    const nibble2 = charMap[char2];
    return undefined === nibble1 || undefined === nibble2 ? undefined : (nibble1 << 4) | nibble2;
};
/**
 * Tries to parse a string representing an unsigned integer.
 * @param {string} str The string to parse.
 * @returns { number | undefined} The number represented by the input or undefined.
 */
exports.tryParseUint = (str) => {
    if ('0' === str) {
        return 0;
    }
    let value = 0;
    for (const char of str) {
        const charMap = Char_To_Digit_Map();
        const digit = charMap[char];
        if (undefined === digit || (0 === value && 0 === digit)) {
            return undefined;
        }
        value *= 10;
        value += digit;
        if (value > Number.MAX_SAFE_INTEGER) {
            return undefined;
        }
    }
    return value;
};
exports.idGeneratorConst = {
    namespace_base_id: [0, 0],
    name_pattern: /^[a-z0-9][a-z0-9-_]*$/,
};
exports.throwInvalidFqn = (reason, name) => {
    throw Error(`fully qualified id is invalid due to ${reason} (${name})`);
};
exports.extractPartName = (name, start, size) => {
    if (0 === size) {
        this.throwInvalidFqn('empty part', name);
    }
    const partName = name.substr(start, size);
    if (!exports.idGeneratorConst.name_pattern.test(partName)) {
        this.throwInvalidFqn(`invalid part name [${partName}]`, name);
    }
    return partName;
};
exports.append = (path, id) => {
    path.push(id);
};
exports.split = (name, processor) => {
    let start = 0;
    for (let index = 0; index < name.length; ++index) {
        if ('.' === name[index]) {
            processor(start, index - start);
            start = index + 1;
        }
    }
    return start;
};
exports.generateNamespaceId = (parentId, name) => {
    const hash = js_sha3_1.sha3_256.create();
    hash.update(Uint32Array.from(parentId).buffer);
    hash.update(name);
    const result = new Uint32Array(hash.arrayBuffer());
    // right zero-filling required to keep unsigned number representation
    return [result[0], (result[1] | 0x80000000) >>> 0];
};
exports.encodeBlock = (input, inputOffset, output, outputOffset) => {
    output[outputOffset + 0] = exports.Alphabet[input[inputOffset + 0] >> 3];
    output[outputOffset + 1] = exports.Alphabet[((input[inputOffset + 0] & 0x07) << 2) | (input[inputOffset + 1] >> 6)];
    output[outputOffset + 2] = exports.Alphabet[(input[inputOffset + 1] & 0x3e) >> 1];
    output[outputOffset + 3] = exports.Alphabet[((input[inputOffset + 1] & 0x01) << 4) | (input[inputOffset + 2] >> 4)];
    output[outputOffset + 4] = exports.Alphabet[((input[inputOffset + 2] & 0x0f) << 1) | (input[inputOffset + 3] >> 7)];
    output[outputOffset + 5] = exports.Alphabet[(input[inputOffset + 3] & 0x7f) >> 2];
    output[outputOffset + 6] = exports.Alphabet[((input[inputOffset + 3] & 0x03) << 3) | (input[inputOffset + 4] >> 5)];
    output[outputOffset + 7] = exports.Alphabet[input[inputOffset + 4] & 0x1f];
};
exports.Char_To_Decoded_Char_Map = () => {
    const builder = exports.createBuilder();
    builder.addRange('A', 'Z', 0);
    builder.addRange('2', '7', 26);
    return builder.map;
};
exports.decodeChar = (c) => {
    const charMap = exports.Char_To_Decoded_Char_Map();
    const decodedChar = charMap[c];
    if (undefined !== decodedChar) {
        return decodedChar;
    }
    throw Error(`illegal base32 character ${c}`);
};
exports.decodeBlock = (input, inputOffset, output, outputOffset) => {
    const bytes = new Uint8Array(exports.Encoded_Block_Size);
    for (let i = 0; i < exports.Encoded_Block_Size; ++i) {
        bytes[i] = exports.decodeChar(input[inputOffset + i]);
    }
    output[outputOffset + 0] = (bytes[0] << 3) | (bytes[1] >> 2);
    output[outputOffset + 1] = ((bytes[1] & 0x03) << 6) | (bytes[2] << 1) | (bytes[3] >> 4);
    output[outputOffset + 2] = ((bytes[3] & 0x0f) << 4) | (bytes[4] >> 1);
    output[outputOffset + 3] = ((bytes[4] & 0x01) << 7) | (bytes[5] << 2) | (bytes[6] >> 3);
    output[outputOffset + 4] = ((bytes[6] & 0x07) << 5) | bytes[7];
};

},{"js-sha3":"/node_modules/js-sha3"}],565:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./RawAddress"));
__export(require("./RawArray"));
__export(require("./Convert"));
__export(require("./IdGenerator"));
__export(require("./KeyGenerator"));
__export(require("./RawUInt64"));

},{"./Convert":558,"./IdGenerator":559,"./KeyGenerator":560,"./RawAddress":561,"./RawArray":562,"./RawUInt64":563}],566:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Address_1 = require("../../model/account/Address");
const MosaicId_1 = require("../../model/mosaic/MosaicId");
const AccountRestriction_1 = require("../../model/restriction/AccountRestriction");
const AccountRestrictions_1 = require("../../model/restriction/AccountRestrictions");
const AccountRestrictionsInfo_1 = require("../../model/restriction/AccountRestrictionsInfo");
const AddressRestrictionFlag_1 = require("../../model/restriction/AddressRestrictionFlag");
const MosaicRestrictionFlag_1 = require("../../model/restriction/MosaicRestrictionFlag");
const OperationRestrictionFlag_1 = require("../../model/restriction/OperationRestrictionFlag");
class DtoMapping {
    /**
     * Create AccountRestrictionsInfo class from Json.
     * @param {object} dataJson The account restriction json object.
     * @returns {module: model/Account/AccountRestrictionsInfo} The AccountRestrictionsInfo class.
     */
    static extractAccountRestrictionFromDto(accountRestrictions) {
        return new AccountRestrictionsInfo_1.AccountRestrictionsInfo(accountRestrictions.meta, new AccountRestrictions_1.AccountRestrictions(Address_1.Address.createFromEncoded(accountRestrictions.accountRestrictions.address), accountRestrictions.accountRestrictions.restrictions.map((prop) => {
            switch (prop.restrictionFlags) {
                case AddressRestrictionFlag_1.AddressRestrictionFlag.AllowIncomingAddress:
                case AddressRestrictionFlag_1.AddressRestrictionFlag.BlockIncomingAddress:
                case AddressRestrictionFlag_1.AddressRestrictionFlag.AllowOutgoingAddress:
                case AddressRestrictionFlag_1.AddressRestrictionFlag.BlockOutgoingAddress:
                    return new AccountRestriction_1.AccountRestriction(prop.restrictionFlags, prop.values.map((value) => Address_1.Address.createFromEncoded(value)));
                case MosaicRestrictionFlag_1.MosaicRestrictionFlag.AllowMosaic:
                case MosaicRestrictionFlag_1.MosaicRestrictionFlag.BlockMosaic:
                    return new AccountRestriction_1.AccountRestriction(prop.restrictionFlags, prop.values.map((value) => new MosaicId_1.MosaicId(value)));
                case OperationRestrictionFlag_1.OperationRestrictionFlag.AllowOutgoingTransactionType:
                case OperationRestrictionFlag_1.OperationRestrictionFlag.BlockOutgoingTransactionType:
                    return new AccountRestriction_1.AccountRestriction(prop.restrictionFlags, prop.values);
                default:
                    throw new Error(`Invalid restriction type: ${prop.restrictionFlags}`);
            }
        })));
    }
    /**
     * Creates a copy of the first object adding the attributes of the second object.
     * @param object the object to be cloned
     * @param attributes the extra attributes to be added to the object.
     * @returns a copy of the first object with the new attributes added.
     */
    static assign(object, attributes) {
        return Object.assign({ __proto__: Object.getPrototypeOf(object) }, object, attributes);
    }
    /**
     * Map one enum type to another by value
     * @param value enum value to be mapped
     */
    static mapEnum(value) {
        return value;
    }
}
exports.DtoMapping = DtoMapping;

},{"../../model/account/Address":618,"../../model/mosaic/MosaicId":642,"../../model/restriction/AccountRestriction":697,"../../model/restriction/AccountRestrictions":699,"../../model/restriction/AccountRestrictionsInfo":700,"../../model/restriction/AddressRestrictionFlag":701,"../../model/restriction/MosaicRestrictionFlag":706,"../../model/restriction/OperationRestrictionFlag":708}],567:[function(require,module,exports){
(function (Buffer){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const js_sha3_1 = require("js-sha3");
const LockHashAlgorithm_1 = require("../../model/transaction/LockHashAlgorithm");
const ripemd160 = require("ripemd160");
const js_sha256_1 = require("js-sha256");
/**
 * Hash utilities for SecretLock hashing
 */
class LockHashUtils {
    /**
     * Perform SHA3_256 hash
     * @param input buffer to be hashed
     * @returns {string} Hash in hexidecimal format
     */
    static Op_Sha3_256(input) {
        return js_sha3_1.sha3_256.create().update(input).hex().toUpperCase();
    }
    /**
     * Perform SHA256 hash
     * @param input buffer to be hashed
     * @returns {string} Hash in hexidecimal format
     */
    static Op_Hash_256(input) {
        const hash = js_sha256_1.sha256(input);
        return js_sha256_1.sha256(Buffer.from(hash, 'hex')).toUpperCase();
    }
    /**
     * Perform ripemd160 hash
     * @param input buffer to be hashed
     * @returns {string} Hash in hexidecimal format
     */
    static Op_Hash_160(input) {
        const sha256Hash = js_sha256_1.sha256(input);
        return new ripemd160().update(Buffer.from(sha256Hash, 'hex')).digest('hex').toUpperCase();
    }
    /**
     * Perform hash for SecretLock with proficed hash algorithm
     * @param hashAlgorithm Hash algorithm
     * @param input buffer to be hashed
     * @returns {string} Hash in hexidecimal format
     */
    static Hash(hashAlgorithm, input) {
        switch (hashAlgorithm) {
            case LockHashAlgorithm_1.LockHashAlgorithm.Op_Hash_160:
                return LockHashUtils.Op_Hash_160(input);
            case LockHashAlgorithm_1.LockHashAlgorithm.Op_Hash_256:
                return LockHashUtils.Op_Hash_256(input);
            case LockHashAlgorithm_1.LockHashAlgorithm.Op_Sha3_256:
                return LockHashUtils.Op_Sha3_256(input);
            default:
                throw new Error('HashAlgorithm is invalid.');
        }
    }
}
exports.LockHashUtils = LockHashUtils;

}).call(this,require("buffer").Buffer)
},{"../../model/transaction/LockHashAlgorithm":728,"buffer":47,"js-sha256":347,"js-sha3":"/node_modules/js-sha3","ripemd160":351}],568:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const CreateTransactionFromDTO_1 = require("../../infrastructure/transaction/CreateTransactionFromDTO");
const CreateTransactionFromPayload_1 = require("../../infrastructure/transaction/CreateTransactionFromPayload");
class TransactionMapping {
    /**
     * Create transaction class from Json.
     * @param {object} dataJson The transaction json object.
     * @returns {module: model/transaction/transaction} The transaction class.
     */
    static createFromDTO(dataJson) {
        return CreateTransactionFromDTO_1.CreateTransactionFromDTO(dataJson);
    }
    /**
     * Create transaction class from payload binary.
     * @param {string} payload The transaction binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction} The transaction class.
     */
    static createFromPayload(payload, isEmbedded = false) {
        return CreateTransactionFromPayload_1.CreateTransactionFromPayload(payload, isEmbedded);
    }
}
exports.TransactionMapping = TransactionMapping;

},{"../../infrastructure/transaction/CreateTransactionFromDTO":604,"../../infrastructure/transaction/CreateTransactionFromPayload":605}],569:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Address_1 = require("../../model/account/Address");
const MosaicId_1 = require("../../model/mosaic/MosaicId");
const NamespaceId_1 = require("../../model/namespace/NamespaceId");
const Convert_1 = require("../format/Convert");
const RawAddress_1 = require("../format/RawAddress");
/**
 * @internal
 */
class UnresolvedMapping {
    /**
     * @internal
     * Map unresolved mosaic string to MosaicId or NamespaceId
     * @param {string} mosaicId The unresolvedMosaic id in hex.
     * @returns {UnresolvedMosaicId}
     */
    static toUnresolvedMosaic(mosaicId) {
        if (!Convert_1.Convert.isHexString(mosaicId)) {
            throw new Error('Input string is not in valid hexadecimal notation.');
        }
        const bytes = Convert_1.Convert.hexToUint8(mosaicId);
        const byte0 = bytes[0];
        // if most significant bit of byte 0 is set, then we have a namespaceId
        if ((byte0 & 128) === 128) {
            return NamespaceId_1.NamespaceId.createFromEncoded(mosaicId);
        }
        // most significant bit of byte 0 is not set => mosaicId
        return new MosaicId_1.MosaicId(mosaicId);
    }
    /**
     * Map unresolved address string to Address or NamespaceId
     * @param {string} address The unresolved address in hex
     * @returns {UnresolvedAddress}
     */
    static toUnresolvedAddress(address) {
        if (!Convert_1.Convert.isHexString(address)) {
            throw new Error('Input string is not in valid hexadecimal notation.');
        }
        // If bit 0 of byte 0 is not set (like in 0x90), then it is a regular address.
        // Else (e.g. 0x91) it represents a namespace id which starts at byte 1.
        const bit0 = Convert_1.Convert.hexToUint8(address.substr(1, 2))[0];
        if ((bit0 & 16) === 16) {
            // namespaceId encoded hexadecimal notation provided
            // only 8 bytes are relevant to resolve the NamespaceId
            const relevantPart = address.substr(2, 16);
            return NamespaceId_1.NamespaceId.createFromEncoded(Convert_1.Convert.uint8ToHex(Convert_1.Convert.hexToUint8Reverse(relevantPart)));
        }
        // read address from encoded hexadecimal notation
        return Address_1.Address.createFromEncoded(address);
    }
    /**
     * Return unresolved address bytes of the unresolved address
     * @internal
     * @param {UnresolvedAddress} unresolvedAddress The unresolved address
     * @param {networkType} networkType the network type serialized in the output.
     * @return {Uint8Array}
     */
    static toUnresolvedAddressBytes(unresolvedAddress, networkType) {
        if (unresolvedAddress instanceof NamespaceId_1.NamespaceId) {
            // received hexadecimal notation of namespaceId (alias)
            return RawAddress_1.RawAddress.aliasToRecipient(Convert_1.Convert.hexToUint8(unresolvedAddress.toHex()), networkType);
        }
        else {
            // received recipient address
            return RawAddress_1.RawAddress.stringToAddress(unresolvedAddress.plain());
        }
    }
}
exports.UnresolvedMapping = UnresolvedMapping;

},{"../../model/account/Address":618,"../../model/mosaic/MosaicId":642,"../../model/namespace/NamespaceId":656,"../format/Convert":558,"../format/RawAddress":561}],570:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./TransactionMapping"));
__export(require("./DtoMapping"));
__export(require("./LockHashUtils"));

},{"./DtoMapping":566,"./LockHashUtils":567,"./TransactionMapping":568}],571:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const AccountInfo_1 = require("../model/account/AccountInfo");
const ActivityBucket_1 = require("../model/account/ActivityBucket");
const Address_1 = require("../model/account/Address");
const Mosaic_1 = require("../model/mosaic/Mosaic");
const MosaicId_1 = require("../model/mosaic/MosaicId");
const UInt64_1 = require("../model/UInt64");
const Http_1 = require("./Http");
const SupplementalPublicKeys_1 = require("../model/account/SupplementalPublicKeys");
const AccountLinkPublicKey_1 = require("../model/account/AccountLinkPublicKey");
const AccountLinkVotingKey_1 = require("../model/account/AccountLinkVotingKey");
const DtoMapping_1 = require("../core/utils/DtoMapping");
/**
 * Account http repository.
 *
 * @since 1.0
 */
class AccountHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, fetchApi) {
        super(url, fetchApi);
        this.accountRoutesApi = new symbol_openapi_typescript_fetch_client_1.AccountRoutesApi(this.config());
    }
    /**
     * Gets an AccountInfo for an account.
     * @param address Address
     * @returns Observable<AccountInfo>
     */
    getAccountInfo(address) {
        return this.call(this.accountRoutesApi.getAccountInfo(address.plain()), (body) => this.toAccountInfo(body));
    }
    /**
     * Gets AccountsInfo for different accounts.
     * @param addresses List of Address
     * @returns Observable<AccountInfo[]>
     */
    getAccountsInfo(addresses) {
        const accountIds = {
            addresses: addresses.map((address) => address.plain()),
        };
        return this.call(this.accountRoutesApi.getAccountsInfo(accountIds), (body) => body.map(this.toAccountInfo));
    }
    /**
     * Gets an array of accounts.
     * @param criteria - Account search criteria
     * @returns Observable<Page<AccountInfo>>
     */
    search(criteria) {
        var _a;
        return this.call(this.accountRoutesApi.searchAccounts(criteria.pageSize, criteria.pageNumber, criteria.offset, DtoMapping_1.DtoMapping.mapEnum(criteria.order), DtoMapping_1.DtoMapping.mapEnum(criteria.orderBy), (_a = criteria.mosaicId) === null || _a === void 0 ? void 0 : _a.toHex()), (body) => super.toPage(body.pagination, body.data, this.toAccountInfo));
    }
    /**
     * This method maps a AccountInfoDTO from rest to the SDK's AccountInfo model object.
     *
     * @internal
     * @param {AccountInfoDTO} dto AccountInfoDTO the dto object from rest.
     * @returns AccountInfo model
     */
    toAccountInfo(dto) {
        var _a, _b, _c, _d;
        return new AccountInfo_1.AccountInfo(Address_1.Address.createFromEncoded(dto.account.address), UInt64_1.UInt64.fromNumericString(dto.account.addressHeight), dto.account.publicKey, UInt64_1.UInt64.fromNumericString(dto.account.publicKeyHeight), dto.account.accountType.valueOf(), new SupplementalPublicKeys_1.SupplementalPublicKeys(dto.account.supplementalPublicKeys.linked
            ? new AccountLinkPublicKey_1.AccountLinkPublicKey((_a = dto.account.supplementalPublicKeys.linked) === null || _a === void 0 ? void 0 : _a.publicKey)
            : undefined, dto.account.supplementalPublicKeys.node
            ? new AccountLinkPublicKey_1.AccountLinkPublicKey((_b = dto.account.supplementalPublicKeys.node) === null || _b === void 0 ? void 0 : _b.publicKey)
            : undefined, dto.account.supplementalPublicKeys.vrf
            ? new AccountLinkPublicKey_1.AccountLinkPublicKey((_c = dto.account.supplementalPublicKeys.vrf) === null || _c === void 0 ? void 0 : _c.publicKey)
            : undefined, dto.account.supplementalPublicKeys.voting
            ? (_d = dto.account.supplementalPublicKeys.voting) === null || _d === void 0 ? void 0 : _d.publicKeys.map((v) => new AccountLinkVotingKey_1.AccountLinkVotingKey(v.publicKey, UInt64_1.UInt64.fromNumericString(v.startPoint), UInt64_1.UInt64.fromNumericString(v.endPoint))) : undefined), dto.account.activityBuckets.map((bucket) => {
            return new ActivityBucket_1.ActivityBucket(UInt64_1.UInt64.fromNumericString(bucket.startHeight), UInt64_1.UInt64.fromNumericString(bucket.totalFeesPaid), bucket.beneficiaryCount, UInt64_1.UInt64.fromNumericString(bucket.rawScore));
        }), dto.account.mosaics.map((mosaicDTO) => new Mosaic_1.Mosaic(new MosaicId_1.MosaicId(mosaicDTO.id), UInt64_1.UInt64.fromNumericString(mosaicDTO.amount))), UInt64_1.UInt64.fromNumericString(dto.account.importance), UInt64_1.UInt64.fromNumericString(dto.account.importanceHeight));
    }
}
exports.AccountHttp = AccountHttp;

},{"../core/utils/DtoMapping":566,"../model/UInt64":609,"../model/account/AccountInfo":611,"../model/account/AccountLinkPublicKey":613,"../model/account/AccountLinkVotingKey":614,"../model/account/ActivityBucket":617,"../model/account/Address":618,"../model/account/SupplementalPublicKeys":622,"../model/mosaic/Mosaic":640,"../model/mosaic/MosaicId":642,"./Http":574,"symbol-openapi-typescript-fetch-client":938}],572:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const DtoMapping_1 = require("../core/utils/DtoMapping");
const Address_1 = require("../model/account/Address");
const PublicAccount_1 = require("../model/account/PublicAccount");
const BlockInfo_1 = require("../model/blockchain/BlockInfo");
const MerklePathItem_1 = require("../model/blockchain/MerklePathItem");
const MerkleProofInfo_1 = require("../model/blockchain/MerkleProofInfo");
const UInt64_1 = require("../model/UInt64");
const Http_1 = require("./Http");
/**
 * Blockchain http repository.
 *
 * @since 1.0
 */
class BlockHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, fetchApi) {
        super(url, fetchApi);
        this.blockRoutesApi = new symbol_openapi_typescript_fetch_client_1.BlockRoutesApi(this.config());
    }
    /**
     * Gets a BlockInfo for a given block height
     * @param height - Block height
     * @returns Observable<BlockInfo>
     */
    getBlockByHeight(height) {
        return this.call(this.blockRoutesApi.getBlockByHeight(height.toString()), (body) => this.toBlockInfo(body));
    }
    /**
     * Gets an array of blocks.
     * @param criteria - Block search criteria
     * @returns Observable<BlockInfo[]>
     */
    search(criteria) {
        return this.call(this.blockRoutesApi.searchBlocks(criteria.signerPublicKey, criteria.beneficiaryAddress, criteria.pageSize, criteria.pageNumber, criteria.offset, DtoMapping_1.DtoMapping.mapEnum(criteria.order), DtoMapping_1.DtoMapping.mapEnum(criteria.orderBy)), (body) => super.toPage(body.pagination, body.data, this.toBlockInfo));
    }
    /**
     * This method maps a BlockInfoDTO from rest to the SDK's BlockInfo model object.
     *
     * @internal
     * @param {BlockInfoDTO} dto the dto object from rest.
     * @returns {BlockInfo} a BlockInfo model
     */
    toBlockInfo(dto) {
        var _a;
        const networkType = dto.block.network.valueOf();
        return new BlockInfo_1.BlockInfo((_a = dto.id) !== null && _a !== void 0 ? _a : '', dto.block.size, dto.meta.hash, dto.meta.generationHash, UInt64_1.UInt64.fromNumericString(dto.meta.totalFee), dto.meta.stateHashSubCacheMerkleRoots, dto.meta.numTransactions, dto.block.signature, PublicAccount_1.PublicAccount.createFromPublicKey(dto.block.signerPublicKey, networkType), networkType, dto.block.version, dto.block.type, UInt64_1.UInt64.fromNumericString(dto.block.height), UInt64_1.UInt64.fromNumericString(dto.block.timestamp), UInt64_1.UInt64.fromNumericString(dto.block.difficulty), dto.block.feeMultiplier, dto.block.previousBlockHash, dto.block.transactionsHash, dto.block.receiptsHash, dto.block.stateHash, dto.block.proofGamma, dto.block.proofScalar, dto.block.proofVerificationHash, dto.block.beneficiaryAddress ? Address_1.Address.createFromEncoded(dto.block.beneficiaryAddress) : undefined, dto.meta.numStatements);
    }
    /**
     * Get the merkle path for a given a transaction and block
     * Returns the merkle path for a [transaction](https://nemtech.github.io/concepts/transaction.html)
     * included in a block. The path is the complementary data needed to calculate the merkle root.
     * A client can compare if the calculated root equals the one recorded in the block header,
     * verifying that the transaction was included in the block.
     * @param height The height of the block.
     * @param hash The hash of the transaction.
     * @return Observable<MerkleProofInfo>
     */
    getMerkleTransaction(height, hash) {
        return this.call(this.blockRoutesApi.getMerkleTransaction(height.toString(), hash), (body) => new MerkleProofInfo_1.MerkleProofInfo(body.merklePath.map((payload) => new MerklePathItem_1.MerklePathItem(DtoMapping_1.DtoMapping.mapEnum(payload.position), payload.hash))));
    }
    /**
     * Get the merkle path for a given a receipt statement hash and block
     * Returns the merkle path for a [receipt statement or resolution](https://nemtech.github.io/concepts/receipt.html)
     * linked to a block. The path is the complementary data needed to calculate the merkle root.
     * A client can compare if the calculated root equals the one recorded in the block header,
     * verifying that the receipt was linked with the block.
     * @param height The height of the block.
     * @param hash The hash of the receipt statement or resolution.
     * @return Observable<MerkleProofInfo>
     */
    getMerkleReceipts(height, hash) {
        return this.call(this.blockRoutesApi.getMerkleReceipts(height.toString(), hash), (body) => new MerkleProofInfo_1.MerkleProofInfo(body.merklePath.map((payload) => new MerklePathItem_1.MerklePathItem(DtoMapping_1.DtoMapping.mapEnum(payload.position), payload.hash))));
    }
}
exports.BlockHttp = BlockHttp;

},{"../core/utils/DtoMapping":566,"../model/UInt64":609,"../model/account/Address":618,"../model/account/PublicAccount":621,"../model/blockchain/BlockInfo":623,"../model/blockchain/MerklePathItem":625,"../model/blockchain/MerkleProofInfo":627,"./Http":574,"symbol-openapi-typescript-fetch-client":938}],573:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const BlockchainScore_1 = require("../model/blockchain/BlockchainScore");
const UInt64_1 = require("../model/UInt64");
const Http_1 = require("./Http");
/**
 * Chian http repository.
 *
 * @since 1.0
 */
class ChainHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, fetchApi) {
        super(url, fetchApi);
        this.chainRoutesApi = new symbol_openapi_typescript_fetch_client_1.ChainRoutesApi(this.config());
    }
    /**
     * Gets current blockchain height
     * @returns Observable<UInt64>
     */
    getBlockchainHeight() {
        return this.call(this.chainRoutesApi.getChainHeight(), (body) => UInt64_1.UInt64.fromNumericString(body.height));
    }
    /**
     * Gets current blockchain score
     * @returns Observable<BlockchainScore>
     */
    getChainScore() {
        return this.call(this.chainRoutesApi.getChainScore(), (body) => new BlockchainScore_1.BlockchainScore(UInt64_1.UInt64.fromNumericString(body.scoreLow), UInt64_1.UInt64.fromNumericString(body.scoreHigh)));
    }
}
exports.ChainHttp = ChainHttp;

},{"../model/UInt64":609,"../model/blockchain/BlockchainScore":624,"./Http":574,"symbol-openapi-typescript-fetch-client":938}],574:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const Page_1 = require("./Page");
const node_fetch_1 = require("node-fetch");
/**
 * Http extended by all http services
 */
class Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, fetchApi) {
        this.url = url;
        this.fetchApi = fetchApi;
    }
    static errorHandling(error) {
        var _a, _b;
        if (error instanceof Error) {
            return rxjs_1.throwError(error);
        }
        const statusCode = parseInt((error === null || error === void 0 ? void 0 : error.status) || (error === null || error === void 0 ? void 0 : error.statusCode) || ((_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.statusCode) || 0);
        const statusMessage = ((error === null || error === void 0 ? void 0 : error.statusText) || (error === null || error === void 0 ? void 0 : error.statusMessage) || ((_b = error === null || error === void 0 ? void 0 : error.response) === null || _b === void 0 ? void 0 : _b.statusMessage) ||
            'Unknown Error').toString();
        const toString = (body) => {
            if (!body) {
                return '';
            }
            if (typeof body === 'string' || body instanceof String) {
                return body.toString();
            }
            return JSON.stringify(body);
        };
        const getBody = (error) => {
            var _a;
            const body = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.body;
            if (body) {
                return rxjs_1.of(toString(body));
            }
            if (error.text) {
                return rxjs_1.from(error.text()).pipe(operators_1.map(toString), operators_1.catchError(() => rxjs_1.of('')));
            }
            return rxjs_1.of('');
        };
        return getBody(error).pipe(operators_1.flatMap((body) => {
            const formattedError = {
                statusCode,
                statusMessage,
                body,
            };
            return rxjs_1.throwError(new Error(JSON.stringify(formattedError)));
        }));
    }
    createNetworkTypeObservable(networkType) {
        if (networkType && networkType instanceof rxjs_1.Observable) {
            return networkType;
        }
        else if (networkType) {
            return rxjs_1.of(networkType);
        }
        else {
            return this.call(new symbol_openapi_typescript_fetch_client_1.NodeRoutesApi(this.config()).getNodeInfo(), (body) => body.networkIdentifier);
        }
    }
    queryParams(queryParams) {
        return {
            pageSize: queryParams ? queryParams.pageSize : undefined,
            id: queryParams ? queryParams.id : undefined,
            ordering: queryParams ? queryParams.order : undefined,
        };
    }
    config() {
        const fetchApi = this.fetchApi || (typeof window !== 'undefined' && window.fetch.bind(window)) || node_fetch_1.default;
        return new symbol_openapi_typescript_fetch_client_1.Configuration({ basePath: this.url, fetchApi: fetchApi, queryParamsStringify: symbol_openapi_typescript_fetch_client_1.querystring });
    }
    /**
     * This method knows how to call, convert and handle exception when doing remote http operations.
     * @param remoteCall the remote call
     * @param mapper the mapper from dto to the model object.
     */
    call(remoteCall, mapper) {
        return rxjs_1.from(remoteCall).pipe(operators_1.map((body) => mapper(body)), operators_1.catchError(Http.errorHandling));
    }
    /**
     * This method maps a rest page object from rest to the SDK's Page model object.
     *
     * @internal
     * @param pagination rest pagination object.
     * @param data rest pagination data object.
     * @param mapper the mapper from dto to the model object.
     * @param networkType the network type.
     * @returns Page<T> model
     */
    toPage(pagination, data, mapper, networkType) {
        return new Page_1.Page(data.map((d) => mapper(d, networkType)), pagination === null || pagination === void 0 ? void 0 : pagination.pageNumber, pagination === null || pagination === void 0 ? void 0 : pagination.pageSize, pagination === null || pagination === void 0 ? void 0 : pagination.totalEntries, pagination === null || pagination === void 0 ? void 0 : pagination.totalPages);
    }
}
exports.Http = Http;

},{"./Page":582,"node-fetch":350,"rxjs":"/node_modules/rxjs","rxjs/operators":"/node_modules/rxjs/operators","symbol-openapi-typescript-fetch-client":938}],575:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const WebSocket = require("ws");
const Address_1 = require("../model/account/Address");
const PublicAccount_1 = require("../model/account/PublicAccount");
const NewBlock_1 = require("../model/blockchain/NewBlock");
const CosignatureSignedTransaction_1 = require("../model/transaction/CosignatureSignedTransaction");
const Deadline_1 = require("../model/transaction/Deadline");
const Transaction_1 = require("../model/transaction/Transaction");
const TransactionStatusError_1 = require("../model/transaction/TransactionStatusError");
const UInt64_1 = require("../model/UInt64");
const CreateTransactionFromDTO_1 = require("./transaction/CreateTransactionFromDTO");
var ListenerChannelName;
(function (ListenerChannelName) {
    ListenerChannelName["block"] = "block";
    ListenerChannelName["confirmedAdded"] = "confirmedAdded";
    ListenerChannelName["unconfirmedAdded"] = "unconfirmedAdded";
    ListenerChannelName["unconfirmedRemoved"] = "unconfirmedRemoved";
    ListenerChannelName["partialAdded"] = "partialAdded";
    ListenerChannelName["partialRemoved"] = "partialRemoved";
    ListenerChannelName["cosignature"] = "cosignature";
    ListenerChannelName["modifyMultisigAccount"] = "modifyMultisigAccount";
    ListenerChannelName["status"] = "status";
})(ListenerChannelName = exports.ListenerChannelName || (exports.ListenerChannelName = {}));
/**
 * Listener service
 */
class Listener {
    /**
     * Constructor
     * @param url - Listener websocket server url. default: rest-gateway's url with ''/ws'' suffix. (e.g. http://localhost:3000/ws).
     * @param namespaceRepository - NamespaceRepository interface for resolving alias.
     * @param websocketInjected - (Optional) WebSocket injected when using listeners in client.
     */
    constructor(
    /**
     * Listener websocket server url. default: rest-gateway's url with ''/ws'' suffix. (e.g. http://localhost:3000/ws)
     */
    url, 
    /**
     * Namespace repository for resolving account alias
     */
    namespaceRepository, 
    /**
     * WebSocket injected when using listeners in client.
     */
    websocketInjected) {
        this.url = url;
        this.namespaceRepository = namespaceRepository;
        this.websocketInjected = websocketInjected;
        this.url = url.replace(/\/$/, '');
        this.messageSubject = new rxjs_1.Subject();
    }
    /**
     * Open web socket connection.
     * @returns Promise<Void>
     */
    open() {
        return new Promise((resolve, reject) => {
            if (this.webSocket === undefined || this.webSocket.readyState === WebSocket.CLOSED) {
                if (this.websocketInjected) {
                    this.webSocket = new this.websocketInjected(this.url);
                }
                else {
                    this.webSocket = new WebSocket(this.url);
                }
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                this.webSocket.onopen = () => { };
                this.webSocket.onerror = (err) => {
                    reject(err);
                };
                this.webSocket.onmessage = (msg) => {
                    const message = JSON.parse(msg.data);
                    this.handleMessage(message, resolve);
                };
            }
            else {
                resolve();
            }
        });
    }
    /**
     * @internal
     *
     * This method handles one incoming message from the web socket and it dispatches it to the message subject listener.
     *
     * @param message the object payload.
     * @param resolve the method to notify when the uid has been resolved and the listener connection has been stablished.
     */
    handleMessage(message, resolve) {
        if (message.uid) {
            this.uid = message.uid;
            resolve();
        }
        else if (message.transaction) {
            this.messageSubject.next({
                channelName: message.meta.channelName,
                message: CreateTransactionFromDTO_1.CreateTransactionFromDTO(message),
            });
        }
        else if (message.block) {
            this.messageSubject.next({
                channelName: ListenerChannelName.block,
                message: this.toNewBlock(message),
            });
        }
        else if (message.code) {
            this.messageSubject.next({
                channelName: ListenerChannelName.status,
                message: new TransactionStatusError_1.TransactionStatusError(Address_1.Address.createFromEncoded(message.address), message.hash, message.code, Deadline_1.Deadline.createFromDTO(message.deadline)),
            });
        }
        else if (message.parentHash) {
            this.messageSubject.next({
                channelName: ListenerChannelName.cosignature,
                message: new CosignatureSignedTransaction_1.CosignatureSignedTransaction(message.parentHash, message.signature, message.signerPublicKey),
            });
        }
        else if (message.meta && message.meta.hash) {
            this.messageSubject.next({
                channelName: message.meta.channelName,
                message: message.meta.hash,
            });
        }
    }
    /**
     * returns a boolean that repressents the open state
     * @returns a boolean
     */
    isOpen() {
        if (this.webSocket) {
            return this.webSocket.readyState === WebSocket.OPEN;
        }
        return false;
    }
    /**
     * Close web socket connection.
     * @returns void
     */
    close() {
        if (this.webSocket && (this.webSocket.readyState === WebSocket.OPEN || this.webSocket.readyState === WebSocket.CONNECTING)) {
            this.webSocket.close();
        }
    }
    /**
     * Returns an observable stream of BlockInfo.
     * Each time a new Block is added into the blockchain,
     * it emits a new BlockInfo in the event stream.
     *
     * @return an observable stream of BlockInfo
     */
    newBlock() {
        this.subscribeTo('block');
        return this.messageSubject.asObservable().pipe(operators_1.share(), operators_1.filter((_) => _.channelName === ListenerChannelName.block), operators_1.filter((_) => _.message instanceof NewBlock_1.NewBlock), operators_1.map((_) => _.message));
    }
    /**
     * Returns an observable stream of Transaction for a specific address.
     * Each time a transaction is in confirmed state an it involves the address,
     * it emits a new Transaction in the event stream.
     *
     * @param address address we listen when a transaction is in confirmed state
     * @param transactionHash transactionHash for filtering multiple transactions
     * @return an observable stream of Transaction with state confirmed
     */
    confirmed(address, transactionHash) {
        return this.transactionSubscription(ListenerChannelName.confirmedAdded, address, transactionHash);
    }
    /**
     * Returns an observable stream of Transaction for a specific address.
     * Each time a transaction is in unconfirmed state an it involves the address,
     * it emits a new Transaction in the event stream.
     *
     * @param address address we listen when a transaction is in unconfirmed state
     * @param transactionHash transactionHash for filtering multiple transactions
     * @return an observable stream of Transaction with state unconfirmed
     */
    unconfirmedAdded(address, transactionHash) {
        return this.transactionSubscription(ListenerChannelName.unconfirmedAdded, address, transactionHash);
    }
    /**
     * Return an observable of {@link AggregateTransaction} for specific address.
     * Each time an aggregate bonded transaction is announced,
     * it emits a new {@link AggregateTransaction} in the event stream.
     *
     * @param address address we listen when a transaction with missing signatures state
     * @param transactionHash transactionHash for filtering multiple transactions
     * @return an observable stream of AggregateTransaction with missing signatures state
     */
    aggregateBondedAdded(address, transactionHash) {
        return this.transactionSubscription(ListenerChannelName.partialAdded, address, transactionHash);
    }
    /**
     * Basic subscription for all the transactions status.
     * @param channel the transaction based channel
     * @param address the address
     * @param transactionHash the transaction hash filter.
     * @return an observable stream of Transactions
     */
    transactionSubscription(channel, address, transactionHash) {
        this.subscribeTo(`${channel}/${address.plain()}`);
        return this.messageSubject.asObservable().pipe(operators_1.filter((listenerMessage) => listenerMessage.channelName === channel), operators_1.filter((listenerMessage) => listenerMessage.message instanceof Transaction_1.Transaction), operators_1.map((listenerMessage) => listenerMessage.message), operators_1.filter((transaction) => this.filterHash(transaction, transactionHash)), this.filterByNotifyAccount(address));
    }
    /**
     * Returns an observable stream of Transaction Hashes for specific address.
     * Each time a transaction with state unconfirmed changes its state,
     * it emits a new message with the transaction hash in the event stream.
     *
     * @param address address we listen when a transaction is removed from unconfirmed state
     * @param transactionHash the transaction hash filter.
     * @return an observable stream of Strings with the transaction hash
     */
    unconfirmedRemoved(address, transactionHash) {
        return this.transactionHashSubscription(ListenerChannelName.unconfirmedRemoved, address, transactionHash);
    }
    /**
     * Returns an observable stream of Transaction Hashes for specific address.
     * Each time an aggregate bonded transaction is announced,
     * it emits a new message with the transaction hash in the event stream.
     *
     * @param address address we listen when a transaction is confirmed or rejected
     * @param transactionHash the transaction hash filter.
     * @return an observable stream of Strings with the transaction hash
     */
    aggregateBondedRemoved(address, transactionHash) {
        return this.transactionHashSubscription(ListenerChannelName.partialRemoved, address, transactionHash);
    }
    /**
     * Generic subscription for all the transaction hash based channels.
     * @param channel the channel
     * @param address the address
     * @param transactionHash the transaction hash (optional)
     * @return an observable stream of Strings with the transaction hash
     */
    transactionHashSubscription(channel, address, transactionHash) {
        this.subscribeTo(`${channel}/${address.plain()}`);
        return this.messageSubject.asObservable().pipe(operators_1.filter((_) => _.channelName === channel), operators_1.filter((_) => typeof _.message === 'string'), operators_1.map((_) => _.message), operators_1.filter((_) => !transactionHash || _.toUpperCase() == transactionHash.toUpperCase()));
    }
    /**
     * Returns an observable stream of {@link TransactionStatusError} for specific address.
     * Each time a transaction contains an error,
     * it emits a new message with the transaction status error in the event stream.
     *
     * @param address address we listen to be notified when some error happened
     * @param transactionHash transactionHash for filtering multiple transactions
     * @return an observable stream of {@link TransactionStatusError}
     */
    status(address, transactionHash) {
        this.subscribeTo(`status/${address.plain()}`);
        return this.messageSubject.asObservable().pipe(operators_1.filter((_) => _.channelName === ListenerChannelName.status), operators_1.filter((_) => _.message instanceof TransactionStatusError_1.TransactionStatusError), operators_1.map((_) => _.message), operators_1.filter((_) => !transactionHash || _.hash.toUpperCase() == transactionHash.toUpperCase()), operators_1.filter((_) => address.equals(_.address)));
    }
    /**
     * Filters the transaction by hash if provided.
     * @param transaction the transaction
     * @param transactionHash the hash.
     */
    filterHash(transaction, transactionHash) {
        if (transactionHash === undefined) {
            return true;
        }
        else {
            const metaHash = transaction.transactionInfo.hash;
            return metaHash !== undefined ? metaHash.toUpperCase() === transactionHash.toUpperCase() : false;
        }
    }
    /**
     * It filters a transaction by address using the aliases.
     *
     * This method delegates the rest loading as much as possible. It tries to filter by signer first.
     *
     * Note: this filter performs one extra rest call and it should be down in the pipeline.
     *
     * @param address the address.
     * @return an observable filter.
     */
    filterByNotifyAccount(address) {
        return (transactionObservable) => {
            return transactionObservable.pipe(operators_1.flatMap((transaction) => {
                if (transaction.isSigned(address)) {
                    return rxjs_1.of(transaction);
                }
                const namespaceIdsObservable = this.namespaceRepository.getAccountsNames([address]).pipe(operators_1.map((names) => {
                    return []
                        .concat(...Array.from(names.map((accountName) => accountName.names)))
                        .map((name) => name.namespaceId);
                }));
                return namespaceIdsObservable.pipe(operators_1.filter((namespaceIds) => transaction.shouldNotifyAccount(address, namespaceIds)), operators_1.map(() => transaction));
            }));
        };
    }
    /**
     * Returns an observable stream of {@link CosignatureSignedTransaction} for specific address.
     * Each time a cosigner signs a transaction the address initialized,
     * it emits a new message with the cosignatory signed transaction in the even stream.
     *
     * @param address address we listen when a cosignatory is added to some transaction address sent
     * @return an observable stream of {@link CosignatureSignedTransaction}
     */
    cosignatureAdded(address) {
        this.subscribeTo(`cosignature/${address.plain()}`);
        return this.messageSubject.asObservable().pipe(operators_1.filter((_) => _.channelName.toUpperCase() === ListenerChannelName.cosignature.toUpperCase()), operators_1.filter((_) => _.message instanceof CosignatureSignedTransaction_1.CosignatureSignedTransaction), operators_1.map((_) => _.message));
    }
    /**
     * @internal
     * Subscribes to a channelName.
     * @param channel - Channel subscribed to.
     */
    subscribeTo(channel) {
        const subscriptionMessage = {
            uid: this.uid,
            subscribe: channel,
        };
        this.webSocket.send(JSON.stringify(subscriptionMessage));
    }
    /**
     * This method maps a BlockInfoDTO from rest to the SDK's BlockInfo model object.
     *
     * @internal
     * @param {BlockInfoDTO} dto the dto object from rest.
     * @returns {NewBlock} a BlockInfo model
     */
    toNewBlock(dto) {
        const networkType = dto.block.network.valueOf();
        return new NewBlock_1.NewBlock(dto.meta.hash, dto.meta.generationHash, dto.block.signature, PublicAccount_1.PublicAccount.createFromPublicKey(dto.block.signerPublicKey, networkType), networkType, dto.block.version, dto.block.type, UInt64_1.UInt64.fromNumericString(dto.block.height), UInt64_1.UInt64.fromNumericString(dto.block.timestamp), UInt64_1.UInt64.fromNumericString(dto.block.difficulty), dto.block.feeMultiplier, dto.block.previousBlockHash, dto.block.transactionsHash, dto.block.receiptsHash, dto.block.stateHash, dto.block.proofGamma, dto.block.proofScalar, dto.block.proofVerificationHash, dto.block.beneficiaryAddress ? Address_1.Address.createFromEncoded(dto.block.beneficiaryAddress) : undefined);
    }
}
exports.Listener = Listener;

},{"../model/UInt64":609,"../model/account/Address":618,"../model/account/PublicAccount":621,"../model/blockchain/NewBlock":628,"../model/transaction/CosignatureSignedTransaction":722,"../model/transaction/Deadline":724,"../model/transaction/Transaction":745,"../model/transaction/TransactionStatusError":749,"./transaction/CreateTransactionFromDTO":604,"rxjs":"/node_modules/rxjs","rxjs/operators":"/node_modules/rxjs/operators","ws":1161}],576:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const Convert_1 = require("../core/format/Convert");
const Address_1 = require("../model/account/Address");
const Metadata_1 = require("../model/metadata/Metadata");
const MetadataEntry_1 = require("../model/metadata/MetadataEntry");
const MetadataType_1 = require("../model/metadata/MetadataType");
const MosaicId_1 = require("../model/mosaic/MosaicId");
const NamespaceId_1 = require("../model/namespace/NamespaceId");
const UInt64_1 = require("../model/UInt64");
const Http_1 = require("./Http");
const DtoMapping_1 = require("../core/utils/DtoMapping");
/**
 * Metadata http repository.
 *
 * @since 1.0
 */
class MetadataHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, fetchApi) {
        super(url, fetchApi);
        this.metadataRoutesApi = new symbol_openapi_typescript_fetch_client_1.MetadataRoutesApi(this.config());
    }
    /**
     * Gets an array of metadata.
     * @param criteria - Metadata search criteria
     * @returns Observable<Page<Metadata>>
     */
    search(criteria) {
        var _a, _b, _c, _d;
        return this.call(this.metadataRoutesApi.searchMetadataEntries((_a = criteria.sourceAddress) === null || _a === void 0 ? void 0 : _a.plain(), (_b = criteria.targetAddress) === null || _b === void 0 ? void 0 : _b.plain(), criteria.scopedMetadataKey, (_c = criteria.targetId) === null || _c === void 0 ? void 0 : _c.toHex(), (_d = criteria.metadataType) === null || _d === void 0 ? void 0 : _d.valueOf(), criteria.pageSize, criteria.pageNumber, criteria.offset, DtoMapping_1.DtoMapping.mapEnum(criteria.order)), (body) => super.toPage(body.pagination, body.data, this.toMetadata));
    }
    /**
     * It maps MetadataDTO into a Metadata
     * @param metadata - the dto
     * @returns the model Metadata.
     */
    toMetadata(metadata) {
        const metadataEntry = metadata.metadataEntry;
        let targetId;
        switch (metadataEntry.metadataType.valueOf()) {
            case MetadataType_1.MetadataType.Mosaic:
                targetId = new MosaicId_1.MosaicId(metadataEntry.targetId);
                break;
            case MetadataType_1.MetadataType.Namespace:
                targetId = NamespaceId_1.NamespaceId.createFromEncoded(metadataEntry.targetId);
                break;
            default:
                targetId = undefined;
        }
        return new Metadata_1.Metadata(metadata.id, new MetadataEntry_1.MetadataEntry(metadataEntry.compositeHash, Address_1.Address.createFromEncoded(metadataEntry.sourceAddress), Address_1.Address.createFromEncoded(metadataEntry.targetAddress), UInt64_1.UInt64.fromHex(metadataEntry.scopedMetadataKey), metadataEntry.metadataType.valueOf(), Convert_1.Convert.decodeHex(metadataEntry.value), targetId));
    }
}
exports.MetadataHttp = MetadataHttp;

},{"../core/format/Convert":558,"../core/utils/DtoMapping":566,"../model/UInt64":609,"../model/account/Address":618,"../model/metadata/Metadata":636,"../model/metadata/MetadataEntry":637,"../model/metadata/MetadataType":638,"../model/mosaic/MosaicId":642,"../model/namespace/NamespaceId":656,"./Http":574,"symbol-openapi-typescript-fetch-client":938}],577:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators_1 = require("rxjs/operators");
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const DtoMapping_1 = require("../core/utils/DtoMapping");
const Address_1 = require("../model/account/Address");
const MosaicFlags_1 = require("../model/mosaic/MosaicFlags");
const MosaicId_1 = require("../model/mosaic/MosaicId");
const MosaicInfo_1 = require("../model/mosaic/MosaicInfo");
const UInt64_1 = require("../model/UInt64");
const Http_1 = require("./Http");
/**
 * Mosaic http repository.
 *
 * @since 1.0
 */
class MosaicHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param networkType the network type.
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, networkType, fetchApi) {
        super(url, fetchApi);
        this.mosaicRoutesApi = new symbol_openapi_typescript_fetch_client_1.MosaicRoutesApi(this.config());
        this.networkTypeObservable = this.createNetworkTypeObservable(networkType);
    }
    /**
     * Gets the MosaicInfo for a given mosaicId
     * @param mosaicId - Mosaic id
     * @returns Observable<MosaicInfo>
     */
    getMosaic(mosaicId) {
        return this.call(this.mosaicRoutesApi.getMosaic(mosaicId.toHex()), (body) => this.toMosaicInfo(body));
    }
    /**
     * Gets MosaicInfo for different mosaicIds.
     * @param mosaicIds - Array of mosaic ids
     * @returns Observable<MosaicInfo[]>
     */
    getMosaics(mosaicIds) {
        return this.call(this.mosaicRoutesApi.getMosaics({
            mosaicIds: mosaicIds.map((id) => id.toHex()),
        }), (body) => body.map((b) => this.toMosaicInfo(b)));
    }
    /**
     * Gets an array of mosaics.
     * @summary Get mosaics created for given address
     * @param criteria Mosaic search criteria
     * @returns {Page<MosaicInfo>}
     */
    search(criteria) {
        return this.networkTypeObservable.pipe(operators_1.mergeMap((networkType) => {
            var _a;
            return this.call(this.mosaicRoutesApi.searchMosaics((_a = criteria.ownerAddress) === null || _a === void 0 ? void 0 : _a.plain(), criteria.pageSize, criteria.pageNumber, criteria.offset, DtoMapping_1.DtoMapping.mapEnum(criteria.order)), (body) => super.toPage(body.pagination, body.data, this.toMosaicInfo, networkType));
        }));
    }
    /**
     * Maps MosaicInfoDTO to MosaicInfo
     *
     * @param mosaicInfo the dto object.
     * @returns the model object
     */
    toMosaicInfo(mosaicInfo) {
        return new MosaicInfo_1.MosaicInfo(mosaicInfo.id, new MosaicId_1.MosaicId(mosaicInfo.mosaic.id), UInt64_1.UInt64.fromNumericString(mosaicInfo.mosaic.supply), UInt64_1.UInt64.fromNumericString(mosaicInfo.mosaic.startHeight), Address_1.Address.createFromEncoded(mosaicInfo.mosaic.ownerAddress), mosaicInfo.mosaic.revision, new MosaicFlags_1.MosaicFlags(mosaicInfo.mosaic.flags), mosaicInfo.mosaic.divisibility, UInt64_1.UInt64.fromNumericString(mosaicInfo.mosaic.duration));
    }
}
exports.MosaicHttp = MosaicHttp;

},{"../core/utils/DtoMapping":566,"../model/UInt64":609,"../model/account/Address":618,"../model/mosaic/MosaicFlags":641,"../model/mosaic/MosaicId":642,"../model/mosaic/MosaicInfo":643,"./Http":574,"rxjs/operators":"/node_modules/rxjs/operators","symbol-openapi-typescript-fetch-client":938}],578:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const Address_1 = require("../model/account/Address");
const MultisigAccountGraphInfo_1 = require("../model/account/MultisigAccountGraphInfo");
const MultisigAccountInfo_1 = require("../model/account/MultisigAccountInfo");
const Http_1 = require("./Http");
/**
 * Multisig http repository.
 *
 * @since 1.0
 */
class MultisigHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, fetchApi) {
        super(url, fetchApi);
        this.multisigRoutesApi = new symbol_openapi_typescript_fetch_client_1.MultisigRoutesApi(this.config());
    }
    /**
     * Gets a MultisigAccountInfo for an account.
     * @param address - * Address can be created rawAddress or publicKey
     * @returns Observable<MultisigAccountInfo>
     */
    getMultisigAccountInfo(address) {
        return this.call(this.multisigRoutesApi.getAccountMultisig(address.plain()), (body) => this.toMultisigAccountInfo(body));
    }
    /**
     * Gets a MultisigAccountGraphInfo for an account.
     * @param address - * Address can be created rawAddress or publicKey
     * @returns Observable<MultisigAccountGraphInfo>
     */
    getMultisigAccountGraphInfo(address) {
        return this.call(this.multisigRoutesApi.getAccountMultisigGraph(address.plain()), (body) => {
            const multisigAccountGraphInfosDTO = body;
            const multisigAccounts = new Map();
            multisigAccountGraphInfosDTO.map((multisigAccountGraphInfoDTO) => {
                multisigAccounts.set(multisigAccountGraphInfoDTO.level, multisigAccountGraphInfoDTO.multisigEntries.map((multisigAccountInfoDTO) => {
                    return this.toMultisigAccountInfo(multisigAccountInfoDTO);
                }));
            });
            return new MultisigAccountGraphInfo_1.MultisigAccountGraphInfo(multisigAccounts);
        });
    }
    /**
     * It maps from MultisigAccountInfoDTO to MultisigAccountInfo
     * @param dto the DTO
     */
    toMultisigAccountInfo(dto) {
        return new MultisigAccountInfo_1.MultisigAccountInfo(Address_1.Address.createFromEncoded(dto.multisig.accountAddress), dto.multisig.minApproval, dto.multisig.minRemoval, dto.multisig.cosignatoryAddresses.map((cosigner) => Address_1.Address.createFromEncoded(cosigner)), dto.multisig.multisigAddresses.map((multisig) => Address_1.Address.createFromEncoded(multisig)));
    }
}
exports.MultisigHttp = MultisigHttp;

},{"../model/account/Address":618,"../model/account/MultisigAccountGraphInfo":619,"../model/account/MultisigAccountInfo":620,"./Http":574,"symbol-openapi-typescript-fetch-client":938}],579:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const operators_1 = require("rxjs/operators");
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const format_1 = require("../core/format");
const AccountNames_1 = require("../model/account/AccountNames");
const Address_1 = require("../model/account/Address");
const MosaicId_1 = require("../model/mosaic/MosaicId");
const MosaicNames_1 = require("../model/mosaic/MosaicNames");
const AddressAlias_1 = require("../model/namespace/AddressAlias");
const AliasType_1 = require("../model/namespace/AliasType");
const EmptyAlias_1 = require("../model/namespace/EmptyAlias");
const MosaicAlias_1 = require("../model/namespace/MosaicAlias");
const NamespaceId_1 = require("../model/namespace/NamespaceId");
const NamespaceInfo_1 = require("../model/namespace/NamespaceInfo");
const NamespaceName_1 = require("../model/namespace/NamespaceName");
const UInt64_1 = require("../model/UInt64");
const Http_1 = require("./Http");
const DtoMapping_1 = require("../core/utils/DtoMapping");
/**
 * Namespace http repository.
 *
 * @since 1.0
 */
class NamespaceHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param networkType the network type.
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, networkType, fetchApi) {
        super(url, fetchApi);
        this.namespaceRoutesApi = new symbol_openapi_typescript_fetch_client_1.NamespaceRoutesApi(this.config());
        this.networkTypeObservable = this.createNetworkTypeObservable(networkType);
    }
    /**
     * Returns friendly names for array of addresses.
     * @summary Get readable names for a set of array of addresses
     * @param addresses - Array of addresses
     */
    getAccountsNames(addresses) {
        const accountIdsBody = {
            addresses: addresses.map((address) => address.plain()),
        };
        return this.call(this.namespaceRoutesApi.getAccountsNames(accountIdsBody), (body) => body.accountNames.map((accountName) => new AccountNames_1.AccountNames(Address_1.Address.createFromEncoded(accountName.address), accountName.names.map((name) => {
            return new NamespaceName_1.NamespaceName(new NamespaceId_1.NamespaceId(name), name);
        }))));
    }
    /**
     * Get readable names for a set of mosaics
     * Returns friendly names for mosaics.
     * @param mosaicIds - Array of mosaic ids
     * @return Observable<MosaicNames[]>
     */
    getMosaicsNames(mosaicIds) {
        const mosaicIdsBody = {
            mosaicIds: mosaicIds.map((id) => id.toHex()),
        };
        return this.call(this.namespaceRoutesApi.getMosaicsNames(mosaicIdsBody), (body) => body.mosaicNames.map((mosaic) => new MosaicNames_1.MosaicNames(new MosaicId_1.MosaicId(mosaic.mosaicId), mosaic.names.map((name) => {
            return new NamespaceName_1.NamespaceName(new NamespaceId_1.NamespaceId(name), name);
        }))));
    }
    /**
     * Gets the NamespaceInfo for a given namespaceId
     * @param namespaceId - Namespace id
     * @returns Observable<NamespaceInfo>
     */
    getNamespace(namespaceId) {
        return this.call(this.namespaceRoutesApi.getNamespace(namespaceId.toHex()), (body) => this.toNamespaceInfo(body));
    }
    /**
     * Gets array of NamespaceName for different namespaceIds
     * @param namespaceIds - Array of namespace ids
     * @returns Observable<NamespaceName[]>
     */
    getNamespacesNames(namespaceIds) {
        const namespaceIdsBody = {
            namespaceIds: namespaceIds.map((id) => id.toHex()),
        };
        return this.call(this.namespaceRoutesApi.getNamespacesNames(namespaceIdsBody), (body) => body.map((namespaceNameDTO) => {
            return new NamespaceName_1.NamespaceName(NamespaceId_1.NamespaceId.createFromEncoded(namespaceNameDTO.id), namespaceNameDTO.name, namespaceNameDTO.parentId ? NamespaceId_1.NamespaceId.createFromEncoded(namespaceNameDTO.parentId) : undefined);
        }));
    }
    /**
     * Gets an array of namespaces.
     * @param criteria - Namespace search criteria
     * @returns Observable<Page<NamespaceInfo>>
     */
    search(criteria) {
        var _a, _b, _c, _d;
        return this.call(this.namespaceRoutesApi.searchNamespaces((_a = criteria.ownerAddress) === null || _a === void 0 ? void 0 : _a.plain(), (_b = criteria.registrationType) === null || _b === void 0 ? void 0 : _b.valueOf(), (_c = criteria.level0) === null || _c === void 0 ? void 0 : _c.toHex(), (_d = criteria.aliasType) === null || _d === void 0 ? void 0 : _d.valueOf(), criteria.pageSize, criteria.pageNumber, criteria.offset, DtoMapping_1.DtoMapping.mapEnum(criteria.order)), (body) => super.toPage(body.pagination, body.data, this.toNamespaceInfo));
    }
    /**
     * Gets the MosaicId from a MosaicAlias
     * @param namespaceId - the namespaceId of the namespace
     * @returns Observable<MosaicId | null>
     */
    getLinkedMosaicId(namespaceId) {
        return this.networkTypeObservable.pipe(operators_1.mergeMap(() => this.call(this.namespaceRoutesApi.getNamespace(namespaceId.toHex()), (body) => {
            const namespaceInfoDTO = body;
            if (namespaceInfoDTO.namespace === undefined) {
                // forward catapult-rest error
                throw namespaceInfoDTO;
            }
            if (namespaceInfoDTO.namespace.alias.type.valueOf() === AliasType_1.AliasType.None ||
                namespaceInfoDTO.namespace.alias.type.valueOf() !== AliasType_1.AliasType.Mosaic ||
                !namespaceInfoDTO.namespace.alias.mosaicId) {
                throw new Error(`No mosaicId is linked to namespace '${namespaceInfoDTO.namespace.level0}'`);
            }
            return new MosaicId_1.MosaicId(namespaceInfoDTO.namespace.alias.mosaicId);
        })));
    }
    /**
     * Gets the Address from a AddressAlias
     * @param namespaceId - the namespaceId of the namespace
     * @returns Observable<Address>
     */
    getLinkedAddress(namespaceId) {
        return this.networkTypeObservable.pipe(operators_1.mergeMap(() => this.call(this.namespaceRoutesApi.getNamespace(namespaceId.toHex()), (body) => {
            const namespaceInfoDTO = body;
            if (namespaceInfoDTO.namespace === undefined) {
                // forward catapult-rest error
                throw namespaceInfoDTO;
            }
            if (namespaceInfoDTO.namespace.alias.type.valueOf() === AliasType_1.AliasType.None ||
                namespaceInfoDTO.namespace.alias.type.valueOf() !== AliasType_1.AliasType.Address ||
                !namespaceInfoDTO.namespace.alias.address) {
                throw new Error(`No address is linked to namespace '${namespaceInfoDTO.namespace.level0}'`);
            }
            const addressDecoded = namespaceInfoDTO.namespace.alias.address;
            const address = format_1.RawAddress.addressToString(format_1.Convert.hexToUint8(addressDecoded));
            return Address_1.Address.createFromRawAddress(address);
        })));
    }
    /**
     * It maps from a NamespaceInfoDTO to NamespaceInfo
     * @param dto the dto
     */
    toNamespaceInfo(dto) {
        return new NamespaceInfo_1.NamespaceInfo(dto.meta.active, dto.meta.index, dto.meta.id, dto.namespace.registrationType, dto.namespace.depth, NamespaceHttp.extractLevels(dto.namespace), NamespaceId_1.NamespaceId.createFromEncoded(dto.namespace.parentId), Address_1.Address.createFromEncoded(dto.namespace.ownerAddress), UInt64_1.UInt64.fromNumericString(dto.namespace.startHeight), UInt64_1.UInt64.fromNumericString(dto.namespace.endHeight), NamespaceHttp.extractAlias(dto.namespace));
    }
    /**
     * Extract the namespace levels
     *
     * @internal
     * @param namespace
     */
    static extractLevels(namespace) {
        const result = [];
        if (namespace.level0) {
            result.push(NamespaceId_1.NamespaceId.createFromEncoded(namespace.level0));
        }
        if (namespace.level1) {
            result.push(NamespaceId_1.NamespaceId.createFromEncoded(namespace.level1));
        }
        if (namespace.level2) {
            result.push(NamespaceId_1.NamespaceId.createFromEncoded(namespace.level2));
        }
        return result;
    }
    /**
     * Extract the alias from a namespace
     *
     * @internal
     * @param namespace
     */
    static extractAlias(namespace) {
        if (namespace.alias && namespace.alias.type.valueOf() === AliasType_1.AliasType.Mosaic) {
            return new MosaicAlias_1.MosaicAlias(new MosaicId_1.MosaicId(namespace.alias.mosaicId));
        }
        else if (namespace.alias && namespace.alias.type.valueOf() === AliasType_1.AliasType.Address) {
            return new AddressAlias_1.AddressAlias(Address_1.Address.createFromEncoded(namespace.alias.address));
        }
        return new EmptyAlias_1.EmptyAlias();
    }
}
exports.NamespaceHttp = NamespaceHttp;

},{"../core/format":565,"../core/utils/DtoMapping":566,"../model/UInt64":609,"../model/account/AccountNames":615,"../model/account/Address":618,"../model/mosaic/MosaicId":642,"../model/mosaic/MosaicNames":644,"../model/namespace/AddressAlias":650,"../model/namespace/AliasType":653,"../model/namespace/EmptyAlias":654,"../model/namespace/MosaicAlias":655,"../model/namespace/NamespaceId":656,"../model/namespace/NamespaceInfo":657,"../model/namespace/NamespaceName":658,"./Http":574,"rxjs/operators":"/node_modules/rxjs/operators","symbol-openapi-typescript-fetch-client":938}],580:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators_1 = require("rxjs/operators");
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const AccountLinkNetworkProperties_1 = require("../model/network/AccountLinkNetworkProperties");
const AccountRestrictionNetworkProperties_1 = require("../model/network/AccountRestrictionNetworkProperties");
const AggregateNetworkProperties_1 = require("../model/network/AggregateNetworkProperties");
const ChainProperties_1 = require("../model/network/ChainProperties");
const HashLockNetworkProperties_1 = require("../model/network/HashLockNetworkProperties");
const MetadataNetworkProperties_1 = require("../model/network/MetadataNetworkProperties");
const MosaicNetworkProperties_1 = require("../model/network/MosaicNetworkProperties");
const MosaicRestrictionNetworkProperties_1 = require("../model/network/MosaicRestrictionNetworkProperties");
const MultisigNetworkProperties_1 = require("../model/network/MultisigNetworkProperties");
const NamespaceNetworkProperties_1 = require("../model/network/NamespaceNetworkProperties");
const NetworkConfiguration_1 = require("../model/network/NetworkConfiguration");
const NetworkName_1 = require("../model/network/NetworkName");
const NetworkProperties_1 = require("../model/network/NetworkProperties");
const PluginProperties_1 = require("../model/network/PluginProperties");
const RentalFees_1 = require("../model/network/RentalFees");
const SecretLockNetworkProperties_1 = require("../model/network/SecretLockNetworkProperties");
const TransactionFees_1 = require("../model/network/TransactionFees");
const TransferNetworkProperties_1 = require("../model/network/TransferNetworkProperties");
const UInt64_1 = require("../model/UInt64");
const Http_1 = require("./Http");
const NodeHttp_1 = require("./NodeHttp");
/**
 * Network http repository.
 *
 * @since 1.0
 */
class NetworkHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, fetchApi) {
        super(url, fetchApi);
        this.nodeHttp = new NodeHttp_1.NodeHttp(url, fetchApi);
        this.networkRoutesApi = new symbol_openapi_typescript_fetch_client_1.NetworkRoutesApi(this.config());
    }
    /**
     * Get current network identifier.
     *
     * @return network identifier.
     */
    getNetworkType() {
        return this.nodeHttp.getNodeInfo().pipe(operators_1.map((nodeInfo) => nodeInfo.networkIdentifier));
    }
    /**
     * Get current network type name and description
     *
     * @return current network type name and description
     */
    getNetworkName() {
        return this.call(this.networkRoutesApi.getNetworkType(), (body) => new NetworkName_1.NetworkName(body.name, body.description));
    }
    /**
     * Returns the content from a catapult-server network configuration file (resources/config-network.properties).
     * To enable this feature, the REST setting \"network.propertiesFilePath\" must define where the file is located.
     * This is adjustable via the configuration file (rest/resources/rest.json) per REST instance.
     * @summary Get the network properties
     */
    getNetworkProperties() {
        return this.call(this.networkRoutesApi.getNetworkProperties(), (body) => this.mapNetworkConfigurationDto(body));
    }
    /**
     * Returns the estimated effective rental fees for namespaces and mosaics. This endpoint is only available
     * if the REST instance has access to catapult-server ``resources/config-network.properties`` file.
     * To activate this feature, add the setting \"network.propertiesFilePath\" in the configuration file (rest/resources/rest.json).
     * @summary Get rental fees information
     */
    getRentalFees() {
        return this.call(this.networkRoutesApi.getRentalFees(), (body) => new RentalFees_1.RentalFees(UInt64_1.UInt64.fromNumericString(body.effectiveRootNamespaceRentalFeePerBlock), UInt64_1.UInt64.fromNumericString(body.effectiveChildNamespaceRentalFee), UInt64_1.UInt64.fromNumericString(body.effectiveMosaicRentalFee)));
    }
    /**
     * Returns information about the average, median, highest and lower fee multiplier over the last
     * \"numBlocksTransactionFeeStats\". The setting \"numBlocksTransactionFeeStats\" is adjustable
     * via a configuration file (rest/resources/rest.json) per REST instance.
     * @summary Get transaction fees information
     */
    getTransactionFees() {
        return this.call(this.networkRoutesApi.getTransactionFees(), (body) => new TransactionFees_1.TransactionFees(body.averageFeeMultiplier, body.medianFeeMultiplier, body.highestFeeMultiplier, body.lowestFeeMultiplier));
    }
    /**
     * Map dto to sdk models
     * @param dto dto object returned from rest
     */
    mapNetworkConfigurationDto(dto) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8;
        return new NetworkConfiguration_1.NetworkConfiguration(new NetworkProperties_1.NetworkProperties(dto.network.identifier, dto.network.nodeEqualityStrategy, dto.network.nemesisSignerPublicKey, dto.network.generationHashSeed, dto.network.epochAdjustment), new ChainProperties_1.ChainProperties(dto.chain.enableVerifiableState, dto.chain.enableVerifiableReceipts, dto.chain.currencyMosaicId, dto.chain.harvestingMosaicId, dto.chain.blockGenerationTargetTime, dto.chain.blockTimeSmoothingFactor, dto.chain.blockFinalizationInterval, dto.chain.importanceGrouping, dto.chain.importanceActivityPercentage, dto.chain.maxRollbackBlocks, dto.chain.maxDifficultyBlocks, dto.chain.defaultDynamicFeeMultiplier, dto.chain.maxTransactionLifetime, dto.chain.maxBlockFutureTime, dto.chain.initialCurrencyAtomicUnits, dto.chain.maxMosaicAtomicUnits, dto.chain.totalChainImportance, dto.chain.minHarvesterBalance, dto.chain.maxHarvesterBalance, dto.chain.minVoterBalance, dto.chain.maxVotingKeysPerAccount, dto.chain.minVotingKeyLifetime, dto.chain.maxVotingKeyLifetime, dto.chain.harvestBeneficiaryPercentage, dto.chain.harvestNetworkPercentage, dto.chain.harvestNetworkFeeSinkAddress, dto.chain.blockPruneInterval, dto.chain.maxTransactionsPerBlock), new PluginProperties_1.PluginProperties(new AccountLinkNetworkProperties_1.AccountLinkNetworkProperties((_a = dto.plugins.accountlink) === null || _a === void 0 ? void 0 : _a.dummy), new AggregateNetworkProperties_1.AggregateNetworkProperties((_b = dto.plugins.aggregate) === null || _b === void 0 ? void 0 : _b.maxTransactionsPerAggregate, (_c = dto.plugins.aggregate) === null || _c === void 0 ? void 0 : _c.maxCosignaturesPerAggregate, (_d = dto.plugins.aggregate) === null || _d === void 0 ? void 0 : _d.enableStrictCosignatureCheck, (_e = dto.plugins.aggregate) === null || _e === void 0 ? void 0 : _e.enableBondedAggregateSupport, (_f = dto.plugins.aggregate) === null || _f === void 0 ? void 0 : _f.maxBondedTransactionLifetime), new HashLockNetworkProperties_1.HashLockNetworkProperties((_g = dto.plugins.lockhash) === null || _g === void 0 ? void 0 : _g.lockedFundsPerAggregate, (_h = dto.plugins.lockhash) === null || _h === void 0 ? void 0 : _h.maxHashLockDuration), new SecretLockNetworkProperties_1.SecretLockNetworkProperties((_j = dto.plugins.locksecret) === null || _j === void 0 ? void 0 : _j.maxSecretLockDuration, (_k = dto.plugins.locksecret) === null || _k === void 0 ? void 0 : _k.minProofSize, (_l = dto.plugins.locksecret) === null || _l === void 0 ? void 0 : _l.maxProofSize), new MetadataNetworkProperties_1.MetadataNetworkProperties((_m = dto.plugins.metadata) === null || _m === void 0 ? void 0 : _m.maxValueSize), new MosaicNetworkProperties_1.MosaicNetworkProperties((_o = dto.plugins.mosaic) === null || _o === void 0 ? void 0 : _o.maxMosaicsPerAccount, (_p = dto.plugins.mosaic) === null || _p === void 0 ? void 0 : _p.maxMosaicDuration, (_q = dto.plugins.mosaic) === null || _q === void 0 ? void 0 : _q.maxMosaicDivisibility, (_r = dto.plugins.mosaic) === null || _r === void 0 ? void 0 : _r.mosaicRentalFeeSinkAddress, (_s = dto.plugins.mosaic) === null || _s === void 0 ? void 0 : _s.mosaicRentalFee), new MultisigNetworkProperties_1.MultisigNetworkProperties((_t = dto.plugins.multisig) === null || _t === void 0 ? void 0 : _t.maxMultisigDepth, (_u = dto.plugins.multisig) === null || _u === void 0 ? void 0 : _u.maxCosignatoriesPerAccount, (_v = dto.plugins.multisig) === null || _v === void 0 ? void 0 : _v.maxCosignedAccountsPerAccount), new NamespaceNetworkProperties_1.NamespaceNetworkProperties((_w = dto.plugins.namespace) === null || _w === void 0 ? void 0 : _w.maxNameSize, (_x = dto.plugins.namespace) === null || _x === void 0 ? void 0 : _x.maxChildNamespaces, (_y = dto.plugins.namespace) === null || _y === void 0 ? void 0 : _y.maxNamespaceDepth, (_z = dto.plugins.namespace) === null || _z === void 0 ? void 0 : _z.minNamespaceDuration, (_0 = dto.plugins.namespace) === null || _0 === void 0 ? void 0 : _0.maxNamespaceDuration, (_1 = dto.plugins.namespace) === null || _1 === void 0 ? void 0 : _1.namespaceGracePeriodDuration, (_2 = dto.plugins.namespace) === null || _2 === void 0 ? void 0 : _2.reservedRootNamespaceNames, (_3 = dto.plugins.namespace) === null || _3 === void 0 ? void 0 : _3.namespaceRentalFeeSinkAddress, (_4 = dto.plugins.namespace) === null || _4 === void 0 ? void 0 : _4.rootNamespaceRentalFeePerBlock, (_5 = dto.plugins.namespace) === null || _5 === void 0 ? void 0 : _5.childNamespaceRentalFee), new AccountRestrictionNetworkProperties_1.AccountRestrictionNetworkProperties((_6 = dto.plugins.restrictionaccount) === null || _6 === void 0 ? void 0 : _6.maxAccountRestrictionValues), new MosaicRestrictionNetworkProperties_1.MosaicRestrictionNetworkProperties((_7 = dto.plugins.restrictionmosaic) === null || _7 === void 0 ? void 0 : _7.maxMosaicRestrictionValues), new TransferNetworkProperties_1.TransferNetworkProperties((_8 = dto.plugins.transfer) === null || _8 === void 0 ? void 0 : _8.maxMessageSize)));
    }
}
exports.NetworkHttp = NetworkHttp;

},{"../model/UInt64":609,"../model/network/AccountLinkNetworkProperties":660,"../model/network/AccountRestrictionNetworkProperties":661,"../model/network/AggregateNetworkProperties":662,"../model/network/ChainProperties":663,"../model/network/HashLockNetworkProperties":664,"../model/network/MetadataNetworkProperties":665,"../model/network/MosaicNetworkProperties":666,"../model/network/MosaicRestrictionNetworkProperties":667,"../model/network/MultisigNetworkProperties":668,"../model/network/NamespaceNetworkProperties":669,"../model/network/NetworkConfiguration":670,"../model/network/NetworkName":671,"../model/network/NetworkProperties":672,"../model/network/PluginProperties":674,"../model/network/RentalFees":675,"../model/network/SecretLockNetworkProperties":676,"../model/network/TransactionFees":677,"../model/network/TransferNetworkProperties":678,"./Http":574,"./NodeHttp":581,"rxjs/operators":"/node_modules/rxjs/operators","symbol-openapi-typescript-fetch-client":938}],581:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const StorageInfo_1 = require("../model/blockchain/StorageInfo");
const NodeHealth_1 = require("../model/node/NodeHealth");
const NodeInfo_1 = require("../model/node/NodeInfo");
const NodeTime_1 = require("../model/node/NodeTime");
const ServerInfo_1 = require("../model/node/ServerInfo");
const UInt64_1 = require("../model/UInt64");
const Http_1 = require("./Http");
/**
 * Node http repository.
 *
 * @since 1.0
 */
class NodeHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, fetchApi) {
        super(url, fetchApi);
        this.nodeRoutesApi = new symbol_openapi_typescript_fetch_client_1.NodeRoutesApi(this.config());
    }
    /**
     * Supplies additional information about the application running on a node.
     * @summary Get the node information
     */
    getNodeInfo() {
        return this.call(this.nodeRoutesApi.getNodeInfo(), (body) => this.toNodeInfo(body));
    }
    /**
     * Gets the list of peers visible by the node,
     * @summary Gets the list of peers visible by the node
     */
    getNodePeers() {
        return this.call(this.nodeRoutesApi.getNodePeers(), (body) => body.map((nodeInfo) => this.toNodeInfo(nodeInfo)));
    }
    /**
     * Gets the node time at the moment the reply was sent and received.
     * @summary Get the node time
     */
    getNodeTime() {
        return this.call(this.nodeRoutesApi.getNodeTime(), (body) => {
            const nodeTimeDTO = body;
            if (nodeTimeDTO.communicationTimestamps.sendTimestamp && nodeTimeDTO.communicationTimestamps.receiveTimestamp) {
                return new NodeTime_1.NodeTime(UInt64_1.UInt64.fromNumericString(nodeTimeDTO.communicationTimestamps.sendTimestamp), UInt64_1.UInt64.fromNumericString(nodeTimeDTO.communicationTimestamps.receiveTimestamp));
            }
            throw Error('Node time not available');
        });
    }
    /**
     * Gets blockchain storage info.
     * @returns Observable<BlockchainStorageInfo>
     */
    getStorageInfo() {
        return this.call(this.nodeRoutesApi.getNodeStorage(), (body) => new StorageInfo_1.StorageInfo(body.numBlocks, body.numTransactions, body.numAccounts));
    }
    /**
     * Gets blockchain server info.
     * @returns Observable<Server>
     */
    getServerInfo() {
        return this.call(this.nodeRoutesApi.getServerInfo(), (body) => new ServerInfo_1.ServerInfo(body.serverInfo.restVersion, body.serverInfo.sdkVersion));
    }
    /**
     * Gets blockchain server info.
     * @returns Observable<Server>
     */
    getNodeHealth() {
        return this.call(this.nodeRoutesApi.getNodeHealth(), (body) => new NodeHealth_1.NodeHealth(body.status.apiNode, body.status.db));
    }
    /**
     * It maps NodeInfoDTO to NodeInfo
     *
     * @param nodeInfo the dto object.
     * @returns the model object
     */
    toNodeInfo(nodeInfo) {
        return new NodeInfo_1.NodeInfo(nodeInfo.publicKey, nodeInfo.networkGenerationHashSeed, nodeInfo.port, nodeInfo.networkIdentifier, nodeInfo.version, nodeInfo.roles, nodeInfo.host, nodeInfo.friendlyName);
    }
}
exports.NodeHttp = NodeHttp;

},{"../model/UInt64":609,"../model/blockchain/StorageInfo":629,"../model/node/NodeHealth":679,"../model/node/NodeInfo":680,"../model/node/NodeTime":681,"../model/node/ServerInfo":683,"./Http":574,"symbol-openapi-typescript-fetch-client":938}],582:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * It represents a page of results after a repository search call.
 *
 * @param <T> then model type.
 */
class Page {
    /**
     * Constructor.
     *
     * @param data the page data
     * @param pageNumber the current page number starting from 1.
     * @param pageSize the page size.
     * @param totalEntries the total entries.
     * @param totalPages the total pages for the given criteria.
     */
    constructor(data, pageNumber, pageSize, totalEntries, totalPages) {
        this.data = data;
        this.pageNumber = pageNumber;
        this.pageSize = pageSize;
        this.totalEntries = totalEntries;
        this.totalPages = totalPages;
        this.isLastPage = this.pageNumber >= this.totalPages;
    }
}
exports.Page = Page;

},{}],583:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Order_1 = require("./searchCriteria/Order");
/**
 * The query params structure describes pagination params for requests.
 *
 * @since 1.0
 */
class QueryParams {
    /**
     * Constructor
     * @param {{
     *         pageSize?: number,
     *         order?: Order,
     *         id?: string;
     *     }} configuration arguments
     */
    constructor(args) {
        /**
         * Page size between 10 and 100, otherwise 10
         */
        this.pageSize = 10;
        /**
         * Order of transactions.
         * DESC. Newer to older.
         * ASC. Older to newer.
         */
        this.order = Order_1.Order.Desc;
        if (args) {
            if (args.pageSize) {
                this.setPageSize(args.pageSize);
            }
            if (args.order) {
                this.order = args.order;
            }
            if (args.id) {
                this.id = args.id;
            }
        }
    }
    /**
     * Set page size
     * @private
     * @param {number} [pageSize]
     * @returns {void}
     */
    setPageSize(pageSize) {
        if (pageSize && pageSize > 100) {
            throw new Error('The page size has to be between 10 and 100');
        }
        this.pageSize = pageSize || 10;
    }
}
exports.QueryParams = QueryParams;

},{"./searchCriteria/Order":603}],584:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const DtoMapping_1 = require("../core/utils/DtoMapping");
const Http_1 = require("./Http");
const CreateReceiptFromDTO_1 = require("./receipt/CreateReceiptFromDTO");
/**
 * Receipt http repository.
 *
 * @since 1.0
 */
class ReceiptHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, fetchApi) {
        super(url, fetchApi);
        this.receiptRoutesApi = new symbol_openapi_typescript_fetch_client_1.ReceiptRoutesApi(this.config());
    }
    searchAddressResolutionStatements(criteria) {
        var _a;
        return this.call(this.receiptRoutesApi.searchAddressResolutionStatements((_a = criteria.height) === null || _a === void 0 ? void 0 : _a.toString(), criteria.pageSize, criteria.pageNumber, criteria.offset, DtoMapping_1.DtoMapping.mapEnum(criteria.order)), (body) => super.toPage(body.pagination, body.data, CreateReceiptFromDTO_1.createAddressResolutionStatement));
    }
    searchMosaicResolutionStatements(criteria) {
        var _a;
        return this.call(this.receiptRoutesApi.searchMosaicResolutionStatements((_a = criteria.height) === null || _a === void 0 ? void 0 : _a.toString(), criteria.pageSize, criteria.pageNumber, criteria.offset, DtoMapping_1.DtoMapping.mapEnum(criteria.order)), (body) => super.toPage(body.pagination, body.data, CreateReceiptFromDTO_1.createMosaicResolutionStatement));
    }
    searchReceipts(criteria) {
        var _a, _b, _c, _d, _e, _f;
        return this.call(this.receiptRoutesApi.searchReceipts((_a = criteria.height) === null || _a === void 0 ? void 0 : _a.toString(), (_b = criteria.receiptTypes) === null || _b === void 0 ? void 0 : _b.map((t) => t.valueOf()), (_c = criteria.recipientAddress) === null || _c === void 0 ? void 0 : _c.plain(), (_d = criteria.senderAddress) === null || _d === void 0 ? void 0 : _d.plain(), (_e = criteria.targetAddress) === null || _e === void 0 ? void 0 : _e.plain(), (_f = criteria.artifactId) === null || _f === void 0 ? void 0 : _f.toHex(), criteria.pageSize, criteria.pageNumber, criteria.offset, DtoMapping_1.DtoMapping.mapEnum(criteria.order)), (body) => super.toPage(body.pagination, body.data, CreateReceiptFromDTO_1.createTransactionStatement));
    }
}
exports.ReceiptHttp = ReceiptHttp;

},{"../core/utils/DtoMapping":566,"./Http":574,"./receipt/CreateReceiptFromDTO":600,"symbol-openapi-typescript-fetch-client":938}],585:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const AccountHttp_1 = require("./AccountHttp");
const BlockHttp_1 = require("./BlockHttp");
const ChainHttp_1 = require("./ChainHttp");
const Listener_1 = require("./Listener");
const MetadataHttp_1 = require("./MetadataHttp");
const MosaicHttp_1 = require("./MosaicHttp");
const MultisigHttp_1 = require("./MultisigHttp");
const NamespaceHttp_1 = require("./NamespaceHttp");
const NetworkHttp_1 = require("./NetworkHttp");
const NodeHttp_1 = require("./NodeHttp");
const ReceiptHttp_1 = require("./ReceiptHttp");
const RestrictionAccountHttp_1 = require("./RestrictionAccountHttp");
const RestrictionMosaicHttp_1 = require("./RestrictionMosaicHttp");
const TransactionHttp_1 = require("./TransactionHttp");
const TransactionStatusHttp_1 = require("./TransactionStatusHttp");
/**
 * Receipt http repository.
 *
 */
class RepositoryFactoryHttp {
    /**
     * Constructor
     * @param url the server url.
     * @param configs optional repository factory configs
     */
    constructor(url, configs) {
        this.url = url;
        this.fetchApi = configs === null || configs === void 0 ? void 0 : configs.fetchApi;
        this.networkType = (configs === null || configs === void 0 ? void 0 : configs.networkType) ? rxjs_1.of(configs.networkType)
            : this.createNetworkRepository().getNetworkType().pipe(operators_1.shareReplay(1));
        this.generationHash = (configs === null || configs === void 0 ? void 0 : configs.generationHash) ? rxjs_1.of(configs === null || configs === void 0 ? void 0 : configs.generationHash)
            : this.createNodeRepository()
                .getNodeInfo()
                .pipe(operators_1.map((b) => b.networkGenerationHashSeed))
                .pipe(operators_1.shareReplay(1));
        this.websocketUrl = (configs === null || configs === void 0 ? void 0 : configs.websocketUrl) ? configs === null || configs === void 0 ? void 0 : configs.websocketUrl : `${url.replace(/\/$/, '')}/ws`;
        this.websocketInjected = configs === null || configs === void 0 ? void 0 : configs.websocketInjected;
    }
    createAccountRepository() {
        return new AccountHttp_1.AccountHttp(this.url, this.fetchApi);
    }
    createBlockRepository() {
        return new BlockHttp_1.BlockHttp(this.url, this.fetchApi);
    }
    createChainRepository() {
        return new ChainHttp_1.ChainHttp(this.url, this.fetchApi);
    }
    createMetadataRepository() {
        return new MetadataHttp_1.MetadataHttp(this.url, this.fetchApi);
    }
    createMosaicRepository() {
        return new MosaicHttp_1.MosaicHttp(this.url, this.networkType, this.fetchApi);
    }
    createMultisigRepository() {
        return new MultisigHttp_1.MultisigHttp(this.url, this.fetchApi);
    }
    createNamespaceRepository() {
        return new NamespaceHttp_1.NamespaceHttp(this.url, this.networkType, this.fetchApi);
    }
    createNetworkRepository() {
        return new NetworkHttp_1.NetworkHttp(this.url, this.fetchApi);
    }
    createNodeRepository() {
        return new NodeHttp_1.NodeHttp(this.url, this.fetchApi);
    }
    createReceiptRepository() {
        return new ReceiptHttp_1.ReceiptHttp(this.url, this.fetchApi);
    }
    createRestrictionAccountRepository() {
        return new RestrictionAccountHttp_1.RestrictionAccountHttp(this.url, this.fetchApi);
    }
    createRestrictionMosaicRepository() {
        return new RestrictionMosaicHttp_1.RestrictionMosaicHttp(this.url, this.fetchApi);
    }
    createTransactionRepository() {
        return new TransactionHttp_1.TransactionHttp(this.url, this.fetchApi);
    }
    createTransactionStatusRepository() {
        return new TransactionStatusHttp_1.TransactionStatusHttp(this.url, this.fetchApi);
    }
    getGenerationHash() {
        return this.generationHash;
    }
    getNetworkType() {
        return this.networkType;
    }
    createListener() {
        return new Listener_1.Listener(this.websocketUrl, this.createNamespaceRepository(), this.websocketInjected);
    }
}
exports.RepositoryFactoryHttp = RepositoryFactoryHttp;

},{"./AccountHttp":571,"./BlockHttp":572,"./ChainHttp":573,"./Listener":575,"./MetadataHttp":576,"./MosaicHttp":577,"./MultisigHttp":578,"./NamespaceHttp":579,"./NetworkHttp":580,"./NodeHttp":581,"./ReceiptHttp":584,"./RestrictionAccountHttp":586,"./RestrictionMosaicHttp":587,"./TransactionHttp":589,"./TransactionStatusHttp":590,"rxjs":"/node_modules/rxjs","rxjs/operators":"/node_modules/rxjs/operators"}],586:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const DtoMapping_1 = require("../core/utils/DtoMapping");
const Http_1 = require("./Http");
/**
 * RestrictionAccount http repository.
 *
 * @since 1.0
 */
class RestrictionAccountHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, fetchApi) {
        super(url, fetchApi);
        this.restrictionAccountRoutesApi = new symbol_openapi_typescript_fetch_client_1.RestrictionAccountRoutesApi(this.config());
    }
    /**
     * Get Account restrictions.
     * @param publicAccount public account
     * @returns Observable<AccountRestrictions[]>
     */
    getAccountRestrictions(address) {
        return this.call(this.restrictionAccountRoutesApi.getAccountRestrictions(address.plain()), (body) => DtoMapping_1.DtoMapping.extractAccountRestrictionFromDto(body).accountRestrictions.restrictions);
    }
    /**
     * Get Account restrictions.
     * @param address list of addresses
     * @returns Observable<AccountRestrictionsInfo[]>
     */
    getAccountRestrictionsFromAccounts(addresses) {
        const accountIds = {
            addresses: addresses.map((address) => address.plain()),
        };
        return this.call(this.restrictionAccountRoutesApi.getAccountRestrictionsFromAccounts(accountIds), (body) => body.map((restriction) => {
            return DtoMapping_1.DtoMapping.extractAccountRestrictionFromDto(restriction).accountRestrictions;
        }));
    }
}
exports.RestrictionAccountHttp = RestrictionAccountHttp;

},{"../core/utils/DtoMapping":566,"./Http":574,"symbol-openapi-typescript-fetch-client":938}],587:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const Address_1 = require("../model/account/Address");
const MosaicId_1 = require("../model/mosaic/MosaicId");
const MosaicAddressRestriction_1 = require("../model/restriction/MosaicAddressRestriction");
const MosaicGlobalRestriction_1 = require("../model/restriction/MosaicGlobalRestriction");
const MosaicGlobalRestrictionItem_1 = require("../model/restriction/MosaicGlobalRestrictionItem");
const Http_1 = require("./Http");
/**
 * RestrictionMosaic http repository.
 *
 * @since 1.0
 */
class RestrictionMosaicHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, fetchApi) {
        super(url, fetchApi);
        this.restrictionMosaicRoutesApi = new symbol_openapi_typescript_fetch_client_1.RestrictionMosaicRoutesApi(this.config());
    }
    /**
     * Get mosaic address restriction.
     * @summary Get mosaic address restrictions for a given mosaic and account identifier.
     * @param mosaicId Mosaic identifier.
     * @param address address
     * @returns Observable<MosaicAddressRestriction>
     */
    getMosaicAddressRestriction(mosaicId, address) {
        return this.call(this.restrictionMosaicRoutesApi.getMosaicAddressRestriction(mosaicId.toHex(), address.plain()), (body) => this.toMosaicAddressRestriction(body));
    }
    /**
     * Get mosaic address restrictions.
     * @summary Get mosaic address restrictions for a given mosaic and account identifiers array
     * @param mosaicId Mosaic identifier.
     * @param addresses list of addresses
     * @returns Observable<MosaicAddressRestriction[]>
     */
    getMosaicAddressRestrictions(mosaicId, addresses) {
        const accountIds = {
            addresses: addresses.map((address) => address.plain()),
        };
        return this.call(this.restrictionMosaicRoutesApi.getMosaicAddressRestrictions(mosaicId.toHex(), accountIds), (body) => body.map(this.toMosaicAddressRestriction));
    }
    /**
     * Get mosaic global restriction.
     * @summary Get mosaic global restrictions for a given mosaic identifier.
     * @param mosaicId Mosaic identifier.
     * @returns Observable<MosaicGlobalRestriction>
     */
    getMosaicGlobalRestriction(mosaicId) {
        return this.call(this.restrictionMosaicRoutesApi.getMosaicGlobalRestriction(mosaicId.toHex()), (body) => this.toMosaicGlobalRestriction(body));
    }
    /**
     * Get mosaic global restrictions.
     * @summary Get mosaic global restrictions for a given list of mosaics.
     * @param mosaicIds List of mosaic identifier.
     * @returns Observable<MosaicGlobalRestriction[]>
     */
    getMosaicGlobalRestrictions(mosaicIds) {
        const mosaicIdsBody = {
            mosaicIds: mosaicIds.map((id) => id.toHex()),
        };
        return this.call(this.restrictionMosaicRoutesApi.getMosaicGlobalRestrictions(mosaicIdsBody), (body) => body.map(this.toMosaicGlobalRestriction));
    }
    /**
     * This method maps a MosaicAddressRestrictionDTO from rest to the SDK's MosaicAddressRestriction model object.
     *
     * @internal
     * @param {MosaicAddressRestrictionDTO} dto the MosaicAddressRestrictionDTO object from rest.
     * @returns {MosaicAddressRestriction} a MosaicAddressRestriction model
     */
    toMosaicAddressRestriction(dto) {
        const restrictionItems = new Map();
        dto.mosaicRestrictionEntry.restrictions.forEach((restriction) => {
            restrictionItems.set(restriction.key, restriction.value);
        });
        return new MosaicAddressRestriction_1.MosaicAddressRestriction(dto.mosaicRestrictionEntry.compositeHash, dto.mosaicRestrictionEntry.entryType.valueOf(), new MosaicId_1.MosaicId(dto.mosaicRestrictionEntry.mosaicId), Address_1.Address.createFromEncoded(dto.mosaicRestrictionEntry.targetAddress), restrictionItems);
    }
    /**
     * This method maps a MosaicGlobalRestrictionDTO from rest to the SDK's MosaicGlobalRestriction model object.
     *
     * @internal
     * @param {MosaicGlobalRestrictionDTO} dto the MosaicGlobalRestrictionDTO object from rest.
     * @returns {MosaicGlobalRestriction} a MosaicGlobalRestriction model
     */
    toMosaicGlobalRestriction(dto) {
        const restirctionItems = new Map();
        dto.mosaicRestrictionEntry.restrictions.forEach((restriction) => restirctionItems.set(restriction.key, new MosaicGlobalRestrictionItem_1.MosaicGlobalRestrictionItem(new MosaicId_1.MosaicId(restriction.restriction.referenceMosaicId), restriction.restriction.restrictionValue, restriction.restriction.restrictionType.valueOf())));
        return new MosaicGlobalRestriction_1.MosaicGlobalRestriction(dto.mosaicRestrictionEntry.compositeHash, dto.mosaicRestrictionEntry.entryType.valueOf(), new MosaicId_1.MosaicId(dto.mosaicRestrictionEntry.mosaicId), restirctionItems);
    }
}
exports.RestrictionMosaicHttp = RestrictionMosaicHttp;

},{"../model/account/Address":618,"../model/mosaic/MosaicId":642,"../model/restriction/MosaicAddressRestriction":702,"../model/restriction/MosaicGlobalRestriction":703,"../model/restriction/MosaicGlobalRestrictionItem":704,"./Http":574,"symbol-openapi-typescript-fetch-client":938}],588:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A transaction could be classified in the following groups:
 * - Unconfirmed: The transaction reached the P2P network. At this point, it is not guaranteed that the transaction will be included in a block.
 * -Confirmed: The transaction is included in a block.
 * - Partial: The transaction requires to be cosigned by other transaction participants in order to be included in a block.
 */
var TransactionGroup;
(function (TransactionGroup) {
    TransactionGroup["Unconfirmed"] = "unconfirmed";
    TransactionGroup["Confirmed"] = "confirmed";
    TransactionGroup["Partial"] = "partial";
})(TransactionGroup = exports.TransactionGroup || (exports.TransactionGroup = {}));

},{}],589:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators_1 = require("rxjs/operators");
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const DtoMapping_1 = require("../core/utils/DtoMapping");
const TransactionAnnounceResponse_1 = require("../model/transaction/TransactionAnnounceResponse");
const TransactionType_1 = require("../model/transaction/TransactionType");
const Http_1 = require("./Http");
const CreateTransactionFromDTO_1 = require("./transaction/CreateTransactionFromDTO");
const TransactionGroup_1 = require("./TransactionGroup");
/**
 * Transaction http repository.
 *
 * @since 1.0
 */
class TransactionHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, fetchApi) {
        super(url, fetchApi);
        this.transactionRoutesApi = new symbol_openapi_typescript_fetch_client_1.TransactionRoutesApi(this.config());
        this.blockRoutesApi = new symbol_openapi_typescript_fetch_client_1.BlockRoutesApi(this.config());
    }
    /**
     * Gets a transaction for a transactionId
     * @param transactionId - Transaction id or hash.
     * @param transactionGroup - Transaction group.
     * @returns Observable<Transaction>
     */
    getTransaction(transactionId, transactionGroup) {
        return this.call(this.getTransactionByGroup(transactionId, transactionGroup), (body) => CreateTransactionFromDTO_1.CreateTransactionFromDTO(body));
    }
    /**
     * Gets an array of transactions for different transaction ids
     * @param transactionIds - Array of transactions id and/or hash.
     * @param transactionGroup - Transaction group.
     * @returns Observable<Transaction[]>
     */
    getTransactionsById(transactionIds, transactionGroup) {
        const transactionIdsBody = {
            transactionIds,
        };
        switch (transactionGroup) {
            case TransactionGroup_1.TransactionGroup.Confirmed:
                return this.call(this.transactionRoutesApi.getConfirmedTransactions(transactionIdsBody), (body) => body.map((transactionDTO) => {
                    return CreateTransactionFromDTO_1.CreateTransactionFromDTO(transactionDTO);
                }));
            case TransactionGroup_1.TransactionGroup.Unconfirmed:
                return this.call(this.transactionRoutesApi.getUnconfirmedTransactions(transactionIdsBody), (body) => body.map((transactionDTO) => {
                    return CreateTransactionFromDTO_1.CreateTransactionFromDTO(transactionDTO);
                }));
            case TransactionGroup_1.TransactionGroup.Partial:
                return this.call(this.transactionRoutesApi.getPartialTransactions(transactionIdsBody), (body) => body.map((transactionDTO) => {
                    return CreateTransactionFromDTO_1.CreateTransactionFromDTO(transactionDTO);
                }));
        }
    }
    /**
     * Send a signed transaction
     * @param signedTransaction - Signed transaction
     * @returns Observable<TransactionAnnounceResponse>
     */
    announce(signedTransaction) {
        if (signedTransaction.type === TransactionType_1.TransactionType.AGGREGATE_BONDED) {
            throw new Error("Announcing aggregate bonded transaction should use 'announceAggregateBonded'");
        }
        return this.call(this.transactionRoutesApi.announceTransaction(signedTransaction), (body) => new TransactionAnnounceResponse_1.TransactionAnnounceResponse(body.message));
    }
    /**
     * Send a signed transaction with missing signatures
     * @param signedTransaction - Signed transaction
     * @returns Observable<TransactionAnnounceResponse>
     */
    announceAggregateBonded(signedTransaction) {
        if (signedTransaction.type !== TransactionType_1.TransactionType.AGGREGATE_BONDED) {
            throw new Error('Only Transaction Type 0x4241 is allowed for announce aggregate bonded');
        }
        return this.call(this.transactionRoutesApi.announcePartialTransaction(signedTransaction), (body) => new TransactionAnnounceResponse_1.TransactionAnnounceResponse(body.message));
    }
    /**
     * Send a cosignature signed transaction of an already announced transaction
     * @param cosignatureSignedTransaction - Cosignature signed transaction
     * @returns Observable<TransactionAnnounceResponse>
     */
    announceAggregateBondedCosignature(cosignatureSignedTransaction) {
        const cosignature = {
            parentHash: cosignatureSignedTransaction.parentHash,
            signerPublicKey: cosignatureSignedTransaction.signerPublicKey,
            signature: cosignatureSignedTransaction.signature,
            version: cosignatureSignedTransaction.version.toString(),
        };
        return this.call(this.transactionRoutesApi.announceCosignatureTransaction(cosignature), (body) => new TransactionAnnounceResponse_1.TransactionAnnounceResponse(body.message));
    }
    /**
     * Gets a transaction's effective paid fee
     * @param transactionId - Transaction id or hash.
     * @returns Observable<number>
     */
    getTransactionEffectiveFee(transactionId) {
        return this.call(this.getTransactionByGroup(transactionId, TransactionGroup_1.TransactionGroup.Confirmed), CreateTransactionFromDTO_1.CreateTransactionFromDTO).pipe(operators_1.mergeMap((transaction) => {
            // now read block details
            return this.call(this.blockRoutesApi.getBlockByHeight(transaction.transactionInfo.height.toString()), (blockDTO) => {
                // @see https://nemtech.github.io/concepts/transaction.html#fees
                // effective_fee = feeMultiplier x transaction::size
                return blockDTO.block.feeMultiplier * transaction.size;
            });
        }));
    }
    /**
     * Returns an array of transactions.
     * @summary Get transactions
     * @param criteria Transaction search criteria
     * @returns {Observable<Page<Transaction>>}
     */
    search(criteria) {
        return this.call(this.searchTransactionByGroup(criteria), (body) => super.toPage(body.pagination, body.data, CreateTransactionFromDTO_1.CreateTransactionFromDTO));
    }
    /**
     * @internal
     * Gets a transaction info
     * @param transactionId - Transaction id or hash.
     * @param transactionGroup - Transaction group.
     * @returns Promise<{response: http.ClientResponse; body: TransactionInfoDTO;}>
     */
    getTransactionByGroup(transactionId, transactionGroup) {
        switch (transactionGroup) {
            case TransactionGroup_1.TransactionGroup.Confirmed:
                return this.transactionRoutesApi.getConfirmedTransaction(transactionId);
            case TransactionGroup_1.TransactionGroup.Unconfirmed:
                return this.transactionRoutesApi.getUnconfirmedTransaction(transactionId);
            case TransactionGroup_1.TransactionGroup.Partial:
                return this.transactionRoutesApi.getPartialTransaction(transactionId);
        }
    }
    /**
     * @internal
     * Gets a transaction search result
     * @param criteria - the criteria.
     * @returns Promise<{response: http.ClientResponse; body: TransactionInfoDTO;}>
     */
    searchTransactionByGroup(criteria) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        switch (criteria.group) {
            case TransactionGroup_1.TransactionGroup.Confirmed:
                return this.transactionRoutesApi.searchConfirmedTransactions((_a = criteria.address) === null || _a === void 0 ? void 0 : _a.plain(), (_b = criteria.recipientAddress) === null || _b === void 0 ? void 0 : _b.plain(), criteria.signerPublicKey, (_c = criteria.height) === null || _c === void 0 ? void 0 : _c.toString(), (_d = criteria.type) === null || _d === void 0 ? void 0 : _d.map((type) => type.valueOf()), criteria.embedded, criteria.pageSize, criteria.pageNumber, criteria.offset, DtoMapping_1.DtoMapping.mapEnum(criteria.order));
            case TransactionGroup_1.TransactionGroup.Unconfirmed:
                return this.transactionRoutesApi.searchUnconfirmedTransactions((_e = criteria.address) === null || _e === void 0 ? void 0 : _e.plain(), (_f = criteria.recipientAddress) === null || _f === void 0 ? void 0 : _f.plain(), criteria.signerPublicKey, (_g = criteria.height) === null || _g === void 0 ? void 0 : _g.toString(), (_h = criteria.type) === null || _h === void 0 ? void 0 : _h.map((type) => type.valueOf()), criteria.embedded, criteria.pageSize, criteria.pageNumber, criteria.offset, DtoMapping_1.DtoMapping.mapEnum(criteria.order));
            case TransactionGroup_1.TransactionGroup.Partial:
                return this.transactionRoutesApi.searchPartialTransactions((_j = criteria.address) === null || _j === void 0 ? void 0 : _j.plain(), (_k = criteria.recipientAddress) === null || _k === void 0 ? void 0 : _k.plain(), criteria.signerPublicKey, (_l = criteria.height) === null || _l === void 0 ? void 0 : _l.toString(), (_m = criteria.type) === null || _m === void 0 ? void 0 : _m.map((type) => type.valueOf()), criteria.embedded, criteria.pageSize, criteria.pageNumber, criteria.offset, DtoMapping_1.DtoMapping.mapEnum(criteria.order));
        }
    }
}
exports.TransactionHttp = TransactionHttp;

},{"../core/utils/DtoMapping":566,"../model/transaction/TransactionAnnounceResponse":746,"../model/transaction/TransactionType":750,"./Http":574,"./TransactionGroup":588,"./transaction/CreateTransactionFromDTO":604,"rxjs/operators":"/node_modules/rxjs/operators","symbol-openapi-typescript-fetch-client":938}],590:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const symbol_openapi_typescript_fetch_client_1 = require("symbol-openapi-typescript-fetch-client");
const Deadline_1 = require("../model/transaction/Deadline");
const TransactionStatus_1 = require("../model/transaction/TransactionStatus");
const UInt64_1 = require("../model/UInt64");
const Http_1 = require("./Http");
/**
 * Transaction status http repository.
 *
 * @since 1.0
 */
class TransactionStatusHttp extends Http_1.Http {
    /**
     * Constructor
     * @param url Base catapult-rest url
     * @param fetchApi fetch function to be used when performing rest requests.
     */
    constructor(url, fetchApi) {
        super(url, fetchApi);
        this.transactionStatusRoutesApi = new symbol_openapi_typescript_fetch_client_1.TransactionStatusRoutesApi(this.config());
    }
    /**
     * Gets a transaction status for a transaction hash
     * @param transactionHash - Transaction hash.
     * @returns Observable<TransactionStatus>
     */
    getTransactionStatus(transactionHash) {
        return this.call(this.transactionStatusRoutesApi.getTransactionStatus(transactionHash), (body) => this.toTransactionStatus(body));
    }
    /**
     * Gets an array of transaction status for different transaction hashes
     * @param transactionHashes - Array of transaction hash
     * @returns Observable<TransactionStatus[]>
     */
    getTransactionStatuses(transactionHashes) {
        const transactionHashesBody = {
            hashes: transactionHashes,
        };
        return this.call(this.transactionStatusRoutesApi.getTransactionStatuses(transactionHashesBody), (body) => body.map(this.toTransactionStatus));
    }
    /**
     * This method maps a TransactionStatusDTO from rest to the SDK's TransactionStatus model object.
     *
     * @internal
     * @param {TransactionStatusDTO} dto the TransactionStatusDTO object from rest.
     * @returns {TransactionStatus} a TransactionStatus model
     */
    toTransactionStatus(dto) {
        return new TransactionStatus_1.TransactionStatus(dto.group, dto.hash, Deadline_1.Deadline.createFromDTO(UInt64_1.UInt64.fromNumericString(dto.deadline).toDTO()), dto.code, dto.height ? UInt64_1.UInt64.fromNumericString(dto.height) : undefined);
    }
}
exports.TransactionStatusHttp = TransactionStatusHttp;

},{"../model/UInt64":609,"../model/transaction/Deadline":724,"../model/transaction/TransactionStatus":748,"./Http":574,"symbol-openapi-typescript-fetch-client":938}],591:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./AccountHttp"));
__export(require("./BlockHttp"));
__export(require("./ChainHttp"));
__export(require("./Http"));
__export(require("./MosaicHttp"));
__export(require("./MetadataHttp"));
__export(require("./NamespaceHttp"));
__export(require("./TransactionHttp"));
__export(require("./Listener"));
__export(require("./QueryParams"));
__export(require("./NetworkHttp"));
__export(require("./NodeHttp"));
__export(require("./RestrictionAccountHttp"));
__export(require("./RestrictionMosaicHttp"));
__export(require("./MultisigHttp"));
__export(require("./ReceiptHttp"));
__export(require("./RepositoryFactoryHttp"));
__export(require("./transaction/NamespaceMosaicIdGenerator"));
__export(require("./TransactionStatusHttp"));
__export(require("./TransactionGroup"));
// Pagination
__export(require("./Page"));
__export(require("./searchCriteria/BlockOrderBy"));
__export(require("./searchCriteria/Order"));
__export(require("./searchCriteria/AccountOrderBy"));
__export(require("./paginationStreamer/BlockPaginationStreamer"));
__export(require("./paginationStreamer/MosaicPaginationStreamer"));
__export(require("./paginationStreamer/PaginationStreamer"));
__export(require("./paginationStreamer/TransactionPaginationStreamer"));
__export(require("./paginationStreamer/AccountPaginationStreamer"));
__export(require("./paginationStreamer/NamespacePaginationStreamer"));
__export(require("./paginationStreamer/MetadataPaginationStreamer"));
__export(require("./paginationStreamer/ReceiptPaginationStreamer"));

},{"./AccountHttp":571,"./BlockHttp":572,"./ChainHttp":573,"./Http":574,"./Listener":575,"./MetadataHttp":576,"./MosaicHttp":577,"./MultisigHttp":578,"./NamespaceHttp":579,"./NetworkHttp":580,"./NodeHttp":581,"./Page":582,"./QueryParams":583,"./ReceiptHttp":584,"./RepositoryFactoryHttp":585,"./RestrictionAccountHttp":586,"./RestrictionMosaicHttp":587,"./TransactionGroup":588,"./TransactionHttp":589,"./TransactionStatusHttp":590,"./paginationStreamer/AccountPaginationStreamer":592,"./paginationStreamer/BlockPaginationStreamer":593,"./paginationStreamer/MetadataPaginationStreamer":594,"./paginationStreamer/MosaicPaginationStreamer":595,"./paginationStreamer/NamespacePaginationStreamer":596,"./paginationStreamer/PaginationStreamer":597,"./paginationStreamer/ReceiptPaginationStreamer":598,"./paginationStreamer/TransactionPaginationStreamer":599,"./searchCriteria/AccountOrderBy":601,"./searchCriteria/BlockOrderBy":602,"./searchCriteria/Order":603,"./transaction/NamespaceMosaicIdGenerator":606}],592:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const PaginationStreamer_1 = require("./PaginationStreamer");
/**
 * A helper object that streams {@link AccountInfo} using the search.
 */
class AccountPaginationStreamer extends PaginationStreamer_1.PaginationStreamer {
    /**
     * Constructor
     *
     * @param searcher the account repository that will perform the searches
     */
    constructor(searcher) {
        super(searcher);
    }
}
exports.AccountPaginationStreamer = AccountPaginationStreamer;

},{"./PaginationStreamer":597}],593:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const PaginationStreamer_1 = require("./PaginationStreamer");
/**
 * A helper object that streams {@link BlockInfo} using the search.
 */
class BlockPaginationStreamer extends PaginationStreamer_1.PaginationStreamer {
    /**
     * Constructor
     *
     * @param searcher the block repository that will perform the searches
     */
    constructor(searcher) {
        super(searcher);
    }
}
exports.BlockPaginationStreamer = BlockPaginationStreamer;

},{"./PaginationStreamer":597}],594:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const PaginationStreamer_1 = require("./PaginationStreamer");
/**
 * A helper object that streams {@link Metadata} using the search.
 */
class MetadataPaginationStreamer extends PaginationStreamer_1.PaginationStreamer {
    /**
     * Constructor
     *
     * @param searcher the metadata repository that will perform the searches
     */
    constructor(searcher) {
        super(searcher);
    }
}
exports.MetadataPaginationStreamer = MetadataPaginationStreamer;

},{"./PaginationStreamer":597}],595:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const PaginationStreamer_1 = require("./PaginationStreamer");
/**
 * A helper object that streams {@link MosaicInfo} using the search.
 */
class MosaicPaginationStreamer extends PaginationStreamer_1.PaginationStreamer {
    /**
     * Constructor
     *
     * @param searcher the mosaic repository that will perform the searches
     */
    constructor(searcher) {
        super(searcher);
    }
}
exports.MosaicPaginationStreamer = MosaicPaginationStreamer;

},{"./PaginationStreamer":597}],596:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const PaginationStreamer_1 = require("./PaginationStreamer");
/**
 * A helper object that streams {@link NamespaceInfo} using the search.
 */
class NamespacePaginationStreamer extends PaginationStreamer_1.PaginationStreamer {
    /**
     * Constructor
     *
     * @param searcher the namespace repository that will perform the searches
     */
    constructor(searcher) {
        super(searcher);
    }
}
exports.NamespacePaginationStreamer = NamespacePaginationStreamer;

},{"./PaginationStreamer":597}],597:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const defer_1 = require("rxjs/internal/observable/defer");
const from_1 = require("rxjs/internal/observable/from");
const operators_1 = require("rxjs/operators");
/**
 * Utility helper that stream pages of searches into an Observable.
 *
 * A streamer will help users to walk through searches without knowing the underlying pagination implementation.
 */
class PaginationStreamer {
    /**
     * Constructor
     *
     * @param searcher the searcher repository
     */
    constructor(
    /**
     * The search method, likely to be the search method of entity's repository
     */
    searcher) {
        this.searcher = searcher;
    }
    /**
     * Main method of the helper, it streams the results in observable only loading the pages when necessary.
     *
     * @param criteria the criteria
     * @return the observable of entities.
     */
    search(criteria) {
        return this.searchInternal(criteria, 1);
    }
    searchInternal(criteria, pageNumber) {
        criteria.pageNumber = pageNumber;
        return defer_1.defer(() => {
            const observable = this.searcher.search(criteria);
            return observable.pipe(operators_1.flatMap((page) => {
                if (page.isLastPage) {
                    return from_1.from(page.data);
                }
                else {
                    return rxjs_1.concat(from_1.from(page.data), this.searchInternal(criteria, pageNumber + 1));
                }
            }));
        });
    }
}
exports.PaginationStreamer = PaginationStreamer;

},{"rxjs":"/node_modules/rxjs","rxjs/internal/observable/defer":372,"rxjs/internal/observable/from":375,"rxjs/operators":"/node_modules/rxjs/operators"}],598:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const PaginationStreamer_1 = require("./PaginationStreamer");
/**
 * A helper object that streams {@link Statement} using the search.
 */
class ReceiptPaginationStreamer {
    /**
     * It creates a transaction statement streamer of TransactionStatement objects.
     *
     * @param repository the {@link ReceiptRepository} repository
     * @return a new Pagination Streamer.
     */
    static transactionStatements(repository) {
        return new PaginationStreamer_1.PaginationStreamer({
            search(criteria) {
                return repository.searchReceipts(criteria);
            },
        });
    }
    /**
     * It creates a transaction statement streamer of AddressResolutionStatement objects.
     *
     * @param repository the {@link ReceiptRepository} repository
     * @return a new Pagination Streamer.
     */
    static addressResolutionStatements(repository) {
        return new PaginationStreamer_1.PaginationStreamer({
            search(criteria) {
                return repository.searchAddressResolutionStatements(criteria);
            },
        });
    }
    /**
     * It creates a mosaic resolution statement streamer of MosaicResolutionStatement objects.
     *
     * @param repository the {@link ReceiptRepository} repository
     * @return a new Pagination Streamer.
     */
    static mosaicResolutionStatements(repository) {
        return new PaginationStreamer_1.PaginationStreamer({
            search(criteria) {
                return repository.searchMosaicResolutionStatements(criteria);
            },
        });
    }
}
exports.ReceiptPaginationStreamer = ReceiptPaginationStreamer;

},{"./PaginationStreamer":597}],599:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const PaginationStreamer_1 = require("./PaginationStreamer");
/**
 * A helper object that streams {@link Transaction} using the search.
 */
class TransactionPaginationStreamer extends PaginationStreamer_1.PaginationStreamer {
    /**
     * Constructor
     *
     * @param searcher the Transaction repository that will perform the searches
     */
    constructor(searcher) {
        super(searcher);
    }
}
exports.TransactionPaginationStreamer = TransactionPaginationStreamer;

},{"./PaginationStreamer":597}],600:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
const Address_1 = require("../../model/account/Address");
const MosaicId_1 = require("../../model/mosaic/MosaicId");
const NamespaceId_1 = require("../../model/namespace/NamespaceId");
const ArtifactExpiryReceipt_1 = require("../../model/receipt/ArtifactExpiryReceipt");
const BalanceChangeReceipt_1 = require("../../model/receipt/BalanceChangeReceipt");
const BalanceTransferReceipt_1 = require("../../model/receipt/BalanceTransferReceipt");
const InflationReceipt_1 = require("../../model/receipt/InflationReceipt");
const ReceiptSource_1 = require("../../model/receipt/ReceiptSource");
const ReceiptType_1 = require("../../model/receipt/ReceiptType");
const ResolutionEntry_1 = require("../../model/receipt/ResolutionEntry");
const ResolutionStatement_1 = require("../../model/receipt/ResolutionStatement");
const ResolutionType_1 = require("../../model/receipt/ResolutionType");
const TransactionStatement_1 = require("../../model/receipt/TransactionStatement");
const UInt64_1 = require("../../model/UInt64");
/**
 * @interal
 * @param unresolvedAddress unresolved address
 * @returns {Address | NamespaceId}
 */
const extractUnresolvedAddress = (unresolvedAddress) => {
    if (typeof unresolvedAddress === 'string') {
        return UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddress(unresolvedAddress);
    }
    else if (typeof unresolvedAddress === 'object') {
        // Is JSON object
        if (unresolvedAddress.hasOwnProperty('address')) {
            return Address_1.Address.createFromRawAddress(unresolvedAddress.address);
        }
        else if (unresolvedAddress.hasOwnProperty('id')) {
            return NamespaceId_1.NamespaceId.createFromEncoded(unresolvedAddress.id);
        }
    }
    throw new Error(`UnresolvedAddress: ${unresolvedAddress} type is not recognised`);
};
/**
 * @internal
 * @param statementInfoDTO
 * @returns {MosaicIdResolutionStatement}
 * @constructor
 */
exports.createMosaicResolutionStatement = (statementInfoDTO) => {
    const statementDTO = statementInfoDTO.statement;
    return new ResolutionStatement_1.ResolutionStatement(ResolutionType_1.ResolutionType.Mosaic, UInt64_1.UInt64.fromNumericString(statementDTO.height), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(statementDTO.unresolved), statementDTO.resolutionEntries.map((entry) => {
        return new ResolutionEntry_1.ResolutionEntry(new MosaicId_1.MosaicId(entry.resolved), new ReceiptSource_1.ReceiptSource(entry.source.primaryId, entry.source.secondaryId));
    }));
};
/**
 * @internal
 * @param statementInfoDTO
 * @returns {AddressResolutionStatement}
 * @constructor
 */
exports.createAddressResolutionStatement = (statementInfoDTO) => {
    const statementDTO = statementInfoDTO.statement;
    return new ResolutionStatement_1.ResolutionStatement(ResolutionType_1.ResolutionType.Address, UInt64_1.UInt64.fromNumericString(statementDTO.height), extractUnresolvedAddress(statementDTO.unresolved), statementDTO.resolutionEntries.map((entry) => {
        return new ResolutionEntry_1.ResolutionEntry(Address_1.Address.createFromEncoded(entry.resolved), new ReceiptSource_1.ReceiptSource(entry.source.primaryId, entry.source.secondaryId));
    }));
};
/**
 * @internal
 * @param receiptDTO
 * @returns {BalanceChangeReceipt}
 * @constructor
 */
const createBalanceChangeReceipt = (receiptDTO) => {
    return new BalanceChangeReceipt_1.BalanceChangeReceipt(Address_1.Address.createFromEncoded(receiptDTO.targetAddress), new MosaicId_1.MosaicId(receiptDTO.mosaicId), UInt64_1.UInt64.fromNumericString(receiptDTO.amount), receiptDTO.version, receiptDTO.type);
};
/**
 * @internal
 * @param receiptDTO
 * @returns {BalanceTransferReceipt}
 * @constructor
 */
const createBalanceTransferReceipt = (receiptDTO) => {
    return new BalanceTransferReceipt_1.BalanceTransferReceipt(Address_1.Address.createFromEncoded(receiptDTO.senderAddress), Address_1.Address.createFromEncoded(receiptDTO.recipientAddress), new MosaicId_1.MosaicId(receiptDTO.mosaicId), UInt64_1.UInt64.fromNumericString(receiptDTO.amount), receiptDTO.version, receiptDTO.type);
};
/**
 * @internal
 * @param receiptType receipt type
 * @param id Artifact id
 * @returns {UnresolvedMosaicId}
 */
const extractArtifactId = (receiptType, id) => {
    switch (receiptType) {
        case ReceiptType_1.ReceiptType.Mosaic_Expired:
            return new MosaicId_1.MosaicId(id);
        case ReceiptType_1.ReceiptType.Namespace_Expired:
        case ReceiptType_1.ReceiptType.Namespace_Deleted:
            return NamespaceId_1.NamespaceId.createFromEncoded(id);
        default:
            throw new Error('Receipt type is not supported.');
    }
};
/**
 * @internal
 * @param receiptDTO
 * @returns {ArtifactExpiryReceipt}
 * @constructor
 */
const createArtifactExpiryReceipt = (receiptDTO) => {
    return new ArtifactExpiryReceipt_1.ArtifactExpiryReceipt(extractArtifactId(receiptDTO.type, receiptDTO.artifactId), receiptDTO.version, receiptDTO.type);
};
/**
 * @internal
 * @param receiptDTO
 * @returns {InflationReceipt}
 * @constructor
 */
const createInflationReceipt = (receiptDTO) => {
    return new InflationReceipt_1.InflationReceipt(new MosaicId_1.MosaicId(receiptDTO.mosaicId), UInt64_1.UInt64.fromNumericString(receiptDTO.amount), receiptDTO.version, receiptDTO.type);
};
/**
 * @param receiptDTO
 * @returns {Receipt}
 * @constructor
 */
exports.CreateReceiptFromDTO = (receiptDTO) => {
    switch (receiptDTO.type) {
        case ReceiptType_1.ReceiptType.Harvest_Fee:
        case ReceiptType_1.ReceiptType.LockHash_Created:
        case ReceiptType_1.ReceiptType.LockHash_Completed:
        case ReceiptType_1.ReceiptType.LockHash_Expired:
        case ReceiptType_1.ReceiptType.LockSecret_Created:
        case ReceiptType_1.ReceiptType.LockSecret_Completed:
        case ReceiptType_1.ReceiptType.LockSecret_Expired:
            return createBalanceChangeReceipt(receiptDTO);
        case ReceiptType_1.ReceiptType.Mosaic_Levy:
        case ReceiptType_1.ReceiptType.Mosaic_Rental_Fee:
        case ReceiptType_1.ReceiptType.Namespace_Rental_Fee:
            return createBalanceTransferReceipt(receiptDTO);
        case ReceiptType_1.ReceiptType.Mosaic_Expired:
        case ReceiptType_1.ReceiptType.Namespace_Expired:
        case ReceiptType_1.ReceiptType.Namespace_Deleted:
            return createArtifactExpiryReceipt(receiptDTO);
        case ReceiptType_1.ReceiptType.Inflation:
            return createInflationReceipt(receiptDTO);
        default:
            throw new Error(`Receipt type: ${receiptDTO.type} not recognized.`);
    }
};
/**
 * @internal
 * @param statementInfoDTO
 * @returns {TransactionStatement}
 * @constructor
 */
exports.createTransactionStatement = (statementInfoDTO) => {
    const statementDTO = statementInfoDTO.statement;
    return new TransactionStatement_1.TransactionStatement(UInt64_1.UInt64.fromNumericString(statementDTO.height), new ReceiptSource_1.ReceiptSource(statementDTO.source.primaryId, statementDTO.source.secondaryId), statementDTO.receipts.map((receipt) => {
        return exports.CreateReceiptFromDTO(receipt);
    }));
};

},{"../../core/utils/UnresolvedMapping":569,"../../model/UInt64":609,"../../model/account/Address":618,"../../model/mosaic/MosaicId":642,"../../model/namespace/NamespaceId":656,"../../model/receipt/ArtifactExpiryReceipt":684,"../../model/receipt/BalanceChangeReceipt":685,"../../model/receipt/BalanceTransferReceipt":686,"../../model/receipt/InflationReceipt":687,"../../model/receipt/ReceiptSource":689,"../../model/receipt/ReceiptType":690,"../../model/receipt/ResolutionEntry":692,"../../model/receipt/ResolutionStatement":693,"../../model/receipt/ResolutionType":694,"../../model/receipt/TransactionStatement":696}],601:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var AccountOrderBy;
(function (AccountOrderBy) {
    AccountOrderBy["Id"] = "id";
    AccountOrderBy["Balance"] = "balance";
})(AccountOrderBy = exports.AccountOrderBy || (exports.AccountOrderBy = {}));

},{}],602:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BlockOrderBy;
(function (BlockOrderBy) {
    BlockOrderBy["Id"] = "id";
    BlockOrderBy["Height"] = "height";
})(BlockOrderBy = exports.BlockOrderBy || (exports.BlockOrderBy = {}));

},{}],603:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Indicates how to sort the results:  * ``asc`` - ascending * ``desc`` - descending
 */
var Order;
(function (Order) {
    Order["Asc"] = "asc";
    Order["Desc"] = "desc";
})(Order = exports.Order || (exports.Order = {}));

},{}],604:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const format_1 = require("../../core/format");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
const Address_1 = require("../../model/account/Address");
const PublicAccount_1 = require("../../model/account/PublicAccount");
const EncryptedMessage_1 = require("../../model/message/EncryptedMessage");
const MessageType_1 = require("../../model/message/MessageType");
const PersistentHarvestingDelegationMessage_1 = require("../../model/message/PersistentHarvestingDelegationMessage");
const PlainMessage_1 = require("../../model/message/PlainMessage");
const Mosaic_1 = require("../../model/mosaic/Mosaic");
const MosaicFlags_1 = require("../../model/mosaic/MosaicFlags");
const MosaicId_1 = require("../../model/mosaic/MosaicId");
const MosaicNonce_1 = require("../../model/mosaic/MosaicNonce");
const NamespaceId_1 = require("../../model/namespace/NamespaceId");
const AccountAddressRestrictionTransaction_1 = require("../../model/transaction/AccountAddressRestrictionTransaction");
const AccountKeyLinkTransaction_1 = require("../../model/transaction/AccountKeyLinkTransaction");
const AccountMetadataTransaction_1 = require("../../model/transaction/AccountMetadataTransaction");
const AccountMosaicRestrictionTransaction_1 = require("../../model/transaction/AccountMosaicRestrictionTransaction");
const AccountOperationRestrictionTransaction_1 = require("../../model/transaction/AccountOperationRestrictionTransaction");
const AddressAliasTransaction_1 = require("../../model/transaction/AddressAliasTransaction");
const AggregateTransaction_1 = require("../../model/transaction/AggregateTransaction");
const AggregateTransactionCosignature_1 = require("../../model/transaction/AggregateTransactionCosignature");
const AggregateTransactionInfo_1 = require("../../model/transaction/AggregateTransactionInfo");
const Deadline_1 = require("../../model/transaction/Deadline");
const LockFundsTransaction_1 = require("../../model/transaction/LockFundsTransaction");
const MosaicAddressRestrictionTransaction_1 = require("../../model/transaction/MosaicAddressRestrictionTransaction");
const MosaicAliasTransaction_1 = require("../../model/transaction/MosaicAliasTransaction");
const MosaicDefinitionTransaction_1 = require("../../model/transaction/MosaicDefinitionTransaction");
const MosaicGlobalRestrictionTransaction_1 = require("../../model/transaction/MosaicGlobalRestrictionTransaction");
const MosaicMetadataTransaction_1 = require("../../model/transaction/MosaicMetadataTransaction");
const MosaicSupplyChangeTransaction_1 = require("../../model/transaction/MosaicSupplyChangeTransaction");
const MultisigAccountModificationTransaction_1 = require("../../model/transaction/MultisigAccountModificationTransaction");
const NamespaceMetadataTransaction_1 = require("../../model/transaction/NamespaceMetadataTransaction");
const NamespaceRegistrationTransaction_1 = require("../../model/transaction/NamespaceRegistrationTransaction");
const NodeKeyLinkTransaction_1 = require("../../model/transaction/NodeKeyLinkTransaction");
const SecretLockTransaction_1 = require("../../model/transaction/SecretLockTransaction");
const SecretProofTransaction_1 = require("../../model/transaction/SecretProofTransaction");
const SignedTransaction_1 = require("../../model/transaction/SignedTransaction");
const TransactionInfo_1 = require("../../model/transaction/TransactionInfo");
const TransactionType_1 = require("../../model/transaction/TransactionType");
const TransferTransaction_1 = require("../../model/transaction/TransferTransaction");
const VotingKeyLinkTransaction_1 = require("../../model/transaction/VotingKeyLinkTransaction");
const VrfKeyLinkTransaction_1 = require("../../model/transaction/VrfKeyLinkTransaction");
const UInt64_1 = require("../../model/UInt64");
/**
 * Extract recipientAddress value from encoded hexadecimal notation.
 *
 * If bit 0 of byte 0 is not set (e.g. 0x90), then it is a regular address.
 * Else (e.g. 0x91) it represents a namespace id which starts at byte 1.
 *
 * @param recipientAddress {string} Encoded hexadecimal recipientAddress notation
 * @return {Address | NamespaceId}
 */
exports.extractRecipient = (recipientAddress) => {
    if (typeof recipientAddress === 'string') {
        return UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddress(recipientAddress);
    }
    else if (typeof recipientAddress === 'object') {
        // Is JSON object
        if (recipientAddress.hasOwnProperty('address')) {
            return Address_1.Address.createFromRawAddress(recipientAddress.address);
        }
        else if (recipientAddress.hasOwnProperty('id')) {
            return NamespaceId_1.NamespaceId.createFromEncoded(recipientAddress.id);
        }
    }
    throw new Error(`Recipient: ${recipientAddress} type is not recognised`);
};
/**
 * Extract mosaics from encoded UInt64 notation.
 *
 * If most significant bit of byte 0 is set, then it is a namespaceId.
 * If most significant bit of byte 0 is not set, then it is a mosaicId.
 *
 * @param mosaics {Array | undefined} The DTO array of mosaics (with UInt64 Id notation)
 * @return {Mosaic[]}
 */
exports.extractMosaics = (mosaics) => {
    if (mosaics === undefined) {
        return [];
    }
    return mosaics.map((mosaicDTO) => {
        const id = UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(mosaicDTO.id);
        return new Mosaic_1.Mosaic(id, UInt64_1.UInt64.fromNumericString(mosaicDTO.amount));
    });
};
/**
 * Extract message from either JSON payload (unencoded) or DTO (encoded)
 *
 * @param message - message payload
 * @return {PlainMessage}
 */
const extractMessage = (message) => {
    let msgObj = PlainMessage_1.EmptyMessage;
    if (message) {
        if (message.type === MessageType_1.MessageType.PlainMessage) {
            msgObj = format_1.Convert.isHexString(message.payload)
                ? PlainMessage_1.PlainMessage.createFromPayload(message.payload)
                : PlainMessage_1.PlainMessage.create(message.payload);
        }
        else if (message.type === MessageType_1.MessageType.EncryptedMessage) {
            msgObj = EncryptedMessage_1.EncryptedMessage.createFromPayload(message.payload);
        }
        else if (message.type === MessageType_1.MessageType.PersistentHarvestingDelegationMessage) {
            msgObj = PersistentHarvestingDelegationMessage_1.PersistentHarvestingDelegationMessage.createFromPayload(message.payload);
        }
    }
    return msgObj;
};
/**
 * @internal
 * Extract transaction meta data
 *
 * @param meta - Transaction meta data
 * @param id - TransactionId
 * @return {TransactionInfo | AggregateTransactionInfo | undefined}
 */
const extractTransactionMeta = (meta, id) => {
    if (!meta) {
        return undefined;
    }
    if (meta.aggregateHash || meta.aggregateId) {
        return new AggregateTransactionInfo_1.AggregateTransactionInfo(UInt64_1.UInt64.fromNumericString(meta.height), meta.index, id, meta.aggregateHash, meta.aggregateId);
    }
    return new TransactionInfo_1.TransactionInfo(UInt64_1.UInt64.fromNumericString(meta.height), meta.index, id, meta.hash, meta.merkleComponentHash);
};
/**
 * @internal
 * @param transactionDTO
 * @param transactionInfo
 * @returns {any}
 * @constructor
 */
const CreateStandaloneTransactionFromDTO = (transactionDTO, transactionInfo) => {
    if (transactionDTO.type === TransactionType_1.TransactionType.TRANSFER) {
        return new TransferTransaction_1.TransferTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), exports.extractRecipient(transactionDTO.recipientAddress), exports.extractMosaics(transactionDTO.mosaics), extractMessage(transactionDTO.message !== undefined ? transactionDTO.message : undefined), transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.NAMESPACE_REGISTRATION) {
        return new NamespaceRegistrationTransaction_1.NamespaceRegistrationTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), transactionDTO.registrationType, transactionDTO.name, NamespaceId_1.NamespaceId.createFromEncoded(transactionDTO.id), transactionDTO.registrationType === 0 ? UInt64_1.UInt64.fromNumericString(transactionDTO.duration) : undefined, transactionDTO.registrationType === 1 ? NamespaceId_1.NamespaceId.createFromEncoded(transactionDTO.parentId) : undefined, transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.MOSAIC_DEFINITION) {
        return new MosaicDefinitionTransaction_1.MosaicDefinitionTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), MosaicNonce_1.MosaicNonce.createFromNumber(transactionDTO.nonce), new MosaicId_1.MosaicId(transactionDTO.id), new MosaicFlags_1.MosaicFlags(transactionDTO.flags), transactionDTO.divisibility, UInt64_1.UInt64.fromNumericString(transactionDTO.duration), transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.MOSAIC_SUPPLY_CHANGE) {
        return new MosaicSupplyChangeTransaction_1.MosaicSupplyChangeTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(transactionDTO.mosaicId), transactionDTO.action, UInt64_1.UInt64.fromNumericString(transactionDTO.delta), transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.MULTISIG_ACCOUNT_MODIFICATION) {
        return new MultisigAccountModificationTransaction_1.MultisigAccountModificationTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), transactionDTO.minApprovalDelta, transactionDTO.minRemovalDelta, transactionDTO.addressAdditions ? transactionDTO.addressAdditions.map((addition) => exports.extractRecipient(addition)) : [], transactionDTO.addressDeletions ? transactionDTO.addressDeletions.map((deletion) => exports.extractRecipient(deletion)) : [], transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.HASH_LOCK) {
        const networkType = transactionDTO.network;
        return new LockFundsTransaction_1.LockFundsTransaction(networkType, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), new Mosaic_1.Mosaic(new MosaicId_1.MosaicId(transactionDTO.mosaicId), UInt64_1.UInt64.fromNumericString(transactionDTO.amount)), UInt64_1.UInt64.fromNumericString(transactionDTO.duration), new SignedTransaction_1.SignedTransaction('', transactionDTO.hash, '', TransactionType_1.TransactionType.AGGREGATE_BONDED, networkType), transactionDTO.signature, transactionDTO.signerPublicKey ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, networkType) : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.SECRET_LOCK) {
        const recipientAddress = transactionDTO.recipientAddress;
        const mosaicId = UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(transactionDTO.mosaicId);
        return new SecretLockTransaction_1.SecretLockTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), new Mosaic_1.Mosaic(mosaicId, UInt64_1.UInt64.fromNumericString(transactionDTO.amount)), UInt64_1.UInt64.fromNumericString(transactionDTO.duration), transactionDTO.hashAlgorithm, transactionDTO.secret, exports.extractRecipient(recipientAddress), transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.SECRET_PROOF) {
        const recipientAddress = transactionDTO.recipientAddress;
        return new SecretProofTransaction_1.SecretProofTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), transactionDTO.hashAlgorithm, transactionDTO.secret, exports.extractRecipient(recipientAddress), transactionDTO.proof, transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.MOSAIC_ALIAS) {
        return new MosaicAliasTransaction_1.MosaicAliasTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), transactionDTO.aliasAction, NamespaceId_1.NamespaceId.createFromEncoded(transactionDTO.namespaceId), new MosaicId_1.MosaicId(transactionDTO.mosaicId), transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.ADDRESS_ALIAS) {
        return new AddressAliasTransaction_1.AddressAliasTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), transactionDTO.aliasAction, NamespaceId_1.NamespaceId.createFromEncoded(transactionDTO.namespaceId), exports.extractRecipient(transactionDTO.address), transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.ACCOUNT_ADDRESS_RESTRICTION) {
        return new AccountAddressRestrictionTransaction_1.AccountAddressRestrictionTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), transactionDTO.restrictionFlags, transactionDTO.restrictionAdditions ? transactionDTO.restrictionAdditions.map((addition) => exports.extractRecipient(addition)) : [], transactionDTO.restrictionDeletions ? transactionDTO.restrictionDeletions.map((deletion) => exports.extractRecipient(deletion)) : [], transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.ACCOUNT_OPERATION_RESTRICTION) {
        return new AccountOperationRestrictionTransaction_1.AccountOperationRestrictionTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), transactionDTO.restrictionFlags, transactionDTO.restrictionAdditions ? transactionDTO.restrictionAdditions : [], transactionDTO.restrictionDeletions ? transactionDTO.restrictionDeletions : [], transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.ACCOUNT_MOSAIC_RESTRICTION) {
        return new AccountMosaicRestrictionTransaction_1.AccountMosaicRestrictionTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), transactionDTO.restrictionFlags, transactionDTO.restrictionAdditions
            ? transactionDTO.restrictionAdditions.map((addition) => UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(addition))
            : [], transactionDTO.restrictionDeletions
            ? transactionDTO.restrictionDeletions.map((deletion) => UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(deletion))
            : [], transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.ACCOUNT_KEY_LINK) {
        return new AccountKeyLinkTransaction_1.AccountKeyLinkTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), transactionDTO.linkedPublicKey, transactionDTO.linkAction, transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.MOSAIC_GLOBAL_RESTRICTION) {
        return new MosaicGlobalRestrictionTransaction_1.MosaicGlobalRestrictionTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(transactionDTO.mosaicId), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(transactionDTO.referenceMosaicId), UInt64_1.UInt64.fromHex(transactionDTO.restrictionKey), UInt64_1.UInt64.fromNumericString(transactionDTO.previousRestrictionValue), transactionDTO.previousRestrictionType, UInt64_1.UInt64.fromNumericString(transactionDTO.newRestrictionValue), transactionDTO.newRestrictionType, transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.MOSAIC_ADDRESS_RESTRICTION) {
        return new MosaicAddressRestrictionTransaction_1.MosaicAddressRestrictionTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(transactionDTO.mosaicId), UInt64_1.UInt64.fromHex(transactionDTO.restrictionKey), exports.extractRecipient(transactionDTO.targetAddress), UInt64_1.UInt64.fromNumericString(transactionDTO.previousRestrictionValue), UInt64_1.UInt64.fromNumericString(transactionDTO.newRestrictionValue), transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.ACCOUNT_METADATA) {
        return new AccountMetadataTransaction_1.AccountMetadataTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), exports.extractRecipient(transactionDTO.targetAddress), UInt64_1.UInt64.fromHex(transactionDTO.scopedMetadataKey), transactionDTO.valueSizeDelta, format_1.Convert.decodeHex(transactionDTO.value), transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.MOSAIC_METADATA) {
        return new MosaicMetadataTransaction_1.MosaicMetadataTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), exports.extractRecipient(transactionDTO.targetAddress), UInt64_1.UInt64.fromHex(transactionDTO.scopedMetadataKey), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(transactionDTO.targetMosaicId), transactionDTO.valueSizeDelta, format_1.Convert.decodeHex(transactionDTO.value), transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.NAMESPACE_METADATA) {
        return new NamespaceMetadataTransaction_1.NamespaceMetadataTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), exports.extractRecipient(transactionDTO.targetAddress), UInt64_1.UInt64.fromHex(transactionDTO.scopedMetadataKey), NamespaceId_1.NamespaceId.createFromEncoded(transactionDTO.targetNamespaceId), transactionDTO.valueSizeDelta, format_1.Convert.decodeHex(transactionDTO.value), transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.VRF_KEY_LINK) {
        return new VrfKeyLinkTransaction_1.VrfKeyLinkTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), transactionDTO.linkedPublicKey, transactionDTO.linkAction, transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.NODE_KEY_LINK) {
        return new NodeKeyLinkTransaction_1.NodeKeyLinkTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), transactionDTO.linkedPublicKey, transactionDTO.linkAction, transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    else if (transactionDTO.type === TransactionType_1.TransactionType.VOTING_KEY_LINK) {
        return new VotingKeyLinkTransaction_1.VotingKeyLinkTransaction(transactionDTO.network, transactionDTO.version, Deadline_1.Deadline.createFromDTO(transactionDTO.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.maxFee || '0'), transactionDTO.linkedPublicKey, UInt64_1.UInt64.fromNumericString(transactionDTO.startPoint), UInt64_1.UInt64.fromNumericString(transactionDTO.endPoint), transactionDTO.linkAction, transactionDTO.signature, transactionDTO.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.signerPublicKey, transactionDTO.network)
            : undefined, transactionInfo).setPayloadSize(transactionDTO.size);
    }
    throw new Error('Unimplemented transaction with type ' + transactionDTO.type);
};
/**
 * @internal
 * @param transactionDTO
 * @returns {Transaction}
 * @constructor
 */
exports.CreateTransactionFromDTO = (transactionDTO) => {
    if (transactionDTO.transaction.type === TransactionType_1.TransactionType.AGGREGATE_COMPLETE ||
        transactionDTO.transaction.type === TransactionType_1.TransactionType.AGGREGATE_BONDED) {
        const innerTransactions = transactionDTO.transaction.transactions
            ? transactionDTO.transaction.transactions.map((innerTransactionDTO) => {
                const aggregateTransactionInfo = extractTransactionMeta(innerTransactionDTO.meta, innerTransactionDTO.id);
                innerTransactionDTO.transaction.maxFee = transactionDTO.transaction.maxFee;
                innerTransactionDTO.transaction.deadline = transactionDTO.transaction.deadline;
                innerTransactionDTO.transaction.signature = transactionDTO.transaction.signature;
                return CreateStandaloneTransactionFromDTO(innerTransactionDTO.transaction, aggregateTransactionInfo);
            })
            : [];
        return new AggregateTransaction_1.AggregateTransaction(transactionDTO.transaction.network, transactionDTO.transaction.type, transactionDTO.transaction.version, Deadline_1.Deadline.createFromDTO(transactionDTO.transaction.deadline), UInt64_1.UInt64.fromNumericString(transactionDTO.transaction.maxFee || '0'), innerTransactions, transactionDTO.transaction.cosignatures
            ? transactionDTO.transaction.cosignatures.map((aggregateCosignatureDTO) => {
                return new AggregateTransactionCosignature_1.AggregateTransactionCosignature(aggregateCosignatureDTO.signature, PublicAccount_1.PublicAccount.createFromPublicKey(aggregateCosignatureDTO.signerPublicKey, transactionDTO.transaction.network), UInt64_1.UInt64.fromNumericString(aggregateCosignatureDTO.version));
            })
            : [], transactionDTO.transaction.signature, transactionDTO.transaction.signerPublicKey
            ? PublicAccount_1.PublicAccount.createFromPublicKey(transactionDTO.transaction.signerPublicKey, transactionDTO.transaction.network)
            : undefined, extractTransactionMeta(transactionDTO.meta, transactionDTO.id)).setPayloadSize(transactionDTO.transaction.size);
    }
    else {
        return CreateStandaloneTransactionFromDTO(transactionDTO.transaction, extractTransactionMeta(transactionDTO.meta, transactionDTO.id));
    }
};

},{"../../core/format":565,"../../core/utils/UnresolvedMapping":569,"../../model/UInt64":609,"../../model/account/Address":618,"../../model/account/PublicAccount":621,"../../model/message/EncryptedMessage":630,"../../model/message/MessageType":633,"../../model/message/PersistentHarvestingDelegationMessage":634,"../../model/message/PlainMessage":635,"../../model/mosaic/Mosaic":640,"../../model/mosaic/MosaicFlags":641,"../../model/mosaic/MosaicId":642,"../../model/mosaic/MosaicNonce":645,"../../model/namespace/NamespaceId":656,"../../model/transaction/AccountAddressRestrictionTransaction":709,"../../model/transaction/AccountKeyLinkTransaction":710,"../../model/transaction/AccountMetadataTransaction":711,"../../model/transaction/AccountMosaicRestrictionTransaction":712,"../../model/transaction/AccountOperationRestrictionTransaction":713,"../../model/transaction/AddressAliasTransaction":716,"../../model/transaction/AggregateTransaction":717,"../../model/transaction/AggregateTransactionCosignature":718,"../../model/transaction/AggregateTransactionInfo":719,"../../model/transaction/Deadline":724,"../../model/transaction/LockFundsTransaction":727,"../../model/transaction/MosaicAddressRestrictionTransaction":729,"../../model/transaction/MosaicAliasTransaction":730,"../../model/transaction/MosaicDefinitionTransaction":731,"../../model/transaction/MosaicGlobalRestrictionTransaction":732,"../../model/transaction/MosaicMetadataTransaction":733,"../../model/transaction/MosaicSupplyChangeTransaction":734,"../../model/transaction/MultisigAccountModificationTransaction":735,"../../model/transaction/NamespaceMetadataTransaction":737,"../../model/transaction/NamespaceRegistrationTransaction":738,"../../model/transaction/NodeKeyLinkTransaction":739,"../../model/transaction/SecretLockTransaction":741,"../../model/transaction/SecretProofTransaction":742,"../../model/transaction/SignedTransaction":743,"../../model/transaction/TransactionInfo":747,"../../model/transaction/TransactionType":750,"../../model/transaction/TransferTransaction":752,"../../model/transaction/VotingKeyLinkTransaction":753,"../../model/transaction/VrfKeyLinkTransaction":754}],605:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const AccountAddressRestrictionTransaction_1 = require("../../model/transaction/AccountAddressRestrictionTransaction");
const AccountKeyLinkTransaction_1 = require("../../model/transaction/AccountKeyLinkTransaction");
const AccountMetadataTransaction_1 = require("../../model/transaction/AccountMetadataTransaction");
const AccountMosaicRestrictionTransaction_1 = require("../../model/transaction/AccountMosaicRestrictionTransaction");
const AccountOperationRestrictionTransaction_1 = require("../../model/transaction/AccountOperationRestrictionTransaction");
const AddressAliasTransaction_1 = require("../../model/transaction/AddressAliasTransaction");
const AggregateTransaction_1 = require("../../model/transaction/AggregateTransaction");
const LockFundsTransaction_1 = require("../../model/transaction/LockFundsTransaction");
const MosaicAddressRestrictionTransaction_1 = require("../../model/transaction/MosaicAddressRestrictionTransaction");
const MosaicAliasTransaction_1 = require("../../model/transaction/MosaicAliasTransaction");
const MosaicDefinitionTransaction_1 = require("../../model/transaction/MosaicDefinitionTransaction");
const MosaicGlobalRestrictionTransaction_1 = require("../../model/transaction/MosaicGlobalRestrictionTransaction");
const MosaicMetadataTransaction_1 = require("../../model/transaction/MosaicMetadataTransaction");
const MosaicSupplyChangeTransaction_1 = require("../../model/transaction/MosaicSupplyChangeTransaction");
const MultisigAccountModificationTransaction_1 = require("../../model/transaction/MultisigAccountModificationTransaction");
const NamespaceMetadataTransaction_1 = require("../../model/transaction/NamespaceMetadataTransaction");
const NamespaceRegistrationTransaction_1 = require("../../model/transaction/NamespaceRegistrationTransaction");
const NodeKeyLinkTransaction_1 = require("../../model/transaction/NodeKeyLinkTransaction");
const SecretLockTransaction_1 = require("../../model/transaction/SecretLockTransaction");
const SecretProofTransaction_1 = require("../../model/transaction/SecretProofTransaction");
const TransactionType_1 = require("../../model/transaction/TransactionType");
const TransferTransaction_1 = require("../../model/transaction/TransferTransaction");
const VotingKeyLinkTransaction_1 = require("../../model/transaction/VotingKeyLinkTransaction");
const VrfKeyLinkTransaction_1 = require("../../model/transaction/VrfKeyLinkTransaction");
/**
 * @internal
 * @param payload - The transaction binary data
 * @param isEmbedded - Is the transaction an embedded inner transaction
 * @returns {Transaction | InnerTransaction}
 * @constructor
 */
exports.CreateTransactionFromPayload = (payload, isEmbedded = false) => {
    const transactionBuilder = isEmbedded
        ? catbuffer_typescript_1.EmbeddedTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
        : catbuffer_typescript_1.TransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
    const type = transactionBuilder.getType().valueOf();
    switch (type) {
        case TransactionType_1.TransactionType.ACCOUNT_ADDRESS_RESTRICTION:
            return AccountAddressRestrictionTransaction_1.AccountAddressRestrictionTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.ACCOUNT_MOSAIC_RESTRICTION:
            return AccountMosaicRestrictionTransaction_1.AccountMosaicRestrictionTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.ACCOUNT_OPERATION_RESTRICTION:
            return AccountOperationRestrictionTransaction_1.AccountOperationRestrictionTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.ACCOUNT_KEY_LINK:
            return AccountKeyLinkTransaction_1.AccountKeyLinkTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.ADDRESS_ALIAS:
            return AddressAliasTransaction_1.AddressAliasTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.MOSAIC_ALIAS:
            return MosaicAliasTransaction_1.MosaicAliasTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.MOSAIC_DEFINITION:
            return MosaicDefinitionTransaction_1.MosaicDefinitionTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.MOSAIC_SUPPLY_CHANGE:
            return MosaicSupplyChangeTransaction_1.MosaicSupplyChangeTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.NAMESPACE_REGISTRATION:
            return NamespaceRegistrationTransaction_1.NamespaceRegistrationTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.TRANSFER:
            return TransferTransaction_1.TransferTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.SECRET_LOCK:
            return SecretLockTransaction_1.SecretLockTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.SECRET_PROOF:
            return SecretProofTransaction_1.SecretProofTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.MULTISIG_ACCOUNT_MODIFICATION:
            return MultisigAccountModificationTransaction_1.MultisigAccountModificationTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.HASH_LOCK:
            return LockFundsTransaction_1.LockFundsTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.MOSAIC_GLOBAL_RESTRICTION:
            return MosaicGlobalRestrictionTransaction_1.MosaicGlobalRestrictionTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.MOSAIC_ADDRESS_RESTRICTION:
            return MosaicAddressRestrictionTransaction_1.MosaicAddressRestrictionTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.ACCOUNT_METADATA:
            return AccountMetadataTransaction_1.AccountMetadataTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.MOSAIC_METADATA:
            return MosaicMetadataTransaction_1.MosaicMetadataTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.NAMESPACE_METADATA:
            return NamespaceMetadataTransaction_1.NamespaceMetadataTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.VRF_KEY_LINK:
            return VrfKeyLinkTransaction_1.VrfKeyLinkTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.NODE_KEY_LINK:
            return NodeKeyLinkTransaction_1.NodeKeyLinkTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.VOTING_KEY_LINK:
            return VotingKeyLinkTransaction_1.VotingKeyLinkTransaction.createFromPayload(payload, isEmbedded);
        case TransactionType_1.TransactionType.AGGREGATE_COMPLETE:
        case TransactionType_1.TransactionType.AGGREGATE_BONDED:
            return AggregateTransaction_1.AggregateTransaction.createFromPayload(payload);
        default:
            throw new Error('Transaction type not implemented yet.');
    }
};

},{"../../core/format":565,"../../model/transaction/AccountAddressRestrictionTransaction":709,"../../model/transaction/AccountKeyLinkTransaction":710,"../../model/transaction/AccountMetadataTransaction":711,"../../model/transaction/AccountMosaicRestrictionTransaction":712,"../../model/transaction/AccountOperationRestrictionTransaction":713,"../../model/transaction/AddressAliasTransaction":716,"../../model/transaction/AggregateTransaction":717,"../../model/transaction/LockFundsTransaction":727,"../../model/transaction/MosaicAddressRestrictionTransaction":729,"../../model/transaction/MosaicAliasTransaction":730,"../../model/transaction/MosaicDefinitionTransaction":731,"../../model/transaction/MosaicGlobalRestrictionTransaction":732,"../../model/transaction/MosaicMetadataTransaction":733,"../../model/transaction/MosaicSupplyChangeTransaction":734,"../../model/transaction/MultisigAccountModificationTransaction":735,"../../model/transaction/NamespaceMetadataTransaction":737,"../../model/transaction/NamespaceRegistrationTransaction":738,"../../model/transaction/NodeKeyLinkTransaction":739,"../../model/transaction/SecretLockTransaction":741,"../../model/transaction/SecretProofTransaction":742,"../../model/transaction/TransactionType":750,"../../model/transaction/TransferTransaction":752,"../../model/transaction/VotingKeyLinkTransaction":753,"../../model/transaction/VrfKeyLinkTransaction":754,"catbuffer-typescript":922}],606:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("../../core/crypto");
const format_1 = require("../../core/format");
class NamespaceMosaicIdGenerator {
}
exports.NamespaceMosaicIdGenerator = NamespaceMosaicIdGenerator;
/**
 * @param {Uint8Array} nonce Mosaic nonce
 * @param {Uint8Array} ownerAddress Address
 * @returns {number[]} mosaic Id
 */
NamespaceMosaicIdGenerator.mosaicId = (nonce, ownerAddress) => {
    return format_1.IdGenerator.generateMosaicId(nonce, ownerAddress);
};
/**
 * @returns random mosaic nonce
 */
NamespaceMosaicIdGenerator.generateRandomMosaicNonce = () => {
    return crypto_1.Crypto.randomBytes(4);
};
/**
 * @param {string} namespaceName - The namespace name
 * @returns sub namespace id
 */
NamespaceMosaicIdGenerator.namespaceId = (namespaceName) => {
    const path = format_1.IdGenerator.generateNamespacePath(namespaceName);
    return path.length ? format_1.IdGenerator.generateNamespacePath(namespaceName)[path.length - 1] : [];
};
/**
 * @param {string} parentNamespaceName - The parent namespace name
 * @param {string} namespaceName - The namespace name
 * @returns sub namespace parent id
 */
NamespaceMosaicIdGenerator.subnamespaceParentId = (parentNamespaceName, namespaceName) => {
    const path = format_1.IdGenerator.generateNamespacePath(`${parentNamespaceName}.${namespaceName}`);
    return format_1.IdGenerator.generateNamespacePath(parentNamespaceName)[path.length - 2];
};
/**
 * @param {string} parentNamespaceName - The parent namespace name
 * @param {string} namespaceName - The namespace name
 * @returns sub namespace id
 */
NamespaceMosaicIdGenerator.subnamespaceNamespaceId = (parentNamespaceName, namespaceName) => {
    const path = format_1.IdGenerator.generateNamespacePath(`${parentNamespaceName}.${namespaceName}`);
    return path[path.length - 1];
};

},{"../../core/crypto":555,"../../core/format":565}],607:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Convert_1 = require("../../core/format/Convert");
const TransactionType_1 = require("../../model/transaction/TransactionType");
/**
 * @internal
 * @param transaction - The transaction class object
 * @returns JSON object
 * @constructor
 */
exports.SerializeTransactionToJSON = (transaction) => {
    switch (transaction.type) {
        case TransactionType_1.TransactionType.ACCOUNT_KEY_LINK:
            const accountLinkTx = transaction;
            return {
                linkedPublicKey: accountLinkTx.linkedPublicKey,
                linkAction: accountLinkTx.linkAction,
            };
        case TransactionType_1.TransactionType.ADDRESS_ALIAS:
            const addressAliasTx = transaction;
            return {
                aliasAction: addressAliasTx.aliasAction,
                namespaceId: addressAliasTx.namespaceId.toHex(),
                address: addressAliasTx.address.toDTO(),
            };
        case TransactionType_1.TransactionType.AGGREGATE_BONDED:
        case TransactionType_1.TransactionType.AGGREGATE_COMPLETE:
            const aggregateTx = transaction;
            return {
                transactions: aggregateTx.innerTransactions.map((innerTransaction) => {
                    return innerTransaction.toJSON();
                }),
                cosignatures: aggregateTx.cosignatures.map((cosignature) => {
                    return cosignature.toDTO();
                }),
            };
        case TransactionType_1.TransactionType.HASH_LOCK:
            const LockFundTx = transaction;
            return {
                mosaicId: LockFundTx.mosaic.id.id,
                amount: LockFundTx.mosaic.amount.toString(),
                duration: LockFundTx.duration.toString(),
                hash: LockFundTx.hash,
            };
        case TransactionType_1.TransactionType.ACCOUNT_ADDRESS_RESTRICTION:
            const accountAddressRestrictionTx = transaction;
            return {
                restrictionFlags: accountAddressRestrictionTx.restrictionFlags,
                restrictionAdditionsCount: accountAddressRestrictionTx.restrictionAdditions.length,
                restrictionDeletionsCount: accountAddressRestrictionTx.restrictionDeletions.length,
                restrictionAdditions: accountAddressRestrictionTx.restrictionAdditions.map((addition) => {
                    return addition.toDTO();
                }),
                restrictionDeletions: accountAddressRestrictionTx.restrictionDeletions.map((deletion) => {
                    return deletion.toDTO();
                }),
            };
        case TransactionType_1.TransactionType.ACCOUNT_OPERATION_RESTRICTION:
            const accountOperationRestrictionTx = transaction;
            return {
                restrictionFlags: accountOperationRestrictionTx.restrictionFlags,
                restrictionAdditionsCount: accountOperationRestrictionTx.restrictionAdditions.length,
                restrictionDeletionsCount: accountOperationRestrictionTx.restrictionDeletions.length,
                restrictionAdditions: accountOperationRestrictionTx.restrictionAdditions.map((addition) => {
                    return addition;
                }),
                restrictionDeletions: accountOperationRestrictionTx.restrictionDeletions.map((deletion) => {
                    return deletion;
                }),
            };
        case TransactionType_1.TransactionType.ACCOUNT_MOSAIC_RESTRICTION:
            const accountMosaicRestrictionTx = transaction;
            return {
                restrictionFlags: accountMosaicRestrictionTx.restrictionFlags,
                restrictionAdditionsCount: accountMosaicRestrictionTx.restrictionAdditions.length,
                restrictionDeletionsCount: accountMosaicRestrictionTx.restrictionDeletions.length,
                restrictionAdditions: accountMosaicRestrictionTx.restrictionAdditions.map((addition) => {
                    return addition.toHex();
                }),
                restrictionDeletions: accountMosaicRestrictionTx.restrictionDeletions.map((deletion) => {
                    return deletion.toHex();
                }),
            };
        case TransactionType_1.TransactionType.MULTISIG_ACCOUNT_MODIFICATION:
            const multisigTx = transaction;
            return {
                minApprovalDelta: multisigTx.minApprovalDelta,
                minRemovalDelta: multisigTx.minRemovalDelta,
                addressAdditions: multisigTx.addressAdditions.map((addition) => {
                    return addition.toDTO();
                }),
                addressDeletions: multisigTx.addressDeletions.map((deletion) => {
                    return deletion.toDTO();
                }),
            };
        case TransactionType_1.TransactionType.MOSAIC_ALIAS:
            const mosaicAliasTx = transaction;
            return {
                aliasAction: mosaicAliasTx.aliasAction,
                namespaceId: mosaicAliasTx.namespaceId.toHex(),
                mosaicId: mosaicAliasTx.mosaicId.toHex(),
            };
        case TransactionType_1.TransactionType.MOSAIC_DEFINITION:
            const mosaicDefinitionTx = transaction;
            return {
                nonce: mosaicDefinitionTx.nonce.toDTO(),
                id: mosaicDefinitionTx.mosaicId.toHex(),
                flags: mosaicDefinitionTx.flags.getValue(),
                divisibility: mosaicDefinitionTx.divisibility,
                duration: mosaicDefinitionTx.duration.toString(),
            };
        case TransactionType_1.TransactionType.MOSAIC_SUPPLY_CHANGE:
            const mosaicSupplyTx = transaction;
            return {
                mosaicId: mosaicSupplyTx.mosaicId.toHex(),
                action: mosaicSupplyTx.action,
                delta: mosaicSupplyTx.delta.toString(),
            };
        case TransactionType_1.TransactionType.NAMESPACE_REGISTRATION:
            const namespaceTx = transaction;
            const registerNamespaceDuration = namespaceTx.duration;
            const registerNamespaceParentId = namespaceTx.parentId;
            const jsonObject = {
                registrationType: namespaceTx.registrationType,
                namespaceName: namespaceTx.namespaceName,
                id: namespaceTx.namespaceId.toHex(),
            };
            if (registerNamespaceDuration) {
                Object.assign(jsonObject, {
                    duration: registerNamespaceDuration.toString(),
                });
            }
            if (registerNamespaceParentId) {
                Object.assign(jsonObject, {
                    parentId: registerNamespaceParentId.toHex(),
                });
            }
            return jsonObject;
        case TransactionType_1.TransactionType.SECRET_LOCK:
            const secretLockTx = transaction;
            return {
                mosaicId: secretLockTx.mosaic.id.id.toHex(),
                amount: secretLockTx.mosaic.amount.toString(),
                duration: secretLockTx.duration.toString(),
                hashAlgorithm: secretLockTx.hashAlgorithm,
                secret: secretLockTx.secret,
                recipientAddress: secretLockTx.recipientAddress.toDTO(),
            };
        case TransactionType_1.TransactionType.SECRET_PROOF:
            const secretProofTx = transaction;
            return {
                hashAlgorithm: secretProofTx.hashAlgorithm,
                secret: secretProofTx.secret,
                recipientAddress: secretProofTx.recipientAddress.toDTO(),
                proof: secretProofTx.proof,
            };
        case TransactionType_1.TransactionType.TRANSFER:
            const transferTx = transaction;
            return {
                recipientAddress: transferTx.recipientAddress.toDTO(),
                mosaics: transferTx.mosaics.map((mosaic) => {
                    return mosaic.toDTO();
                }),
                message: transferTx.message.toDTO(),
            };
        case TransactionType_1.TransactionType.MOSAIC_GLOBAL_RESTRICTION:
            const mosaicGlobalRestrictionTx = transaction;
            return {
                mosaicId: mosaicGlobalRestrictionTx.mosaicId.toHex(),
                referenceMosaicId: mosaicGlobalRestrictionTx.referenceMosaicId.toHex(),
                restrictionKey: mosaicGlobalRestrictionTx.restrictionKey.toHex(),
                previousRestrictionValue: mosaicGlobalRestrictionTx.previousRestrictionValue.toString(),
                previousRestrictionType: mosaicGlobalRestrictionTx.previousRestrictionType,
                newRestrictionValue: mosaicGlobalRestrictionTx.newRestrictionValue.toString(),
                newRestrictionType: mosaicGlobalRestrictionTx.newRestrictionType,
            };
        case TransactionType_1.TransactionType.MOSAIC_ADDRESS_RESTRICTION:
            const mosaicAddressRestrictionTx = transaction;
            return {
                mosaicId: mosaicAddressRestrictionTx.mosaicId.toHex(),
                restrictionKey: mosaicAddressRestrictionTx.restrictionKey.toHex(),
                targetAddress: mosaicAddressRestrictionTx.targetAddress.toDTO(),
                previousRestrictionValue: mosaicAddressRestrictionTx.previousRestrictionValue.toString(),
                newRestrictionValue: mosaicAddressRestrictionTx.newRestrictionValue.toString(),
            };
        case TransactionType_1.TransactionType.ACCOUNT_METADATA:
            const accountMetadataTx = transaction;
            return {
                targetAddress: accountMetadataTx.targetAddress,
                scopedMetadataKey: accountMetadataTx.scopedMetadataKey.toHex(),
                valueSizeDelta: accountMetadataTx.valueSizeDelta,
                valueSize: accountMetadataTx.value.length,
                value: Convert_1.Convert.utf8ToHex(accountMetadataTx.value),
            };
        case TransactionType_1.TransactionType.MOSAIC_METADATA:
            const mosaicMetadataTx = transaction;
            return {
                targetAddress: mosaicMetadataTx.targetAddress,
                scopedMetadataKey: mosaicMetadataTx.scopedMetadataKey.toHex(),
                valueSizeDelta: mosaicMetadataTx.valueSizeDelta,
                targetMosaicId: mosaicMetadataTx.targetMosaicId.id.toHex(),
                valueSize: mosaicMetadataTx.value.length,
                value: Convert_1.Convert.utf8ToHex(mosaicMetadataTx.value),
            };
        case TransactionType_1.TransactionType.NAMESPACE_METADATA:
            const namespaceMetaTx = transaction;
            return {
                targetAddress: namespaceMetaTx.targetAddress,
                scopedMetadataKey: namespaceMetaTx.scopedMetadataKey.toHex(),
                valueSizeDelta: namespaceMetaTx.valueSizeDelta,
                targetNamespaceId: namespaceMetaTx.targetNamespaceId.id.toHex(),
                valueSize: namespaceMetaTx.value.length,
                value: Convert_1.Convert.utf8ToHex(namespaceMetaTx.value),
            };
        case TransactionType_1.TransactionType.VRF_KEY_LINK:
            const vrfKeyLinkTx = transaction;
            return {
                linkedPublicKey: vrfKeyLinkTx.linkedPublicKey,
                linkAction: vrfKeyLinkTx.linkAction,
            };
        case TransactionType_1.TransactionType.NODE_KEY_LINK:
            const nodeKeyLinkTx = transaction;
            return {
                linkedPublicKey: nodeKeyLinkTx.linkedPublicKey,
                linkAction: nodeKeyLinkTx.linkAction,
            };
        case TransactionType_1.TransactionType.VOTING_KEY_LINK:
            const votingKeyLinkTx = transaction;
            return {
                linkedPublicKey: votingKeyLinkTx.linkedPublicKey,
                startPoint: votingKeyLinkTx.startPoint.toString(),
                endPoint: votingKeyLinkTx.endPoint.toString(),
                linkAction: votingKeyLinkTx.linkAction,
            };
        default:
            throw new Error('Transaction type not implemented yet.');
    }
};

},{"../../core/format/Convert":558,"../../model/transaction/TransactionType":750}],608:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const UInt64_1 = require("./UInt64");
/**
 * This class is used to define mosaicIds and namespaceIds
 */
class Id extends UInt64_1.UInt64 {
    static fromHex(hexId) {
        const higher = parseInt(hexId.substr(0, 8), 16);
        const lower = parseInt(hexId.substr(8, 8), 16);
        return new Id([lower, higher]);
    }
    /**
     * Get string value of id
     * @returns {string}
     */
    toHex() {
        const part1 = this.higher.toString(16);
        const part2 = this.lower.toString(16);
        return (this.pad(part1, 8) + this.pad(part2, 8)).toUpperCase();
    }
    /**
     * @param str
     * @param maxVal
     * @returns {string}
     */
    pad(str, maxVal) {
        return str.length < maxVal ? this.pad(`0${str}`, maxVal) : str;
    }
}
exports.Id = Id;

},{"./UInt64":609}],609:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Long = require("long");
const format_1 = require("../core/format");
/**
 * UInt64 data model
 */
class UInt64 {
    /**
     * Constructor
     * @param uintArray
     */
    constructor(uintArray) {
        if (uintArray.length !== 2 || uintArray[0] < 0 || uintArray[1] < 0) {
            throw new Error('uintArray must be be an array of two uint numbers');
        }
        this.lower = uintArray[0];
        this.higher = uintArray[1];
    }
    /**
     * Create from uint value
     * @param value
     * @returns {UInt64}
     */
    static fromUint(value) {
        if (value < 0) {
            throw new Error('Unsigned integer cannot be negative');
        }
        return new UInt64(format_1.RawUInt64.fromUint(value));
    }
    /**
     * Parses a hex string into a UInt64.
     * @param {string} input A hex encoded string.
     * @returns {module:coders/uint64~uint64} The uint64 representation of the input.
     */
    static fromHex(input) {
        const dto = format_1.RawUInt64.fromHex(input);
        return new UInt64(dto);
    }
    /**
     * Parses a numeric string into a UInt64.
     * @param {string} input A numeric string.
     * @returns {module:coders/uint64~uint64} The uint64 representation of the input.
     */
    static fromNumericString(input) {
        if (!UInt64.isLongNumericString(input)) {
            throw new Error('Input string is not a valid numeric string');
        }
        const input_long = Long.fromString(input, true);
        return new UInt64([input_long.getLowBitsUnsigned(), input_long.getHighBitsUnsigned()]);
    }
    /**
     * Check if input string is a numeric string or not
     * @param {string} input A string.
     * @returns {boolean}
     */
    static isLongNumericString(input) {
        const input_long = Long.fromString(input, true);
        if (!/^\d+$/.test(input) || (input.substr(0, 1) === '0' && input.length > 1) || !Long.isLong(input_long)) {
            return false;
        }
        return true;
    }
    /**
     * Get DTO representation with format: `[lower, higher]`
     *
     * @internal
     * @returns {[number,number]}
     */
    toDTO() {
        return [this.lower, this.higher];
    }
    /**
     * Get hexadecimal representation
     *
     * @return {string}
     */
    toHex() {
        return format_1.RawUInt64.toHex(this.toDTO());
    }
    /**
     * Get numeric string representation
     *
     * @return {string}
     */
    toString() {
        return Long.fromBits(this.lower, this.higher, true).toString();
    }
    /**
     * Compact higher and lower uint parts into a uint
     * @returns {number}
     */
    compact() {
        const result = format_1.RawUInt64.compact(this.toDTO());
        if (Array.isArray(result)) {
            throw new Error('Compacted value is greater than Number.Max_Value.');
        }
        return result;
    }
    /**
     * Compares for equality
     * @param other
     * @returns {boolean}
     */
    equals(other) {
        return this.lower === other.lower && this.higher === other.higher;
    }
    /**
     * Compares two UInt64
     * @param other
     * @returns {number} - -1, 0, 1
     */
    compare(other) {
        const long_a = Long.fromBits(this.lower, this.higher, true);
        const long_b = Long.fromBits(other.lower, other.higher, true);
        return long_a.compare(long_b);
    }
    /**
     * UInt64 add operation
     * @param other
     * @returns {UInt64}
     */
    add(other) {
        const long_value = Long.fromBits(this.lower, this.higher, true);
        const long_b = Long.fromBits(other.lower, other.higher, true);
        return this.longToUint64(long_value.add(long_b));
    }
    /**
     * UInt64 add operation
     * @param other
     * @returns {UInt64}
     */
    subtract(other) {
        const long_value = Long.fromBits(this.lower, this.higher, true);
        const long_b = Long.fromBits(other.lower, other.higher, true);
        if (long_value.compare(long_b) < 0) {
            throw new Error('Unsigned substraction result cannot be negative.');
        }
        return this.longToUint64(long_value.subtract(long_b));
    }
    /**
     * Convert long value to UInt64
     * @param longValue long value
     */
    longToUint64(longValue) {
        return new UInt64([longValue.getLowBitsUnsigned(), longValue.getHighBitsUnsigned()]);
    }
}
exports.UInt64 = UInt64;

},{"../core/format":565,"long":349}],610:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("../../core/crypto");
const format_1 = require("../../core/format");
const EncryptedMessage_1 = require("../message/EncryptedMessage");
const Address_1 = require("./Address");
const PublicAccount_1 = require("./PublicAccount");
/**
 * The account structure describes an account private key, public key, address and allows signing transactions.
 */
class Account {
    /**
     * @internal
     * @param address
     * @param keyPair
     */
    constructor(
    /**
     * The account address.
     */
    address, 
    /**
     * The account keyPair, public and private key.
     */
    keyPair) {
        this.address = address;
        this.keyPair = keyPair;
    }
    /**
     * Create an Account from a given private key
     * @param privateKey - Private key from an account
     * @param networkType - Network type
     * @return {Account}
     */
    static createFromPrivateKey(privateKey, networkType) {
        const keyPair = crypto_1.KeyPair.createKeyPairFromPrivateKeyString(privateKey);
        const address = format_1.RawAddress.addressToString(format_1.RawAddress.publicKeyToAddress(keyPair.publicKey, networkType));
        return new Account(Address_1.Address.createFromRawAddress(address), keyPair);
    }
    /**
     * Generate a new account
     * @param networkType - Network type
     */
    static generateNewAccount(networkType) {
        // Create random bytes
        const randomBytesArray = crypto_1.Crypto.randomBytes(32);
        // Hash random bytes with entropy seed
        // Finalize and keep only 32 bytes
        const hashKey = format_1.Convert.uint8ToHex(randomBytesArray);
        // Create KeyPair from hash key
        const keyPair = crypto_1.KeyPair.createKeyPairFromPrivateKeyString(hashKey);
        const address = Address_1.Address.createFromPublicKey(format_1.Convert.uint8ToHex(keyPair.publicKey), networkType);
        return new Account(address, keyPair);
    }
    /**
     * Create a new encrypted Message
     * @param message - Plain message to be encrypted
     * @param recipientPublicAccount - Recipient public account
     * @returns {EncryptedMessage}
     */
    encryptMessage(message, recipientPublicAccount) {
        return EncryptedMessage_1.EncryptedMessage.create(message, recipientPublicAccount, this.privateKey);
    }
    /**
     * Decrypts an encrypted message
     * @param encryptedMessage - Encrypted message
     * @param publicAccount - The public account originally encrypted the message
     * @returns {PlainMessage}
     */
    decryptMessage(encryptedMessage, publicAccount) {
        return EncryptedMessage_1.EncryptedMessage.decrypt(encryptedMessage, this.privateKey, publicAccount);
    }
    /**
     * Account public key.
     * @return {string}
     */
    get publicKey() {
        return format_1.Convert.uint8ToHex(this.keyPair.publicKey);
    }
    /**
     * Public account.
     * @return {PublicAccount}
     */
    get publicAccount() {
        return PublicAccount_1.PublicAccount.createFromPublicKey(this.publicKey, this.address.networkType);
    }
    /**
     * Account private key.
     * @return {string}
     */
    get privateKey() {
        return format_1.Convert.uint8ToHex(this.keyPair.privateKey);
    }
    /**
     * Account network type.
     * @return {NetworkType}
     */
    get networkType() {
        return this.address.networkType;
    }
    /**
     * Sign a transaction
     * @param transaction - The transaction to be signed.
     * @param generationHash - Network generation hash hex
     * @return {SignedTransaction}
     */
    sign(transaction, generationHash) {
        return transaction.signWith(this, generationHash);
    }
    /**
     * Sign transaction with cosignatories creating a new SignedTransaction
     * @param transaction - The aggregate transaction to be signed.
     * @param cosignatories - The array of accounts that will cosign the transaction
     * @param generationHash - Network generation hash hex
     * @return {SignedTransaction}
     */
    signTransactionWithCosignatories(transaction, cosignatories, generationHash) {
        return transaction.signTransactionWithCosignatories(this, cosignatories, generationHash);
    }
    /**
     * Sign transaction with cosignatories collected from cosigned transactions and creating a new SignedTransaction
     * For off chain Aggregated Complete Transaction co-signing.
     * @param initiatorAccount - Initiator account
     * @param {CosignatureSignedTransaction[]} cosignatureSignedTransactions - Array of cosigned transaction
     * @param generationHash - Network generation hash hex
     * @return {SignedTransaction}
     */
    signTransactionGivenSignatures(transaction, cosignatureSignedTransactions, generationHash) {
        return transaction.signTransactionGivenSignatures(this, cosignatureSignedTransactions, generationHash);
    }
    /**
     * Sign aggregate signature transaction
     * @param cosignatureTransaction - The aggregate signature transaction.
     * @return {CosignatureSignedTransaction}
     */
    signCosignatureTransaction(cosignatureTransaction) {
        return cosignatureTransaction.signWith(this);
    }
    /**
     * Sign raw data
     * @param data - Data to be signed
     * @return {string} - Signed data result
     */
    signData(data) {
        return format_1.Convert.uint8ToHex(crypto_1.KeyPair.sign(this.keyPair, format_1.Convert.hexToUint8(format_1.Convert.utf8ToHex(data))));
    }
}
exports.Account = Account;

},{"../../core/crypto":555,"../../core/format":565,"../message/EncryptedMessage":630,"./Address":618,"./PublicAccount":621}],611:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const PublicAccount_1 = require("./PublicAccount");
/**
 * The account info structure describes basic information for an account.
 */
class AccountInfo {
    /**
     *
     */
    constructor(
    /**
     * Address of the account.
     */
    address, 
    /**
     * Height when the address was published.
     */
    addressHeight, 
    /**
     * Public key of the account.
     */
    publicKey, 
    /**
     * Height when the public key was published.
     */
    publicKeyHeight, 
    /**
     * Account type
     */
    accountType, 
    /**
     * Account keys
     */
    supplementalPublicKeys, 
    /**
     * Account activity bucket
     */
    activityBucket, 
    /**
     * Mosaics held by the account.
     */
    mosaics, 
    /**
     * Importance of the account.
     */
    importance, 
    /**
     * Importance height of the account.
     */
    importanceHeight) {
        this.address = address;
        this.addressHeight = addressHeight;
        this.publicKey = publicKey;
        this.publicKeyHeight = publicKeyHeight;
        this.accountType = accountType;
        this.supplementalPublicKeys = supplementalPublicKeys;
        this.activityBucket = activityBucket;
        this.mosaics = mosaics;
        this.importance = importance;
        this.importanceHeight = importanceHeight;
    }
    /**
     * Returns account public account.
     * @returns {PublicAccount}
     */
    get publicAccount() {
        return PublicAccount_1.PublicAccount.createFromPublicKey(this.publicKey, this.address.networkType);
    }
}
exports.AccountInfo = AccountInfo;

},{"./PublicAccount":621}],612:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The account key flags enum,.
 */
var AccountKeyTypeFlags;
(function (AccountKeyTypeFlags) {
    /**
     * Unset key.
     */
    AccountKeyTypeFlags[AccountKeyTypeFlags["Unset"] = 0] = "Unset";
    /**
     * Linked account public key.
     * note This can be either a remote or main account public key depending on context.
     */
    AccountKeyTypeFlags[AccountKeyTypeFlags["Linked"] = 1] = "Linked";
    /**
     * Node public key on which remote is allowed to harvest.
     */
    AccountKeyTypeFlags[AccountKeyTypeFlags["Node"] = 2] = "Node";
    /**
     * VRF public key.
     */
    AccountKeyTypeFlags[AccountKeyTypeFlags["VRF"] = 4] = "VRF";
    /**
     * All valid keys.
     */
    AccountKeyTypeFlags[AccountKeyTypeFlags["All"] = 7] = "All";
})(AccountKeyTypeFlags = exports.AccountKeyTypeFlags || (exports.AccountKeyTypeFlags = {}));

},{}],613:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Account key
 */
class AccountLinkPublicKey {
    /**
     *
     */
    constructor(
    /**
     * public key
     */
    publicKey) {
        this.publicKey = publicKey;
    }
}
exports.AccountLinkPublicKey = AccountLinkPublicKey;

},{}],614:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Account link voting key
 */
class AccountLinkVotingKey {
    /**
     *
     */
    constructor(
    /**
     * public key
     */
    publicKey, 
    /**
     * Start point
     */
    startPoint, 
    /**
     * End point
     */
    endPoint) {
        this.publicKey = publicKey;
        this.startPoint = startPoint;
        this.endPoint = endPoint;
    }
}
exports.AccountLinkVotingKey = AccountLinkVotingKey;

},{}],615:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Account with linked names
 */
class AccountNames {
    /**
     *
     */
    constructor(
    /**
     * Address of the account.
     */
    address, 
    /**
     * Address linked namespace Ids
     */
    names) {
        this.address = address;
        this.names = names;
    }
}
exports.AccountNames = AccountNames;

},{}],616:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"),
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * 0 - Unlinked.
 * 1 - Main account that is linked to a remote harvester account.
 * 2 - Remote harvester account that is linked to a balance-holding account.
 * 3 - Remote harvester eligible account that is unlinked.
 */
var AccountType;
(function (AccountType) {
    AccountType[AccountType["Unlinked"] = 0] = "Unlinked";
    AccountType[AccountType["Main"] = 1] = "Main";
    AccountType[AccountType["Remote"] = 2] = "Remote";
    AccountType[AccountType["Remote_Unlinked"] = 3] = "Remote_Unlinked";
})(AccountType = exports.AccountType || (exports.AccountType = {}));

},{}],617:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Account activity bucket.
 */
class ActivityBucket {
    /**
     * Constructor
     * @param meta
     * @param accountRestrictions
     */
    constructor(
    /**
     * Start height
     */
    startHeight, 
    /**
     * Total fees paid.
     */
    totalFeesPaid, 
    /**
     * Beneficiary count.
     */
    beneficiaryCount, 
    /**
     * Raw score.
     */
    rawScore) {
        this.startHeight = startHeight;
        this.totalFeesPaid = totalFeesPaid;
        this.beneficiaryCount = beneficiaryCount;
        this.rawScore = rawScore;
    }
}
exports.ActivityBucket = ActivityBucket;

},{}],618:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const format_1 = require("../../core/format");
const NetworkType_1 = require("../network/NetworkType");
/**
 * The address structure describes an address with its network
 */
class Address {
    /**
     * @internal
     * @param address
     * @param networkType
     */
    constructor(
    /**
     * The address value.
     */
    address, 
    /**
     * The NEM network type.
     */
    networkType) {
        this.address = address;
        this.networkType = networkType;
    }
    /**
     * Create from private key
     * @param publicKey - The account public key.
     * @param networkType - The NEM network type.
     * @returns {Address}
     */
    static createFromPublicKey(publicKey, networkType) {
        const publicKeyUint8 = format_1.Convert.hexToUint8(publicKey);
        const address = format_1.RawAddress.addressToString(format_1.RawAddress.publicKeyToAddress(publicKeyUint8, networkType));
        return new Address(address, networkType);
    }
    /**
     * Create an Address from a given raw address.
     * @param rawAddress - Address in string format.
     *                  ex: SB3KUBHATFCPV7UZQLWAQ2EUR6SIHBSBEOEDDDF3 or SB3KUB-HATFCP-V7UZQL-WAQ2EU-R6SIHB-SBEOED-DDF3
     * @returns {Address}
     */
    static createFromRawAddress(rawAddress) {
        let networkType;
        const addressTrimAndUpperCase = rawAddress.trim().toUpperCase().replace(/-/g, '');
        if (addressTrimAndUpperCase.length !== 39) {
            throw new Error('Address ' + addressTrimAndUpperCase + ' has to be 39 characters long');
        }
        if (addressTrimAndUpperCase.charAt(0) === 'S') {
            networkType = NetworkType_1.NetworkType.MIJIN_TEST;
        }
        else if (addressTrimAndUpperCase.charAt(0) === 'M') {
            networkType = NetworkType_1.NetworkType.MIJIN;
        }
        else if (addressTrimAndUpperCase.charAt(0) === 'T') {
            networkType = NetworkType_1.NetworkType.TEST_NET;
        }
        else if (addressTrimAndUpperCase.charAt(0) === 'N') {
            networkType = NetworkType_1.NetworkType.MAIN_NET;
        }
        else {
            throw new Error('Address Network unsupported');
        }
        return new Address(addressTrimAndUpperCase, networkType);
    }
    /**
     * Create an Address from a given encoded address.
     * @param {string} encoded address. Expected format: 9085215E4620D383C2DF70235B9EF7607F6A28EF6D16FD7B9C.
     * @return {Address}
     */
    static createFromEncoded(encoded) {
        return Address.createFromRawAddress(format_1.RawAddress.addressToString(format_1.Convert.hexToUint8(encoded)));
    }
    /**
     * Get address in plain format ex: SB3KUBHATFCPV7UZQLWAQ2EUR6SIHBSBEOEDDDF3.
     * @returns {string}
     */
    plain() {
        return this.address;
    }
    /**
     * Get address in the encoded format ex: NAR3W7B4BCOZSZMFIZRYB3N5YGOUSWIYJCJ6HDFH.
     * @returns {string}
     */
    encoded() {
        return format_1.Convert.uint8ToHex(format_1.RawAddress.stringToAddress(this.address));
    }
    /**
     * Get address in pretty format ex: SB3KUB-HATFCP-V7UZQL-WAQ2EU-R6SIHB-SBEOED-DDF3.
     * @returns {string}
     */
    pretty() {
        return this.address.match(/.{1,6}/g).join('-');
    }
    /**
     * Compares addresses for equality
     * @param address - Address to compare
     * @returns {boolean}
     */
    equals(address) {
        if (address instanceof Address) {
            return this.plain() === address.plain() && this.networkType === address.networkType;
        }
        return false;
    }
    /**
     * Create DTO object
     */
    toDTO() {
        return {
            address: this.address,
            networkType: this.networkType,
        };
    }
    /**
     * Encoded address or namespace id. Note that namespace id get the hex reversed and
     * zero padded.
     * @returns {Uint8Array}
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    encodeUnresolvedAddress(networkType) {
        return format_1.Convert.hexToUint8(this.encoded());
    }
}
exports.Address = Address;
/**
 * Determines the validity of an raw address string.
 * @param {string} rawAddress The raw address string. Expected format SATNE7Q5BITMUTRRN6IB4I7FLSDRDWZA34I2PMQ
 * @returns {boolean} true if the raw address string is valid, false otherwise.
 */
Address.isValidRawAddress = (rawAddress) => {
    if (!['A', 'I', 'Q', 'Y'].includes(rawAddress.slice(-1).toUpperCase())) {
        return false;
    }
    try {
        return format_1.RawAddress.isValidAddress(format_1.RawAddress.stringToAddress(rawAddress));
    }
    catch (err) {
        return false;
    }
};
/**
 * Determines the validity of an encoded address string.
 * @param {string} encoded The encoded address string. Expected format: 6823BB7C3C089D996585466380EDBDC19D4959184893E38C
 * @returns {boolean} true if the encoded address string is valid, false otherwise.
 */
Address.isValidEncodedAddress = (encoded) => {
    try {
        return format_1.RawAddress.isValidAddress(format_1.Convert.hexToUint8(encoded));
    }
    catch (err) {
        return false;
    }
};

},{"../../core/format":565,"../network/NetworkType":673}],619:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Multisig account graph info model
 */
class MultisigAccountGraphInfo {
    /**
     * @param multisigEntries
     */
    constructor(
    /**
     * The multisig accounts.
     */
    multisigEntries) {
        this.multisigEntries = multisigEntries;
    }
}
exports.MultisigAccountGraphInfo = MultisigAccountGraphInfo;

},{}],620:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The multisig account graph info structure describes the information of all the mutlisig levels an account is involved in.
 */
class MultisigAccountInfo {
    /**
     * @param accountAddress
     * @param minApproval
     * @param minRemoval
     * @param cosignatoryAddresses
     * @param multisigAddresses
     */
    constructor(
    /**
     * The account multisig address.
     */
    accountAddress, 
    /**
     * The number of signatures needed to approve a transaction.
     */
    minApproval, 
    /**
     * The number of signatures needed to remove a cosignatory.
     */
    minRemoval, 
    /**
     * The multisig account cosignatories.
     */
    cosignatoryAddresses, 
    /**
     * The multisig accounts this account is cosigner of.
     */
    multisigAddresses) {
        this.accountAddress = accountAddress;
        this.minApproval = minApproval;
        this.minRemoval = minRemoval;
        this.cosignatoryAddresses = cosignatoryAddresses;
        this.multisigAddresses = multisigAddresses;
    }
    /**
     * Checks if the account is a multisig account.
     * @returns {boolean}
     */
    isMultisig() {
        return this.minRemoval !== 0 && this.minApproval !== 0;
    }
    /**
     * Checks if an account is cosignatory of the multisig account.
     * @param address
     * @returns {boolean}
     */
    hasCosigner(address) {
        return this.cosignatoryAddresses.find((cosigner) => cosigner.equals(address)) !== undefined;
    }
    /**
     * Checks if the multisig account is cosignatory of an account.
     * @param address
     * @returns {boolean}
     */
    isCosignerOfMultisigAccount(address) {
        return this.multisigAddresses.find((multisig) => multisig.equals(address)) !== undefined;
    }
}
exports.MultisigAccountInfo = MultisigAccountInfo;

},{}],621:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("../../core/crypto");
const format_1 = require("../../core/format");
const Address_1 = require("./Address");
const Hash512 = 64;
/**
 * The public account structure contains account's address and public key.
 */
class PublicAccount {
    /**
     * @internal
     * @param publicKey
     * @param address
     */
    constructor(
    /**
     * The account public private.
     */
    publicKey, 
    /**
     * The account address.
     */
    address) {
        this.publicKey = publicKey;
        this.address = address;
    }
    /**
     * Create a PublicAccount from a public key and network type.
     * @param publicKey Public key
     * @param networkType Network type
     * @returns {PublicAccount}
     */
    static createFromPublicKey(publicKey, networkType) {
        if (publicKey == null || (publicKey.length !== 64 && publicKey.length !== 66)) {
            throw new Error('Not a valid public key');
        }
        const address = Address_1.Address.createFromPublicKey(publicKey, networkType);
        return new PublicAccount(publicKey, address);
    }
    /**
     * Verify a signature.
     *
     * @param {string} data - The data to verify.
     * @param {string} signature - The signature to verify.
     * @return {boolean}  - True if the signature is valid, false otherwise.
     */
    verifySignature(data, signature) {
        if (!signature) {
            throw new Error('Missing argument');
        }
        if (signature.length / 2 !== Hash512) {
            throw new Error('Signature length is incorrect');
        }
        if (!format_1.Convert.isHexString(signature)) {
            throw new Error('Signature must be hexadecimal only');
        }
        // Convert signature key to Uint8Array
        const convertedSignature = format_1.Convert.hexToUint8(signature);
        // Convert to Uint8Array
        const convertedData = format_1.Convert.hexToUint8(format_1.Convert.utf8ToHex(data));
        return crypto_1.KeyPair.verify(format_1.Convert.hexToUint8(this.publicKey), convertedData, convertedSignature);
    }
    /**
     * Compares public accounts for equality.
     * @param publicAccount
     * @returns {boolean}
     */
    equals(publicAccount) {
        return this.publicKey === publicAccount.publicKey && this.address.plain() === publicAccount.address.plain();
    }
    /**
     * Create DTO object
     */
    toDTO() {
        return {
            publicKey: this.publicKey,
            address: this.address.toDTO(),
        };
    }
}
exports.PublicAccount = PublicAccount;

},{"../../core/crypto":555,"../../core/format":565,"./Address":618}],622:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * SupplementalPublicKeys
 */
class SupplementalPublicKeys {
    /**
     *
     */
    constructor(
    /**
     * Linked keys
     */
    linked, 
    /**
     * Node linked keys
     */
    node, 
    /**
     * VRF linked keys
     */
    vrf, 
    /**
     * Voting linked keys
     */
    voting) {
        this.linked = linked;
        this.node = node;
        this.vrf = vrf;
        this.voting = voting;
    }
}
exports.SupplementalPublicKeys = SupplementalPublicKeys;

},{}],623:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The block info structure describes basic information of a block.
 */
class BlockInfo {
    /**
     * @param recordId
     * @param size
     * @param hash
     * @param generationHash
     * @param totalFee
     * @param stateHashSubCacheMerkleRoots
     * @param numTransactions
     * @param signature
     * @param signer
     * @param networkType
     * @param version
     * @param type
     * @param height
     * @param timestamp
     * @param difficulty
     * @param proofGamma
     * @param proofScalar
     * @param proofVerificationHash
     * @param feeMultiplier
     * @param previousBlockHash
     * @param blockTransactionsHash
     * @param blockReceiptsHash
     * @param blockStateHash
     * @param beneficiaryAddress
     * @param numStatements
     */
    constructor(
    /**
     * The database record id.
     */
    recordId, 
    /**
     * Entity size in bytes.
     */
    size, 
    /**
     * The block hash.
     */
    hash, 
    /**
     * The generation hash
     */
    generationHash, 
    /**
     * The sum of all transaction fees included in the block.
     */
    totalFee, 
    /**
     * State hash sub cache merkle roots
     */
    stateHashSubCacheMerkleRoots, 
    /**
     * The number of transactions included.
     */
    numTransactions, 
    /**
     * The block signature.
     * The signature was generated by the signer and can be used to validate that the blockchain
     * data was not modified by a node.
     */
    signature, 
    /**
     * The public account of block harvester.
     */
    signer, 
    /**
     * The network type.
     */
    networkType, 
    /**
     * The transaction version.
     */
    version, 
    /**
     * The block type.
     */
    type, 
    /**
     * The height of which the block was confirmed.
     * Each block has a unique height. Subsequent blocks differ in height by 1.
     */
    height, 
    /**
     * The number of milliseconds elapsed since the creation of the nemesis blockchain.
     */
    timestamp, 
    /**
     * The POI difficulty to harvest a block.
     */
    difficulty, 
    /**
     * The feeMultiplier defined by the harvester.
     */
    feeMultiplier, 
    /**
     * The last block hash.
     */
    previousBlockHash, 
    /**
     * The block transaction hash.
     */
    blockTransactionsHash, 
    /**
     * The block receipt hash.
     */
    blockReceiptsHash, 
    /**
     * The state hash.
     */
    stateHash, 
    /**
     * The proof gamma.
     */
    proofGamma, 
    /**
     * The proof scalar.
     */
    proofScalar, 
    /**
     * The proof verification hash.
     */
    proofVerificationHash, 
    /**
     * The beneficiary address.
     */
    beneficiaryAddress, 
    /**
     * The number of statements included.
     */
    numStatements) {
        this.recordId = recordId;
        this.size = size;
        this.hash = hash;
        this.generationHash = generationHash;
        this.totalFee = totalFee;
        this.stateHashSubCacheMerkleRoots = stateHashSubCacheMerkleRoots;
        this.numTransactions = numTransactions;
        this.signature = signature;
        this.signer = signer;
        this.networkType = networkType;
        this.version = version;
        this.type = type;
        this.height = height;
        this.timestamp = timestamp;
        this.difficulty = difficulty;
        this.feeMultiplier = feeMultiplier;
        this.previousBlockHash = previousBlockHash;
        this.blockTransactionsHash = blockTransactionsHash;
        this.blockReceiptsHash = blockReceiptsHash;
        this.stateHash = stateHash;
        this.proofGamma = proofGamma;
        this.proofScalar = proofScalar;
        this.proofVerificationHash = proofVerificationHash;
        this.beneficiaryAddress = beneficiaryAddress;
        this.numStatements = numStatements;
    }
}
exports.BlockInfo = BlockInfo;

},{}],624:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The blockchain score structure describes blockchain difficulty.
 */
class BlockchainScore {
    /**
     * @param scoreLow
     * @param scoreHigh
     */
    constructor(
    /**
     * Low part of the blockchain score.
     */
    scoreLow, 
    /**
     * High part of the blockchain score.
     */
    scoreHigh) {
        this.scoreLow = scoreLow;
        this.scoreHigh = scoreHigh;
    }
}
exports.BlockchainScore = BlockchainScore;

},{}],625:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The block merkle path item
 */
class MerklePathItem {
    /**
     * @param position
     * @param hash
     */
    constructor(
    /**
     * The position
     */
    position, 
    /**
     * The hash
     */
    hash) {
        this.position = position;
        this.hash = hash;
    }
}
exports.MerklePathItem = MerklePathItem;

},{}],626:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MerklePosition;
(function (MerklePosition) {
    MerklePosition["Left"] = "left";
    MerklePosition["Right"] = "right";
})(MerklePosition = exports.MerklePosition || (exports.MerklePosition = {}));

},{}],627:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The block merkle proof info
 */
class MerkleProofInfo {
    /**
     * @param merklePath - Array of merkle path items
     */
    constructor(
    /**
     * The merkle path
     */
    merklePath) {
        this.merklePath = merklePath;
    }
}
exports.MerkleProofInfo = MerkleProofInfo;

},{}],628:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The block info structure describes basic information of a new gernated block (Websocket payload).
 */
class NewBlock {
    /**
     * @param hash
     * @param generationHash
     * @param signature
     * @param signer
     * @param networkType
     * @param version
     * @param type
     * @param height
     * @param timestamp
     * @param difficulty
     * @param proofGamma
     * @param proofScalar
     * @param proofVerificationHash
     * @param feeMultiplier
     * @param previousBlockHash
     * @param blockTransactionsHash
     * @param blockReceiptsHash
     * @param blockStateHash
     * @param beneficiaryAddress
     */
    constructor(
    /**
     * The block hash.
     */
    hash, 
    /**
     * The generation hash
     */
    generationHash, 
    /**
     * The block signature.
     * The signature was generated by the signer and can be used to validate that the blockchain
     * data was not modified by a node.
     */
    signature, 
    /**
     * The public account of block harvester.
     */
    signer, 
    /**
     * The network type.
     */
    networkType, 
    /**
     * The transaction version.
     */
    version, 
    /**
     * The block type.
     */
    type, 
    /**
     * The height of which the block was confirmed.
     * Each block has a unique height. Subsequent blocks differ in height by 1.
     */
    height, 
    /**
     * The number of milliseconds elapsed since the creation of the nemesis blockchain.
     */
    timestamp, 
    /**
     * The POI difficulty to harvest a block.
     */
    difficulty, 
    /**
     * The feeMultiplier defined by the harvester.
     */
    feeMultiplier, 
    /**
     * The last block hash.
     */
    previousBlockHash, 
    /**
     * The block transaction hash.
     */
    blockTransactionsHash, 
    /**
     * The block receipt hash.
     */
    blockReceiptsHash, 
    /**
     * The state hash.
     */
    stateHash, 
    /**
     * The proof gamma.
     */
    proofGamma, 
    /**
     * The proof scalar.
     */
    proofScalar, 
    /**
     * The proof verification hash.
     */
    proofVerificationHash, 
    /**
     * The beneficiary address.
     */
    beneficiaryAddress) {
        this.hash = hash;
        this.generationHash = generationHash;
        this.signature = signature;
        this.signer = signer;
        this.networkType = networkType;
        this.version = version;
        this.type = type;
        this.height = height;
        this.timestamp = timestamp;
        this.difficulty = difficulty;
        this.feeMultiplier = feeMultiplier;
        this.previousBlockHash = previousBlockHash;
        this.blockTransactionsHash = blockTransactionsHash;
        this.blockReceiptsHash = blockReceiptsHash;
        this.stateHash = stateHash;
        this.proofGamma = proofGamma;
        this.proofScalar = proofScalar;
        this.proofVerificationHash = proofVerificationHash;
        this.beneficiaryAddress = beneficiaryAddress;
    }
}
exports.NewBlock = NewBlock;

},{}],629:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The blockchain storage info structure describes stored data.
 */
class StorageInfo {
    /**
     * @param numBlocks
     * @param numTransactions
     * @param numAccounts
     */
    constructor(
    /**
     * The number of confirmed blocks.
     */
    numBlocks, 
    /**
     * The number of confirmed transactions.
     */
    numTransactions, 
    /**
     * The number accounts published in the blockchain.
     */
    numAccounts) {
        this.numBlocks = numBlocks;
        this.numTransactions = numTransactions;
        this.numAccounts = numAccounts;
    }
}
exports.StorageInfo = StorageInfo;

},{}],630:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("../../core/crypto");
const Message_1 = require("./Message");
const MessageType_1 = require("./MessageType");
const PlainMessage_1 = require("./PlainMessage");
/**
 * Encrypted Message model
 */
class EncryptedMessage extends Message_1.Message {
    constructor(payload, recipientPublicAccount) {
        super(MessageType_1.MessageType.EncryptedMessage, payload);
        this.recipientPublicAccount = recipientPublicAccount;
    }
    /**
     *
     * @param message - Plain message to be encrypted
     * @param recipientPublicAccount - Recipient public account
     * @param privateKey - Sender private key
     * @return {EncryptedMessage}
     */
    static create(message, recipientPublicAccount, privateKey) {
        return new EncryptedMessage(crypto_1.Crypto.encode(privateKey, recipientPublicAccount.publicKey, message).toUpperCase(), recipientPublicAccount);
    }
    /**
     *
     * @param payload
     */
    static createFromPayload(payload) {
        return new EncryptedMessage(this.decodeHex(payload));
    }
    /**
     *
     * @param encryptMessage - Encrypted message to be decrypted
     * @param privateKey - Recipient private key
     * @param recipientPublicAccount - Sender public account
     * @return {PlainMessage}
     */
    static decrypt(encryptMessage, privateKey, recipientPublicAccount) {
        return new PlainMessage_1.PlainMessage(this.decodeHex(crypto_1.Crypto.decode(privateKey, recipientPublicAccount.publicKey, encryptMessage.payload)));
    }
}
exports.EncryptedMessage = EncryptedMessage;

},{"../../core/crypto":555,"./Message":631,"./MessageType":633,"./PlainMessage":635}],631:[function(require,module,exports){
(function (Buffer){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An abstract message class that serves as the base class of all message types.
 */
class Message {
    /**
     * @internal
     * @param type
     * @param payload
     */
    constructor(
    /**
     * Message type
     */
    type, 
    /**
     * Message payload
     */
    payload) {
        this.type = type;
        this.payload = payload;
    }
    /**
     * @internal
     * @param hex
     * @returns {string}
     */
    static decodeHex(hex) {
        return Buffer.from(hex, 'hex').toString();
    }
    /**
     * Create DTO object
     */
    toDTO() {
        return {
            type: this.type,
            payload: this.payload,
        };
    }
}
exports.Message = Message;

}).call(this,require("buffer").Buffer)
},{"buffer":47}],632:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class MessageMarker {
}
exports.MessageMarker = MessageMarker;
/**
 * 8-byte marker: E201735761802AFE for PersistentDelegationRequestTransaction message
 */
MessageMarker.PersistentDelegationUnlock = 'E201735761802AFE';

},{}],633:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The Message type. Supported supply types are:
 * 0: PlainMessage
 * 1: EncryptedMessage.
 * 254: Persistent harvesting delegation.
 */
var MessageType;
(function (MessageType) {
    MessageType[MessageType["PlainMessage"] = 0] = "PlainMessage";
    MessageType[MessageType["EncryptedMessage"] = 1] = "EncryptedMessage";
    MessageType[MessageType["PersistentHarvestingDelegationMessage"] = 254] = "PersistentHarvestingDelegationMessage";
})(MessageType = exports.MessageType || (exports.MessageType = {}));

},{}],634:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("../../core/crypto");
const Convert_1 = require("../../core/format/Convert");
const Account_1 = require("../account/Account");
const Message_1 = require("./Message");
const MessageMarker_1 = require("./MessageMarker");
const MessageType_1 = require("./MessageType");
class PersistentHarvestingDelegationMessage extends Message_1.Message {
    constructor(payload) {
        super(MessageType_1.MessageType.PersistentHarvestingDelegationMessage, payload);
        if (!Convert_1.Convert.isHexString(payload)) {
            throw Error('Payload format is not valid hexadecimal string');
        }
    }
    /**
     * @param signingPrivateKey - Remote harvester signing private key linked to the main account
     * @param vrfPrivateKey - VRF private key linked to the main account
     * @param nodePublicKey - Node certificate public key
     * @param {NetworkType} networkType - Catapult network type
     * @return {PersistentHarvestingDelegationMessage}
     */
    static create(signingPrivateKey, vrfPrivateKey, nodePublicKey, networkType) {
        const ephemeralKeypair = Account_1.Account.generateNewAccount(networkType);
        const encrypted = MessageMarker_1.MessageMarker.PersistentDelegationUnlock +
            ephemeralKeypair.publicKey +
            crypto_1.Crypto.encode(ephemeralKeypair.privateKey, nodePublicKey, signingPrivateKey + vrfPrivateKey, true).toUpperCase();
        return new PersistentHarvestingDelegationMessage(encrypted);
    }
    /**
     * Create PersistentHarvestingDelegationMessage from DTO payload
     * @param payload
     */
    static createFromPayload(payload) {
        const msgTypeHex = MessageType_1.MessageType.PersistentHarvestingDelegationMessage.toString(16).toUpperCase();
        return new PersistentHarvestingDelegationMessage(msgTypeHex + payload.toUpperCase());
    }
    /**
     *
     * @param encryptMessage - Encrypted message to be decrypted
     * @param privateKey - Node certificate private key
     * @return {string}
     */
    static decrypt(encryptMessage, privateKey) {
        const markerLength = MessageMarker_1.MessageMarker.PersistentDelegationUnlock.length;
        const ephemeralPublicKey = encryptMessage.payload.substring(markerLength, markerLength + 64);
        const payload = encryptMessage.payload.substring(markerLength + ephemeralPublicKey.length);
        const decrypted = crypto_1.Crypto.decode(privateKey, ephemeralPublicKey, payload);
        return decrypted.toUpperCase();
    }
}
exports.PersistentHarvestingDelegationMessage = PersistentHarvestingDelegationMessage;

},{"../../core/crypto":555,"../../core/format/Convert":558,"../account/Account":610,"./Message":631,"./MessageMarker":632,"./MessageType":633}],635:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Message_1 = require("./Message");
const MessageType_1 = require("./MessageType");
/**
 * The plain message model defines a plain string. When sending it to the network we transform the payload to hex-string.
 */
class PlainMessage extends Message_1.Message {
    /**
     * Create plain message object.
     * @returns PlainMessage
     */
    static create(message) {
        return new PlainMessage(message);
    }
    /**
     * @internal
     */
    static createFromPayload(payload) {
        return new PlainMessage(this.decodeHex(payload));
    }
    /**
     * @internal
     * @param payload
     */
    constructor(payload) {
        super(MessageType_1.MessageType.PlainMessage, payload);
    }
}
exports.PlainMessage = PlainMessage;
/**
 * Plain message containing an empty string
 * @type {PlainMessage}
 */
exports.EmptyMessage = PlainMessage.create('');

},{"./Message":631,"./MessageType":633}],636:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A mosaic describes an instance of a mosaic definition.
 * Mosaics can be transferred by means of a transfer transaction.
 */
class Metadata {
    /**
     * Constructor
     * @param id - The metadata id
     * @param metadataEntry - The metadata entry
     */
    constructor(
    /**
     * The metadata id
     */
    id, 
    /**
     * The metadata entry
     */
    metadataEntry) {
        this.id = id;
        this.metadataEntry = metadataEntry;
    }
}
exports.Metadata = Metadata;

},{}],637:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A mosaic describes an instance of a mosaic definition.
 * Mosaics can be transferred by means of a transfer transaction.
 */
class MetadataEntry {
    /**
     * Constructor
     * @param {string} compositeHash - The composite hash
     * @param {string} sourceAddress - The metadata source address (provider)
     * @param {string} targetAddress - The metadata target address
     * @param {UInt64} scopedMetadataKey - The key scoped to source, target and type
     * @param {MetadatType} metadataType - The metadata type (Account | Mosaic | Namespace)
     * @param {string} value - The metadata value
     * @param {UnresolvedMosaicId | undefined} targetId - The target mosaic or namespace identifier
     */
    constructor(
    /**
     * The composite hash
     */
    compositeHash, 
    /**
     * The metadata source address (provider)
     */
    sourceAddress, 
    /**
     * The metadata target address
     */
    targetAddress, 
    /**
     * The key scoped to source, target and type
     */
    scopedMetadataKey, 
    /**
     * The metadata type
     */
    metadataType, 
    /**
     * The metadata value
     */
    value, 
    /**
     * The target mosaic or namespace identifier
     */
    targetId) {
        this.compositeHash = compositeHash;
        this.sourceAddress = sourceAddress;
        this.targetAddress = targetAddress;
        this.scopedMetadataKey = scopedMetadataKey;
        this.metadataType = metadataType;
        this.value = value;
        this.targetId = targetId;
    }
}
exports.MetadataEntry = MetadataEntry;

},{}],638:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MetadataType;
(function (MetadataType) {
    MetadataType[MetadataType["Account"] = 0] = "Account";
    MetadataType[MetadataType["Mosaic"] = 1] = "Mosaic";
    MetadataType[MetadataType["Namespace"] = 2] = "Namespace";
})(MetadataType = exports.MetadataType || (exports.MetadataType = {}));

},{}],639:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./UInt64"));
__export(require("./Id"));
// Account
__export(require("./account/Account"));
__export(require("./account/AccountType"));
__export(require("./account/ActivityBucket"));
__export(require("./account/AccountInfo"));
__export(require("./account/Address"));
__export(require("./account/MultisigAccountGraphInfo"));
__export(require("./account/MultisigAccountInfo"));
__export(require("./account/PublicAccount"));
__export(require("./account/AccountNames"));
__export(require("./account/AccountKeyTypeFlags"));
__export(require("./account/AccountLinkPublicKey"));
__export(require("./account/AccountLinkVotingKey"));
__export(require("./account/SupplementalPublicKeys"));
// Blockchain
__export(require("./blockchain/BlockchainScore"));
__export(require("./blockchain/StorageInfo"));
__export(require("./blockchain/BlockInfo"));
__export(require("./blockchain/MerklePathItem"));
__export(require("./blockchain/MerkleProofInfo"));
__export(require("./blockchain/NewBlock"));
__export(require("./blockchain/MerklePosition"));
// Diagnostic
__export(require("./node/ServerInfo"));
// Mosaic
__export(require("./mosaic/Mosaic"));
__export(require("./mosaic/MosaicInfo"));
__export(require("./mosaic/MosaicId"));
__export(require("./mosaic/MosaicNonce"));
__export(require("./mosaic/MosaicSupplyChangeAction"));
__export(require("./mosaic/MosaicFlags"));
__export(require("../service/MosaicView"));
__export(require("../service/MosaicAmountView"));
__export(require("./mosaic/NetworkCurrencyLocal"));
__export(require("./mosaic/NetworkCurrencyPublic"));
__export(require("./mosaic/NetworkHarvestLocal"));
__export(require("./mosaic/MosaicNames"));
// Mosaic
__export(require("./metadata/Metadata"));
__export(require("./metadata/MetadataEntry"));
__export(require("./metadata/MetadataType"));
__export(require("./namespace/AliasType"));
__export(require("./namespace/Alias"));
__export(require("./namespace/AddressAlias"));
__export(require("./namespace/MosaicAlias"));
__export(require("./namespace/NamespaceId"));
__export(require("./namespace/NamespaceInfo"));
__export(require("./namespace/NamespaceName"));
__export(require("./namespace/NamespaceRegistrationType"));
__export(require("./namespace/AliasAction"));
__export(require("./namespace/EmptyAlias"));
// Network
__export(require("./network/AccountLinkNetworkProperties"));
__export(require("./network/AccountRestrictionNetworkProperties"));
__export(require("./network/AggregateNetworkProperties"));
__export(require("./network/ChainProperties"));
__export(require("./network/HashLockNetworkProperties"));
__export(require("./network/MetadataNetworkProperties"));
__export(require("./network/MosaicNetworkProperties"));
__export(require("./network/MosaicRestrictionNetworkProperties"));
__export(require("./network/MultisigNetworkProperties"));
__export(require("./network/NamespaceNetworkProperties"));
__export(require("./network/NetworkConfiguration"));
__export(require("./network/NetworkName"));
__export(require("./network/NetworkProperties"));
__export(require("./network/NetworkType"));
__export(require("./network/PluginProperties"));
__export(require("./network/RentalFees"));
__export(require("./network/SecretLockNetworkProperties"));
__export(require("./network/TransactionFees"));
__export(require("./network/TransferNetworkProperties"));
// Node
__export(require("./node/NodeInfo"));
__export(require("./node/NodeTime"));
__export(require("./node/RoleType"));
__export(require("./node/NodeHealth"));
// Receipt
__export(require("./receipt/ArtifactExpiryReceipt"));
__export(require("./receipt/BalanceChangeReceipt"));
__export(require("./receipt/BalanceTransferReceipt"));
__export(require("./receipt/Receipt"));
__export(require("./receipt/ReceiptSource"));
__export(require("./receipt/ReceiptType"));
__export(require("./receipt/ReceiptVersion"));
__export(require("./receipt/ResolutionEntry"));
__export(require("./receipt/ResolutionStatement"));
__export(require("./receipt/TransactionStatement"));
__export(require("./receipt/ResolutionType"));
__export(require("./receipt/InflationReceipt"));
__export(require("./receipt/Statement"));
// Restriction
__export(require("./restriction/AccountRestrictions"));
__export(require("./restriction/AccountRestrictionsInfo"));
__export(require("./restriction/AccountRestriction"));
__export(require("./restriction/AccountRestrictionModificationAction"));
__export(require("./restriction/AddressRestrictionFlag"));
__export(require("./restriction/MosaicRestrictionFlag"));
__export(require("./restriction/OperationRestrictionFlag"));
__export(require("./restriction/MosaicRestrictionType"));
__export(require("./restriction/MosaicAddressRestriction"));
__export(require("./restriction/MosaicGlobalRestriction"));
__export(require("./restriction/MosaicGlobalRestrictionItem"));
__export(require("./restriction/MosaicRestrictionEntryType"));
// Message
__export(require("./message/PersistentHarvestingDelegationMessage"));
__export(require("./message/EncryptedMessage"));
__export(require("./message/Message"));
__export(require("./message/PlainMessage"));
__export(require("./message/MessageMarker"));
__export(require("./message/MessageType"));
// Transaction
__export(require("./transaction/AccountKeyLinkTransaction"));
__export(require("./transaction/AccountRestrictionTransaction"));
__export(require("./transaction/AccountAddressRestrictionTransaction"));
__export(require("./transaction/AccountMosaicRestrictionTransaction"));
__export(require("./transaction/AccountOperationRestrictionTransaction"));
__export(require("./transaction/AccountRestrictionModification"));
__export(require("./transaction/AddressAliasTransaction"));
__export(require("./transaction/AggregateTransaction"));
__export(require("./transaction/AggregateTransactionCosignature"));
__export(require("./transaction/AggregateTransactionInfo"));
__export(require("./transaction/AliasTransaction"));
__export(require("./transaction/CosignatureSignedTransaction"));
__export(require("./transaction/CosignatureTransaction"));
__export(require("./transaction/Deadline"));
__export(require("./transaction/PersistentDelegationRequestTransaction"));
__export(require("./transaction/HashLockTransaction"));
__export(require("./transaction/LockHashAlgorithm"));
__export(require("./transaction/LinkAction"));
__export(require("./transaction/LockFundsTransaction"));
__export(require("./transaction/MultisigAccountModificationTransaction"));
__export(require("./transaction/MosaicAliasTransaction"));
__export(require("./transaction/MosaicDefinitionTransaction"));
__export(require("./transaction/MosaicSupplyChangeTransaction"));
__export(require("./transaction/MultisigCosignatoryModification"));
__export(require("./transaction/CosignatoryModificationAction"));
__export(require("./transaction/NamespaceRegistrationTransaction"));
__export(require("./transaction/SecretLockTransaction"));
__export(require("./transaction/SecretProofTransaction"));
__export(require("./transaction/SignedTransaction"));
__export(require("./transaction/SyncAnnounce"));
__export(require("./transaction/Transaction"));
__export(require("./transaction/TransactionAnnounceResponse"));
__export(require("./transaction/TransactionInfo"));
__export(require("./transaction/TransactionStatus"));
__export(require("./transaction/TransactionStatusError"));
__export(require("./transaction/TransactionType"));
__export(require("./transaction/TransferTransaction"));
__export(require("./transaction/AccountMetadataTransaction"));
__export(require("./transaction/MosaicMetadataTransaction"));
__export(require("./transaction/NamespaceMetadataTransaction"));
__export(require("./transaction/MosaicGlobalRestrictionTransaction"));
__export(require("./transaction/MosaicAddressRestrictionTransaction"));
__export(require("./transaction/VotingKeyLinkTransaction"));
__export(require("./transaction/VrfKeyLinkTransaction"));
__export(require("./transaction/NodeKeyLinkTransaction"));
__export(require("./wallet/Password"));
__export(require("./wallet/SimpleWallet"));
__export(require("./wallet/Wallet"));

},{"../service/MosaicAmountView":762,"../service/MosaicView":765,"./Id":608,"./UInt64":609,"./account/Account":610,"./account/AccountInfo":611,"./account/AccountKeyTypeFlags":612,"./account/AccountLinkPublicKey":613,"./account/AccountLinkVotingKey":614,"./account/AccountNames":615,"./account/AccountType":616,"./account/ActivityBucket":617,"./account/Address":618,"./account/MultisigAccountGraphInfo":619,"./account/MultisigAccountInfo":620,"./account/PublicAccount":621,"./account/SupplementalPublicKeys":622,"./blockchain/BlockInfo":623,"./blockchain/BlockchainScore":624,"./blockchain/MerklePathItem":625,"./blockchain/MerklePosition":626,"./blockchain/MerkleProofInfo":627,"./blockchain/NewBlock":628,"./blockchain/StorageInfo":629,"./message/EncryptedMessage":630,"./message/Message":631,"./message/MessageMarker":632,"./message/MessageType":633,"./message/PersistentHarvestingDelegationMessage":634,"./message/PlainMessage":635,"./metadata/Metadata":636,"./metadata/MetadataEntry":637,"./metadata/MetadataType":638,"./mosaic/Mosaic":640,"./mosaic/MosaicFlags":641,"./mosaic/MosaicId":642,"./mosaic/MosaicInfo":643,"./mosaic/MosaicNames":644,"./mosaic/MosaicNonce":645,"./mosaic/MosaicSupplyChangeAction":646,"./mosaic/NetworkCurrencyLocal":647,"./mosaic/NetworkCurrencyPublic":648,"./mosaic/NetworkHarvestLocal":649,"./namespace/AddressAlias":650,"./namespace/Alias":651,"./namespace/AliasAction":652,"./namespace/AliasType":653,"./namespace/EmptyAlias":654,"./namespace/MosaicAlias":655,"./namespace/NamespaceId":656,"./namespace/NamespaceInfo":657,"./namespace/NamespaceName":658,"./namespace/NamespaceRegistrationType":659,"./network/AccountLinkNetworkProperties":660,"./network/AccountRestrictionNetworkProperties":661,"./network/AggregateNetworkProperties":662,"./network/ChainProperties":663,"./network/HashLockNetworkProperties":664,"./network/MetadataNetworkProperties":665,"./network/MosaicNetworkProperties":666,"./network/MosaicRestrictionNetworkProperties":667,"./network/MultisigNetworkProperties":668,"./network/NamespaceNetworkProperties":669,"./network/NetworkConfiguration":670,"./network/NetworkName":671,"./network/NetworkProperties":672,"./network/NetworkType":673,"./network/PluginProperties":674,"./network/RentalFees":675,"./network/SecretLockNetworkProperties":676,"./network/TransactionFees":677,"./network/TransferNetworkProperties":678,"./node/NodeHealth":679,"./node/NodeInfo":680,"./node/NodeTime":681,"./node/RoleType":682,"./node/ServerInfo":683,"./receipt/ArtifactExpiryReceipt":684,"./receipt/BalanceChangeReceipt":685,"./receipt/BalanceTransferReceipt":686,"./receipt/InflationReceipt":687,"./receipt/Receipt":688,"./receipt/ReceiptSource":689,"./receipt/ReceiptType":690,"./receipt/ReceiptVersion":691,"./receipt/ResolutionEntry":692,"./receipt/ResolutionStatement":693,"./receipt/ResolutionType":694,"./receipt/Statement":695,"./receipt/TransactionStatement":696,"./restriction/AccountRestriction":697,"./restriction/AccountRestrictionModificationAction":698,"./restriction/AccountRestrictions":699,"./restriction/AccountRestrictionsInfo":700,"./restriction/AddressRestrictionFlag":701,"./restriction/MosaicAddressRestriction":702,"./restriction/MosaicGlobalRestriction":703,"./restriction/MosaicGlobalRestrictionItem":704,"./restriction/MosaicRestrictionEntryType":705,"./restriction/MosaicRestrictionFlag":706,"./restriction/MosaicRestrictionType":707,"./restriction/OperationRestrictionFlag":708,"./transaction/AccountAddressRestrictionTransaction":709,"./transaction/AccountKeyLinkTransaction":710,"./transaction/AccountMetadataTransaction":711,"./transaction/AccountMosaicRestrictionTransaction":712,"./transaction/AccountOperationRestrictionTransaction":713,"./transaction/AccountRestrictionModification":714,"./transaction/AccountRestrictionTransaction":715,"./transaction/AddressAliasTransaction":716,"./transaction/AggregateTransaction":717,"./transaction/AggregateTransactionCosignature":718,"./transaction/AggregateTransactionInfo":719,"./transaction/AliasTransaction":720,"./transaction/CosignatoryModificationAction":721,"./transaction/CosignatureSignedTransaction":722,"./transaction/CosignatureTransaction":723,"./transaction/Deadline":724,"./transaction/HashLockTransaction":725,"./transaction/LinkAction":726,"./transaction/LockFundsTransaction":727,"./transaction/LockHashAlgorithm":728,"./transaction/MosaicAddressRestrictionTransaction":729,"./transaction/MosaicAliasTransaction":730,"./transaction/MosaicDefinitionTransaction":731,"./transaction/MosaicGlobalRestrictionTransaction":732,"./transaction/MosaicMetadataTransaction":733,"./transaction/MosaicSupplyChangeTransaction":734,"./transaction/MultisigAccountModificationTransaction":735,"./transaction/MultisigCosignatoryModification":736,"./transaction/NamespaceMetadataTransaction":737,"./transaction/NamespaceRegistrationTransaction":738,"./transaction/NodeKeyLinkTransaction":739,"./transaction/PersistentDelegationRequestTransaction":740,"./transaction/SecretLockTransaction":741,"./transaction/SecretProofTransaction":742,"./transaction/SignedTransaction":743,"./transaction/SyncAnnounce":744,"./transaction/Transaction":745,"./transaction/TransactionAnnounceResponse":746,"./transaction/TransactionInfo":747,"./transaction/TransactionStatus":748,"./transaction/TransactionStatusError":749,"./transaction/TransactionType":750,"./transaction/TransferTransaction":752,"./transaction/VotingKeyLinkTransaction":753,"./transaction/VrfKeyLinkTransaction":754,"./wallet/Password":755,"./wallet/SimpleWallet":756,"./wallet/Wallet":757}],640:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A mosaic describes an instance of a mosaic definition.
 * Mosaics can be transferred by means of a transfer transaction.
 */
class Mosaic {
    /**
     * Constructor
     * @param id
     * @param amount
     */
    constructor(
    /**
     * The mosaic id
     */
    id, 
    /**
     * The mosaic amount. The quantity is always given in smallest units for the mosaic
     * i.e. if it has a divisibility of 3 the quantity is given in millis.
     */
    amount) {
        this.id = id;
        this.amount = amount;
    }
    /**
     * @internal
     * @returns {{amount: number[], id: number[]}}
     */
    toDTO() {
        return {
            amount: this.amount.toString(),
            id: this.id.id.toHex(),
        };
    }
}
exports.Mosaic = Mosaic;

},{}],641:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Mosaic flags model
 */
class MosaicFlags {
    /**
     * @param flags
     * @param divisibility
     * @param duration
     */
    constructor(flags) {
        let binaryFlags = '00' + (flags >>> 0).toString(2);
        binaryFlags = binaryFlags.substr(binaryFlags.length - 3, 3);
        this.supplyMutable = binaryFlags[2] === '1';
        this.transferable = binaryFlags[1] === '1';
        this.restrictable = binaryFlags[0] === '1';
    }
    /**
     * Static constructor function with default parameters
     * @returns {MosaicFlags}
     * @param supplyMutable
     * @param transferable
     * @param restrictable
     */
    static create(supplyMutable, transferable, restrictable = false) {
        const flags = (supplyMutable ? 1 : 0) + (transferable ? 2 : 0) + (restrictable ? 4 : 0);
        return new MosaicFlags(flags);
    }
    /**
     * Get mosaic flag value in number
     * @returns {number}
     */
    getValue() {
        return (this.supplyMutable ? 1 : 0) + (this.transferable ? 2 : 0) + (this.restrictable ? 4 : 0);
    }
    /**
     * Create DTO object
     */
    toDTO() {
        return {
            flags: this.getValue(),
        };
    }
}
exports.MosaicFlags = MosaicFlags;

},{}],642:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const format_1 = require("../../core/format");
const NamespaceMosaicIdGenerator_1 = require("../../infrastructure/transaction/NamespaceMosaicIdGenerator");
const Id_1 = require("../Id");
/**
 * The mosaic id structure describes mosaic id
 *
 * @since 1.0
 */
class MosaicId {
    /**
     * Create MosaicId from mosaic id in form of array of number (ex: [3646934825, 3576016193])
     * or the hexadecimal notation thereof in form of a string.
     *
     * @param id
     */
    constructor(id) {
        if (id === undefined) {
            throw new Error('MosaicId undefined');
        }
        if (id instanceof Array) {
            this.id = new Id_1.Id(id);
        }
        else if (typeof id === 'string') {
            if (!/^[0-9A-Fa-f]{16}$/i.test(id)) {
                throw new Error('Invalid size for MosaicId hexadecimal notation');
            }
            // hexadecimal formatted MosaicId
            this.id = new Id_1.Id(format_1.RawUInt64.fromHex(id));
        }
    }
    /**
     * Create a MosaicId for given `nonce` MosaicNonce and `owner` PublicAccount.
     *
     * @param   nonce   {MosaicNonce}
     * @param   ownerAddress   {Address}
     * @return  {MosaicId}
     */
    static createFromNonce(nonce, ownerAddress) {
        const mosaicId = NamespaceMosaicIdGenerator_1.NamespaceMosaicIdGenerator.mosaicId(nonce.toUint8Array(), format_1.Convert.hexToUint8(ownerAddress.encoded()));
        return new MosaicId(mosaicId);
    }
    /**
     * Get string value of id
     * @returns {string}
     */
    toHex() {
        return this.id.toHex().toUpperCase();
    }
    /**
     * Compares mosaicIds for equality.
     *
     * @return boolean
     */
    equals(other) {
        if (other instanceof MosaicId) {
            return this.id.equals(other.id);
        }
        return false;
    }
    /**
     * Create DTO object.
     */
    toDTO() {
        return this.id.toDTO();
    }
}
exports.MosaicId = MosaicId;

},{"../../core/format":565,"../../infrastructure/transaction/NamespaceMosaicIdGenerator":606,"../Id":608}],643:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The mosaic info structure describes a mosaic.
 */
class MosaicInfo {
    /**
     * @param recordId
     * @param id
     * @param supply
     * @param startHeight
     * @param ownerAddress
     * @param revision
     * @param flags
     * @param divisibility
     * @param duration
     */
    constructor(
    /**
     * The database record id.
     */
    recordId, 
    /**
     * The mosaic id.
     */
    id, 
    /**
     * The mosaic supply.
     */
    supply, 
    /**
     * The block height were mosaic was created.
     */
    startHeight, 
    /**
     * The mosaic owner address.
     */
    ownerAddress, 
    /**
     * The mosaic revision
     */
    revision, 
    /**
     * The mosaic flags.
     */
    flags, 
    /**
     * Mosaic divisibility
     */
    divisibility, 
    /**
     * Mosaic duration
     */
    duration) {
        this.recordId = recordId;
        this.id = id;
        this.supply = supply;
        this.startHeight = startHeight;
        this.ownerAddress = ownerAddress;
        this.revision = revision;
        this.flags = flags;
        this.divisibility = divisibility;
        this.duration = duration;
    }
    /**
     * Is mosaic supply mutable
     * @returns {boolean}
     */
    isSupplyMutable() {
        return this.flags.supplyMutable;
    }
    /**
     * Is mosaic transferable
     * @returns {boolean}
     */
    isTransferable() {
        return this.flags.transferable;
    }
    /**
     * Is mosaic restrictable
     * @returns {boolean}
     */
    isRestrictable() {
        return this.flags.restrictable;
    }
}
exports.MosaicInfo = MosaicInfo;

},{}],644:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Mosaic with linked names
 */
class MosaicNames {
    /**
     *
     */
    constructor(
    /**
     * Mosaic Id
     */
    mosaicId, 
    /**
     * Address linked namespace names
     */
    names) {
        this.mosaicId = mosaicId;
        this.names = names;
    }
}
exports.MosaicNames = MosaicNames;

},{}],645:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const crypto_1 = require("../../core/crypto");
const format_1 = require("../../core/format");
/**
 * The mosaic nonce structure
 *
 * @since 1.0
 */
class MosaicNonce {
    /**
     * Create MosaicNonce from int
     *
     * @param nonce nonce
     */
    constructor(nonce) {
        if (nonce.length !== 4) {
            throw Error('Invalid byte size for nonce, should be 4 bytes but received ' + nonce.length);
        }
        this.nonce = nonce;
    }
    /**
     * Create a random MosaicNonce
     *
     * @return  {MosaicNonce}
     */
    static createRandom() {
        const bytes = crypto_1.Crypto.randomBytes(4);
        const nonce = new Uint8Array(bytes);
        return this.createFromUint8Array(nonce);
    }
    /**
     * Create a MosaicNonce from a Uint8Array notation.
     *
     * @param   nonce {number}
     * @return  {MosaicNonce}
     */
    static createFromUint8Array(nonce) {
        return new MosaicNonce(nonce);
    }
    /**
     * Create a MosaicNonce from a number notation.
     *
     * @param   nonce {number}
     * @return  {MosaicNonce}
     */
    static createFromNumber(nonce) {
        return new MosaicNonce(format_1.Convert.numberToUint8Array(nonce, 4));
    }
    /**
     * Create a MosaicNonce from hexadecimal notation.
     *
     * @param   hex     {string}
     * @return  {MosaicNonce}
     */
    static createFromHex(hex) {
        return new MosaicNonce(format_1.Convert.hexToUint8(hex));
    }
    /**
     * @returns the nonce as an array of 4 digits
     */
    toUint8Array() {
        return this.nonce;
    }
    /**
     * @internal
     * @returns the nonce as number
     */
    toDTO() {
        return format_1.Convert.uintArray8ToNumber(this.nonce);
    }
    /**
     * Get string value of nonce
     * @returns the nonce as hex
     */
    toHex() {
        return format_1.Convert.uint8ToHex(this.nonce);
    }
}
exports.MosaicNonce = MosaicNonce;

},{"../../core/crypto":555,"../../core/format":565}],646:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The supply type. Supported supply types are:
 * 0: Increase in supply.
 * 1: Decrease in supply.
 */
var MosaicSupplyChangeAction;
(function (MosaicSupplyChangeAction) {
    MosaicSupplyChangeAction[MosaicSupplyChangeAction["Decrease"] = 0] = "Decrease";
    MosaicSupplyChangeAction[MosaicSupplyChangeAction["Increase"] = 1] = "Increase";
})(MosaicSupplyChangeAction = exports.MosaicSupplyChangeAction || (exports.MosaicSupplyChangeAction = {}));

},{}],647:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const NamespaceId_1 = require("../namespace/NamespaceId");
const UInt64_1 = require("../UInt64");
const Mosaic_1 = require("./Mosaic");
/**
 * NetworkCurrencyLocal mosaic for local test network (local bootstrap server)
 *
 * This represents the per-network currency mosaic. This mosaicId is aliased
 * with namespace name `cat.currency`.
 *
 * @since 0.10.2
 */
class NetworkCurrencyLocal extends Mosaic_1.Mosaic {
    /**
     * constructor
     * @param owner
     * @param amount
     */
    constructor(amount) {
        super(NetworkCurrencyLocal.NAMESPACE_ID, amount);
    }
    /**
     * Create NetworkCurrencyLocal with using NetworkCurrencyLocal as unit.
     *
     * @param amount
     * @returns {NetworkCurrencyLocal}
     */
    static createRelative(amount) {
        if (typeof amount === 'number') {
            return new NetworkCurrencyLocal(UInt64_1.UInt64.fromUint(amount * Math.pow(10, NetworkCurrencyLocal.DIVISIBILITY)));
        }
        return new NetworkCurrencyLocal(UInt64_1.UInt64.fromUint(amount.compact() * Math.pow(10, NetworkCurrencyLocal.DIVISIBILITY)));
    }
    /**
     * Create NetworkCurrencyLocal with using micro NetworkCurrencyLocal as unit,
     * 1 NetworkCurrencyLocal = 1000000 micro NetworkCurrencyLocal.
     *
     * @param amount
     * @returns {NetworkCurrencyLocal}
     */
    static createAbsolute(amount) {
        if (typeof amount === 'number') {
            return new NetworkCurrencyLocal(UInt64_1.UInt64.fromUint(amount));
        }
        return new NetworkCurrencyLocal(amount);
    }
}
exports.NetworkCurrencyLocal = NetworkCurrencyLocal;
/**
 * namespaceId of `currency` namespace.
 *
 * @type {Id}
 */
NetworkCurrencyLocal.NAMESPACE_ID = new NamespaceId_1.NamespaceId('cat.currency');
/**
 * Divisiblity
 * @type {number}
 */
NetworkCurrencyLocal.DIVISIBILITY = 6;
/**
 * Initial supply
 * @type {number}
 */
NetworkCurrencyLocal.INITIAL_SUPPLY = 8999999998;
/**
 * Is tranferable
 * @type {boolean}
 */
NetworkCurrencyLocal.TRANSFERABLE = true;
/**
 * Is Supply mutable
 * @type {boolean}
 */
NetworkCurrencyLocal.SUPPLY_MUTABLE = false;

},{"../UInt64":609,"../namespace/NamespaceId":656,"./Mosaic":640}],648:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const NamespaceId_1 = require("../namespace/NamespaceId");
const UInt64_1 = require("../UInt64");
const Mosaic_1 = require("./Mosaic");
/**
 * NetworkCurrencyPublic mosaic for public / Public_test network
 *
 * This represents the per-network currency mosaic. This mosaicId is aliased
 * with namespace name `symbol.xym`.
 *
 * @since 0.10.2
 */
class NetworkCurrencyPublic extends Mosaic_1.Mosaic {
    /**
     * constructor
     * @param owner
     * @param amount
     */
    constructor(amount) {
        super(NetworkCurrencyPublic.NAMESPACE_ID, amount);
    }
    /**
     * Create NetworkCurrencyPublic with using NetworkCurrencyPublic as unit.
     *
     * @param amount
     * @returns {NetworkCurrencyPublic}
     */
    static createRelative(amount) {
        if (typeof amount === 'number') {
            return new NetworkCurrencyPublic(UInt64_1.UInt64.fromUint(amount * Math.pow(10, NetworkCurrencyPublic.DIVISIBILITY)));
        }
        return new NetworkCurrencyPublic(UInt64_1.UInt64.fromUint(amount.compact() * Math.pow(10, NetworkCurrencyPublic.DIVISIBILITY)));
    }
    /**
     * Create NetworkCurrencyPublic with using micro NetworkCurrencyPublic as unit,
     * 1 NetworkCurrencyPublic = 1000000 micro NetworkCurrencyPublic.
     *
     * @param amount
     * @returns {NetworkCurrencyPublic}
     */
    static createAbsolute(amount) {
        if (typeof amount === 'number') {
            return new NetworkCurrencyPublic(UInt64_1.UInt64.fromUint(amount));
        }
        return new NetworkCurrencyPublic(amount);
    }
}
exports.NetworkCurrencyPublic = NetworkCurrencyPublic;
/**
 * namespaceId of `currency` namespace.
 *
 * @type {Id}
 */
NetworkCurrencyPublic.NAMESPACE_ID = new NamespaceId_1.NamespaceId('symbol.xym');
/**
 * Divisiblity
 * @type {number}
 */
NetworkCurrencyPublic.DIVISIBILITY = 6;
/**
 * Initial supply
 * @type {number}
 */
NetworkCurrencyPublic.INITIAL_SUPPLY = 8999999998;
/**
 * Is tranferable
 * @type {boolean}
 */
NetworkCurrencyPublic.TRANSFERABLE = true;
/**
 * Is Supply mutable
 * @type {boolean}
 */
NetworkCurrencyPublic.SUPPLY_MUTABLE = false;

},{"../UInt64":609,"../namespace/NamespaceId":656,"./Mosaic":640}],649:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NamespaceId_1 = require("../namespace/NamespaceId");
const UInt64_1 = require("../UInt64");
const Mosaic_1 = require("./Mosaic");
/**
 * NetworkHarvestLocal mosaic
 *
 * This represents the per-network harvest mosaic. This mosaicId is aliased
 * with namespace name `cat.harvest`.
 *
 * @since 0.10.2
 */
class NetworkHarvestLocal extends Mosaic_1.Mosaic {
    /**
     * constructor
     * @param owner
     * @param amount
     */
    constructor(amount) {
        super(NetworkHarvestLocal.NAMESPACE_ID, amount);
    }
    /**
     * Create NetworkHarvestLocal with using NetworkHarvestLocal as unit.
     *
     * @param amount
     * @returns {NetworkHarvestLocal}
     */
    static createRelative(amount) {
        if (typeof amount === 'number') {
            return new NetworkHarvestLocal(UInt64_1.UInt64.fromUint(amount * Math.pow(10, NetworkHarvestLocal.DIVISIBILITY)));
        }
        return new NetworkHarvestLocal(UInt64_1.UInt64.fromUint(amount.compact() * Math.pow(10, NetworkHarvestLocal.DIVISIBILITY)));
    }
    /**
     * Create NetworkHarvestLocal with using micro NetworkHarvestLocal as unit,
     * 1 NetworkHarvestLocal = 1000000 micro NetworkHarvestLocal.
     *
     * @param amount
     * @returns {NetworkHarvestLocal}
     */
    static createAbsolute(amount) {
        if (typeof amount === 'number') {
            return new NetworkHarvestLocal(UInt64_1.UInt64.fromUint(amount));
        }
        return new NetworkHarvestLocal(amount);
    }
}
exports.NetworkHarvestLocal = NetworkHarvestLocal;
/**
 * namespaceId of `currency` namespace.
 *
 * @type {Id}
 */
NetworkHarvestLocal.NAMESPACE_ID = new NamespaceId_1.NamespaceId('cat.harvest');
/**
 * Divisiblity
 * @type {number}
 */
NetworkHarvestLocal.DIVISIBILITY = 3;
/**
 * Initial supply
 * @type {number}
 */
NetworkHarvestLocal.INITIAL_SUPPLY = 15000000;
/**
 * Is tranferable
 * @type {boolean}
 */
NetworkHarvestLocal.TRANSFERABLE = true;
/**
 * Is Supply mutable
 * @type {boolean}
 */
NetworkHarvestLocal.SUPPLY_MUTABLE = true;

},{"../UInt64":609,"../namespace/NamespaceId":656,"./Mosaic":640}],650:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RawAddress_1 = require("../../core/format/RawAddress");
const Alias_1 = require("./Alias");
const AliasType_1 = require("./AliasType");
/**
 * The AddressAlias structure describes address aliases
 *
 * @since 0.10.2
 */
class AddressAlias extends Alias_1.Alias {
    /**
     * Create AddressAlias object
     * @param content
     */
    constructor(
    /**
     * The alias address
     */
    address) {
        super(AliasType_1.AliasType.Address, address, undefined);
        this.address = address;
    }
    /**
     * Compares AddressAlias for equality.
     *
     * @return boolean
     */
    equals(alias) {
        if (alias instanceof AddressAlias) {
            return this.address.equals(alias.address);
        }
        return false;
    }
    /**
     * Generate alias buffer
     * @return {Uint8Array}
     */
    serialize() {
        return RawAddress_1.RawAddress.stringToAddress(this.address.plain());
    }
}
exports.AddressAlias = AddressAlias;

},{"../../core/format/RawAddress":561,"./Alias":651,"./AliasType":653}],651:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Abtract class for Aliases
 *
 * @since 0.10.2
 */
class Alias {
    /**
     * @internal
     * @param type - Alias type
     * @param address - Address for AddressAlias
     * @param mosaicId - MosaicId for MosaicAlias
     */
    constructor(
    /**
     * The alias type
     *
     * - 0 : No alias
     * - 1 : Mosaic id alias
     * - 2 : Address alias
     */
    type, 
    /**
     * The alias address
     */
    address, 
    /**
     * The alias mosaicId
     */
    mosaicId) {
        this.type = type;
        this.address = address;
        this.mosaicId = mosaicId;
    }
}
exports.Alias = Alias;

},{}],652:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The alias action type. Supported actions are:
 * 0: Link an alias.
 * 1: Unlink an alias.
 */
var AliasAction;
(function (AliasAction) {
    AliasAction[AliasAction["Link"] = 1] = "Link";
    AliasAction[AliasAction["Unlink"] = 0] = "Unlink";
})(AliasAction = exports.AliasAction || (exports.AliasAction = {}));

},{}],653:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The alias type. Supported types are:
 * 0: No alias.
 * 1: Mosaic id alias.
 * 2: Address alias.
 *
 * @since 0.10.2
 */
var AliasType;
(function (AliasType) {
    AliasType[AliasType["None"] = 0] = "None";
    AliasType[AliasType["Mosaic"] = 1] = "Mosaic";
    AliasType[AliasType["Address"] = 2] = "Address";
})(AliasType = exports.AliasType || (exports.AliasType = {}));

},{}],654:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Alias_1 = require("./Alias");
const AliasType_1 = require("./AliasType");
/**
 * The EmptyAlias structure describes empty aliases (type:0)
 *
 * @since 0.10.2
 */
class EmptyAlias extends Alias_1.Alias {
    /**
     * Create EmptyAlias object
     *
     * @param type
     * @param content
     */
    constructor() {
        super(AliasType_1.AliasType.None);
    }
    /**
     * Compares EmptyAlias for equality.
     *
     * @return boolean
     */
    equals(alias) {
        return alias instanceof EmptyAlias || alias.type === 0;
    }
    /**
     * Generate alias buffer
     * @return {Uint8Array}
     */
    serialize() {
        return new Uint8Array(0);
    }
}
exports.EmptyAlias = EmptyAlias;

},{"./Alias":651,"./AliasType":653}],655:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Alias_1 = require("./Alias");
const AliasType_1 = require("./AliasType");
/**
 * The MosaicAlias structure describe mosaic aliases
 *
 * @since 0.10.2
 */
class MosaicAlias extends Alias_1.Alias {
    /**
     * Create AddressAlias object
     * @param mosaicId
     */
    constructor(
    /**
     * The alias address
     */
    mosaicId) {
        super(AliasType_1.AliasType.Mosaic, undefined, mosaicId);
        this.mosaicId = mosaicId;
    }
    /**
     * Compares AddressAlias for equality.
     *
     * @return boolean
     */
    equals(alias) {
        if (alias instanceof MosaicAlias) {
            return this.mosaicId.equals(alias.mosaicId);
        }
        return false;
    }
    /**
     * Get string value of mosaicId
     * @returns {string}
     */
    toHex() {
        return this.mosaicId.toHex();
    }
}
exports.MosaicAlias = MosaicAlias;

},{"./Alias":651,"./AliasType":653}],656:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const format_1 = require("../../core/format");
const NamespaceMosaicIdGenerator_1 = require("../../infrastructure/transaction/NamespaceMosaicIdGenerator");
const Id_1 = require("../Id");
/**
 * The namespace id structure describes namespace id
 *
 * @since 1.0
 */
class NamespaceId {
    /**
     * Create NamespaceId from namespace string name (ex: nem or domain.subdom.subdome)
     * or id in form of array number (ex: [929036875, 2226345261])
     *
     * @param id
     */
    constructor(id) {
        if (id instanceof Array) {
            this.id = new Id_1.Id(id);
        }
        else if (typeof id === 'string') {
            this.fullName = id;
            this.id = new Id_1.Id(NamespaceMosaicIdGenerator_1.NamespaceMosaicIdGenerator.namespaceId(id));
        }
    }
    /**
     * Create a NamespaceId object from its encoded hexadecimal notation.
     * @param encoded
     * @returns {NamespaceId}
     */
    static createFromEncoded(encoded) {
        const uint = format_1.Convert.hexToUint8(encoded);
        const hex = format_1.Convert.uint8ToHex(uint);
        const namespace = new NamespaceId(Id_1.Id.fromHex(hex).toDTO());
        return namespace;
    }
    /**
     * Get string value of id
     * @returns {string}
     */
    toHex() {
        return this.id.toHex();
    }
    /**
     * Compares namespaceIds for equality.
     *
     * @return boolean
     */
    equals(id) {
        if (id instanceof NamespaceId) {
            return this.id.equals(id.id);
        }
        return false;
    }
    /**
     * Create DTO object
     */
    toDTO() {
        return {
            id: this.id.toHex(),
            fullName: this.fullName ? this.fullName : '',
        };
    }
    /**
     * Encoded unresolved address
     * @returns {Uint8Array}
     */
    encodeUnresolvedAddress(networkType) {
        return format_1.RawAddress.aliasToRecipient(format_1.Convert.hexToUint8(this.toHex()), networkType);
    }
}
exports.NamespaceId = NamespaceId;

},{"../../core/format":565,"../../infrastructure/transaction/NamespaceMosaicIdGenerator":606,"../Id":608}],657:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Object containing information of a namespace.
 */
class NamespaceInfo {
    /**
     * @param active
     * @param index
     * @param metaId
     * @param registrationType
     * @param depth
     * @param levels
     * @param parentId
     * @param ownerAddress
     * @param startHeight
     * @param endHeight
     */
    constructor(
    /**
     * Namespace is active.
     */
    active, 
    /**
     * The namespace index.
     */
    index, 
    /**
     * The meta data id.
     */
    metaId, 
    /**
     * The namespace registration type, namespace and sub namespace.
     */
    registrationType, 
    /**
     * The level of namespace.
     */
    depth, 
    /**
     * The namespace id levels.
     */
    levels, 
    /**
     * The namespace parent id.
     */
    parentId, 
    /**
     * The namespace owner's address.
     */
    ownerAddress, 
    /**
     * The height at which the ownership begins.
     */
    startHeight, 
    /**
     * The height at which the ownership ends.
     */
    endHeight, 
    /**
     * The alias linked to a namespace.
     */
    alias) {
        this.active = active;
        this.index = index;
        this.metaId = metaId;
        this.registrationType = registrationType;
        this.depth = depth;
        this.levels = levels;
        this.parentId = parentId;
        this.ownerAddress = ownerAddress;
        this.startHeight = startHeight;
        this.endHeight = endHeight;
        this.alias = alias;
    }
    /**
     * Namespace id
     * @returns {Id}
     */
    get id() {
        return this.levels[this.levels.length - 1];
    }
    /**
     * Is root namespace
     * @returns {boolean}
     */
    isRoot() {
        return this.registrationType === 0;
    }
    /**
     * Is sub namepsace
     * @returns {boolean}
     */
    isSubnamespace() {
        return this.registrationType === 1;
    }
    /**
     * Has alias
     * @returns {boolean}
     */
    hasAlias() {
        return this.alias.type !== 0;
    }
    /**
     * Get parent id
     * @returns {Id}
     */
    parentNamespaceId() {
        if (this.isRoot()) {
            throw new Error('Is a Root Namespace');
        }
        return this.parentId;
    }
}
exports.NamespaceInfo = NamespaceInfo;

},{}],658:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The namespace name info structure describes basic information of a namespace and name.
 */
class NamespaceName {
    /**
     * @param namespaceId
     * @param name
     */
    constructor(
    /**
     * The namespace id.
     */
    namespaceId, 
    /**
     * The namespace name.
     */
    name, 
    /**
     * The parent id.
     */
    parentId) {
        this.namespaceId = namespaceId;
        this.name = name;
        this.parentId = parentId;
    }
}
exports.NamespaceName = NamespaceName;

},{}],659:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Namespace type. Supported types are:
 * 0: Namespace.
 * 1: Sub namespace.
 */
var NamespaceRegistrationType;
(function (NamespaceRegistrationType) {
    NamespaceRegistrationType[NamespaceRegistrationType["RootNamespace"] = 0] = "RootNamespace";
    NamespaceRegistrationType[NamespaceRegistrationType["SubNamespace"] = 1] = "SubNamespace";
})(NamespaceRegistrationType = exports.NamespaceRegistrationType || (exports.NamespaceRegistrationType = {}));

},{}],660:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class AccountLinkNetworkProperties {
    /**
     * @param dummy - to trigger plugin load.
     */
    constructor(dummy) {
        this.dummy = dummy;
    }
}
exports.AccountLinkNetworkProperties = AccountLinkNetworkProperties;

},{}],661:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class AccountRestrictionNetworkProperties {
    /**
     * @param maxAccountRestrictionValues - Maximum number of account restriction values.
     */
    constructor(maxAccountRestrictionValues) {
        this.maxAccountRestrictionValues = maxAccountRestrictionValues;
    }
}
exports.AccountRestrictionNetworkProperties = AccountRestrictionNetworkProperties;

},{}],662:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class AggregateNetworkProperties {
    /**
     * @param maxTransactionsPerAggregate - Maximum number of transactions per aggregate.
     * @param maxCosignaturesPerAggregate - Maximum number of cosignatures per aggregate.
     * @param enableStrictCosignatureCheck - Set to true if cosignatures must exactly match component signers. Set to false if cosignatures should be validated externally.
     * @param enableBondedAggregateSupport - Set to true if bonded aggregates should be allowed. Set to false if bonded aggregates should be rejected.
     * @param maxBondedTransactionLifetime - Maximum lifetime a bonded transaction can have before it expires.
     */
    constructor(maxTransactionsPerAggregate, maxCosignaturesPerAggregate, enableStrictCosignatureCheck, enableBondedAggregateSupport, maxBondedTransactionLifetime) {
        this.maxTransactionsPerAggregate = maxTransactionsPerAggregate;
        this.maxCosignaturesPerAggregate = maxCosignaturesPerAggregate;
        this.enableStrictCosignatureCheck = enableStrictCosignatureCheck;
        this.enableBondedAggregateSupport = enableBondedAggregateSupport;
        this.maxBondedTransactionLifetime = maxBondedTransactionLifetime;
    }
}
exports.AggregateNetworkProperties = AggregateNetworkProperties;

},{}],663:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License: string, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing: string, software
 * distributed under the License is distributed on an "AS IS" BASIS: string,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND: string, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Chain related configuration properties.
 */
class ChainProperties {
    /**
     * @param enableVerifiableState - Set to true if block chain should calculate state hashes so that state is fully verifiable at each block.
     * @param enableVerifiableReceipts - Set to true if block chain should calculate receipts so that state changes are fully verifiable at each block.
     * @param currencyMosaicId - Mosaic id used as primary chain currency.
     * @param harvestingMosaicId - Mosaic id used to provide harvesting ability.
     * @param blockGenerationTargetTime - Targeted time between blocks.
     * @param blockTimeSmoothingFactor - A higher value makes the network more biased.
     * @param blockFinalizationInterval - Number of blocks between successive finalization attempts.
     * @param importanceGrouping - Number of blocks that should be treated as a group for importance purposes.
     * @param importanceActivityPercentage - Percentage of importance resulting from fee generation and beneficiary usage.
     * @param maxRollbackBlocks - Maximum number of blocks that can be rolled back.
     * @param maxDifficultyBlocks - Maximum number of blocks to use in a difficulty calculation.
     * @param defaultDynamicFeeMultiplier - Default multiplier to use for dynamic fees.
     * @param maxTransactionLifetime - Maximum lifetime a transaction can have before it expires.
     * @param maxBlockFutureTime - Maximum future time of a block that can be accepted.
     * @param initialCurrencyAtomicUnits - Initial currency atomic units available in the network.
     * @param maxMosaicAtomicUnits - Maximum atomic units (total-supply * 10 ^ divisibility) of a mosaic allowed in the network.
     * @param totalChainImportance - Total whole importance units available in the network.
     * @param minHarvesterBalance - Minimum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting.
     * @param maxHarvesterBalance - Maximum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting.
     * @param minVoterBalance - Minimum number of harvesting mosaic atomic units needed for an account to be eligible for voting.
     * @param maxVotingKeysPerAccount - Maximum number of voting keys that can be registered at once per account.
     * @param minVotingKeyLifetime - Minimum number of finalization rounds for which voting key can be registered.
     * @param maxVotingKeyLifetime - Maximum number of finalization rounds for which voting key can be registered.
     * @param harvestBeneficiaryPercentage - Percentage of the harvested fee that is collected by the beneficiary account.
     * @param harvestNetworkPercentage - Percentage of the harvested fee that is collected by network.
     * @param harvestNetworkFeeSinkAddress - The harvest network fee sink address.
     * @param blockPruneInterval - Number of blocks between cache pruning.
     * @param maxTransactionsPerBlock - Maximum number of transactions per block.
     */
    constructor(enableVerifiableState, enableVerifiableReceipts, currencyMosaicId, harvestingMosaicId, blockGenerationTargetTime, blockTimeSmoothingFactor, blockFinalizationInterval, importanceGrouping, importanceActivityPercentage, maxRollbackBlocks, maxDifficultyBlocks, defaultDynamicFeeMultiplier, maxTransactionLifetime, maxBlockFutureTime, initialCurrencyAtomicUnits, maxMosaicAtomicUnits, totalChainImportance, minHarvesterBalance, maxHarvesterBalance, minVoterBalance, maxVotingKeysPerAccount, minVotingKeyLifetime, maxVotingKeyLifetime, harvestBeneficiaryPercentage, harvestNetworkPercentage, harvestNetworkFeeSinkAddress, blockPruneInterval, maxTransactionsPerBlock) {
        this.enableVerifiableState = enableVerifiableState;
        this.enableVerifiableReceipts = enableVerifiableReceipts;
        this.currencyMosaicId = currencyMosaicId;
        this.harvestingMosaicId = harvestingMosaicId;
        this.blockGenerationTargetTime = blockGenerationTargetTime;
        this.blockTimeSmoothingFactor = blockTimeSmoothingFactor;
        this.blockFinalizationInterval = blockFinalizationInterval;
        this.importanceGrouping = importanceGrouping;
        this.importanceActivityPercentage = importanceActivityPercentage;
        this.maxRollbackBlocks = maxRollbackBlocks;
        this.maxDifficultyBlocks = maxDifficultyBlocks;
        this.defaultDynamicFeeMultiplier = defaultDynamicFeeMultiplier;
        this.maxTransactionLifetime = maxTransactionLifetime;
        this.maxBlockFutureTime = maxBlockFutureTime;
        this.initialCurrencyAtomicUnits = initialCurrencyAtomicUnits;
        this.maxMosaicAtomicUnits = maxMosaicAtomicUnits;
        this.totalChainImportance = totalChainImportance;
        this.minHarvesterBalance = minHarvesterBalance;
        this.maxHarvesterBalance = maxHarvesterBalance;
        this.minVoterBalance = minVoterBalance;
        this.maxVotingKeysPerAccount = maxVotingKeysPerAccount;
        this.minVotingKeyLifetime = minVotingKeyLifetime;
        this.maxVotingKeyLifetime = maxVotingKeyLifetime;
        this.harvestBeneficiaryPercentage = harvestBeneficiaryPercentage;
        this.harvestNetworkPercentage = harvestNetworkPercentage;
        this.harvestNetworkFeeSinkAddress = harvestNetworkFeeSinkAddress;
        this.blockPruneInterval = blockPruneInterval;
        this.maxTransactionsPerBlock = maxTransactionsPerBlock;
    }
}
exports.ChainProperties = ChainProperties;

},{}],664:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class HashLockNetworkProperties {
    /**
     * @param lockedFundsPerAggregate - Amount that has to be locked per aggregate in partial cache.
     * @param maxHashLockDuration - Maximum number of blocks for which a hash lock can exist.
     */
    constructor(lockedFundsPerAggregate, maxHashLockDuration) {
        this.lockedFundsPerAggregate = lockedFundsPerAggregate;
        this.maxHashLockDuration = maxHashLockDuration;
    }
}
exports.HashLockNetworkProperties = HashLockNetworkProperties;

},{}],665:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class MetadataNetworkProperties {
    /**
     * @param maxValueSize - Maximum metadata value size.
     */
    constructor(maxValueSize) {
        this.maxValueSize = maxValueSize;
    }
}
exports.MetadataNetworkProperties = MetadataNetworkProperties;

},{}],666:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class MosaicNetworkProperties {
    /**
     * @param maxMosaicsPerAccount - Maximum number of mosaics that an account can own.
     * @param maxMosaicDuration - Maximum mosaic duration.
     * @param maxMosaicDivisibility - Maximum mosaic divisibility.
     * @param mosaicRentalFeeSinkAddress - Public key of the mosaic rental fee sink address.
     * @param mosaicRentalFee - Mosaic rental fee.
     */
    constructor(maxMosaicsPerAccount, maxMosaicDuration, maxMosaicDivisibility, mosaicRentalFeeSinkAddress, mosaicRentalFee) {
        this.maxMosaicsPerAccount = maxMosaicsPerAccount;
        this.maxMosaicDuration = maxMosaicDuration;
        this.maxMosaicDivisibility = maxMosaicDivisibility;
        this.mosaicRentalFeeSinkAddress = mosaicRentalFeeSinkAddress;
        this.mosaicRentalFee = mosaicRentalFee;
    }
}
exports.MosaicNetworkProperties = MosaicNetworkProperties;

},{}],667:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class MosaicRestrictionNetworkProperties {
    /**
     * @param maxMosaicRestrictionValues - Maximum number of mosaic restriction values.
     */
    constructor(maxMosaicRestrictionValues) {
        this.maxMosaicRestrictionValues = maxMosaicRestrictionValues;
    }
}
exports.MosaicRestrictionNetworkProperties = MosaicRestrictionNetworkProperties;

},{}],668:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class MultisigNetworkProperties {
    /**
     * @param maxMultisigDepth - Maximum number of multisig levels.
     * @param maxCosignatoriesPerAccount - Maximum number of cosignatories per account.
     * @param maxCosignedAccountsPerAccount - Maximum number of accounts a single account can cosign.
     */
    constructor(maxMultisigDepth, maxCosignatoriesPerAccount, maxCosignedAccountsPerAccount) {
        this.maxMultisigDepth = maxMultisigDepth;
        this.maxCosignatoriesPerAccount = maxCosignatoriesPerAccount;
        this.maxCosignedAccountsPerAccount = maxCosignedAccountsPerAccount;
    }
}
exports.MultisigNetworkProperties = MultisigNetworkProperties;

},{}],669:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class NamespaceNetworkProperties {
    /**
     * @param maxNameSize - Maximum namespace name size.
     * @param maxChildNamespaces - Maximum number of children for a root namespace.
     * @param maxNamespaceDepth - Maximum namespace depth.
     * @param minNamespaceDuration - Minimum namespace duration.
     * @param maxNamespaceDuration - Maximum namespace duration.
     * @param namespaceGracePeriodDuration - Grace period during which time only the previous owner can renew an expired namespace.
     * @param reservedRootNamespaceNames - Reserved root namespaces that cannot be claimed.
     * @param namespaceRentalFeeSinkAddress - Public key of the namespace rental fee sink address.
     * @param rootNamespaceRentalFeePerBlock - Root namespace rental fee per block.
     * @param childNamespaceRentalFee - Child namespace rental fee.
     */
    constructor(maxNameSize, maxChildNamespaces, maxNamespaceDepth, minNamespaceDuration, maxNamespaceDuration, namespaceGracePeriodDuration, reservedRootNamespaceNames, namespaceRentalFeeSinkAddress, rootNamespaceRentalFeePerBlock, childNamespaceRentalFee) {
        this.maxNameSize = maxNameSize;
        this.maxChildNamespaces = maxChildNamespaces;
        this.maxNamespaceDepth = maxNamespaceDepth;
        this.minNamespaceDuration = minNamespaceDuration;
        this.maxNamespaceDuration = maxNamespaceDuration;
        this.namespaceGracePeriodDuration = namespaceGracePeriodDuration;
        this.reservedRootNamespaceNames = reservedRootNamespaceNames;
        this.namespaceRentalFeeSinkAddress = namespaceRentalFeeSinkAddress;
        this.rootNamespaceRentalFeePerBlock = rootNamespaceRentalFeePerBlock;
        this.childNamespaceRentalFee = childNamespaceRentalFee;
    }
}
exports.NamespaceNetworkProperties = NamespaceNetworkProperties;

},{}],670:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Network Configuration
 */
class NetworkConfiguration {
    /**
     * @param network - Network related configuration properties.
     * @param chain - Chain related configuration properties.
     * @param plugins - Plugin related configuration properties.
     */
    constructor(network, chain, plugins) {
        this.network = network;
        this.chain = chain;
        this.plugins = plugins;
    }
}
exports.NetworkConfiguration = NetworkConfiguration;

},{}],671:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Network Name
 */
class NetworkName {
    /**
     * @param name - Network name
     * @param description - Network description
     */
    constructor(name, description) {
        this.name = name;
        this.description = description;
    }
}
exports.NetworkName = NetworkName;

},{}],672:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Network related configuration properties.
 */
class NetworkProperties {
    /**
     * @param identifier - Network identifier.
     * @param nodeEqualityStrategy - Node equality strategy. Defines if the identifier for the node must be its public key or host.
     * @param nemesisSignerPublicKey - Nemesis public key.
     * @param generationHashSeed - Seed for generate nemesis generation hash.
     * @param epochAdjustment - Nemesis epoch time adjustment.
     */
    constructor(identifier, nodeEqualityStrategy, nemesisSignerPublicKey, generationHashSeed, epochAdjustment) {
        this.identifier = identifier;
        this.nodeEqualityStrategy = nodeEqualityStrategy;
        this.nemesisSignerPublicKey = nemesisSignerPublicKey;
        this.generationHashSeed = generationHashSeed;
        this.epochAdjustment = epochAdjustment;
    }
}
exports.NetworkProperties = NetworkProperties;

},{}],673:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Static class containing network type constants.
 */
var NetworkType;
(function (NetworkType) {
    /**
     * Main net network
     * @type {number}
     */
    NetworkType[NetworkType["MAIN_NET"] = 104] = "MAIN_NET";
    /**
     * Test net network
     * @type {number}
     */
    NetworkType[NetworkType["TEST_NET"] = 152] = "TEST_NET";
    /**
     * Mijin net network
     * @type {number}
     */
    NetworkType[NetworkType["MIJIN"] = 96] = "MIJIN";
    /**
     * Mijin test net network
     * @type {number}
     */
    NetworkType[NetworkType["MIJIN_TEST"] = 144] = "MIJIN_TEST";
})(NetworkType = exports.NetworkType || (exports.NetworkType = {}));

},{}],674:[function(require,module,exports){
"use strict";
/*
import { AccountLinkNetworkProperties } from './AccountLinkNetworkProperties';
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Network related configuration properties.
 */
class PluginProperties {
    /**
     * @param accountlink - Network identifier.
     * @param aggregate - Nemesis public key.
     * @param lockhash - Nemesis generation hash.
     * @param locksecret - Nemesis epoch time adjustment.
     * @param metadata -
     * @param mosaic -
     * @param multisig -
     * @param namespace -
     * @param restrictionaccount -
     * @param restrictionmosaic -
     * @param transfer -
     */
    constructor(accountlink, aggregate, lockhash, locksecret, metadata, mosaic, multisig, namespace, restrictionaccount, restrictionmosaic, transfer) {
        this.accountlink = accountlink;
        this.aggregate = aggregate;
        this.lockhash = lockhash;
        this.locksecret = locksecret;
        this.metadata = metadata;
        this.mosaic = mosaic;
        this.multisig = multisig;
        this.namespace = namespace;
        this.restrictionaccount = restrictionaccount;
        this.restrictionmosaic = restrictionmosaic;
        this.transfer = transfer;
    }
}
exports.PluginProperties = PluginProperties;

},{}],675:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Rental Fees
 */
class RentalFees {
    /**
     * @param effectiveRootNamespaceRentalFeePerBlock - Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @param effectiveChildNamespaceRentalFee - Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @param effectiveMosaicRentalFee - bsolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     */
    constructor(effectiveRootNamespaceRentalFeePerBlock, effectiveChildNamespaceRentalFee, effectiveMosaicRentalFee) {
        this.effectiveRootNamespaceRentalFeePerBlock = effectiveRootNamespaceRentalFeePerBlock;
        this.effectiveChildNamespaceRentalFee = effectiveChildNamespaceRentalFee;
        this.effectiveMosaicRentalFee = effectiveMosaicRentalFee;
    }
}
exports.RentalFees = RentalFees;

},{}],676:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class SecretLockNetworkProperties {
    /**
     * @param maxSecretLockDuration - Maximum number of blocks for which a secret lock can exist.
     * @param minProofSize - Minimum size of a proof in bytes.
     * @param maxProofSize - Maximum size of a proof in bytes.
     */
    constructor(maxSecretLockDuration, minProofSize, maxProofSize) {
        this.maxSecretLockDuration = maxSecretLockDuration;
        this.minProofSize = minProofSize;
        this.maxProofSize = maxProofSize;
    }
}
exports.SecretLockNetworkProperties = SecretLockNetworkProperties;

},{}],677:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Transacation Fees
 */
class TransactionFees {
    /**
     * @param averageFeeMultiplier - Average fee multiplier over the last \"numBlocksTransactionFeeStats\".
     * @param medianFeeMultiplier - Median fee multiplier over the last \"numBlocksTransactionFeeStats\".
     * @param highestFeeMultiplier - Highest fee multiplier over the last "numBlocksTransactionFeeStats".
     * @param lowestFeeMultiplier - Lowest fee multiplier over the last "numBlocksTransactionFeeStats".
     */
    constructor(averageFeeMultiplier, medianFeeMultiplier, highestFeeMultiplier, lowestFeeMultiplier) {
        this.averageFeeMultiplier = averageFeeMultiplier;
        this.medianFeeMultiplier = medianFeeMultiplier;
        this.highestFeeMultiplier = highestFeeMultiplier;
        this.lowestFeeMultiplier = lowestFeeMultiplier;
    }
}
exports.TransactionFees = TransactionFees;

},{}],678:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class TransferNetworkProperties {
    /**
     * @param maxMessageSize - Maximum transaction message size.
     */
    constructor(maxMessageSize) {
        this.maxMessageSize = maxMessageSize;
    }
}
exports.TransferNetworkProperties = TransferNetworkProperties;

},{}],679:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The node info structure describes basic information of a node health.
 */
class NodeHealth {
    /**
     * @param apiNode
     * @param db
     */
    constructor(
    /**
     * The api node status
     */
    apiNode, 
    /**
     * The database status
     */
    db) {
        this.apiNode = apiNode;
        this.db = db;
    }
}
exports.NodeHealth = NodeHealth;

},{}],680:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The node info structure describes basic information of a node.
 */
class NodeInfo {
    /**
     * @param publicKey
     * @param networkGenerationHashSeed
     * @param port
     * @param networkIdentifier
     * @param version
     * @param roles
     * @param host
     * @param friendlyName
     */
    constructor(
    /**
     * The public key used to identify the node.
     */
    publicKey, 
    /**
     * The network generation hash seed
     */
    networkGenerationHashSeed, 
    /**
     * The port used for the communication.
     */
    port, 
    /**
     * The network identifier.
     */
    networkIdentifier, 
    /**
     * The version of the application.
     */
    version, 
    /**
     * The roles of the application.
     */
    roles, 
    /**
     * The IP address of the endpoint.
     */
    host, 
    /**
     * The name of the node.
     */
    friendlyName) {
        this.publicKey = publicKey;
        this.networkGenerationHashSeed = networkGenerationHashSeed;
        this.port = port;
        this.networkIdentifier = networkIdentifier;
        this.version = version;
        this.roles = roles;
        this.host = host;
        this.friendlyName = friendlyName;
    }
}
exports.NodeInfo = NodeInfo;

},{}],681:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The node info structure describes basic information of a node.
 */
class NodeTime {
    /**
     * @param sendTimeStamp
     * @param receiveTimeStamp
     */
    constructor(
    /**
     * The request send timestamp
     */
    sendTimeStamp, 
    /**
     * The request received timestamp
     */
    receiveTimeStamp) {
        this.sendTimeStamp = sendTimeStamp;
        this.receiveTimeStamp = receiveTimeStamp;
    }
}
exports.NodeTime = NodeTime;

},{}],682:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var RoleType;
(function (RoleType) {
    RoleType[RoleType["PeerNode"] = 1] = "PeerNode";
    RoleType[RoleType["ApiNode"] = 2] = "ApiNode";
    RoleType[RoleType["DualNode"] = 3] = "DualNode";
})(RoleType = exports.RoleType || (exports.RoleType = {}));

},{}],683:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The server information.
 */
class ServerInfo {
    /**
     * @param restVersion - The catapult-rest component version
     * @param sdkVersion - the catapult-sdk component version
     */
    constructor(
    /**
     * The catapult-rest component version
     */
    restVersion, 
    /**
     * the catapult-sdk component version
     */
    sdkVersion) {
        this.restVersion = restVersion;
        this.sdkVersion = sdkVersion;
    }
}
exports.ServerInfo = ServerInfo;

},{}],684:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const MosaicId_1 = require("../mosaic/MosaicId");
const Receipt_1 = require("./Receipt");
const ReceiptVersion_1 = require("./ReceiptVersion");
/**
 * Artifact Expiry: An artifact (e.g. namespace, mosaic) expired.
 */
class ArtifactExpiryReceipt extends Receipt_1.Receipt {
    /**
     * Artifact expiry receipt
     * @param artifactId -The id of the artifact (eg. namespace, mosaic).
     * @param version - The receipt version
     * @param type - The receipt type
     * @param size - the receipt size
     */
    constructor(artifactId, version, type, size) {
        super(version, type, size);
        this.artifactId = artifactId;
    }
    /**
     * @internal
     * Generate buffer
     * @return {Uint8Array}
     */
    serialize() {
        if (this.artifactId instanceof MosaicId_1.MosaicId) {
            return new catbuffer_typescript_1.MosaicExpiryReceiptBuilder(ReceiptVersion_1.ReceiptVersion.ARTIFACT_EXPIRY, this.type.valueOf(), new catbuffer_typescript_1.MosaicIdDto(this.artifactId.toDTO())).serialize();
        }
        return new catbuffer_typescript_1.NamespaceExpiryReceiptBuilder(ReceiptVersion_1.ReceiptVersion.ARTIFACT_EXPIRY, this.type.valueOf(), new catbuffer_typescript_1.NamespaceIdDto(this.artifactId.id.toDTO())).serialize();
    }
}
exports.ArtifactExpiryReceipt = ArtifactExpiryReceipt;

},{"../mosaic/MosaicId":642,"./Receipt":688,"./ReceiptVersion":691,"catbuffer-typescript":922}],685:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const Convert_1 = require("../../core/format/Convert");
const Receipt_1 = require("./Receipt");
const ReceiptVersion_1 = require("./ReceiptVersion");
const catbuffer_typescript_2 = require("catbuffer-typescript");
/**
 * Balance Change: A mosaic credit or debit was triggered.
 */
class BalanceChangeReceipt extends Receipt_1.Receipt {
    /**
     * Balance change expiry receipt
     * @param targetAddress - The target account address.
     * @param mosaicId - The mosaic id.
     * @param amount - The amount of mosaic.
     * @param version - The receipt version
     * @param type - The receipt type
     * @param size - the receipt size
     */
    constructor(
    /**
     * The target account address.
     */
    targetAddress, 
    /**
     * The mosaic id.
     */
    mosaicId, 
    /**
     * The amount of mosaic.
     */
    amount, version, type, size) {
        super(version, type, size);
        this.targetAddress = targetAddress;
        this.mosaicId = mosaicId;
        this.amount = amount;
    }
    /**
     * @internal
     * Generate buffer
     * @return {Uint8Array}
     */
    serialize() {
        return new catbuffer_typescript_1.BalanceChangeReceiptBuilder(ReceiptVersion_1.ReceiptVersion.BALANCE_CHANGE, this.type.valueOf(), new catbuffer_typescript_1.MosaicBuilder(new catbuffer_typescript_1.MosaicIdDto(this.mosaicId.toDTO()), new catbuffer_typescript_1.AmountDto(this.amount.toDTO())), new catbuffer_typescript_2.AddressDto(Convert_1.Convert.hexToUint8(this.targetAddress.encoded()))).serialize();
    }
}
exports.BalanceChangeReceipt = BalanceChangeReceipt;

},{"../../core/format/Convert":558,"./Receipt":688,"./ReceiptVersion":691,"catbuffer-typescript":922}],686:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const Convert_1 = require("../../core/format/Convert");
const Receipt_1 = require("./Receipt");
const ReceiptVersion_1 = require("./ReceiptVersion");
/**
 * Balance Transfer: A mosaic transfer was triggered.
 */
class BalanceTransferReceipt extends Receipt_1.Receipt {
    /**
     * Balance transfer expiry receipt
     * @param senderAddress - The sender address.
     * @param recipientAddress - The mosaic recipient address.
     * @param mosaicId - The mosaic id.
     * @param amount - The amount of mosaic.
     * @param version - The receipt version
     * @param type - The receipt type
     * @param size - the receipt size
     */
    constructor(
    /**
     * The sender address.
     */
    senderAddress, 
    /**
     * The mosaic recipient address.
     */
    recipientAddress, 
    /**
     * The mosaic id.
     */
    mosaicId, 
    /**
     * The amount of mosaic.
     */
    amount, version, type, size) {
        super(version, type, size);
        this.senderAddress = senderAddress;
        this.recipientAddress = recipientAddress;
        this.mosaicId = mosaicId;
        this.amount = amount;
    }
    /**
     * @internal
     * Generate buffer
     * @return {Uint8Array}
     */
    serialize() {
        return new catbuffer_typescript_1.BalanceTransferReceiptBuilder(ReceiptVersion_1.ReceiptVersion.BALANCE_TRANSFER, this.type.valueOf(), new catbuffer_typescript_1.MosaicBuilder(new catbuffer_typescript_1.MosaicIdDto(this.mosaicId.toDTO()), new catbuffer_typescript_1.AmountDto(this.amount.toDTO())), new catbuffer_typescript_1.AddressDto(Convert_1.Convert.hexToUint8(this.senderAddress.encoded())), new catbuffer_typescript_1.AddressDto(Convert_1.Convert.hexToUint8(this.recipientAddress.encoded()))).serialize();
    }
}
exports.BalanceTransferReceipt = BalanceTransferReceipt;

},{"../../core/format/Convert":558,"./Receipt":688,"./ReceiptVersion":691,"catbuffer-typescript":922}],687:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const Receipt_1 = require("./Receipt");
const ReceiptVersion_1 = require("./ReceiptVersion");
/**
 * Balance Transfer: A mosaic transfer was triggered.
 */
class InflationReceipt extends Receipt_1.Receipt {
    /**
     * Balance transfer expiry receipt
     * @param mosaicId - The mosaic id.
     * @param amount - The amount of mosaic.
     * @param version - The receipt version
     * @param type - The receipt type
     * @param size - the receipt size
     */
    constructor(
    /**
     * The mosaic id.
     */
    mosaicId, 
    /**
     * The amount of mosaic.
     */
    amount, version, type, size) {
        super(version, type, size);
        this.mosaicId = mosaicId;
        this.amount = amount;
    }
    /**
     * @internal
     * Generate buffer
     * @return {Uint8Array}
     */
    serialize() {
        return new catbuffer_typescript_1.InflationReceiptBuilder(ReceiptVersion_1.ReceiptVersion.INFLATION_RECEIPT, this.type.valueOf(), new catbuffer_typescript_1.MosaicBuilder(new catbuffer_typescript_1.MosaicIdDto(this.mosaicId.toDTO()), new catbuffer_typescript_1.AmountDto(this.amount.toDTO()))).serialize();
    }
}
exports.InflationReceipt = InflationReceipt;

},{"./Receipt":688,"./ReceiptVersion":691,"catbuffer-typescript":922}],688:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An abstract transaction class that serves as the base class of all receipts.
 */
class Receipt {
    /**
     * @constructor
     * @param size
     * @param version
     * @param type
     */
    constructor(
    /**
     * The receipt version.
     */
    version, 
    /**
     * The receipt type.
     */
    type, 
    /**
     * The receipt size.
     */
    size) {
        this.version = version;
        this.type = type;
        this.size = size;
    }
}
exports.Receipt = Receipt;

},{}],689:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The receipt source object.
 */
class ReceiptSource {
    /**
     * @constructor
     * @param primaryId - The transaction primary source (e.g. index within block).
     * @param secondaryId - The transaction secondary source (e.g. index within aggregate).
     */
    constructor(
    /**
     * The transaction primary source (e.g. index within block).
     */
    primaryId, 
    /**
     * The transaction secondary source (e.g. index within aggregate).
     */
    secondaryId) {
        this.primaryId = primaryId;
        this.secondaryId = secondaryId;
    }
    /**
     * @internal
     * Generate buffer
     * @return {Uint8Array}
     */
    serialize() {
        return catbuffer_typescript_1.GeneratorUtils.concatTypedArrays(catbuffer_typescript_1.GeneratorUtils.uintToBuffer(this.primaryId, 4), catbuffer_typescript_1.GeneratorUtils.uintToBuffer(this.secondaryId, 4));
    }
}
exports.ReceiptSource = ReceiptSource;

},{"catbuffer-typescript":922}],690:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, type 2.0 (the "License"),
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Receipt type enums.
 *
 * @see https://github.com/nemtech/catapult-server/blob/main/src/catapult/model/ReceiptType.h
 * @see https://github.com/nemtech/catapult-server/blob/main/src/catapult/model/ReceiptType.cpp
 */
var ReceiptType;
(function (ReceiptType) {
    /**
     * The recipient, account and amount of fees received for harvesting a block. It is recorded when a block is harvested.
     */
    ReceiptType[ReceiptType["Harvest_Fee"] = 8515] = "Harvest_Fee";
    /**
     * The unresolved and resolved alias. It is recorded when a transaction indicates a valid address alias instead of an address.
     */
    ReceiptType[ReceiptType["Address_Alias_Resolution"] = 61763] = "Address_Alias_Resolution";
    /**
     * The unresolved and resolved alias. It is recorded when a transaction indicates a valid mosaic alias instead of a mosaicId.
     */
    ReceiptType[ReceiptType["Mosaic_Alias_Resolution"] = 62019] = "Mosaic_Alias_Resolution";
    /**
     * A collection of state changes for a given source. It is recorded when a state change receipt is issued.
     */
    ReceiptType[ReceiptType["Transaction_Group"] = 57667] = "Transaction_Group";
    /**
     * The mosaicId expiring in this block. It is recorded when a mosaic expires.
     */
    ReceiptType[ReceiptType["Mosaic_Expired"] = 16717] = "Mosaic_Expired";
    /**
     * The sender and recipient of the levied mosaic, the mosaicId and amount. It is recorded when a transaction has a levied mosaic.
     */
    ReceiptType[ReceiptType["Mosaic_Levy"] = 4685] = "Mosaic_Levy";
    /**
     * The sender and recipient of the mosaicId and amount representing the cost of registering the mosaic.
     * It is recorded when a mosaic is registered.
     */
    ReceiptType[ReceiptType["Mosaic_Rental_Fee"] = 4685] = "Mosaic_Rental_Fee";
    /**
     * The identifier of the namespace expiring in this block. It is recorded when the namespace lifetime elapses.
     */
    ReceiptType[ReceiptType["Namespace_Expired"] = 16718] = "Namespace_Expired";
    /**
     * The sender and recipient of the mosaicId and amount representing the cost of extending the namespace.
     * It is recorded when a namespace is registered or its duration is extended.
     */
    ReceiptType[ReceiptType["Namespace_Rental_Fee"] = 4942] = "Namespace_Rental_Fee";
    /**
     * The identifier of the namespace deleted in this block. It is recorded when the namespace grace period elapses.
     */
    ReceiptType[ReceiptType["Namespace_Deleted"] = 16974] = "Namespace_Deleted";
    /**
     * The lockhash sender, mosaicId and amount locked. It is recorded when a valid HashLockTransaction is announced.
     */
    ReceiptType[ReceiptType["LockHash_Created"] = 12616] = "LockHash_Created";
    /**
     * The haslock sender, mosaicId and amount locked that is returned.
     * It is recorded when an aggregate bonded transaction linked to the hash completes.
     */
    ReceiptType[ReceiptType["LockHash_Completed"] = 8776] = "LockHash_Completed";
    /**
     * The account receiving the locked mosaic, the mosaicId and the amount. It is recorded when a lock hash expires.
     */
    ReceiptType[ReceiptType["LockHash_Expired"] = 9032] = "LockHash_Expired";
    /**
     * The secretlock sender, mosaicId and amount locked. It is recorded when a valid SecretLockTransaction is announced.
     */
    ReceiptType[ReceiptType["LockSecret_Created"] = 12626] = "LockSecret_Created";
    /**
     * The secretlock sender, mosaicId and amount locked. It is recorded when a secretlock is proved.
     */
    ReceiptType[ReceiptType["LockSecret_Completed"] = 8786] = "LockSecret_Completed";
    /**
     * The account receiving the locked mosaic, the mosaicId and the amount. It is recorded when a secretlock expires
     */
    ReceiptType[ReceiptType["LockSecret_Expired"] = 9042] = "LockSecret_Expired";
    /**
     * The amount of native currency mosaics created. The receipt is recorded when the network has inflation configured,
     * and a new block triggers the creation of currency mosaics.
     */
    ReceiptType[ReceiptType["Inflation"] = 20803] = "Inflation";
})(ReceiptType = exports.ReceiptType || (exports.ReceiptType = {}));

},{}],691:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Receipt version constants.
 *
 * @see https://github.com/nemtech/catapult-server/blob/main/src/catapult/model/ReceiptType.h
 * @see https://github.com/nemtech/catapult-server/blob/main/src/catapult/model/ReceiptType.cpp
 */
class ReceiptVersion {
}
exports.ReceiptVersion = ReceiptVersion;
/**
 * Balance transfer receipt version.
 * @type {number}
 */
ReceiptVersion.BALANCE_TRANSFER = 0x1;
/**
 * Balance change receipt version
 * @type {number}
 */
ReceiptVersion.BALANCE_CHANGE = 0x1;
/**
 * Artifact expiry receipt version
 * @type {number}
 */
ReceiptVersion.ARTIFACT_EXPIRY = 0x1;
/**
 * Transaction statement version
 * @type {number}
 */
ReceiptVersion.TRANSACTION_STATEMENT = 0x1;
/**
 * Resolution statement version
 * @type {number}
 */
ReceiptVersion.RESOLUTION_STATEMENT = 0x1;
/**
 * Resolution statement version
 * @type {number}
 */
ReceiptVersion.INFLATION_RECEIPT = 0x1;

},{}],692:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const RawAddress_1 = require("../../core/format/RawAddress");
const Address_1 = require("../account/Address");
const UInt64_1 = require("../UInt64");
/**
 * The receipt source object.
 */
class ResolutionEntry {
    /**
     * @constructor
     * @param resolved - A resolved address or resolved mosaicId (alias).
     * @param source - The receipt source.
     */
    constructor(
    /**
     * A resolved address or resolved mosaicId (alias).
     */
    resolved, 
    /**
     * The receipt source.
     */
    source) {
        this.resolved = resolved;
        this.source = source;
    }
    /**
     * @internal
     * Generate buffer
     * @return {Uint8Array}
     */
    serialize() {
        let resolvedBytes;
        if (this.resolved instanceof Address_1.Address) {
            resolvedBytes = RawAddress_1.RawAddress.stringToAddress(this.resolved.plain());
        }
        else {
            resolvedBytes = catbuffer_typescript_1.GeneratorUtils.uint64ToBuffer(UInt64_1.UInt64.fromHex(this.resolved.toHex()).toDTO());
        }
        const sourceBytes = this.source.serialize();
        return catbuffer_typescript_1.GeneratorUtils.concatTypedArrays(resolvedBytes, sourceBytes);
    }
}
exports.ResolutionEntry = ResolutionEntry;

},{"../../core/format/RawAddress":561,"../UInt64":609,"../account/Address":618,"catbuffer-typescript":922}],693:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const js_sha3_1 = require("js-sha3");
const RawAddress_1 = require("../../core/format/RawAddress");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
const UInt64_1 = require("../UInt64");
const ReceiptType_1 = require("./ReceiptType");
const ReceiptVersion_1 = require("./ReceiptVersion");
const ResolutionType_1 = require("./ResolutionType");
/**
 * When a transaction includes an alias, a so called resolution statement reflects the resolved value for that block:
 * - Address Resolution: An account alias was used in the block.
 * - Mosaic Resolution: A mosaic alias was used in the block.
 */
class ResolutionStatement {
    /**
     * Receipt - resolution statement object
     * @param resolutionType - The resolution type
     * @param height - The block height
     * @param unresolved - An unresolved address or unresolved mosaicId.
     * @param resolutionEntries - The array of resolution entries.
     */
    constructor(
    /**
     * Resolution type
     */
    resolutionType, 
    /**
     * The block height.
     */
    height, 
    /**
     * An unresolved address or unresolved mosaicId.
     */
    unresolved, 
    /**
     * The array of resolution entries.
     */
    resolutionEntries) {
        this.resolutionType = resolutionType;
        this.height = height;
        this.unresolved = unresolved;
        this.resolutionEntries = resolutionEntries;
    }
    /**
     * Generate receipt hash
     * @param {networkType} the network type serialized in the output.
     * @return {string} receipt hash in hex
     */
    generateHash(networkType) {
        const type = this.resolutionType === ResolutionType_1.ResolutionType.Address ? ReceiptType_1.ReceiptType.Address_Alias_Resolution : ReceiptType_1.ReceiptType.Mosaic_Alias_Resolution;
        const builder = this.resolutionType === ResolutionType_1.ResolutionType.Address
            ? new catbuffer_typescript_1.AddressResolutionStatementBuilder(ReceiptVersion_1.ReceiptVersion.RESOLUTION_STATEMENT, type.valueOf(), new catbuffer_typescript_1.UnresolvedAddressDto(UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddressBytes(this.unresolved, networkType)), this.resolutionEntries.map((entry) => new catbuffer_typescript_1.AddressResolutionEntryBuilder(new catbuffer_typescript_1.ReceiptSourceBuilder(entry.source.primaryId, entry.source.secondaryId), new catbuffer_typescript_1.AddressDto(RawAddress_1.RawAddress.stringToAddress(entry.resolved.plain())))))
            : new catbuffer_typescript_1.MosaicResolutionStatementBuilder(ReceiptVersion_1.ReceiptVersion.RESOLUTION_STATEMENT, type.valueOf(), new catbuffer_typescript_1.UnresolvedMosaicIdDto(UInt64_1.UInt64.fromHex(this.unresolved.toHex()).toDTO()), this.resolutionEntries.map((entry) => new catbuffer_typescript_1.MosaicResolutionEntryBuilder(new catbuffer_typescript_1.ReceiptSourceBuilder(entry.source.primaryId, entry.source.secondaryId), new catbuffer_typescript_1.MosaicIdDto(entry.resolved.toDTO()))));
        const hasher = js_sha3_1.sha3_256.create();
        hasher.update(builder.serialize());
        return hasher.hex().toUpperCase();
    }
    /**
     * @internal
     * Find resolution entry for given primaryId and secondaryId
     * @param primaryId Primary id
     * @param secondaryId Secondary id
     * @returns {ResolutionEntry | undefined}
     */
    getResolutionEntryById(primaryId, secondaryId) {
        /*
        Primary id and secondary id do not specifically map to the exact transaction index on the same block.
        The ids are just the order of the resolution reflecting on the order of transactions (ordered by index).
        E.g 1 - Bob -> 1 random.token -> Alice
            2 - Carol -> 1 random.token > Denis
        Based on above example, 2 transactions (index 0 & 1) are created on the same block, however, only 1
        resolution entry get generated for both.
        */
        const resolvedPrimaryId = this.getMaxAvailablePrimaryId(primaryId);
        /*
        If no primaryId found, it means there's no resolution entry available for the process. Invalid entry.

        e.g. Given:
        Entries: [{P:2, S:0}, {P:5, S:6}]
        Transaction: [Inx:1(0+1), AggInx:0]
        It should return Entry: undefined
        */
        if (resolvedPrimaryId === 0) {
            return undefined;
        }
        else if (primaryId > resolvedPrimaryId) {
            /*
            If the transaction index is greater than the overall most recent source primary id.
            Use the most recent resolution entry (Max.PrimaryId + Max.SecondaryId)

            e.g. Given:
            Entries: [{P:1, S:0}, {P:2, S:0}, {P:4, S:2}, {P:4, S:4} {P:7, S:6}]
            Transaction: [Inx:5(4+1), AggInx:0]
            It should return Entry: {P:4, S:4}

            e.g. Given:
            Entries: [{P:1, S:0}, {P:2, S:0}, {P:4, S:2}, {P:4, S:4}, {P:7, S:6}]
            Transaction: [Inx:3(2+1), AggInx:0]
            It should return Entry: {P:2, S:0}
            */
            return this.resolutionEntries.find((entry) => entry.source.primaryId === resolvedPrimaryId &&
                entry.source.secondaryId === this.getMaxSecondaryIdByPrimaryId(resolvedPrimaryId));
        }
        // When transaction index matches a primaryId, get the most recent secondaryId (resolvedPrimaryId can only <= primaryId)
        const resolvedSecondaryId = this.getMaxSecondaryIdByPrimaryIdAndSecondaryId(resolvedPrimaryId, secondaryId);
        /*
        If no most recent secondaryId matched transaction index, find previous resolution entry (most recent).
        This means the resolution entry for the specific inner transaction (inside Aggregate) /
        was generated previously outside the aggregate. It should return the previous entry (previous primaryId)

        e.g. Given:
        Entries: [{P:1, S:0}, {P:2, S:0}, {P:5, S:6}]
        Transaction: [Inx:5(4+1), AggInx:3(2+1)]
        It should return Entry: {P:2, S:0}
        */
        if (resolvedSecondaryId === 0 && resolvedSecondaryId !== secondaryId) {
            const lastPrimaryId = this.getMaxAvailablePrimaryId(resolvedPrimaryId - 1);
            return this.resolutionEntries.find((entry) => entry.source.primaryId === lastPrimaryId &&
                entry.source.secondaryId === this.getMaxSecondaryIdByPrimaryId(lastPrimaryId));
        }
        /*
        Found a matched resolution entry on both primaryId and secondaryId

        e.g. Given:
        Entries: [{P:1, S:0}, {P:2, S:0}, {P:5, S:6}]
        Transaction: [Inx:5(4+1), AggInx:6(2+1)]
        It should return Entry: {P:5, S:6}
        */
        return this.resolutionEntries.find((entry) => entry.source.primaryId === resolvedPrimaryId && entry.source.secondaryId === resolvedSecondaryId);
    }
    /**
     * @internal
     * Get max secondary id by a given primaryId
     * @param primaryId Primary source id
     * @returns {number}
     */
    getMaxSecondaryIdByPrimaryId(primaryId) {
        return Math.max(...this.resolutionEntries
            .filter((entry) => entry.source.primaryId === primaryId)
            .map((filtered) => filtered.source.secondaryId));
    }
    /**
     * Get most `recent` available secondary id by a given primaryId
     * @param primaryId Primary source id
     * @param secondaryId Secondary source id
     * @returns {number}
     */
    getMaxSecondaryIdByPrimaryIdAndSecondaryId(primaryId, secondaryId) {
        return Math.max(...this.resolutionEntries
            .filter((entry) => entry.source.primaryId === primaryId)
            .map((filtered) => (secondaryId >= filtered.source.secondaryId ? filtered.source.secondaryId : 0)));
    }
    /**
     * @internal
     * Get most `recent` primary source id by a given id (transaction index) as PrimaryId might not be the same as block transaction index.
     * @param primaryId Primary source id
     * @returns {number}
     */
    getMaxAvailablePrimaryId(primaryId) {
        return Math.max(...this.resolutionEntries.map((entry) => (primaryId >= entry.source.primaryId ? entry.source.primaryId : 0)));
    }
}
exports.ResolutionStatement = ResolutionStatement;

},{"../../core/format/RawAddress":561,"../../core/utils/UnresolvedMapping":569,"../UInt64":609,"./ReceiptType":690,"./ReceiptVersion":691,"./ResolutionType":694,"catbuffer-typescript":922,"js-sha3":"/node_modules/js-sha3"}],694:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Resolution type.
 * 0: Address.
 * 1: Mosaic.
 */
var ResolutionType;
(function (ResolutionType) {
    ResolutionType[ResolutionType["Address"] = 0] = "Address";
    ResolutionType[ResolutionType["Mosaic"] = 1] = "Mosaic";
})(ResolutionType = exports.ResolutionType || (exports.ResolutionType = {}));

},{}],695:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Mosaic_1 = require("../mosaic/Mosaic");
const NamespaceId_1 = require("../namespace/NamespaceId");
const ResolutionType_1 = require("./ResolutionType");
class Statement {
    /**
     * Receipt - transaction statement object
     * @param transactionStatements - The transaction statements.
     * @param addressResolutionStatements - The address resolution statements.
     * @param mosaicResolutionStatements - The mosaic resolution statements.
     */
    constructor(
    /**
     * The transaction statements.
     */
    transactionStatements, 
    /**
     * The address resolution statements.
     */
    addressResolutionStatements, 
    /**
     * The mosaic resolution statements.
     */
    mosaicResolutionStatements) {
        this.transactionStatements = transactionStatements;
        this.addressResolutionStatements = addressResolutionStatements;
        this.mosaicResolutionStatements = mosaicResolutionStatements;
    }
    /**
     * Resolve unresolvedAddress from statement
     * @param unresolvedAddress Unresolved address
     * @param height Block height
     * @param transactionIndex Transaction index
     * @param aggregateTransactionIndex Aggregate transaction index
     * @returns {Address}
     */
    resolveAddress(unresolvedAddress, height, transactionIndex, aggregateTransactionIndex = 0) {
        return unresolvedAddress instanceof NamespaceId_1.NamespaceId
            ? this.getResolvedFromReceipt(ResolutionType_1.ResolutionType.Address, unresolvedAddress, transactionIndex, height, aggregateTransactionIndex)
            : unresolvedAddress;
    }
    /**
     * Resolve unresolvedMosaicId from statement
     * @param unresolvedMosaicId Unresolved mosaic id
     * @param height Block height
     * @param transactionIndex Transaction index
     * @param aggregateTransactionIndex Aggregate transaction index
     * @returns {MosaicId}
     */
    resolveMosaicId(unresolvedMosaicId, height, transactionIndex, aggregateTransactionIndex = 0) {
        return unresolvedMosaicId instanceof NamespaceId_1.NamespaceId
            ? this.getResolvedFromReceipt(ResolutionType_1.ResolutionType.Mosaic, unresolvedMosaicId, transactionIndex, height, aggregateTransactionIndex)
            : unresolvedMosaicId;
    }
    /**
     * Resolve unresolvedMosaic from statement
     * @param unresolvedMosaic Unresolved mosaic
     * @param height Block height
     * @param transactionIndex Transaction index
     * @param aggregateTransactionIndex Aggregate transaction index
     * @returns {Mosaic}
     */
    resolveMosaic(unresolvedMosaic, height, transactionIndex, aggregateTransactionIndex = 0) {
        return unresolvedMosaic.id instanceof NamespaceId_1.NamespaceId
            ? new Mosaic_1.Mosaic(this.getResolvedFromReceipt(ResolutionType_1.ResolutionType.Mosaic, unresolvedMosaic.id, transactionIndex, height, aggregateTransactionIndex), unresolvedMosaic.amount)
            : unresolvedMosaic;
    }
    /**
     * @internal
     * Extract resolved address | mosaic from block receipt
     * @param resolutionType Resolution type: Address / Mosaic
     * @param unresolved Unresolved address / mosaicId
     * @param transactionIndex Transaction index
     * @param height Transaction height
     * @param aggregateTransactionIndex Transaction index for aggregate
     * @returns {MosaicId | Address}
     */
    getResolvedFromReceipt(resolutionType, unresolved, transactionIndex, height, aggregateTransactionIndex) {
        const list = resolutionType === ResolutionType_1.ResolutionType.Address ? this.addressResolutionStatements : this.mosaicResolutionStatements;
        const filter = (resolution) => resolution.height.toString() === height && resolution.unresolved.equals(unresolved);
        const resolutionStatement = list.find(filter);
        if (!resolutionStatement) {
            throw new Error(`No resolution statement found on block: ${height} for unresolved: ${unresolved.toHex()}`);
        }
        // If only one entry exists on the statement, just return
        if (resolutionStatement.resolutionEntries.length === 1) {
            return resolutionStatement.resolutionEntries[0].resolved;
        }
        // Get the most recent resolution entry
        const resolutionEntry = resolutionStatement.getResolutionEntryById(aggregateTransactionIndex !== undefined ? aggregateTransactionIndex + 1 : transactionIndex + 1, aggregateTransactionIndex !== undefined ? transactionIndex + 1 : 0);
        if (!resolutionEntry) {
            throw new Error(`No resolution entry found on block: ${height} for unresolved: ${unresolved.toHex()}`);
        }
        return resolutionEntry.resolved;
    }
}
exports.Statement = Statement;

},{"../mosaic/Mosaic":640,"../namespace/NamespaceId":656,"./ResolutionType":694}],696:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const js_sha3_1 = require("js-sha3");
const ReceiptType_1 = require("./ReceiptType");
const ReceiptVersion_1 = require("./ReceiptVersion");
/**
 * A transaction statement is a collection of receipts linked with a transaction in a particular block.
 * - Balance Transfer: A mosaic transfer was triggered.
 * - Balance Change: A mosaic credit or debit was triggered.
 * - Artifact Expiry: An artifact (e.g. namespace, mosaic) expired.
 */
class TransactionStatement {
    /**
     * Receipt - transaction statement object
     * @param height - The block height
     * @param source - The receipt source
     * @param receipts - The array of receipt headers.
     */
    constructor(
    /**
     * The block height.
     */
    height, 
    /**
     * The receipt source.
     */
    source, 
    /**
     * The array of receipt headers.
     */
    receipts) {
        this.height = height;
        this.source = source;
        this.receipts = receipts;
    }
    /**
     * Generate receipt hash
     * @return {string} receipt hash in hex
     */
    generateHash() {
        const hasher = js_sha3_1.sha3_256.create();
        hasher.update(catbuffer_typescript_1.GeneratorUtils.uintToBuffer(ReceiptVersion_1.ReceiptVersion.TRANSACTION_STATEMENT, 2));
        hasher.update(catbuffer_typescript_1.GeneratorUtils.uintToBuffer(ReceiptType_1.ReceiptType.Transaction_Group, 2));
        hasher.update(this.source.serialize());
        let receiptBytes = Uint8Array.from([]);
        this.receipts.forEach((receipt) => {
            const bytes = receipt.serialize();
            receiptBytes = catbuffer_typescript_1.GeneratorUtils.concatTypedArrays(receiptBytes, bytes);
        });
        hasher.update(receiptBytes);
        return hasher.hex().toUpperCase();
    }
}
exports.TransactionStatement = TransactionStatement;

},{"./ReceiptType":690,"./ReceiptVersion":691,"catbuffer-typescript":922,"js-sha3":"/node_modules/js-sha3"}],697:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Account restriction structure describes restriction information.
 */
class AccountRestriction {
    /**
     * Constructor
     * @param restrictionFlags
     * @param values
     */
    constructor(
    /**
     * Account restriction flag
     */
    restrictionFlags, 
    /**
     * Restriction values.
     */
    values) {
        this.restrictionFlags = restrictionFlags;
        this.values = values;
    }
}
exports.AccountRestriction = AccountRestriction;

},{}],698:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Account restriction modification type
 */
var AccountRestrictionModificationAction;
(function (AccountRestrictionModificationAction) {
    AccountRestrictionModificationAction[AccountRestrictionModificationAction["Add"] = 1] = "Add";
    AccountRestrictionModificationAction[AccountRestrictionModificationAction["Remove"] = 0] = "Remove";
})(AccountRestrictionModificationAction = exports.AccountRestrictionModificationAction || (exports.AccountRestrictionModificationAction = {}));

},{}],699:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Account restrictions structure describes restriction information for an account.
 */
class AccountRestrictions {
    /**
     * Constructor
     * @param address
     * @param restrictions
     */
    constructor(
    /**
     * Account Address
     */
    address, 
    /**
     * Restrictions.
     */
    restrictions) {
        this.address = address;
        this.restrictions = restrictions;
    }
}
exports.AccountRestrictions = AccountRestrictions;

},{}],700:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Account restrictions structure describes restriction information for an account.
 */
class AccountRestrictionsInfo {
    /**
     * Constructor
     * @param meta
     * @param accountRestrictions
     */
    constructor(
    /**
     * meta
     */
    meta, 
    /**
     * Restrictions.
     */
    accountRestrictions) {
        this.meta = meta;
        this.accountRestrictions = accountRestrictions;
    }
}
exports.AccountRestrictionsInfo = AccountRestrictionsInfo;

},{}],701:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"),
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var AddressRestrictionFlag;
(function (AddressRestrictionFlag) {
    /**
     * Allow only incoming transactions from a given address.
     */
    AddressRestrictionFlag[AddressRestrictionFlag["AllowIncomingAddress"] = 1] = "AllowIncomingAddress";
    /**
     * Allow only outgoing transactions to a given address.
     */
    AddressRestrictionFlag[AddressRestrictionFlag["AllowOutgoingAddress"] = 16385] = "AllowOutgoingAddress";
    /**
     * Block incoming transactions from a given address.
     */
    AddressRestrictionFlag[AddressRestrictionFlag["BlockIncomingAddress"] = 32769] = "BlockIncomingAddress";
    /**
     * Block outgoing transactions from a given address.
     */
    AddressRestrictionFlag[AddressRestrictionFlag["BlockOutgoingAddress"] = 49153] = "BlockOutgoingAddress";
})(AddressRestrictionFlag = exports.AddressRestrictionFlag || (exports.AddressRestrictionFlag = {}));

},{}],702:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Mosaic address restriction structure describes restriction information for an mosaic.
 */
class MosaicAddressRestriction {
    /**
     * Constructor
     * @param compositeHash
     * @param entryType
     * @param mosaicId
     * @param targetAddress
     * @param restrictions
     */
    constructor(
    /**
     * composite hash
     */
    compositeHash, 
    /**
     * Mosaic restriction entry type.
     */
    entryType, 
    /**
     * Mosaic identifier.
     */
    mosaicId, 
    /**
     * Target address
     */
    targetAddress, 
    /**
     * Mosaic restriction items
     */
    restrictions) {
        this.compositeHash = compositeHash;
        this.entryType = entryType;
        this.mosaicId = mosaicId;
        this.targetAddress = targetAddress;
        this.restrictions = restrictions;
    }
}
exports.MosaicAddressRestriction = MosaicAddressRestriction;

},{}],703:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Mosaic global restriction structure describes restriction information for an mosaic.
 */
class MosaicGlobalRestriction {
    /**
     * Constructor
     * @param compositeHash
     * @param entryType
     * @param mosaicId
     * @param targetAddress
     * @param restrictions
     */
    constructor(
    /**
     * composite hash
     */
    compositeHash, 
    /**
     * Mosaic restriction entry type.
     */
    entryType, 
    /**
     * Mosaic identifier.
     */
    mosaicId, 
    /**
     * Mosaic restriction items
     */
    restrictions) {
        this.compositeHash = compositeHash;
        this.entryType = entryType;
        this.mosaicId = mosaicId;
        this.restrictions = restrictions;
    }
}
exports.MosaicGlobalRestriction = MosaicGlobalRestriction;

},{}],704:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Mosaic global restriction item structure .
 */
class MosaicGlobalRestrictionItem {
    /**
     * Constructor
     * @param referenceMosaicId
     * @param restrictionValue
     * @param restrictionType
     */
    constructor(
    /**
     * Reference mosaic identifier
     */
    referenceMosaicId, 
    /**
     * Mosaic restriction value.
     */
    restrictionValue, 
    /**
     * Mosaic restriction type.
     */
    restrictionType) {
        this.referenceMosaicId = referenceMosaicId;
        this.restrictionValue = restrictionValue;
        this.restrictionType = restrictionType;
    }
}
exports.MosaicGlobalRestrictionItem = MosaicGlobalRestrictionItem;

},{}],705:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MosaicRestrictionEntryType;
(function (MosaicRestrictionEntryType) {
    /**
     * Mosaic address restriction
     */
    MosaicRestrictionEntryType[MosaicRestrictionEntryType["ADDRESS"] = 0] = "ADDRESS";
    /**
     * Mosaic global restriction
     */
    MosaicRestrictionEntryType[MosaicRestrictionEntryType["GLOBAL"] = 1] = "GLOBAL";
})(MosaicRestrictionEntryType = exports.MosaicRestrictionEntryType || (exports.MosaicRestrictionEntryType = {}));

},{}],706:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"),
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var MosaicRestrictionFlag;
(function (MosaicRestrictionFlag) {
    /**
     * Allow only incoming transactions containing a a given mosaic identifier.
     */
    MosaicRestrictionFlag[MosaicRestrictionFlag["AllowMosaic"] = 2] = "AllowMosaic";
    /**
     * Block incoming transactions containing a given mosaic identifier.
     */
    MosaicRestrictionFlag[MosaicRestrictionFlag["BlockMosaic"] = 32770] = "BlockMosaic";
})(MosaicRestrictionFlag = exports.MosaicRestrictionFlag || (exports.MosaicRestrictionFlag = {}));

},{}],707:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MosaicRestrictionType;
(function (MosaicRestrictionType) {
    /**
     * uninitialized value indicating no restriction
     */
    MosaicRestrictionType[MosaicRestrictionType["NONE"] = 0] = "NONE";
    /**
     * allow if equal
     */
    MosaicRestrictionType[MosaicRestrictionType["EQ"] = 1] = "EQ";
    /**
     * allow if not equal
     */
    MosaicRestrictionType[MosaicRestrictionType["NE"] = 2] = "NE";
    /**
     * allow if less than
     */
    MosaicRestrictionType[MosaicRestrictionType["LT"] = 3] = "LT";
    /**
     * allow if less than or equal
     */
    MosaicRestrictionType[MosaicRestrictionType["LE"] = 4] = "LE";
    /**
     * allow if greater than
     */
    MosaicRestrictionType[MosaicRestrictionType["GT"] = 5] = "GT";
    /**
     * allow if greater than or equal
     */
    MosaicRestrictionType[MosaicRestrictionType["GE"] = 6] = "GE";
})(MosaicRestrictionType = exports.MosaicRestrictionType || (exports.MosaicRestrictionType = {}));

},{}],708:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"),
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var OperationRestrictionFlag;
(function (OperationRestrictionFlag) {
    /**
     * Allow only outgoing transactions with a given transaction type.
     */
    OperationRestrictionFlag[OperationRestrictionFlag["AllowOutgoingTransactionType"] = 16388] = "AllowOutgoingTransactionType";
    /**
     * Block outgoing transactions with a given transaction type.
     */
    OperationRestrictionFlag[OperationRestrictionFlag["BlockOutgoingTransactionType"] = 49156] = "BlockOutgoingTransactionType";
})(OperationRestrictionFlag = exports.OperationRestrictionFlag || (exports.OperationRestrictionFlag = {}));

},{}],709:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const DtoMapping_1 = require("../../core/utils/DtoMapping");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
class AccountAddressRestrictionTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param restrictionFlags
     * @param restrictionAdditions
     * @param restrictionDeletions
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, restrictionFlags, restrictionAdditions, restrictionDeletions, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.ACCOUNT_ADDRESS_RESTRICTION, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.restrictionFlags = restrictionFlags;
        this.restrictionAdditions = restrictionAdditions;
        this.restrictionDeletions = restrictionDeletions;
    }
    /**
     * Create a modify account address restriction transaction object
     * @param deadline - The deadline to include the transaction.
     * @param restrictionFlags - The account restriction flags.
     * @param restrictionAdditions - Account restriction additions.
     * @param restrictionDeletions - Account restriction deletions.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {AccountAddressRestrictionTransaction}
     */
    static create(deadline, restrictionFlags, restrictionAdditions, restrictionDeletions, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new AccountAddressRestrictionTransaction(networkType, TransactionVersion_1.TransactionVersion.ACCOUNT_ADDRESS_RESTRICTION, deadline, maxFee, restrictionFlags, restrictionAdditions, restrictionDeletions, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedAccountAddressRestrictionTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.AccountAddressRestrictionTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = AccountAddressRestrictionTransaction.create(isEmbedded
            ? Deadline_1.Deadline.create()
            : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), builder.getRestrictionFlags().valueOf(), builder.getRestrictionAdditions().map((addition) => {
            return UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddress(format_1.Convert.uint8ToHex(addition.unresolvedAddress));
        }), builder.getRestrictionDeletions().map((deletion) => {
            return UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddress(format_1.Convert.uint8ToHex(deletion.unresolvedAddress));
        }), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.AccountAddressRestrictionTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.ACCOUNT_ADDRESS_RESTRICTION.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), this.restrictionFlags.valueOf(), this.restrictionAdditions.map((addition) => {
            return new catbuffer_typescript_1.UnresolvedAddressDto(addition.encodeUnresolvedAddress(this.networkType));
        }), this.restrictionDeletions.map((deletion) => {
            return new catbuffer_typescript_1.UnresolvedAddressDto(deletion.encodeUnresolvedAddress(this.networkType));
        }));
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedAccountAddressRestrictionTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.ACCOUNT_ADDRESS_RESTRICTION.valueOf(), this.restrictionFlags.valueOf(), this.restrictionAdditions.map((addition) => {
            return new catbuffer_typescript_1.UnresolvedAddressDto(addition.encodeUnresolvedAddress(this.networkType));
        }), this.restrictionDeletions.map((deletion) => {
            return new catbuffer_typescript_1.UnresolvedAddressDto(deletion.encodeUnresolvedAddress(this.networkType));
        }));
    }
    /**
     * @internal
     * @param statement Block receipt statement
     * @param aggregateTransactionIndex Transaction index for aggregated transaction
     * @returns {AccountAddressRestrictionTransaction}
     */
    resolveAliases(statement, aggregateTransactionIndex = 0) {
        const transactionInfo = this.checkTransactionHeightAndIndex();
        return DtoMapping_1.DtoMapping.assign(this, {
            restrictionAdditions: this.restrictionAdditions.map((addition) => statement.resolveAddress(addition, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex)),
            restrictionDeletions: this.restrictionDeletions.map((deletion) => statement.resolveAddress(deletion, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex)),
        });
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @param alias address alias (names)
     * @returns {boolean}
     */
    shouldNotifyAccount(address, alias) {
        return (super.isSigned(address) ||
            this.restrictionAdditions.find((_) => _.equals(address) || alias.find((a) => _.equals(a)) !== undefined) !== undefined ||
            this.restrictionDeletions.find((_) => _.equals(address) || alias.find((a) => _.equals(a)) !== undefined) !== undefined);
    }
}
exports.AccountAddressRestrictionTransaction = AccountAddressRestrictionTransaction;

},{"../../core/format":565,"../../core/utils/DtoMapping":566,"../../core/utils/UnresolvedMapping":569,"../UInt64":609,"../account/PublicAccount":621,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],710:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
const Address_1 = require("../account/Address");
/**
 * Announce an AccountKeyLinkTransaction to delegate the account importance to a proxy account.
 * By doing so, you can enable delegated harvesting
 */
class AccountKeyLinkTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param linkedPublicKey
     * @param linkAction
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The public key of the remote account.
     */
    linkedPublicKey, 
    /**
     * The account link action.
     */
    linkAction, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.ACCOUNT_KEY_LINK, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.linkedPublicKey = linkedPublicKey;
        this.linkAction = linkAction;
    }
    /**
     * Create a link account transaction object
     * @param deadline - The deadline to include the transaction.
     * @param linkedPublicKey - The public key of the remote account.
     * @param linkAction - The account link action.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {AccountLinkTransaction}
     */
    static create(deadline, linkedPublicKey, linkAction, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new AccountKeyLinkTransaction(networkType, TransactionVersion_1.TransactionVersion.ACCOUNT_KEY_LINK, deadline, maxFee, linkedPublicKey, linkAction, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedAccountKeyLinkTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.AccountKeyLinkTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = AccountKeyLinkTransaction.create(isEmbedded ? Deadline_1.Deadline.create() : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), format_1.Convert.uint8ToHex(builder.getLinkedPublicKey().key), builder.getLinkAction().valueOf(), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.AccountKeyLinkTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.ACCOUNT_KEY_LINK.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.linkedPublicKey)), this.linkAction.valueOf());
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedAccountKeyLinkTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.ACCOUNT_KEY_LINK.valueOf(), new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.linkedPublicKey)), this.linkAction.valueOf());
    }
    /**
     * @internal
     * @returns {AccountKeyLinkTransaction}
     */
    resolveAliases() {
        return this;
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @returns {boolean}
     */
    shouldNotifyAccount(address) {
        return super.isSigned(address) || Address_1.Address.createFromPublicKey(this.linkedPublicKey, this.networkType).equals(address);
    }
}
exports.AccountKeyLinkTransaction = AccountKeyLinkTransaction;

},{"../../core/format":565,"../UInt64":609,"../account/Address":618,"../account/PublicAccount":621,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],711:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
/**
 * Announce an account metadata transaction to associate a key-value state to an account.
 */
class AccountMetadataTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param targetAddress
     * @param scopedMetadataKey
     * @param valueSizeDelta
     * @param value
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * target account address.
     */
    targetAddress, 
    /**
     * Metadata key scoped to source, target and type.
     */
    scopedMetadataKey, 
    /**
     * Change in value size in bytes.
     */
    valueSizeDelta, 
    /**
     * String value with UTF-8 encoding.
     * Difference between the previous value and new value.
     */
    value, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.ACCOUNT_METADATA, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.targetAddress = targetAddress;
        this.scopedMetadataKey = scopedMetadataKey;
        this.valueSizeDelta = valueSizeDelta;
        this.value = value;
    }
    /**
     * Create a account meta data transaction object
     * @param deadline - transaction deadline
     * @param targetAddress - target account address.
     * @param scopedMetadataKey - Metadata key scoped to source, target and type.
     * @param valueSizeDelta - Change in value size in bytes.
     * @param value - String value with UTF-8 encoding
     *                Difference between the previous value and new value.
     *                You can calculate value as xor(previous-value, new-value).
     *                If there is no previous value, use directly the new value.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {AccountMetadataTransaction}
     */
    static create(deadline, targetAddress, scopedMetadataKey, valueSizeDelta, value, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new AccountMetadataTransaction(networkType, TransactionVersion_1.TransactionVersion.ACCOUNT_METADATA, deadline, maxFee, targetAddress, scopedMetadataKey, valueSizeDelta, value, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedAccountMetadataTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.AccountMetadataTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = AccountMetadataTransaction.create(isEmbedded ? Deadline_1.Deadline.create() : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddress(format_1.Convert.uint8ToHex(builder.getTargetAddress().unresolvedAddress)), new UInt64_1.UInt64(builder.getScopedMetadataKey()), builder.getValueSizeDelta(), format_1.Convert.uint8ToUtf8(builder.getValue()), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.AccountMetadataTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.ACCOUNT_METADATA.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.UnresolvedAddressDto(this.targetAddress.encodeUnresolvedAddress(this.networkType)), this.scopedMetadataKey.toDTO(), this.valueSizeDelta, format_1.Convert.utf8ToUint8(this.value));
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedAccountMetadataTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.ACCOUNT_METADATA.valueOf(), new catbuffer_typescript_1.UnresolvedAddressDto(this.targetAddress.encodeUnresolvedAddress(this.networkType)), this.scopedMetadataKey.toDTO(), this.valueSizeDelta, format_1.Convert.utf8ToUint8(this.value));
    }
    /**
     * @internal
     * @returns {AccountMetadataTransaction}
     */
    resolveAliases() {
        return this;
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @param alias address alias (names)
     * @returns {boolean}
     */
    shouldNotifyAccount(address, alias) {
        return (super.isSigned(address) ||
            this.targetAddress.equals(address) ||
            alias.find((name) => this.targetAddress.equals(name)) !== undefined);
    }
}
exports.AccountMetadataTransaction = AccountMetadataTransaction;

},{"../../core/format":565,"../../core/utils/UnresolvedMapping":569,"../UInt64":609,"../account/PublicAccount":621,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],712:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const DtoMapping_1 = require("../../core/utils/DtoMapping");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
class AccountMosaicRestrictionTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param restrictionFlags
     * @param restrictionAdditions
     * @param restrictionDeletions
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, restrictionFlags, restrictionAdditions, restrictionDeletions, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.ACCOUNT_MOSAIC_RESTRICTION, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.restrictionFlags = restrictionFlags;
        this.restrictionAdditions = restrictionAdditions;
        this.restrictionDeletions = restrictionDeletions;
    }
    /**
     * Create a modify account mosaic restriction transaction object
     * @param deadline - The deadline to include the transaction.
     * @param restrictionFlags - The account restriction flags.
     * @param restrictionAdditions - Account restriction additions.
     * @param restrictionDeletions - Account restriction deletions.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {AccountAddressRestrictionTransaction}
     */
    static create(deadline, restrictionFlags, restrictionAdditions, restrictionDeletions, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new AccountMosaicRestrictionTransaction(networkType, TransactionVersion_1.TransactionVersion.ACCOUNT_MOSAIC_RESTRICTION, deadline, maxFee, restrictionFlags, restrictionAdditions, restrictionDeletions, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedAccountMosaicRestrictionTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.AccountMosaicRestrictionTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = AccountMosaicRestrictionTransaction.create(isEmbedded
            ? Deadline_1.Deadline.create()
            : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), builder.getRestrictionFlags().valueOf(), builder.getRestrictionAdditions().map((addition) => {
            return UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(new UInt64_1.UInt64(addition.unresolvedMosaicId).toHex());
        }), builder.getRestrictionDeletions().map((deletion) => {
            return UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(new UInt64_1.UInt64(deletion.unresolvedMosaicId).toHex());
        }), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.AccountMosaicRestrictionTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.ACCOUNT_MOSAIC_RESTRICTION.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), this.restrictionFlags.valueOf(), this.restrictionAdditions.map((addition) => {
            return new catbuffer_typescript_1.UnresolvedMosaicIdDto(addition.id.toDTO());
        }), this.restrictionDeletions.map((deletion) => {
            return new catbuffer_typescript_1.UnresolvedMosaicIdDto(deletion.id.toDTO());
        }));
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedAccountMosaicRestrictionTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.ACCOUNT_MOSAIC_RESTRICTION.valueOf(), this.restrictionFlags.valueOf(), this.restrictionAdditions.map((addition) => {
            return new catbuffer_typescript_1.UnresolvedMosaicIdDto(addition.id.toDTO());
        }), this.restrictionDeletions.map((deletion) => {
            return new catbuffer_typescript_1.UnresolvedMosaicIdDto(deletion.id.toDTO());
        }));
    }
    /**
     * @internal
     * @param statement Block receipt statement
     * @param aggregateTransactionIndex Transaction index for aggregated transaction
     * @returns {AccountMosaicRestrictionTransaction}
     */
    resolveAliases(statement, aggregateTransactionIndex = 0) {
        const transactionInfo = this.checkTransactionHeightAndIndex();
        return DtoMapping_1.DtoMapping.assign(this, {
            restrictionAdditions: this.restrictionAdditions.map((addition) => statement.resolveMosaicId(addition, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex)),
            restrictionDeletions: this.restrictionDeletions.map((deletion) => statement.resolveMosaicId(deletion, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex)),
        });
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @returns {boolean}
     */
    shouldNotifyAccount(address) {
        return super.isSigned(address);
    }
}
exports.AccountMosaicRestrictionTransaction = AccountMosaicRestrictionTransaction;

},{"../../core/format":565,"../../core/utils/DtoMapping":566,"../../core/utils/UnresolvedMapping":569,"../UInt64":609,"../account/PublicAccount":621,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],713:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
class AccountOperationRestrictionTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param restrictionFlags
     * @param restrictionAdditions
     * @param restrictionDeletions
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, restrictionFlags, restrictionAdditions, restrictionDeletions, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.ACCOUNT_OPERATION_RESTRICTION, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.restrictionFlags = restrictionFlags;
        this.restrictionAdditions = restrictionAdditions;
        this.restrictionDeletions = restrictionDeletions;
    }
    /**
     * Create a modify account operation restriction type transaction object
     * @param deadline - The deadline to include the transaction.
     * @param restrictionFlags - The account restriction flags.
     * @param restrictionAdditions - Account restriction additions.
     * @param restrictionDeletions - Account restriction deletions.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {AccountOperationRestrictionTransaction}
     */
    static create(deadline, restrictionFlags, restrictionAdditions, restrictionDeletions, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new AccountOperationRestrictionTransaction(networkType, TransactionVersion_1.TransactionVersion.MODIFY_ACCOUNT_RESTRICTION_ENTITY_TYPE, deadline, maxFee, restrictionFlags, restrictionAdditions, restrictionDeletions, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedAccountOperationRestrictionTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.AccountOperationRestrictionTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signer = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = AccountOperationRestrictionTransaction.create(isEmbedded
            ? Deadline_1.Deadline.create()
            : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), builder.getRestrictionFlags().valueOf(), builder.getRestrictionAdditions(), builder.getRestrictionDeletions(), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signer.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signer, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signer, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.AccountOperationRestrictionTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.ACCOUNT_OPERATION_RESTRICTION.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), this.restrictionFlags.valueOf(), this.restrictionAdditions, this.restrictionDeletions);
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedAccountOperationRestrictionTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.ACCOUNT_OPERATION_RESTRICTION.valueOf(), this.restrictionFlags.valueOf(), this.restrictionAdditions, this.restrictionDeletions);
    }
    /**
     * @internal
     * @returns {AccountOperationRestrictionTransaction}
     */
    resolveAliases() {
        return this;
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @returns {boolean}
     */
    shouldNotifyAccount(address) {
        return super.isSigned(address);
    }
}
exports.AccountOperationRestrictionTransaction = AccountOperationRestrictionTransaction;

},{"../../core/format":565,"../UInt64":609,"../account/PublicAccount":621,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],714:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class AccountRestrictionModification {
    /**
     * Constructor
     * @param modificationAction
     * @param value
     */
    constructor(
    /**
     * Modification type.
     */
    modificationAction, 
    /**
     * Modification value (Address, Mosaic or Transaction Type).
     */
    value) {
        this.modificationAction = modificationAction;
        this.value = value;
    }
    /**
     * Create an address filter for account restriction modification
     * @param modificationAction - modification type. 0: Add, 1: Remove
     * @param value - modification value (Address)
     * @returns {AccountRestrictionModification}
     */
    static createForAddress(modificationAction, value) {
        return new AccountRestrictionModification(modificationAction, value.plain());
    }
    /**
     * Create an mosaic filter for account restriction modification
     * @param modificationAction - modification type. 0: Add, 1: Remove
     * @param value - modification value (Mosaic)
     * @returns {AccountRestrictionModification}
     */
    static createForMosaic(modificationAction, value) {
        return new AccountRestrictionModification(modificationAction, value.id.toDTO());
    }
    /**
     * Create an operation filter for account restriction modification
     * @param modificationAction - modification type. 0: Add, 1: Remove
     * @param operation - modification value (Transaction Type)
     * @returns {AccountRestrictionModification}
     */
    static createForOperation(modificationAction, value) {
        return new AccountRestrictionModification(modificationAction, value);
    }
    /**
     * @internal
     */
    toDTO() {
        return {
            value: this.value,
            modificationAction: this.modificationAction,
        };
    }
}
exports.AccountRestrictionModification = AccountRestrictionModification;

},{}],715:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const UInt64_1 = require("../UInt64");
const AccountAddressRestrictionTransaction_1 = require("./AccountAddressRestrictionTransaction");
const AccountMosaicRestrictionTransaction_1 = require("./AccountMosaicRestrictionTransaction");
const AccountOperationRestrictionTransaction_1 = require("./AccountOperationRestrictionTransaction");
class AccountRestrictionTransaction {
    /**
     * Create an account address restriction transaction object
     * @param deadline - The deadline to include the transaction.
     * @param restrictionFlags - Type of account restriction transaction
     * @param restrictionAdditions - Account restriction additions.
     * @param restrictionDeletions - Account restriction deletions.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {AccountAddressRestrictionTransaction}
     */
    static createAddressRestrictionModificationTransaction(deadline, restrictionFlags, restrictionAdditions, restrictionDeletions, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return AccountAddressRestrictionTransaction_1.AccountAddressRestrictionTransaction.create(deadline, restrictionFlags, restrictionAdditions, restrictionDeletions, networkType, maxFee, signature, signer);
    }
    /**
     * Create an account mosaic restriction transaction object
     * @param deadline - The deadline to include the transaction.
     * @param restrictionFlags - Type of account restriction transaction
     * @param restrictionAdditions - Account restriction additions.
     * @param restrictionDeletions - Account restriction deletions.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {AccountMosaicRestrictionTransaction}
     */
    static createMosaicRestrictionModificationTransaction(deadline, restrictionFlags, restrictionAdditions, restrictionDeletions, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return AccountMosaicRestrictionTransaction_1.AccountMosaicRestrictionTransaction.create(deadline, restrictionFlags, restrictionAdditions, restrictionDeletions, networkType, maxFee, signature, signer);
    }
    /**
     * Create an account operation restriction transaction object
     * @param deadline - The deadline to include the transaction.
     * @param restrictionFlags - Type of account restriction transaction
     * @param restrictionAdditions - Account restriction additions.
     * @param restrictionDeletions - Account restriction deletions.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {AccountOperationRestrictionTransaction}
     */
    static createOperationRestrictionModificationTransaction(deadline, restrictionFlags, restrictionAdditions, restrictionDeletions, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return AccountOperationRestrictionTransaction_1.AccountOperationRestrictionTransaction.create(deadline, restrictionFlags, restrictionAdditions, restrictionDeletions, networkType, maxFee, signature, signer);
    }
}
exports.AccountRestrictionTransaction = AccountRestrictionTransaction;

},{"../UInt64":609,"./AccountAddressRestrictionTransaction":709,"./AccountMosaicRestrictionTransaction":712,"./AccountOperationRestrictionTransaction":713}],716:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const Address_1 = require("../account/Address");
const PublicAccount_1 = require("../account/PublicAccount");
const NamespaceId_1 = require("../namespace/NamespaceId");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
/**
 * In case a mosaic has the flag 'supplyMutable' set to true, the creator of the mosaic can change the supply,
 * i.e. increase or decrease the supply.
 */
class AddressAliasTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param aliasAction
     * @param namespaceId
     * @param address
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The alias action type.
     */
    aliasAction, 
    /**
     * The namespace id that will be an alias.
     */
    namespaceId, 
    /**
     * The address.
     */
    address, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.ADDRESS_ALIAS, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.aliasAction = aliasAction;
        this.namespaceId = namespaceId;
        this.address = address;
    }
    /**
     * Create a address alias transaction object
     * @param deadline - The deadline to include the transaction.
     * @param aliasAction - The alias action type.
     * @param namespaceId - The namespace id.
     * @param address - The address.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {AddressAliasTransaction}
     */
    static create(deadline, aliasAction, namespaceId, address, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new AddressAliasTransaction(networkType, TransactionVersion_1.TransactionVersion.ADDRESS_ALIAS, deadline, maxFee, aliasAction, namespaceId, address, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedAddressAliasTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.AddressAliasTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = AddressAliasTransaction.create(isEmbedded ? Deadline_1.Deadline.create() : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), builder.getAliasAction().valueOf(), new NamespaceId_1.NamespaceId(builder.getNamespaceId().namespaceId), Address_1.Address.createFromEncoded(format_1.Convert.uint8ToHex(builder.getAddress().address)), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.AddressAliasTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.ADDRESS_ALIAS.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.NamespaceIdDto(this.namespaceId.id.toDTO()), new catbuffer_typescript_1.AddressDto(format_1.RawAddress.stringToAddress(this.address.plain())), this.aliasAction.valueOf());
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedAddressAliasTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.ADDRESS_ALIAS.valueOf(), new catbuffer_typescript_1.NamespaceIdDto(this.namespaceId.id.toDTO()), new catbuffer_typescript_1.AddressDto(format_1.RawAddress.stringToAddress(this.address.plain())), this.aliasAction.valueOf());
    }
    /**
     * @internal
     * @returns {AddressAliasTransaction}
     */
    resolveAliases() {
        return this;
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @returns {boolean}
     */
    shouldNotifyAccount(address) {
        return super.isSigned(address) || this.address.equals(address);
    }
}
exports.AddressAliasTransaction = AddressAliasTransaction;

},{"../../core/format":565,"../UInt64":609,"../account/Address":618,"../account/PublicAccount":621,"../namespace/NamespaceId":656,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],717:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const crypto_1 = require("../../core/crypto");
const format_1 = require("../../core/format");
const DtoMapping_1 = require("../../core/utils/DtoMapping");
const CreateTransactionFromPayload_1 = require("../../infrastructure/transaction/CreateTransactionFromPayload");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const AggregateTransactionCosignature_1 = require("./AggregateTransactionCosignature");
const Deadline_1 = require("./Deadline");
const SignedTransaction_1 = require("./SignedTransaction");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
/**
 * Aggregate innerTransactions contain multiple innerTransactions that can be initiated by different accounts.
 */
class AggregateTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param type
     * @param version
     * @param deadline
     * @param maxFee
     * @param innerTransactions
     * @param cosignatures
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, type, version, deadline, maxFee, 
    /**
     * The array of innerTransactions included in the aggregate transaction.
     */
    innerTransactions, 
    /**
     * The array of transaction cosigners signatures.
     */
    cosignatures, signature, signer, transactionInfo) {
        super(type, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.innerTransactions = innerTransactions;
        this.cosignatures = cosignatures;
    }
    /**
     * Create an aggregate complete transaction object
     * @param deadline - The deadline to include the transaction.
     * @param innerTransactions - The array of inner innerTransactions.
     * @param networkType - The network type.
     * @param cosignatures
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {AggregateTransaction}
     */
    static createComplete(deadline, innerTransactions, networkType, cosignatures, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new AggregateTransaction(networkType, TransactionType_1.TransactionType.AGGREGATE_COMPLETE, TransactionVersion_1.TransactionVersion.AGGREGATE_COMPLETE, deadline, maxFee, innerTransactions, cosignatures, signature, signer);
    }
    /**
     * Create an aggregate bonded transaction object
     * @param {Deadline} deadline
     * @param {InnerTransaction[]} innerTransactions
     * @param {NetworkType} networkType
     * @param {AggregateTransactionCosignature[]} cosignatures
     * @param {UInt64} maxFee - (Optional) Max fee defined by the sender
     * @param {string} signature - (Optional) Transaction signature
     * @param {PublicAccount} signer - (Optional) Signer public account
     * @return {AggregateTransaction}
     */
    static createBonded(deadline, innerTransactions, networkType, cosignatures = [], maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new AggregateTransaction(networkType, TransactionType_1.TransactionType.AGGREGATE_BONDED, TransactionVersion_1.TransactionVersion.AGGREGATE_BONDED, deadline, maxFee, innerTransactions, cosignatures, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @returns {AggregateTransaction}
     */
    static createFromPayload(payload) {
        /**
         * Get transaction type from the payload hex
         * As buffer uses separate builder class for Complete and bonded
         */
        const type = parseInt(format_1.Convert.uint8ToHex(format_1.Convert.hexToUint8(payload.substring(220, 224)).reverse()), 16);
        const builder = type === TransactionType_1.TransactionType.AGGREGATE_COMPLETE
            ? catbuffer_typescript_1.AggregateCompleteTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.AggregateBondedTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const innerTransactions = builder.getTransactions().map((t) => format_1.Convert.uint8ToHex(catbuffer_typescript_1.EmbeddedTransactionHelper.serialize(t)));
        const networkType = builder.getNetwork().valueOf();
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const signature = payload.substring(16, 144);
        const consignatures = builder.getCosignatures().map((cosig) => {
            return new AggregateTransactionCosignature_1.AggregateTransactionCosignature(format_1.Convert.uint8ToHex(cosig.signature.signature), PublicAccount_1.PublicAccount.createFromPublicKey(format_1.Convert.uint8ToHex(cosig.signerPublicKey.key), networkType), new UInt64_1.UInt64(cosig.version));
        });
        return type === TransactionType_1.TransactionType.AGGREGATE_COMPLETE
            ? AggregateTransaction.createComplete(Deadline_1.Deadline.createFromDTO(builder.deadline.timestamp), innerTransactions.map((transactionRaw) => {
                return CreateTransactionFromPayload_1.CreateTransactionFromPayload(transactionRaw, true);
            }), networkType, consignatures, new UInt64_1.UInt64(builder.fee.amount), signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType))
            : AggregateTransaction.createBonded(Deadline_1.Deadline.createFromDTO(builder.deadline.timestamp), innerTransactions.map((transactionRaw) => {
                return CreateTransactionFromPayload_1.CreateTransactionFromPayload(transactionRaw, true);
            }), networkType, consignatures, new UInt64_1.UInt64(builder.fee.amount), signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
    }
    /**
     * @description add inner transactions to current list
     * @param {InnerTransaction[]} transaction
     * @returns {AggregateTransaction}
     * @memberof AggregateTransaction
     */
    addTransactions(transactions) {
        const innerTransactions = this.innerTransactions.concat(transactions);
        return DtoMapping_1.DtoMapping.assign(this, { innerTransactions });
    }
    /**
     * @description add cosignatures to current list
     * @param {AggregateTransactionCosignature[]} transaction
     * @returns {AggregateTransaction}
     * @memberof AggregateTransaction
     */
    addCosignatures(cosigs) {
        const cosignatures = this.cosignatures.concat(cosigs);
        return DtoMapping_1.DtoMapping.assign(this, { cosignatures });
    }
    /**
     * @internal
     * Sign transaction with cosignatories creating a new SignedTransaction
     * @param initiatorAccount - Initiator account
     * @param cosignatories - The array of accounts that will cosign the transaction
     * @param generationHash - Network generation hash hex
     * @returns {SignedTransaction}
     */
    signTransactionWithCosignatories(initiatorAccount, cosignatories, generationHash) {
        const signedTransaction = this.signWith(initiatorAccount, generationHash);
        const transactionHashBytes = format_1.Convert.hexToUint8(signedTransaction.hash);
        let signedPayload = signedTransaction.payload;
        cosignatories.forEach((cosigner) => {
            const keyPairEncoded = crypto_1.KeyPair.createKeyPairFromPrivateKeyString(cosigner.privateKey);
            const signature = crypto_1.KeyPair.sign(keyPairEncoded, transactionHashBytes);
            signedPayload += UInt64_1.UInt64.fromUint(0).toHex() + cosigner.publicKey + format_1.Convert.uint8ToHex(signature);
        });
        // Calculate new size
        const size = `00000000${(signedPayload.length / 2).toString(16)}`;
        const formatedSize = size.substr(size.length - 8, size.length);
        const littleEndianSize = formatedSize.substr(6, 2) + formatedSize.substr(4, 2) + formatedSize.substr(2, 2) + formatedSize.substr(0, 2);
        signedPayload = littleEndianSize + signedPayload.substr(8, signedPayload.length - 8);
        return new SignedTransaction_1.SignedTransaction(signedPayload, signedTransaction.hash, initiatorAccount.publicKey, this.type, this.networkType);
    }
    /**
     * @internal
     * Sign transaction with cosignatories collected from cosigned transactions and creating a new SignedTransaction
     * For off chain Aggregated Complete Transaction co-signing.
     * @param initiatorAccount - Initiator account
     * @param {CosignatureSignedTransaction[]} cosignatureSignedTransactions - Array of cosigned transaction
     * @param generationHash - Network generation hash hex
     * @return {SignedTransaction}
     */
    signTransactionGivenSignatures(initiatorAccount, cosignatureSignedTransactions, generationHash) {
        const signedTransaction = this.signWith(initiatorAccount, generationHash);
        let signedPayload = signedTransaction.payload;
        cosignatureSignedTransactions.forEach((cosignedTransaction) => {
            signedPayload += cosignedTransaction.version.toHex() + cosignedTransaction.signerPublicKey + cosignedTransaction.signature;
        });
        // Calculate new size
        const size = `00000000${(signedPayload.length / 2).toString(16)}`;
        const formatedSize = size.substr(size.length - 8, size.length);
        const littleEndianSize = formatedSize.substr(6, 2) + formatedSize.substr(4, 2) + formatedSize.substr(2, 2) + formatedSize.substr(0, 2);
        signedPayload = littleEndianSize + signedPayload.substr(8, signedPayload.length - 8);
        return new SignedTransaction_1.SignedTransaction(signedPayload, signedTransaction.hash, initiatorAccount.publicKey, this.type, this.networkType);
    }
    /**
     * Check if account has signed transaction
     * @param publicAccount - Signer public account
     * @returns {boolean}
     */
    signedByAccount(publicAccount) {
        return (this.cosignatures.find((cosignature) => cosignature.signer.equals(publicAccount)) !== undefined ||
            (this.signer !== undefined && this.signer.equals(publicAccount)));
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactions = this.innerTransactions.map((transaction) => transaction.toEmbeddedTransaction());
        const cosignatures = this.cosignatures.map((cosignature) => {
            const signerBytes = format_1.Convert.hexToUint8(cosignature.signer.publicKey);
            const signatureBytes = format_1.Convert.hexToUint8(cosignature.signature);
            return new catbuffer_typescript_1.CosignatureBuilder(cosignature.version.toDTO(), new catbuffer_typescript_1.KeyDto(signerBytes), new catbuffer_typescript_1.SignatureDto(signatureBytes));
        });
        const transactionBuilder = this.type === TransactionType_1.TransactionType.AGGREGATE_COMPLETE
            ? new catbuffer_typescript_1.AggregateCompleteTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), this.type.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.Hash256Dto(this.calculateInnerTransactionHash()), transactions, cosignatures)
            : new catbuffer_typescript_1.AggregateBondedTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), this.type.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.Hash256Dto(this.calculateInnerTransactionHash()), transactions, cosignatures);
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        throw new Error('Method not implemented');
    }
    /**
     * @internal
     * Generate inner transaction root hash (merkle tree)
     * @returns {Uint8Array}
     */
    calculateInnerTransactionHash() {
        // Note: Transaction hashing *always* uses SHA3
        const hasher = crypto_1.SHA3Hasher.createHasher(32);
        const builder = new crypto_1.MerkleHashBuilder(32);
        this.innerTransactions.forEach((transaction) => {
            const entityHash = new Uint8Array(32);
            // for each embedded transaction hash their body
            hasher.reset();
            hasher.update(transaction.toAggregateTransactionBytes());
            hasher.finalize(entityHash);
            // update merkle tree (add transaction hash)
            builder.update(entityHash);
        });
        // calculate root hash with all transactions
        return builder.getRootHash();
    }
    /**
     * Gets the padding size that rounds up \a size to the next multiple of \a alignment.
     * @param size Inner transaction size
     * @param alignment Next multiple alignment
     */
    getInnerTransactionPaddingSize(size, alignment) {
        return 0 === size % alignment ? 0 : alignment - (size % alignment);
    }
    /**
     * @internal
     * @returns {AggregateTransaction}
     */
    resolveAliases(statement) {
        const transactionInfo = this.checkTransactionHeightAndIndex();
        return DtoMapping_1.DtoMapping.assign(this, {
            innerTransactions: this.innerTransactions
                .map((tx) => tx.resolveAliases(statement, transactionInfo.index))
                .sort((a, b) => a.transactionInfo.index - b.transactionInfo.index),
        });
    }
    /**
     * Set transaction maxFee using fee multiplier for **ONLY AGGREGATE TRANSACTIONS**
     * @param feeMultiplier The fee multiplier
     * @param requiredCosignatures Required number of cosignatures
     * @returns {AggregateTransaction}
     */
    setMaxFeeForAggregate(feeMultiplier, requiredCosignatures) {
        if (this.type !== TransactionType_1.TransactionType.AGGREGATE_BONDED && this.type !== TransactionType_1.TransactionType.AGGREGATE_COMPLETE) {
            throw new Error('setMaxFeeForAggregate can only be used for aggregate transactions.');
        }
        // Check if current cosignature count is greater than requiredCosignatures.
        const calculatedCosignatures = requiredCosignatures > this.cosignatures.length ? requiredCosignatures : this.cosignatures.length;
        // Remove current cosignature length and use the calculated one.
        const calculatedSize = this.size - this.cosignatures.length * 96 + calculatedCosignatures * 96;
        return DtoMapping_1.DtoMapping.assign(this, {
            maxFee: UInt64_1.UInt64.fromUint(calculatedSize * feeMultiplier),
        });
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @param alias address alias (names)
     * @returns {boolean}
     */
    shouldNotifyAccount(address, alias) {
        return (super.isSigned(address) ||
            this.cosignatures.find((_) => _.signer.address.equals(address)) !== undefined ||
            this.innerTransactions.find((innerTransaction) => innerTransaction.shouldNotifyAccount(address, alias)) !==
                undefined);
    }
}
exports.AggregateTransaction = AggregateTransaction;

},{"../../core/crypto":555,"../../core/format":565,"../../core/utils/DtoMapping":566,"../../infrastructure/transaction/CreateTransactionFromPayload":605,"../UInt64":609,"../account/PublicAccount":621,"./AggregateTransactionCosignature":718,"./Deadline":724,"./SignedTransaction":743,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],718:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const UInt64_1 = require("../UInt64");
/**
 * Model representing cosignature of an aggregate transaction.
 */
class AggregateTransactionCosignature {
    /**
     * @param signature
     * @param signer
     * @param version
     */
    constructor(
    /**
     * The signature of aggregate transaction done by the cosigner.
     */
    signature, 
    /**
     * The cosigner public account.
     */
    signer, 
    /**
     * Version
     */
    version = UInt64_1.UInt64.fromUint(0)) {
        this.signature = signature;
        this.signer = signer;
        this.version = version;
    }
    /**
     * Create DTO object
     */
    toDTO() {
        return {
            version: this.version.toDTO(),
            signature: this.signature,
            signerPublicKey: this.signer.toDTO(),
        };
    }
}
exports.AggregateTransactionCosignature = AggregateTransactionCosignature;

},{"../UInt64":609}],719:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const TransactionInfo_1 = require("./TransactionInfo");
/**
 * Inner transaction information model included in all aggregate inner transactions
 */
class AggregateTransactionInfo extends TransactionInfo_1.TransactionInfo {
    /**
     * @param height
     * @param index
     * @param id
     * @param aggregateHash
     * @param aggregateId
     */
    constructor(height, index, id, 
    /**
     * The hash of the aggregate transaction.
     */
    aggregateHash, 
    /**
     * The id of the aggregate transaction.
     */
    aggregateId) {
        super(height, index, id);
        this.aggregateHash = aggregateHash;
        this.aggregateId = aggregateId;
    }
}
exports.AggregateTransactionInfo = AggregateTransactionInfo;

},{"./TransactionInfo":747}],720:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const UInt64_1 = require("../UInt64");
const AddressAliasTransaction_1 = require("./AddressAliasTransaction");
const MosaicAliasTransaction_1 = require("./MosaicAliasTransaction");
const Transaction_1 = require("./Transaction");
class AliasTransaction extends Transaction_1.Transaction {
    /**
     * Create an address alias transaction object
     * @param deadline - The deadline to include the transaction.
     * @param aliasAction - The namespace id.
     * @param namespaceId - The namespace id.
     * @param address - The address.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {AddressAliasTransaction}
     */
    static createForAddress(deadline, aliasAction, namespaceId, address, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return AddressAliasTransaction_1.AddressAliasTransaction.create(deadline, aliasAction, namespaceId, address, networkType, maxFee, signature, signer);
    }
    /**
     * Create a mosaic alias transaction object
     * @param deadline - The deadline to include the transaction.
     * @param aliasAction - The namespace id.
     * @param namespaceId - The namespace id.
     * @param mosaicId - The mosaic id.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {MosaicAliasTransaction}
     */
    static createForMosaic(deadline, aliasAction, namespaceId, mosaicId, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return MosaicAliasTransaction_1.MosaicAliasTransaction.create(deadline, aliasAction, namespaceId, mosaicId, networkType, maxFee, signature, signer);
    }
}
exports.AliasTransaction = AliasTransaction;

},{"../UInt64":609,"./AddressAliasTransaction":716,"./MosaicAliasTransaction":730,"./Transaction":745}],721:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Multsig cosignatory modification type. Supported types are:
 * 0: Add cosignatory.
 * 1: Remove cosignatory.
 */
var CosignatoryModificationAction;
(function (CosignatoryModificationAction) {
    CosignatoryModificationAction[CosignatoryModificationAction["Add"] = 1] = "Add";
    CosignatoryModificationAction[CosignatoryModificationAction["Remove"] = 0] = "Remove";
})(CosignatoryModificationAction = exports.CosignatoryModificationAction || (exports.CosignatoryModificationAction = {}));

},{}],722:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const UInt64_1 = require("../UInt64");
/**
 * Co-signature signed transaction.
 */
class CosignatureSignedTransaction {
    /**
     * @param parentHash
     * @param signature
     * @param signerPublicKey
     * @param version
     */
    constructor(
    /**
     * The hash of parent aggregate transaction that has been signed by a cosignatory of the transaction
     */
    parentHash, 
    /**
     * The signatures generated by signing the parent aggregate transaction hash.
     */
    signature, 
    /**
     * The signer publicKey of the transaction.
     */
    signerPublicKey, 
    /**
     * Version
     */
    version = UInt64_1.UInt64.fromUint(0)) {
        this.parentHash = parentHash;
        this.signature = signature;
        this.signerPublicKey = signerPublicKey;
        this.version = version;
    }
}
exports.CosignatureSignedTransaction = CosignatureSignedTransaction;

},{"../UInt64":609}],723:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("../../core/crypto");
const Convert_1 = require("../../core/format/Convert");
const CosignatureSignedTransaction_1 = require("./CosignatureSignedTransaction");
const Transaction_1 = require("./Transaction");
/**
 * Cosignature transaction is used to sign an aggregate transactions with missing cosignatures.
 */
class CosignatureTransaction {
    /**
     * @param transactionToCosign Aggregate transaction
     */
    constructor(
    /**
     * Transaction to cosign.
     */
    transactionToCosign) {
        this.transactionToCosign = transactionToCosign;
    }
    /**
     * Create a cosignature transaction
     * @param transactionToCosign - Transaction to cosign.
     * @returns {CosignatureTransaction}
     */
    static create(transactionToCosign) {
        return new CosignatureTransaction(transactionToCosign);
    }
    /**
     * Co-sign transaction with transaction payload (off chain)
     * Creating a new CosignatureSignedTransaction
     * @param account - The signing account
     * @param payload - off transaction payload (aggregated transaction is unannounced)
     * @param generationHash - Network generation hash
     * @returns {CosignatureSignedTransaction}
     */
    static signTransactionPayload(account, payload, generationHash) {
        /**
         * For aggregated complete transaction, cosignatories are gathered off chain announced.
         */
        const transactionHash = Transaction_1.Transaction.createTransactionHash(payload, Array.from(Convert_1.Convert.hexToUint8(generationHash)));
        const hashBytes = Convert_1.Convert.hexToUint8(transactionHash);
        const keyPairEncoded = crypto_1.KeyPair.createKeyPairFromPrivateKeyString(account.privateKey);
        const signature = crypto_1.KeyPair.sign(keyPairEncoded, new Uint8Array(hashBytes));
        return new CosignatureSignedTransaction_1.CosignatureSignedTransaction(Convert_1.Convert.uint8ToHex(hashBytes), Convert_1.Convert.uint8ToHex(signature), account.publicKey);
    }
    /**
     * Serialize and sign transaction creating a new SignedTransaction
     * @param account
     * @param transactionHash Transaction hash (optional)
     * @returns {CosignatureSignedTransaction}
     */
    signWith(account, transactionHash) {
        if ((!this.transactionToCosign.transactionInfo || !this.transactionToCosign.transactionInfo.hash) && !transactionHash) {
            throw new Error('Transaction to cosign should be announced first');
        }
        const hash = !transactionHash ? this.transactionToCosign.transactionInfo.hash : transactionHash;
        const hashBytes = Convert_1.Convert.hexToUint8(hash ? hash : '');
        const keyPairEncoded = crypto_1.KeyPair.createKeyPairFromPrivateKeyString(account.privateKey);
        const signature = crypto_1.KeyPair.sign(keyPairEncoded, new Uint8Array(hashBytes));
        return new CosignatureSignedTransaction_1.CosignatureSignedTransaction(hash ? hash : '', Convert_1.Convert.uint8ToHex(signature), account.publicKey);
    }
}
exports.CosignatureTransaction = CosignatureTransaction;

},{"../../core/crypto":555,"../../core/format/Convert":558,"./CosignatureSignedTransaction":722,"./Transaction":745}],724:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const js_joda_1 = require("js-joda");
const UInt64_1 = require("../UInt64");
/**
 * The deadline of the transaction. The deadline is given as the number of seconds elapsed since the creation of the nemesis block.
 * If a transaction does not get included in a block before the deadline is reached, it is deleted.
 */
class Deadline {
    /**
     * @param deadline
     */
    constructor(deadline) {
        this.value = deadline;
    }
    /**
     * Create deadline model
     * @param deadline
     * @param chronoUnit
     * @returns {Deadline}
     */
    static create(deadline = 2, chronoUnit = js_joda_1.ChronoUnit.HOURS) {
        const networkTimeStamp = new Date().getTime();
        const timeStampDateTime = js_joda_1.LocalDateTime.ofInstant(js_joda_1.Instant.ofEpochMilli(networkTimeStamp), js_joda_1.ZoneId.SYSTEM);
        const deadlineDateTime = timeStampDateTime.plus(deadline, chronoUnit);
        if (deadline <= 0) {
            throw new Error('deadline should be greater than 0');
        }
        else if (timeStampDateTime.plus(24, js_joda_1.ChronoUnit.HOURS).compareTo(deadlineDateTime) !== 1) {
            throw new Error('deadline should be less than 24 hours');
        }
        return new Deadline(deadlineDateTime);
    }
    /**
     * @internal
     * @param value
     * @returns {Deadline}
     */
    static createFromDTO(value) {
        const uint64Value = 'string' === typeof value ? UInt64_1.UInt64.fromNumericString(value) : new UInt64_1.UInt64(value);
        const dateSeconds = uint64Value.compact();
        const deadline = js_joda_1.LocalDateTime.ofInstant(js_joda_1.Instant.ofEpochMilli(Math.round(dateSeconds + Deadline.timestampNemesisBlock * 1000)), js_joda_1.ZoneId.SYSTEM);
        return new Deadline(deadline);
    }
    /**
     * @internal
     */
    toDTO() {
        return UInt64_1.UInt64.fromUint(this.value.atZone(js_joda_1.ZoneId.SYSTEM).toInstant().toEpochMilli() - Deadline.timestampNemesisBlock * 1000).toDTO();
    }
    /**
     * @internal
     */
    toString() {
        return UInt64_1.UInt64.fromUint(this.value.atZone(js_joda_1.ZoneId.SYSTEM).toInstant().toEpochMilli() - Deadline.timestampNemesisBlock * 1000).toString();
    }
}
exports.Deadline = Deadline;
/**
 * @type {number}
 */
Deadline.timestampNemesisBlock = 1573430400;

},{"../UInt64":609,"js-joda":346}],725:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const LockFundsTransaction_1 = require("./LockFundsTransaction");
/*
 * An alias for LockFundsTransaction class
 */
class HashLockTransaction extends LockFundsTransaction_1.LockFundsTransaction {
}
exports.HashLockTransaction = HashLockTransaction;

},{"./LockFundsTransaction":727}],726:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var LinkAction;
(function (LinkAction) {
    LinkAction[LinkAction["Link"] = 1] = "Link";
    LinkAction[LinkAction["Unlink"] = 0] = "Unlink";
})(LinkAction = exports.LinkAction || (exports.LinkAction = {}));

},{}],727:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const DtoMapping_1 = require("../../core/utils/DtoMapping");
const PublicAccount_1 = require("../account/PublicAccount");
const Mosaic_1 = require("../mosaic/Mosaic");
const MosaicId_1 = require("../mosaic/MosaicId");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const SignedTransaction_1 = require("./SignedTransaction");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
/**
 * Lock funds transaction is used before sending an Aggregate bonded transaction, as a deposit to announce the transaction.
 * When aggregate bonded transaction is confirmed funds are returned to LockFundsTransaction signer.
 *
 * @since 1.0
 */
class LockFundsTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param mosaic
     * @param duration
     * @param signedTransaction
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The locked mosaic.
     */
    mosaic, 
    /**
     * The funds lock duration.
     */
    duration, signedTransaction, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.HASH_LOCK, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.mosaic = mosaic;
        this.duration = duration;
        this.hash = signedTransaction.hash;
        this.signedTransaction = signedTransaction;
        if (signedTransaction.type !== TransactionType_1.TransactionType.AGGREGATE_BONDED) {
            throw new Error('Signed transaction must be Aggregate Bonded Transaction');
        }
    }
    /**
     * Create a Lock funds transaction object
     * @param deadline - The deadline to include the transaction.
     * @param mosaic - The locked mosaic.
     * @param duration - The funds lock duration.
     * @param signedTransaction - The signed transaction for which funds are locked.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {LockFundsTransaction}
     */
    static create(deadline, mosaic, duration, signedTransaction, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new LockFundsTransaction(networkType, TransactionVersion_1.TransactionVersion.HASH_LOCK, deadline, maxFee, mosaic, duration, signedTransaction, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedHashLockTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.HashLockTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = LockFundsTransaction.create(isEmbedded ? Deadline_1.Deadline.create() : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), new Mosaic_1.Mosaic(new MosaicId_1.MosaicId(builder.getMosaic().mosaicId.unresolvedMosaicId), new UInt64_1.UInt64(builder.getMosaic().amount.amount)), new UInt64_1.UInt64(builder.getDuration().blockDuration), new SignedTransaction_1.SignedTransaction('', format_1.Convert.uint8ToHex(builder.getHash().hash256), '', TransactionType_1.TransactionType.AGGREGATE_BONDED, networkType), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.HashLockTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.HASH_LOCK.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.UnresolvedMosaicBuilder(new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.mosaic.id.id.toDTO()), new catbuffer_typescript_1.AmountDto(this.mosaic.amount.toDTO())), new catbuffer_typescript_1.BlockDurationDto(this.duration.toDTO()), new catbuffer_typescript_1.Hash256Dto(format_1.Convert.hexToUint8(this.hash)));
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedHashLockTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.HASH_LOCK.valueOf(), new catbuffer_typescript_1.UnresolvedMosaicBuilder(new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.mosaic.id.id.toDTO()), new catbuffer_typescript_1.AmountDto(this.mosaic.amount.toDTO())), new catbuffer_typescript_1.BlockDurationDto(this.duration.toDTO()), new catbuffer_typescript_1.Hash256Dto(format_1.Convert.hexToUint8(this.hash)));
    }
    /**
     * @internal
     * @param statement Block receipt statement
     * @param aggregateTransactionIndex Transaction index for aggregated transaction
     * @returns {LockFundsTransaction}
     */
    resolveAliases(statement, aggregateTransactionIndex = 0) {
        const transactionInfo = this.checkTransactionHeightAndIndex();
        return DtoMapping_1.DtoMapping.assign(this, {
            mosaic: statement.resolveMosaic(this.mosaic, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex),
        });
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @returns {boolean}
     */
    shouldNotifyAccount(address) {
        return super.isSigned(address);
    }
}
exports.LockFundsTransaction = LockFundsTransaction;

},{"../../core/format":565,"../../core/utils/DtoMapping":566,"../UInt64":609,"../account/PublicAccount":621,"../mosaic/Mosaic":640,"../mosaic/MosaicId":642,"./Deadline":724,"./SignedTransaction":743,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],728:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Hash type. Supported types are:
 * 0: Op_Sha3_256 (default).
 * 1: Op_Keccak_256 (ETH compatibility).
 * 2: Op_Hash_160 (first with SHA-256 and then with RIPEMD-160 (BTC compatibility))
 * 3: Op_Hash_256: input is hashed twice with SHA-256 (BTC compatibility)
 */
const format_1 = require("../../core/format");
var LockHashAlgorithm;
(function (LockHashAlgorithm) {
    LockHashAlgorithm[LockHashAlgorithm["Op_Sha3_256"] = 0] = "Op_Sha3_256";
    LockHashAlgorithm[LockHashAlgorithm["Op_Hash_160"] = 1] = "Op_Hash_160";
    LockHashAlgorithm[LockHashAlgorithm["Op_Hash_256"] = 2] = "Op_Hash_256";
})(LockHashAlgorithm = exports.LockHashAlgorithm || (exports.LockHashAlgorithm = {}));
/**
 * Validate the hash length
 * @param hashAlgorithm Secret lock hash algorithm
 * @param input Hashed value
 * @returns {boolean}
 */
function LockHashAlgorithmLengthValidator(hashAlgorithm, input) {
    if (format_1.Convert.isHexString(input)) {
        switch (hashAlgorithm) {
            case LockHashAlgorithm.Op_Sha3_256:
            case LockHashAlgorithm.Op_Hash_256:
                return input.length === 64;
            case LockHashAlgorithm.Op_Hash_160:
                return input.length === 40 || input.length === 64;
            default:
                break;
        }
    }
    return false;
}
exports.LockHashAlgorithmLengthValidator = LockHashAlgorithmLengthValidator;

},{"../../core/format":565}],729:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const DtoMapping_1 = require("../../core/utils/DtoMapping");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
const PublicAccount_1 = require("../account/PublicAccount");
const NamespaceId_1 = require("../namespace/NamespaceId");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
class MosaicAddressRestrictionTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param mosaicId
     * @param signature
     * @param restrictionKey
     * @param targetAddress
     * @param previousRestrictionValue
     * @param newRestrictionValue
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The mosaic id.
     */
    mosaicId, 
    /**
     * The restriction key.
     */
    restrictionKey, 
    /**
     * The affected unresolved address.
     */
    targetAddress, 
    /**
     * The previous restriction value.
     */
    previousRestrictionValue, 
    /**
     * The new restriction value.
     */
    newRestrictionValue, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.MOSAIC_ADDRESS_RESTRICTION, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.mosaicId = mosaicId;
        this.restrictionKey = restrictionKey;
        this.targetAddress = targetAddress;
        this.previousRestrictionValue = previousRestrictionValue;
        this.newRestrictionValue = newRestrictionValue;
    }
    /**
     * Create a mosaic address restriction transaction object
     *
     * Enabling accounts to transact with the token is similar to the process of
     * adding elevated permissions to a user in a company computer network.
     *
     * The mosaic creator can modify the permissions of an account by sending a
     * mosaic restriction transaction targeting the account address.
     *
     * **MosaicAddressRestrictionTransaction can only be announced in with Aggregate Transaction
     *
     * @param deadline - The deadline to include the transaction.
     * @param mosaicId - The unresolved mosaic identifier.
     * @param restrictionKey - The restriction key.
     * @param targetAddress - The affected unresolved address.
     * @param newRestrictionValue - The new restriction value.
     * @param networkType - The network type.
     * @param previousRestrictionValue - (Optional) The previous restriction value.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {MosaicAddressRestrictionTransaction}
     */
    static create(deadline, mosaicId, restrictionKey, targetAddress, newRestrictionValue, networkType, previousRestrictionValue = UInt64_1.UInt64.fromHex('FFFFFFFFFFFFFFFF'), maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new MosaicAddressRestrictionTransaction(networkType, TransactionVersion_1.TransactionVersion.MOSAIC_ADDRESS_RESTRICTION, deadline, maxFee, mosaicId, restrictionKey, targetAddress, previousRestrictionValue, newRestrictionValue, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedMosaicAddressRestrictionTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.MosaicAddressRestrictionTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = MosaicAddressRestrictionTransaction.create(isEmbedded
            ? Deadline_1.Deadline.create()
            : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(new UInt64_1.UInt64(builder.getMosaicId().unresolvedMosaicId).toHex()), new UInt64_1.UInt64(builder.getRestrictionKey()), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddress(format_1.Convert.uint8ToHex(builder.getTargetAddress().unresolvedAddress)), new UInt64_1.UInt64(builder.getNewRestrictionValue()), networkType, new UInt64_1.UInt64(builder.getPreviousRestrictionValue()), isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * Return the string notation for the set recipient
     * @internal
     * @returns {string}
     */
    targetAddressToString() {
        if (this.targetAddress instanceof NamespaceId_1.NamespaceId) {
            // namespaceId recipient, return hexadecimal notation
            return this.targetAddress.toHex();
        }
        // address recipient
        return this.targetAddress.plain();
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.MosaicAddressRestrictionTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MOSAIC_ADDRESS_RESTRICTION.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.mosaicId.id.toDTO()), this.restrictionKey.toDTO(), this.previousRestrictionValue.toDTO(), this.newRestrictionValue.toDTO(), new catbuffer_typescript_1.UnresolvedAddressDto(this.targetAddress.encodeUnresolvedAddress(this.networkType)));
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedMosaicAddressRestrictionTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MOSAIC_ADDRESS_RESTRICTION.valueOf(), new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.mosaicId.id.toDTO()), this.restrictionKey.toDTO(), this.previousRestrictionValue.toDTO(), this.newRestrictionValue.toDTO(), new catbuffer_typescript_1.UnresolvedAddressDto(this.targetAddress.encodeUnresolvedAddress(this.networkType)));
    }
    /**
     * @internal
     * @param statement Block receipt statement
     * @param aggregateTransactionIndex Transaction index for aggregated transaction
     * @returns {MosaicAddressRestrictionTransaction}
     */
    resolveAliases(statement, aggregateTransactionIndex = 0) {
        const transactionInfo = this.checkTransactionHeightAndIndex();
        return DtoMapping_1.DtoMapping.assign(this, {
            mosaicId: statement.resolveMosaicId(this.mosaicId, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex),
            targetAddress: statement.resolveAddress(this.targetAddress, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex),
        });
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @param alias address alias (names)
     * @returns {boolean}
     */
    shouldNotifyAccount(address, alias) {
        return (super.isSigned(address) ||
            this.targetAddress.equals(address) ||
            alias.find((name) => this.targetAddress.equals(name)) !== undefined);
    }
}
exports.MosaicAddressRestrictionTransaction = MosaicAddressRestrictionTransaction;

},{"../../core/format":565,"../../core/utils/DtoMapping":566,"../../core/utils/UnresolvedMapping":569,"../UInt64":609,"../account/PublicAccount":621,"../namespace/NamespaceId":656,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],730:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const PublicAccount_1 = require("../account/PublicAccount");
const MosaicId_1 = require("../mosaic/MosaicId");
const NamespaceId_1 = require("../namespace/NamespaceId");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
class MosaicAliasTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param aliasAction
     * @param namespaceId
     * @param mosaicId
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The alias action type.
     */
    aliasAction, 
    /**
     * The namespace id that will be an alias.
     */
    namespaceId, 
    /**
     * The mosaic id.
     */
    mosaicId, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.MOSAIC_ALIAS, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.aliasAction = aliasAction;
        this.namespaceId = namespaceId;
        this.mosaicId = mosaicId;
    }
    /**
     * Create a mosaic alias transaction object
     * @param deadline - The deadline to include the transaction.
     * @param aliasAction - The alias action type.
     * @param namespaceId - The namespace id.
     * @param mosaicId - The mosaic id.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {MosaicAliasTransaction}
     */
    static create(deadline, aliasAction, namespaceId, mosaicId, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new MosaicAliasTransaction(networkType, TransactionVersion_1.TransactionVersion.MOSAIC_ALIAS, deadline, maxFee, aliasAction, namespaceId, mosaicId, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedMosaicAliasTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.MosaicAliasTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = MosaicAliasTransaction.create(isEmbedded ? Deadline_1.Deadline.create() : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), builder.getAliasAction().valueOf(), new NamespaceId_1.NamespaceId(builder.getNamespaceId().namespaceId), new MosaicId_1.MosaicId(builder.getMosaicId().mosaicId), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.MosaicAliasTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MOSAIC_ALIAS.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.NamespaceIdDto(this.namespaceId.id.toDTO()), new catbuffer_typescript_1.MosaicIdDto(this.mosaicId.id.toDTO()), this.aliasAction.valueOf());
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedMosaicAliasTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MOSAIC_ALIAS.valueOf(), new catbuffer_typescript_1.NamespaceIdDto(this.namespaceId.id.toDTO()), new catbuffer_typescript_1.MosaicIdDto(this.mosaicId.id.toDTO()), this.aliasAction.valueOf());
    }
    /**
     * @internal
     * @returns {MosaicAliasTransaction}
     */
    resolveAliases() {
        return this;
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @returns {boolean}
     */
    shouldNotifyAccount(address) {
        return super.isSigned(address);
    }
}
exports.MosaicAliasTransaction = MosaicAliasTransaction;

},{"../../core/format":565,"../UInt64":609,"../account/PublicAccount":621,"../mosaic/MosaicId":642,"../namespace/NamespaceId":656,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],731:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const PublicAccount_1 = require("../account/PublicAccount");
const MosaicFlags_1 = require("../mosaic/MosaicFlags");
const MosaicId_1 = require("../mosaic/MosaicId");
const MosaicNonce_1 = require("../mosaic/MosaicNonce");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
/**
 * Before a mosaic can be created or transferred, a corresponding definition of the mosaic has to be created and published to the network.
 * This is done via a mosaic definition transaction.
 */
class MosaicDefinitionTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param nonce
     * @param mosaicId
     * @param flags
     * @param divisibility
     * @param duration
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The mosaic nonce.
     */
    nonce, 
    /**
     * The mosaic id.
     */
    mosaicId, 
    /**
     * The mosaic properties.
     */
    flags, 
    /**
     * Mosaic divisibility
     */
    divisibility, 
    /**
     * Mosaic duration, 0 value for eternal mosaic
     */
    duration = UInt64_1.UInt64.fromUint(0), signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.MOSAIC_DEFINITION, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.nonce = nonce;
        this.mosaicId = mosaicId;
        this.flags = flags;
        this.divisibility = divisibility;
        this.duration = duration;
    }
    /**
     * Create a mosaic creation transaction object
     * @param deadline - The deadline to include the transaction.
     * @param nonce - The mosaic nonce ex: MosaicNonce.createRandom().
     * @param mosaicId - The mosaic id ex: new MosaicId([481110499, 231112638]).
     * @param flags - The mosaic flags.
     * @param divisibility - The mosaic divicibility.
     * @param duration - The mosaic duration.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {MosaicDefinitionTransaction}
     */
    static create(deadline, nonce, mosaicId, flags, divisibility, duration, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new MosaicDefinitionTransaction(networkType, TransactionVersion_1.TransactionVersion.MOSAIC_DEFINITION, deadline, maxFee, nonce, mosaicId, flags, divisibility, duration, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedMosaicDefinitionTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.MosaicDefinitionTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = MosaicDefinitionTransaction.create(isEmbedded
            ? Deadline_1.Deadline.create()
            : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), MosaicNonce_1.MosaicNonce.createFromUint8Array(builder.getNonce().serialize()), new MosaicId_1.MosaicId(builder.getId().mosaicId), MosaicFlags_1.MosaicFlags.create((builder.getFlags() & 1) === 1, (builder.getFlags() & 2) === 2, (builder.getFlags() & 4) === 4), builder.getDivisibility(), new UInt64_1.UInt64(builder.getDuration().blockDuration), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @description Get mosaic nonce int value
     * @returns {number}
     * @memberof MosaicDefinitionTransaction
     */
    getMosaicNonceIntValue() {
        return this.nonce.toDTO();
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.MosaicDefinitionTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MOSAIC_DEFINITION.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.MosaicIdDto(this.mosaicId.id.toDTO()), new catbuffer_typescript_1.BlockDurationDto(this.duration.toDTO()), new catbuffer_typescript_1.MosaicNonceDto(this.getMosaicNonceIntValue()), this.flags.getValue(), this.divisibility);
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedMosaicDefinitionTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MOSAIC_DEFINITION.valueOf(), new catbuffer_typescript_1.MosaicIdDto(this.mosaicId.id.toDTO()), new catbuffer_typescript_1.BlockDurationDto(this.duration.toDTO()), new catbuffer_typescript_1.MosaicNonceDto(this.getMosaicNonceIntValue()), this.flags.getValue(), this.divisibility);
    }
    /**
     * @internal
     * @returns {MosaicDefinitionTransaction}
     */
    resolveAliases() {
        return this;
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @returns {boolean}
     */
    shouldNotifyAccount(address) {
        return super.isSigned(address);
    }
}
exports.MosaicDefinitionTransaction = MosaicDefinitionTransaction;

},{"../../core/format":565,"../UInt64":609,"../account/PublicAccount":621,"../mosaic/MosaicFlags":641,"../mosaic/MosaicId":642,"../mosaic/MosaicNonce":645,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],732:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const DtoMapping_1 = require("../../core/utils/DtoMapping");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
class MosaicGlobalRestrictionTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType - The network type
     * @param version - The transaction version
     * @param deadline - The deadline to include the transaction.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param mosaicId - The unresolved mosaic identifier.
     * @param referenceMosaicId - The mosaic id providing the restriction key.
     * @param restrictionKey - The restriction key.
     * @param previousRestrictionValue - The previous restriction value.
     * @param previousRestrictionType - The previous restriction type.
     * @param newRestrictionValue - The new restriction value.
     * @param previousRestrictionType - The previous restriction tpye.
     * @param signature - The transaction signature
     * @param signer - The signer
     * @param transactionInfo - The transaction info
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The mosaic id.
     */
    mosaicId, 
    /**
     * The refrence mosaic id.
     */
    referenceMosaicId, 
    /**
     * The restriction key.
     */
    restrictionKey, 
    /**
     * The previous restriction value.
     */
    previousRestrictionValue, 
    /**
     * The previous restriction type.
     */
    previousRestrictionType, 
    /**
     * The new restriction value.
     */
    newRestrictionValue, 
    /**
     * The new restriction type.
     */
    newRestrictionType, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.MOSAIC_GLOBAL_RESTRICTION, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.mosaicId = mosaicId;
        this.referenceMosaicId = referenceMosaicId;
        this.restrictionKey = restrictionKey;
        this.previousRestrictionValue = previousRestrictionValue;
        this.previousRestrictionType = previousRestrictionType;
        this.newRestrictionValue = newRestrictionValue;
        this.newRestrictionType = newRestrictionType;
    }
    /**
     * Create a mosaic address restriction transaction object
     *
     * The mosaic global restrictions are the network-wide rules that will determine
     * whether an account will be able to transact a given mosaic.
     *
     * Only accounts tagged with the key identifiers and values that meet the conditions
     * will be able to execute transactions involving the mosaic.
     *
     * Additionally, the mosaic creator can define restrictions that depend directly on
     * global restrictions set on another mosaic - known as **reference mosaic**.
     * The referenced mosaic and the restricted mosaic do not necessarily have to be created
     * by the same account, enabling the delegation of mosaic permissions to a third party.
     *
     * @param deadline - The deadline to include the transaction.
     * @param mosaicId - The mosaic id ex: new MosaicId([481110499, 231112638]).
     * @param restrictionKey - The restriction key.
     * @param previousRestrictionValue - The previous restriction value.
     * @param previousRestrictionType - The previous restriction type.
     * @param newRestrictionValue - The new restriction value.
     * @param newRestrictionType - The new restriction tpye.
     * @param networkType - The network type.
     * @param referenceMosaicId - (Optional) The unresolved mosaic identifier providing the restriction key.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {MosaicGlobalRestrictionTransaction}
     */
    static create(deadline, mosaicId, restrictionKey, previousRestrictionValue, previousRestrictionType, newRestrictionValue, newRestrictionType, networkType, referenceMosaicId = UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(UInt64_1.UInt64.fromUint(0).toHex()), maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new MosaicGlobalRestrictionTransaction(networkType, TransactionVersion_1.TransactionVersion.MOSAIC_GLOBAL_RESTRICTION, deadline, maxFee, mosaicId, referenceMosaicId, restrictionKey, previousRestrictionValue, previousRestrictionType, newRestrictionValue, newRestrictionType, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedMosaicGlobalRestrictionTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.MosaicGlobalRestrictionTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = MosaicGlobalRestrictionTransaction.create(isEmbedded
            ? Deadline_1.Deadline.create()
            : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(new UInt64_1.UInt64(builder.getMosaicId().unresolvedMosaicId).toHex()), new UInt64_1.UInt64(builder.getRestrictionKey()), new UInt64_1.UInt64(builder.getPreviousRestrictionValue()), builder.getPreviousRestrictionType().valueOf(), new UInt64_1.UInt64(builder.getNewRestrictionValue()), builder.getNewRestrictionType().valueOf(), networkType, UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(new UInt64_1.UInt64(builder.getReferenceMosaicId().unresolvedMosaicId).toHex()), isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.MosaicGlobalRestrictionTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MOSAIC_GLOBAL_RESTRICTION.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.mosaicId.id.toDTO()), new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.referenceMosaicId.id.toDTO()), this.restrictionKey.toDTO(), this.previousRestrictionValue.toDTO(), this.newRestrictionValue.toDTO(), this.previousRestrictionType.valueOf(), this.newRestrictionType.valueOf());
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedMosaicGlobalRestrictionTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MOSAIC_GLOBAL_RESTRICTION.valueOf(), new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.mosaicId.id.toDTO()), new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.referenceMosaicId.id.toDTO()), this.restrictionKey.toDTO(), this.previousRestrictionValue.toDTO(), this.newRestrictionValue.toDTO(), this.previousRestrictionType.valueOf(), this.newRestrictionType.valueOf());
    }
    /**
     * @internal
     * @param statement Block receipt statement
     * @param aggregateTransactionIndex Transaction index for aggregated transaction
     * @returns {MosaicGlobalRestrictionTransaction}
     */
    resolveAliases(statement, aggregateTransactionIndex = 0) {
        const transactionInfo = this.checkTransactionHeightAndIndex();
        return DtoMapping_1.DtoMapping.assign(this, {
            mosaicId: statement.resolveMosaicId(this.mosaicId, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex),
            referenceMosaicId: statement.resolveMosaicId(this.referenceMosaicId, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex),
        });
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @returns {boolean}
     */
    shouldNotifyAccount(address) {
        return super.isSigned(address);
    }
}
exports.MosaicGlobalRestrictionTransaction = MosaicGlobalRestrictionTransaction;

},{"../../core/format":565,"../../core/utils/DtoMapping":566,"../../core/utils/UnresolvedMapping":569,"../UInt64":609,"../account/PublicAccount":621,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],733:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const DtoMapping_1 = require("../../core/utils/DtoMapping");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
/**
 * Announce an mosaic metadata transaction to associate a key-value state to an account.
 */
class MosaicMetadataTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param targetAddress
     * @param scopedMetadataKey
     * @param targetMosaicId
     * @param valueSizeDelta
     * @param value
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * target account address.
     */
    targetAddress, 
    /**
     * Metadata key scoped to source, target and type.
     */
    scopedMetadataKey, 
    /**
     * Target mosaic identifier.
     */
    targetMosaicId, 
    /**
     * Change in value size in bytes.
     */
    valueSizeDelta, 
    /**
     * String value with UTF-8 encoding.
     * Difference between the previous value and new value.
     */
    value, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.MOSAIC_METADATA, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.targetAddress = targetAddress;
        this.scopedMetadataKey = scopedMetadataKey;
        this.targetMosaicId = targetMosaicId;
        this.valueSizeDelta = valueSizeDelta;
        this.value = value;
    }
    /**
     * Create a mosaic meta data transaction object
     * @param deadline - transaction deadline
     * @param targetAddress - target account address.
     * @param scopedMetadataKey - Metadata key scoped to source, target and type.
     * @param targetMosaicId - Target unresolved mosaic identifier.
     * @param valueSizeDelta - Change in value size in bytes.
     * @param value - String value with UTF-8 encoding
     *                Difference between the previous value and new value.
     *                You can calculate value as xor(previous-value, new-value).
     *                If there is no previous value, use directly the new value.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {MosaicMetadataTransaction}
     */
    static create(deadline, targetAddress, scopedMetadataKey, targetMosaicId, valueSizeDelta, value, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new MosaicMetadataTransaction(networkType, TransactionVersion_1.TransactionVersion.MOSAIC_METADATA, deadline, maxFee, targetAddress, scopedMetadataKey, targetMosaicId, valueSizeDelta, value, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedMosaicMetadataTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.MosaicMetadataTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = MosaicMetadataTransaction.create(isEmbedded ? Deadline_1.Deadline.create() : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddress(format_1.Convert.uint8ToHex(builder.getTargetAddress().unresolvedAddress)), new UInt64_1.UInt64(builder.getScopedMetadataKey()), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(new UInt64_1.UInt64(builder.getTargetMosaicId().unresolvedMosaicId).toHex()), builder.getValueSizeDelta(), format_1.Convert.uint8ToUtf8(builder.getValue()), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.MosaicMetadataTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MOSAIC_METADATA.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.UnresolvedAddressDto(this.targetAddress.encodeUnresolvedAddress(this.networkType)), this.scopedMetadataKey.toDTO(), new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.targetMosaicId.id.toDTO()), this.valueSizeDelta, format_1.Convert.utf8ToUint8(this.value));
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedMosaicMetadataTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MOSAIC_METADATA.valueOf(), new catbuffer_typescript_1.UnresolvedAddressDto(this.targetAddress.encodeUnresolvedAddress(this.networkType)), this.scopedMetadataKey.toDTO(), new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.targetMosaicId.id.toDTO()), this.valueSizeDelta, format_1.Convert.utf8ToUint8(this.value));
    }
    /**
     * @internal
     * @param statement Block receipt statement
     * @param aggregateTransactionIndex Transaction index for aggregated transaction
     * @returns {MosaicMetadataTransaction}
     */
    resolveAliases(statement, aggregateTransactionIndex = 0) {
        const transactionInfo = this.checkTransactionHeightAndIndex();
        return DtoMapping_1.DtoMapping.assign(this, {
            targetMosaicId: statement.resolveMosaicId(this.targetMosaicId, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex),
        });
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @param alias address alias (names)
     * @returns {boolean}
     */
    shouldNotifyAccount(address, alias) {
        return (super.isSigned(address) ||
            this.targetAddress.equals(address) ||
            alias.find((name) => this.targetAddress.equals(name)) !== undefined);
    }
}
exports.MosaicMetadataTransaction = MosaicMetadataTransaction;

},{"../../core/format":565,"../../core/utils/DtoMapping":566,"../../core/utils/UnresolvedMapping":569,"../UInt64":609,"../account/PublicAccount":621,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],734:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const DtoMapping_1 = require("../../core/utils/DtoMapping");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
/**
 * In case a mosaic has the flag 'supplyMutable' set to true, the creator of the mosaic can change the supply,
 * i.e. increase or decrease the supply.
 */
class MosaicSupplyChangeTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param mosaicId
     * @param action
     * @param delta
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The unresolved mosaic id.
     */
    mosaicId, 
    /**
     * The supply type.
     */
    action, 
    /**
     * The supply change in units for the mosaic.
     */
    delta, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.MOSAIC_SUPPLY_CHANGE, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.mosaicId = mosaicId;
        this.action = action;
        this.delta = delta;
    }
    /**
     * Create a mosaic supply change transaction object
     * @param deadline - The deadline to include the transaction.
     * @param mosaicId - The unresolved mosaic id.
     * @param action - The supply change action (increase | decrease).
     * @param delta - The supply change in units for the mosaic.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {MosaicSupplyChangeTransaction}
     */
    static create(deadline, mosaicId, action, delta, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new MosaicSupplyChangeTransaction(networkType, TransactionVersion_1.TransactionVersion.MOSAIC_SUPPLY_CHANGE, deadline, maxFee, mosaicId, action, delta, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedMosaicSupplyChangeTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.MosaicSupplyChangeTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = MosaicSupplyChangeTransaction.create(isEmbedded
            ? Deadline_1.Deadline.create()
            : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(new UInt64_1.UInt64(builder.getMosaicId().unresolvedMosaicId).toHex()), builder.getAction().valueOf(), new UInt64_1.UInt64(builder.getDelta().amount), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.MosaicSupplyChangeTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MOSAIC_SUPPLY_CHANGE.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.mosaicId.id.toDTO()), new catbuffer_typescript_1.AmountDto(this.delta.toDTO()), this.action.valueOf());
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedMosaicSupplyChangeTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MOSAIC_SUPPLY_CHANGE.valueOf(), new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.mosaicId.id.toDTO()), new catbuffer_typescript_1.AmountDto(this.delta.toDTO()), this.action.valueOf());
    }
    /**
     * @internal
     * @param statement Block receipt statement
     * @param aggregateTransactionIndex Transaction index for aggregated transaction
     * @returns {MosaicSupplyChangeTransaction}
     */
    resolveAliases(statement, aggregateTransactionIndex = 0) {
        const transactionInfo = this.checkTransactionHeightAndIndex();
        return DtoMapping_1.DtoMapping.assign(this, {
            mosaicId: statement.resolveMosaicId(this.mosaicId, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex),
        });
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @returns {boolean}
     */
    shouldNotifyAccount(address) {
        return super.isSigned(address);
    }
}
exports.MosaicSupplyChangeTransaction = MosaicSupplyChangeTransaction;

},{"../../core/format":565,"../../core/utils/DtoMapping":566,"../../core/utils/UnresolvedMapping":569,"../UInt64":609,"../account/PublicAccount":621,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],735:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
/**
 * Modify multisig account transactions are part of the NEM's multisig account system.
 * A modify multisig account transaction holds an array of multisig cosignatory modifications,
 * min number of signatures to approve a transaction and a min number of signatures to remove a cosignatory.
 * @since 1.0
 */
class MultisigAccountModificationTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param minApprovalDelta
     * @param minRemovalDelta
     * @param addressAdditions
     * @param addressDeletions
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The number of signatures needed to approve a transaction.
     * If we are modifying and existing multi-signature account this indicates the relative change of the minimum cosignatories.
     */
    minApprovalDelta, 
    /**
     * The number of signatures needed to remove a cosignatory.
     * If we are modifying and existing multi-signature account this indicates the relative change of the minimum cosignatories.
     */
    minRemovalDelta, 
    /**
     * The Cosignatory address additions.
     */
    addressAdditions, 
    /**
     * The Cosignatory address deletion.
     */
    addressDeletions, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.MULTISIG_ACCOUNT_MODIFICATION, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.minApprovalDelta = minApprovalDelta;
        this.minRemovalDelta = minRemovalDelta;
        this.addressAdditions = addressAdditions;
        this.addressDeletions = addressDeletions;
    }
    /**
     * Create a modify multisig account transaction object
     * @param deadline - The deadline to include the transaction.
     * @param minApprovalDelta - The min approval relative change.
     * @param minRemovalDelta - The min removal relative change.
     * @param addressAdditions - Cosignatory address additions.
     * @param addressDeletions - Cosignatory address deletions.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {MultisigAccountModificationTransaction}
     */
    static create(deadline, minApprovalDelta, minRemovalDelta, addressAdditions, addressDeletions, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new MultisigAccountModificationTransaction(networkType, TransactionVersion_1.TransactionVersion.MULTISIG_ACCOUNT_MODIFICATION, deadline, maxFee, minApprovalDelta, minRemovalDelta, addressAdditions, addressDeletions, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedMultisigAccountModificationTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.MultisigAccountModificationTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = MultisigAccountModificationTransaction.create(isEmbedded
            ? Deadline_1.Deadline.create()
            : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), builder.getMinApprovalDelta(), builder.getMinRemovalDelta(), builder.getAddressAdditions().map((addition) => {
            return UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddress(format_1.Convert.uint8ToHex(addition.unresolvedAddress));
        }), builder.getAddressDeletions().map((deletion) => {
            return UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddress(format_1.Convert.uint8ToHex(deletion.unresolvedAddress));
        }), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.MultisigAccountModificationTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MULTISIG_ACCOUNT_MODIFICATION.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), this.minRemovalDelta, this.minApprovalDelta, this.addressAdditions.map((addition) => {
            return new catbuffer_typescript_1.UnresolvedAddressDto(addition.encodeUnresolvedAddress(this.networkType));
        }), this.addressDeletions.map((deletion) => {
            return new catbuffer_typescript_1.UnresolvedAddressDto(deletion.encodeUnresolvedAddress(this.networkType));
        }));
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedMultisigAccountModificationTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.MULTISIG_ACCOUNT_MODIFICATION.valueOf(), this.minRemovalDelta, this.minApprovalDelta, this.addressAdditions.map((addition) => {
            return new catbuffer_typescript_1.UnresolvedAddressDto(addition.encodeUnresolvedAddress(this.networkType));
        }), this.addressDeletions.map((deletion) => {
            return new catbuffer_typescript_1.UnresolvedAddressDto(deletion.encodeUnresolvedAddress(this.networkType));
        }));
    }
    /**
     * @internal
     * @returns {MultisigAccountModificationTransaction}
     */
    resolveAliases() {
        return this;
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @param alias address alias (names)
     * @returns {boolean}
     */
    shouldNotifyAccount(address, alias) {
        return (super.isSigned(address) ||
            this.addressAdditions.find((_) => _.equals(address) || alias.find((a) => _.equals(a)) !== undefined) !== undefined ||
            this.addressDeletions.find((_) => _.equals(address) || alias.find((a) => _.equals(a)) !== undefined) !== undefined);
    }
}
exports.MultisigAccountModificationTransaction = MultisigAccountModificationTransaction;

},{"../../core/format":565,"../../core/utils/UnresolvedMapping":569,"../UInt64":609,"../account/PublicAccount":621,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],736:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Multisig cosignatory modifications are part of the NEM's multisig account system.
 * With a multisig cosignatory modification a cosignatory is added to or deleted from a multisig account.
 * Multisig cosignatory modifications are part of a modify multisig account transactions.
 *
 */
class MultisigCosignatoryModification {
    /**
     * Constructor
     * @param modificationAction
     * @param cosignatoryPublicAccount
     */
    constructor(
    /**
     * Multi-signature modification type.
     */
    modificationAction, 
    /**
     * Cosignatory public account.
     */
    cosignatoryPublicAccount) {
        this.modificationAction = modificationAction;
        this.cosignatoryPublicAccount = cosignatoryPublicAccount;
    }
    /**
     * @internal
     */
    toDTO() {
        return {
            cosignatoryPublicKey: this.cosignatoryPublicAccount.publicKey,
            modificationAction: this.modificationAction,
        };
    }
}
exports.MultisigCosignatoryModification = MultisigCosignatoryModification;

},{}],737:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const PublicAccount_1 = require("../account/PublicAccount");
const NamespaceId_1 = require("../namespace/NamespaceId");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
/**
 * Announce an namespace metadata transaction to associate a key-value state to an account.
 */
class NamespaceMetadataTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param targetAddress
     * @param scopedMetadataKey
     * @param targetNamespaceId
     * @param valueSizeDelta
     * @param value
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * target account address.
     */
    targetAddress, 
    /**
     * Metadata key scoped to source, target and type.
     */
    scopedMetadataKey, 
    /**
     * Target namespace identifier.
     */
    targetNamespaceId, 
    /**
     * Change in value size in bytes.
     */
    valueSizeDelta, 
    /**
     * String value with UTF-8 encoding.
     * Difference between the previous value and new value.
     */
    value, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.NAMESPACE_METADATA, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.targetAddress = targetAddress;
        this.scopedMetadataKey = scopedMetadataKey;
        this.targetNamespaceId = targetNamespaceId;
        this.valueSizeDelta = valueSizeDelta;
        this.value = value;
    }
    /**
     * Create a mosaic meta data transaction object
     * @param deadline - transaction deadline
     * @param targetAddress - target account address.
     * @param scopedMetadataKey - Metadata key scoped to source, target and type.
     * @param targetNamespaceId - Target namespace identifier.
     * @param valueSizeDelta - Change in value size in bytes.
     * @param value - String value with UTF-8 encoding
     *                Difference between the previous value and new value.
     *                You can calculate value as xor(previous-value, new-value).
     *                If there is no previous value, use directly the new value.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {NamespaceMetadataTransaction}
     */
    static create(deadline, targetAddress, scopedMetadataKey, targetNamespaceId, valueSizeDelta, value, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new NamespaceMetadataTransaction(networkType, TransactionVersion_1.TransactionVersion.NAMESPACE_METADATA, deadline, maxFee, targetAddress, scopedMetadataKey, targetNamespaceId, valueSizeDelta, value, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedNamespaceMetadataTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.NamespaceMetadataTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = NamespaceMetadataTransaction.create(isEmbedded
            ? Deadline_1.Deadline.create()
            : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddress(format_1.Convert.uint8ToHex(builder.getTargetAddress().unresolvedAddress)), new UInt64_1.UInt64(builder.getScopedMetadataKey()), new NamespaceId_1.NamespaceId(builder.getTargetNamespaceId().namespaceId), builder.getValueSizeDelta(), format_1.Convert.uint8ToUtf8(builder.getValue()), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.NamespaceMetadataTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.NAMESPACE_METADATA.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.UnresolvedAddressDto(this.targetAddress.encodeUnresolvedAddress(this.networkType)), this.scopedMetadataKey.toDTO(), new catbuffer_typescript_1.NamespaceIdDto(this.targetNamespaceId.id.toDTO()), this.valueSizeDelta, format_1.Convert.utf8ToUint8(this.value));
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedNamespaceMetadataTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.NAMESPACE_METADATA.valueOf(), new catbuffer_typescript_1.UnresolvedAddressDto(this.targetAddress.encodeUnresolvedAddress(this.networkType)), this.scopedMetadataKey.toDTO(), new catbuffer_typescript_1.NamespaceIdDto(this.targetNamespaceId.id.toDTO()), this.valueSizeDelta, format_1.Convert.utf8ToUint8(this.value));
    }
    /**
     * @internal
     * @returns {NamespaceMetadataTransaction}
     */
    resolveAliases() {
        return this;
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @param alias address alias (names)
     * @returns {boolean}
     */
    shouldNotifyAccount(address, alias) {
        return (super.isSigned(address) ||
            this.targetAddress.equals(address) ||
            alias.find((name) => this.targetAddress.equals(name)) !== undefined);
    }
}
exports.NamespaceMetadataTransaction = NamespaceMetadataTransaction;

},{"../../core/format":565,"../../core/utils/UnresolvedMapping":569,"../UInt64":609,"../account/PublicAccount":621,"../namespace/NamespaceId":656,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],738:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const NamespaceMosaicIdGenerator_1 = require("../../infrastructure/transaction/NamespaceMosaicIdGenerator");
const PublicAccount_1 = require("../account/PublicAccount");
const NamespaceId_1 = require("../namespace/NamespaceId");
const NamespaceRegistrationType_1 = require("../namespace/NamespaceRegistrationType");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
/**
 * Accounts can rent a namespace for an amount of blocks and after a this renew the contract.
 * This is done via a NamespaceRegistrationTransaction.
 */
class NamespaceRegistrationTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param registrationType
     * @param namespaceName
     * @param namespaceId
     * @param duration
     * @param parentId
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The namespace type could be namespace or sub namespace
     */
    registrationType, 
    /**
     * The namespace name
     */
    namespaceName, 
    /**
     * The id of the namespace derived from namespaceName.
     * When creating a sub namespace the namespaceId is derived from namespaceName and parentName.
     */
    namespaceId, 
    /**
     * The number of blocks a namespace is active
     */
    duration, 
    /**
     * The id of the parent sub namespace
     */
    parentId, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.NAMESPACE_REGISTRATION, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.registrationType = registrationType;
        this.namespaceName = namespaceName;
        this.namespaceId = namespaceId;
        this.duration = duration;
        this.parentId = parentId;
    }
    /**
     * Create a root namespace object
     * @param deadline - The deadline to include the transaction.
     * @param namespaceName - The namespace name.
     * @param duration - The duration of the namespace.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {NamespaceRegistrationTransaction}
     */
    static createRootNamespace(deadline, namespaceName, duration, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new NamespaceRegistrationTransaction(networkType, TransactionVersion_1.TransactionVersion.NAMESPACE_REGISTRATION, deadline, maxFee, NamespaceRegistrationType_1.NamespaceRegistrationType.RootNamespace, namespaceName, new NamespaceId_1.NamespaceId(namespaceName), duration, undefined, signature, signer);
    }
    /**
     * Create a sub namespace object
     * @param deadline - The deadline to include the transaction.
     * @param namespaceName - The namespace name.
     * @param parentNamespace - The parent namespace name.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - Transaction signature
     * @param signer - Signer public account
     * @returns {NamespaceRegistrationTransaction}
     */
    static createSubNamespace(deadline, namespaceName, parentNamespace, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        let parentId;
        if (typeof parentNamespace === 'string') {
            parentId = new NamespaceId_1.NamespaceId(NamespaceMosaicIdGenerator_1.NamespaceMosaicIdGenerator.subnamespaceParentId(parentNamespace, namespaceName));
        }
        else {
            parentId = parentNamespace;
        }
        return new NamespaceRegistrationTransaction(networkType, TransactionVersion_1.TransactionVersion.NAMESPACE_REGISTRATION, deadline, maxFee, NamespaceRegistrationType_1.NamespaceRegistrationType.SubNamespace, namespaceName, typeof parentNamespace === 'string'
            ? new NamespaceId_1.NamespaceId(NamespaceMosaicIdGenerator_1.NamespaceMosaicIdGenerator.subnamespaceNamespaceId(parentNamespace, namespaceName))
            : new NamespaceId_1.NamespaceId(NamespaceMosaicIdGenerator_1.NamespaceMosaicIdGenerator.namespaceId(namespaceName)), undefined, parentId, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedNamespaceRegistrationTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.NamespaceRegistrationTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const registrationType = builder.getRegistrationType().valueOf();
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = registrationType === NamespaceRegistrationType_1.NamespaceRegistrationType.RootNamespace
            ? NamespaceRegistrationTransaction.createRootNamespace(isEmbedded
                ? Deadline_1.Deadline.create()
                : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), format_1.Convert.decodeHex(format_1.Convert.uint8ToHex(builder.getName())), new UInt64_1.UInt64(builder.getDuration().blockDuration), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType))
            : NamespaceRegistrationTransaction.createSubNamespace(isEmbedded
                ? Deadline_1.Deadline.create()
                : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), format_1.Convert.decodeHex(format_1.Convert.uint8ToHex(builder.getName())), new NamespaceId_1.NamespaceId(builder.getParentId().namespaceId), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        let transactionBuilder;
        if (this.registrationType === NamespaceRegistrationType_1.NamespaceRegistrationType.RootNamespace) {
            transactionBuilder = new catbuffer_typescript_1.NamespaceRegistrationTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.NAMESPACE_REGISTRATION.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.NamespaceIdDto(this.namespaceId.id.toDTO()), format_1.Convert.hexToUint8(format_1.Convert.utf8ToHex(this.namespaceName)), new catbuffer_typescript_1.BlockDurationDto(this.duration.toDTO()), undefined);
        }
        else {
            transactionBuilder = new catbuffer_typescript_1.NamespaceRegistrationTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.NAMESPACE_REGISTRATION.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.NamespaceIdDto(this.namespaceId.id.toDTO()), format_1.Convert.hexToUint8(format_1.Convert.utf8ToHex(this.namespaceName)), undefined, new catbuffer_typescript_1.NamespaceIdDto(this.parentId.id.toDTO()));
        }
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        if (this.registrationType === NamespaceRegistrationType_1.NamespaceRegistrationType.RootNamespace) {
            return new catbuffer_typescript_1.EmbeddedNamespaceRegistrationTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.NAMESPACE_REGISTRATION.valueOf(), new catbuffer_typescript_1.NamespaceIdDto(this.namespaceId.id.toDTO()), format_1.Convert.hexToUint8(format_1.Convert.utf8ToHex(this.namespaceName)), new catbuffer_typescript_1.BlockDurationDto(this.duration.toDTO()), undefined);
        }
        return new catbuffer_typescript_1.EmbeddedNamespaceRegistrationTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.NAMESPACE_REGISTRATION.valueOf(), new catbuffer_typescript_1.NamespaceIdDto(this.namespaceId.id.toDTO()), format_1.Convert.hexToUint8(format_1.Convert.utf8ToHex(this.namespaceName)), undefined, new catbuffer_typescript_1.NamespaceIdDto(this.parentId.id.toDTO()));
    }
    /**
     * @internal
     * @returns {NamespaceRegistrationTransaction}
     */
    resolveAliases() {
        return this;
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @returns {boolean}
     */
    shouldNotifyAccount(address) {
        return super.isSigned(address);
    }
}
exports.NamespaceRegistrationTransaction = NamespaceRegistrationTransaction;

},{"../../core/format":565,"../../infrastructure/transaction/NamespaceMosaicIdGenerator":606,"../UInt64":609,"../account/PublicAccount":621,"../namespace/NamespaceId":656,"../namespace/NamespaceRegistrationType":659,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],739:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
const Address_1 = require("../account/Address");
class NodeKeyLinkTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param linkedPublicKey
     * @param linkAction
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The public key of the remote account.
     */
    linkedPublicKey, 
    /**
     * The account link action.
     */
    linkAction, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.NODE_KEY_LINK, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.linkedPublicKey = linkedPublicKey;
        this.linkAction = linkAction;
    }
    /**
     * Create a node key link transaction object
     * @param deadline - The deadline to include the transaction.
     * @param linkedPublicKey - The linked public key.
     * @param linkAction - The account link action.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {NodeKeyLinkTransaction}
     */
    static create(deadline, linkedPublicKey, linkAction, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new NodeKeyLinkTransaction(networkType, TransactionVersion_1.TransactionVersion.NODE_KEY_LINK, deadline, maxFee, linkedPublicKey, linkAction, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedNodeKeyLinkTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.NodeKeyLinkTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = NodeKeyLinkTransaction.create(isEmbedded ? Deadline_1.Deadline.create() : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), format_1.Convert.uint8ToHex(builder.getLinkedPublicKey().key), builder.getLinkAction().valueOf(), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.NodeKeyLinkTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.NODE_KEY_LINK.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.linkedPublicKey)), this.linkAction.valueOf());
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedNodeKeyLinkTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.NODE_KEY_LINK.valueOf(), new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.linkedPublicKey)), this.linkAction.valueOf());
    }
    /**
     * @internal
     * @returns {NodeKeyLinkTransaction}
     */
    resolveAliases() {
        return this;
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @returns {boolean}
     */
    shouldNotifyAccount(address) {
        return super.isSigned(address) || Address_1.Address.createFromPublicKey(this.linkedPublicKey, this.networkType).equals(address);
    }
}
exports.NodeKeyLinkTransaction = NodeKeyLinkTransaction;

},{"../../core/format":565,"../UInt64":609,"../account/Address":618,"../account/PublicAccount":621,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],740:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Address_1 = require("../account/Address");
const PersistentHarvestingDelegationMessage_1 = require("../message/PersistentHarvestingDelegationMessage");
const UInt64_1 = require("../UInt64");
const TransferTransaction_1 = require("./TransferTransaction");
class PersistentDelegationRequestTransaction extends TransferTransaction_1.TransferTransaction {
    /**
     * Create a PersistentDelegationRequestTransaction with special message payload
     * for presistent harvesting delegation unlocking
     * @param deadline - The deadline to include the transaction.
     * @param signingPrivateKey - Remote harvester signing private key linked to the main account
     * @param vrfPrivateKey - VRF private key linked to the main account
     * @param nodePublicKey - Node certificate public key
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {TransferTransaction}
     */
    static createPersistentDelegationRequestTransaction(deadline, signingPrivateKey, vrfPrivateKey, nodePublicKey, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        const message = PersistentHarvestingDelegationMessage_1.PersistentHarvestingDelegationMessage.create(signingPrivateKey, vrfPrivateKey, nodePublicKey, networkType);
        return super.create(deadline, Address_1.Address.createFromPublicKey(nodePublicKey, networkType), [], message, networkType, maxFee, signature, signer);
    }
}
exports.PersistentDelegationRequestTransaction = PersistentDelegationRequestTransaction;

},{"../UInt64":609,"../account/Address":618,"../message/PersistentHarvestingDelegationMessage":634,"./TransferTransaction":752}],741:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const DtoMapping_1 = require("../../core/utils/DtoMapping");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
const PublicAccount_1 = require("../account/PublicAccount");
const Mosaic_1 = require("../mosaic/Mosaic");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const LockHashAlgorithm_1 = require("./LockHashAlgorithm");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
class SecretLockTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param mosaic
     * @param duration
     * @param hashAlgorithm
     * @param secret
     * @param recipientAddress
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The locked mosaic.
     */
    mosaic, 
    /**
     * The duration for the funds to be released or returned.
     */
    duration, 
    /**
     * The hash algorithm, secret is generated with.
     */
    hashAlgorithm, 
    /**
     * The proof hashed.
     */
    secret, 
    /**
     * The unresolved recipientAddress of the funds.
     */
    recipientAddress, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.SECRET_LOCK, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.mosaic = mosaic;
        this.duration = duration;
        this.hashAlgorithm = hashAlgorithm;
        this.secret = secret;
        this.recipientAddress = recipientAddress;
        if (!LockHashAlgorithm_1.LockHashAlgorithmLengthValidator(hashAlgorithm, this.secret)) {
            throw new Error('HashAlgorithm and Secret have incompatible length or not hexadecimal string');
        }
    }
    /**
     * Create a secret lock transaction object.
     *
     * @param deadline - The deadline to include the transaction.
     * @param mosaic - The locked mosaic.
     * @param duration - The funds lock duration.
     * @param hashAlgorithm - The hash algorithm secret is generated with.
     * @param secret - The proof hashed.
     * @param recipientAddress - The unresolved recipient address of the funds.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @return a SecretLockTransaction instance
     */
    static create(deadline, mosaic, duration, hashAlgorithm, secret, recipientAddress, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new SecretLockTransaction(networkType, TransactionVersion_1.TransactionVersion.SECRET_LOCK, deadline, maxFee, mosaic, duration, hashAlgorithm, secret, recipientAddress, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedSecretLockTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.SecretLockTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = SecretLockTransaction.create(isEmbedded ? Deadline_1.Deadline.create() : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), new Mosaic_1.Mosaic(UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(new UInt64_1.UInt64(builder.getMosaic().mosaicId.unresolvedMosaicId).toHex()), new UInt64_1.UInt64(builder.getMosaic().amount.amount)), new UInt64_1.UInt64(builder.getDuration().blockDuration), builder.getHashAlgorithm().valueOf(), format_1.Convert.uint8ToHex(builder.getSecret().hash256), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddress(format_1.Convert.uint8ToHex(builder.getRecipientAddress().unresolvedAddress)), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @description Get secret bytes
     * @returns {Uint8Array}
     * @memberof SecretLockTransaction
     */
    getSecretByte() {
        return format_1.Convert.hexToUint8(64 > this.secret.length ? this.secret + '0'.repeat(64 - this.secret.length) : this.secret);
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.SecretLockTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.SECRET_LOCK.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.UnresolvedAddressDto(this.recipientAddress.encodeUnresolvedAddress(this.networkType)), new catbuffer_typescript_1.Hash256Dto(this.getSecretByte()), new catbuffer_typescript_1.UnresolvedMosaicBuilder(new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.mosaic.id.id.toDTO()), new catbuffer_typescript_1.AmountDto(this.mosaic.amount.toDTO())), new catbuffer_typescript_1.BlockDurationDto(this.duration.toDTO()), this.hashAlgorithm.valueOf());
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedSecretLockTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.SECRET_LOCK.valueOf(), new catbuffer_typescript_1.UnresolvedAddressDto(this.recipientAddress.encodeUnresolvedAddress(this.networkType)), new catbuffer_typescript_1.Hash256Dto(this.getSecretByte()), new catbuffer_typescript_1.UnresolvedMosaicBuilder(new catbuffer_typescript_1.UnresolvedMosaicIdDto(this.mosaic.id.id.toDTO()), new catbuffer_typescript_1.AmountDto(this.mosaic.amount.toDTO())), new catbuffer_typescript_1.BlockDurationDto(this.duration.toDTO()), this.hashAlgorithm.valueOf());
    }
    /**
     * @internal
     * @param statement Block receipt statement
     * @param aggregateTransactionIndex Transaction index for aggregated transaction
     * @returns {SecretLockTransaction}
     */
    resolveAliases(statement, aggregateTransactionIndex = 0) {
        const transactionInfo = this.checkTransactionHeightAndIndex();
        return DtoMapping_1.DtoMapping.assign(this, {
            recipientAddress: statement.resolveAddress(this.recipientAddress, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex),
            mosaic: statement.resolveMosaic(this.mosaic, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex),
        });
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @param alias address alias (names)
     * @returns {boolean}
     */
    shouldNotifyAccount(address, alias) {
        return (super.isSigned(address) ||
            this.recipientAddress.equals(address) ||
            alias.find((name) => this.recipientAddress.equals(name)) !== undefined);
    }
}
exports.SecretLockTransaction = SecretLockTransaction;

},{"../../core/format":565,"../../core/utils/DtoMapping":566,"../../core/utils/UnresolvedMapping":569,"../UInt64":609,"../account/PublicAccount":621,"../mosaic/Mosaic":640,"./Deadline":724,"./LockHashAlgorithm":728,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],742:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const DtoMapping_1 = require("../../core/utils/DtoMapping");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const LockHashAlgorithm_1 = require("./LockHashAlgorithm");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
class SecretProofTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param hashAlgorithm
     * @param secret
     * @param recipientAddress
     * @param proof
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, hashAlgorithm, secret, recipientAddress, proof, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.SECRET_PROOF, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.hashAlgorithm = hashAlgorithm;
        this.secret = secret;
        this.recipientAddress = recipientAddress;
        this.proof = proof;
        if (!LockHashAlgorithm_1.LockHashAlgorithmLengthValidator(hashAlgorithm, this.secret)) {
            throw new Error('HashType and Secret have incompatible length or not hexadecimal string');
        }
    }
    /**
     * Create a secret proof transaction object.
     *
     * @param deadline - The deadline to include the transaction.
     * @param hashAlgorithm - The hash algorithm secret is generated with.
     * @param secret - The seed proof hashed.
     * @param recipientAddress - UnresolvedAddress
     * @param proof - The seed proof.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @return a SecretProofTransaction instance
     */
    static create(deadline, hashAlgorithm, secret, recipientAddress, proof, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new SecretProofTransaction(networkType, TransactionVersion_1.TransactionVersion.SECRET_PROOF, deadline, maxFee, hashAlgorithm, secret, recipientAddress, proof, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedSecretProofTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.SecretProofTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = SecretProofTransaction.create(isEmbedded ? Deadline_1.Deadline.create() : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), builder.getHashAlgorithm().valueOf(), format_1.Convert.uint8ToHex(builder.getSecret().hash256), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddress(format_1.Convert.uint8ToHex(builder.getRecipientAddress().unresolvedAddress)), format_1.Convert.uint8ToHex(builder.getProof()), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @description Get secret bytes
     * @returns {Uint8Array}
     * @memberof SecretLockTransaction
     */
    getSecretByte() {
        return format_1.Convert.hexToUint8(64 > this.secret.length ? this.secret + '0'.repeat(64 - this.secret.length) : this.secret);
    }
    /**
     * @description Get proof bytes
     * @returns {Uint8Array}
     * @memberof SecretLockTransaction
     */
    getProofByte() {
        return format_1.Convert.hexToUint8(this.proof);
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.SecretProofTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.SECRET_PROOF.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.UnresolvedAddressDto(this.recipientAddress.encodeUnresolvedAddress(this.networkType)), new catbuffer_typescript_1.Hash256Dto(this.getSecretByte()), this.hashAlgorithm.valueOf(), this.getProofByte());
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedSecretProofTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.SECRET_PROOF.valueOf(), new catbuffer_typescript_1.UnresolvedAddressDto(this.recipientAddress.encodeUnresolvedAddress(this.networkType)), new catbuffer_typescript_1.Hash256Dto(this.getSecretByte()), this.hashAlgorithm.valueOf(), this.getProofByte());
    }
    /**
     * @internal
     * @param statement Block receipt statement
     * @param aggregateTransactionIndex Transaction index for aggregated transaction
     * @returns {SecretProofTransaction}
     */
    resolveAliases(statement, aggregateTransactionIndex = 0) {
        const transactionInfo = this.checkTransactionHeightAndIndex();
        return DtoMapping_1.DtoMapping.assign(this, {
            recipientAddress: statement.resolveAddress(this.recipientAddress, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex),
        });
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @param alias address alias (names)
     * @returns {boolean}
     */
    shouldNotifyAccount(address, alias) {
        return (super.isSigned(address) ||
            this.recipientAddress.equals(address) ||
            alias.find((name) => this.recipientAddress.equals(name)) !== undefined);
    }
}
exports.SecretProofTransaction = SecretProofTransaction;

},{"../../core/format":565,"../../core/utils/DtoMapping":566,"../../core/utils/UnresolvedMapping":569,"../UInt64":609,"../account/PublicAccount":621,"./Deadline":724,"./LockHashAlgorithm":728,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],743:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const PublicAccount_1 = require("../account/PublicAccount");
/**
 * SignedTransaction object is used to transfer the transaction data and the signature to the server
 * in order to initiate and broadcast a transaction.
 */
class SignedTransaction {
    /**
     * @param payload
     * @param hash
     * @param type
     * @param networkType
     */
    constructor(
    /**
     * Transaction serialized data
     */
    payload, 
    /**
     * Transaction hash
     */
    hash, 
    /**
     * Transaction signerPublicKey
     */
    signerPublicKey, 
    /**
     * Transaction type
     */
    type, 
    /**
     * Signer network type
     */
    networkType) {
        this.payload = payload;
        this.hash = hash;
        this.signerPublicKey = signerPublicKey;
        this.type = type;
        this.networkType = networkType;
        if (hash.length !== 64) {
            throw new Error('hash must be 64 characters long');
        }
    }
    /**
     * Create DTO object
     */
    toDTO() {
        return {
            payload: this.payload,
            hash: this.hash,
            signerPublicKey: this.signerPublicKey,
            type: this.type,
            networkType: this.networkType,
        };
    }
    /**
     * Return signer's address
     * @returns {Address}
     */
    getSignerAddress() {
        return PublicAccount_1.PublicAccount.createFromPublicKey(this.signerPublicKey, this.networkType).address;
    }
}
exports.SignedTransaction = SignedTransaction;

},{"../account/PublicAccount":621}],744:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class SyncAnnounce {
    /**
     * @internal
     * @param payload
     * @param hash
     * @param address
     */
    constructor(
    /**
     * Transaction serialized data
     */
    payload, 
    /**
     * Transaction hash
     */
    hash, 
    /**
     * Transaction address
     */
    address) {
        this.payload = payload;
        this.hash = hash;
        this.address = address;
    }
}
exports.SyncAnnounce = SyncAnnounce;

},{}],745:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const crypto_1 = require("../../core/crypto");
const format_1 = require("../../core/format");
const DtoMapping_1 = require("../../core/utils/DtoMapping");
const SerializeTransactionToJSON_1 = require("../../infrastructure/transaction/SerializeTransactionToJSON");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const SignedTransaction_1 = require("./SignedTransaction");
const TransactionType_1 = require("./TransactionType");
/**
 * An abstract transaction class that serves as the base class of all NEM transactions.
 */
class Transaction {
    /**
     * @constructor
     * @param type
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(
    /**
     * The transaction type.
     */
    type, 
    /**
     * The network type.
     */
    networkType, 
    /**
     * The transaction version number.
     */
    version, 
    /**
     * The deadline to include the transaction.
     */
    deadline, 
    /**
     * A sender of a transaction must specify during the transaction definition a max_fee,
     * meaning the maximum fee the account allows to spend for this transaction.
     */
    maxFee, 
    /**
     * The transaction signature (missing if part of an aggregate transaction).
     */
    signature, 
    /**
     * The account of the transaction creator.
     */
    signer, 
    /**
     * Transactions meta data object contains additional information about the transaction.
     */
    transactionInfo) {
        this.type = type;
        this.networkType = networkType;
        this.version = version;
        this.deadline = deadline;
        this.maxFee = maxFee;
        this.signature = signature;
        this.signer = signer;
        this.transactionInfo = transactionInfo;
        this.payloadSize = undefined;
    }
    /**
     * Generate transaction hash hex
     *
     * @see https://github.com/nemtech/catapult-server/blob/main/src/catapult/model/EntityHasher.cpp#L32
     * @see https://github.com/nemtech/catapult-server/blob/main/src/catapult/model/EntityHasher.cpp#L35
     * @see https://github.com/nemtech/catapult-server/blob/main/sdk/src/extensions/TransactionExtensions.cpp#L46
     * @param {string} transactionPayload HexString Payload
     * @param {Array<number>} generationHashBuffer Network generation hash byte
     * @returns {string} Returns Transaction Payload hash
     */
    static createTransactionHash(transactionPayload, generationHashBuffer) {
        // prepare
        const entityHash = new Uint8Array(32);
        const transactionBytes = format_1.Convert.hexToUint8(transactionPayload);
        // read transaction type
        const typeIdx = Transaction.Type_Index;
        const typeBytes = transactionBytes.slice(typeIdx, typeIdx + 2).reverse(); // REVERSED
        const entityType = parseInt(format_1.Convert.uint8ToHex(typeBytes), 16);
        const isAggregateTransaction = [TransactionType_1.TransactionType.AGGREGATE_BONDED, TransactionType_1.TransactionType.AGGREGATE_COMPLETE].find((type) => entityType === type) !==
            undefined;
        // 1) add full signature
        const signature = transactionBytes.slice(8, 8 + 64);
        // 2) add public key to match sign/verify behavior (32 bytes)
        const pubKeyIdx = signature.length;
        const publicKey = transactionBytes.slice(8 + 64, 8 + 64 + 32);
        // 3) add generationHash (32 bytes)
        const generationHashIdx = pubKeyIdx + publicKey.length;
        const generationHash = Uint8Array.from(generationHashBuffer);
        // 4) add transaction data without header (EntityDataBuffer)
        // @link https://github.com/nemtech/catapult-server/blob/main/src/catapult/model/EntityHasher.cpp#L30
        const transactionBodyIdx = generationHashIdx + generationHash.length;
        let transactionBody = transactionBytes.slice(Transaction.Header_Size);
        // in case of aggregate transactions, we hash only the merkle transaction hash.
        if (isAggregateTransaction) {
            transactionBody = transactionBytes.slice(Transaction.Header_Size, Transaction.Body_Index + 32);
        }
        // 5) concatenate binary hash parts
        // layout: `signature_R || signerPublicKey || generationHash || EntityDataBuffer`
        const entityHashBytes = new Uint8Array(signature.length + publicKey.length + generationHash.length + transactionBody.length);
        entityHashBytes.set(signature, 0);
        entityHashBytes.set(publicKey, pubKeyIdx);
        entityHashBytes.set(generationHash, generationHashIdx);
        entityHashBytes.set(transactionBody, transactionBodyIdx);
        // 6) create SHA3 hash of transaction data
        // Note: Transaction hashing *always* uses SHA3
        crypto_1.SHA3Hasher.func(entityHash, entityHashBytes, 32);
        return format_1.Convert.uint8ToHex(entityHash);
    }
    /**
     * Set transaction maxFee using fee multiplier for **ONLY NONE AGGREGATE TRANSACTIONS**
     * @param feeMultiplier The fee multiplier
     * @returns {TransferTransaction}
     */
    setMaxFee(feeMultiplier) {
        if (this.type === TransactionType_1.TransactionType.AGGREGATE_BONDED || this.type === TransactionType_1.TransactionType.AGGREGATE_COMPLETE) {
            throw new Error('setMaxFee can only be used for none aggregate transactions.');
        }
        return DtoMapping_1.DtoMapping.assign(this, {
            maxFee: UInt64_1.UInt64.fromUint(this.size * feeMultiplier),
        });
    }
    /**
     * @internal
     * Serialize and sign transaction creating a new SignedTransaction
     * @param account - The account to sign the transaction
     * @param generationHash - Network generation hash hex
     * @returns {SignedTransaction}
     */
    signWith(account, generationHash) {
        const generationHashBytes = Array.from(format_1.Convert.hexToUint8(generationHash));
        const byteBuffer = Array.from(this.generateBytes());
        const signingBytes = this.getSigningBytes(byteBuffer, generationHashBytes);
        const keyPairEncoded = crypto_1.KeyPair.createKeyPairFromPrivateKeyString(account.privateKey);
        const signature = Array.from(crypto_1.KeyPair.sign(keyPairEncoded, new Uint8Array(signingBytes)));
        const signedTransactionBuffer = byteBuffer
            .splice(0, 8)
            .concat(signature)
            .concat(Array.from(keyPairEncoded.publicKey))
            .concat(Array.from(new Uint8Array(4)))
            .concat(byteBuffer.splice(64 + 32 + 4, byteBuffer.length));
        const payload = format_1.Convert.uint8ToHex(signedTransactionBuffer);
        return new SignedTransaction_1.SignedTransaction(payload, Transaction.createTransactionHash(payload, generationHashBytes), account.publicKey, this.type, this.networkType);
    }
    /**
     * Generate signing bytes
     * @param payloadBytes Payload buffer
     * @param generationHashBytes GenerationHash buffer
     * @return {number[]}
     */
    getSigningBytes(payloadBytes, generationHashBytes) {
        const byteBufferWithoutHeader = payloadBytes.slice(4 + 64 + 32 + 8);
        if (this.type === TransactionType_1.TransactionType.AGGREGATE_BONDED || this.type === TransactionType_1.TransactionType.AGGREGATE_COMPLETE) {
            return generationHashBytes.concat(byteBufferWithoutHeader.slice(0, 52));
        }
        else {
            return generationHashBytes.concat(byteBufferWithoutHeader);
        }
    }
    /**
     * Converts the transaction into AggregateTransaction compatible
     * @returns {Array.<*>} AggregateTransaction bytes
     */
    aggregateTransaction() {
        const signerPublicKey = format_1.Convert.hexToUint8(this.signer.publicKey);
        let resultBytes = Array.from(this.generateBytes());
        resultBytes.splice(0, 4 + 64 + 32);
        resultBytes = Array.from(signerPublicKey).concat(resultBytes);
        resultBytes.splice(32 + 2 + 2, 16);
        return Array.from(new Uint8Array([
            (resultBytes.length + 4) & 0x000000ff,
            ((resultBytes.length + 4) & 0x0000ff00) >> 8,
            ((resultBytes.length + 4) & 0x00ff0000) >> 16,
            ((resultBytes.length + 4) & 0xff000000) >> 24,
        ])).concat(resultBytes);
    }
    /**
     * Convert an aggregate transaction to an inner transaction including transaction signer.
     * Signer is optional for `AggregateComplete` transaction `ONLY`.
     * If no signer provided, aggregate transaction signer will be delegated on signing
     * @param signer - Innre transaction signer.
     * @returns InnerTransaction
     */
    toAggregate(signer) {
        if (this.type === TransactionType_1.TransactionType.AGGREGATE_BONDED || this.type === TransactionType_1.TransactionType.AGGREGATE_COMPLETE) {
            throw new Error('Inner transaction cannot be an aggregated transaction.');
        }
        return DtoMapping_1.DtoMapping.assign(this, { signer });
    }
    /**
     * Takes a transaction and formats bytes to be included in an aggregate transaction.
     *
     * @return transaction with signer serialized to be part of an aggregate transaction
     */
    toAggregateTransactionBytes() {
        return catbuffer_typescript_1.EmbeddedTransactionHelper.serialize(this.toEmbeddedTransaction());
    }
    /**
     * Transaction pending to be included in a block
     * @returns {boolean}
     */
    isUnconfirmed() {
        return (this.transactionInfo != null &&
            this.transactionInfo.height.compact() === 0 &&
            this.transactionInfo.hash !== undefined &&
            this.transactionInfo.merkleComponentHash !== undefined &&
            this.transactionInfo.hash.toUpperCase() === this.transactionInfo.merkleComponentHash.toUpperCase());
    }
    /**
     * Transaction included in a block
     * @returns {boolean}
     */
    isConfirmed() {
        return this.transactionInfo != null && this.transactionInfo.height.compact() > 0;
    }
    /**
     * Returns if a transaction has missing signatures.
     * @returns {boolean}
     */
    hasMissingSignatures() {
        return (this.transactionInfo != null &&
            this.transactionInfo.height.compact() === 0 &&
            this.transactionInfo.hash !== undefined &&
            this.transactionInfo.merkleComponentHash !== undefined &&
            this.transactionInfo.hash.toUpperCase() !== this.transactionInfo.merkleComponentHash.toUpperCase());
    }
    /**
     * Transaction is not known by the network
     * @return {boolean}
     */
    isUnannounced() {
        return this.transactionInfo == null;
    }
    /**
     * @internal
     */
    versionToDTO() {
        return (this.networkType << 8) + this.version;
    }
    /**
     * @internal
     */
    versionToHex() {
        return '0x' + this.versionToDTO().toString(16);
    }
    /**
     * @description reapply a given value to the transaction in an immutable way
     * @param {Deadline} deadline
     * @returns {Transaction}
     * @memberof Transaction
     */
    reapplyGiven(deadline = Deadline_1.Deadline.create()) {
        if (this.isUnannounced()) {
            return DtoMapping_1.DtoMapping.assign(this, { deadline });
        }
        throw new Error("an Announced transaction can't be modified");
    }
    /**
     * @override Transaction.size()
     * @description get the byte size of a transaction using the builder
     * @returns {number}
     * @memberof TransferTransaction
     */
    get size() {
        var _a;
        return (_a = this.payloadSize) !== null && _a !== void 0 ? _a : this.createBuilder().getSize();
    }
    /**
     * @internal
     * Set payload size
     * @param size payload size
     * @returns {AggregateTransaction}
     */
    setPayloadSize(size) {
        this.payloadSize = size;
        return this;
    }
    /**
     * @internal
     * @returns {Uint8Array}
     */
    generateBytes() {
        return this.createBuilder().serialize();
    }
    /**
     * @description Serialize a transaction object
     * @returns {string}
     * @memberof Transaction
     */
    serialize() {
        return format_1.Convert.uint8ToHex(this.generateBytes());
    }
    /**
     * @description Create JSON object
     * @returns {Object}
     * @memberof Transaction
     */
    toJSON() {
        const commonTransactionObject = {
            type: this.type,
            network: this.networkType,
            version: this.versionToDTO(),
            maxFee: this.maxFee.toString(),
            deadline: this.deadline.toString(),
            signature: this.signature ? this.signature : '',
        };
        if (this.signer) {
            Object.assign(commonTransactionObject, {
                signerPublicKey: this.signer.publicKey,
            });
        }
        const childClassObject = SerializeTransactionToJSON_1.SerializeTransactionToJSON(this);
        return {
            transaction: Object.assign(commonTransactionObject, childClassObject),
        };
    }
    /**
     * @internal
     * Check if index and height exists in transactionInfo
     * @returns TransactionInfo
     */
    checkTransactionHeightAndIndex() {
        if (this.transactionInfo === undefined || this.transactionInfo.height === undefined || this.transactionInfo.index === undefined) {
            throw new Error('Transaction height or index undefined');
        }
        return this.transactionInfo;
    }
    /**
     * @internal
     * Checks if the transaction is signer by an address.
     * @param address the address.
     */
    isSigned(address) {
        return this.signer !== undefined && this.signer.address.equals(address);
    }
}
exports.Transaction = Transaction;
/**
 * Transaction header size
 *
 * Included fields are `size`, `verifiableEntityHeader_Reserved1`,
 * `signature`, `signerPublicKey` and `entityBody_Reserved1`.
 *
 * @var {number}
 */
Transaction.Header_Size = 8 + 64 + 32 + 4;
/**
 * Index of the transaction *type*
 *
 * Included fields are the transaction header, `version`
 * and `network`
 *
 * @var {number}
 */
Transaction.Type_Index = Transaction.Header_Size + 2;
/**
 * Index of the transaction *body*
 *
 * Included fields are the transaction header, `version`,
 * `network`, `type`, `maxFee` and `deadline`
 *
 * @var {number}
 */
Transaction.Body_Index = Transaction.Header_Size + 1 + 1 + 2 + 8 + 8;

},{"../../core/crypto":555,"../../core/format":565,"../../core/utils/DtoMapping":566,"../../infrastructure/transaction/SerializeTransactionToJSON":607,"../UInt64":609,"./Deadline":724,"./SignedTransaction":743,"./TransactionType":750,"catbuffer-typescript":922}],746:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Transaction response of an announce transaction
 */
class TransactionAnnounceResponse {
    /**
     * @internal
     * @param message
     */
    constructor(
    /**
     * The success or error message.
     */
    message) {
        this.message = message;
    }
}
exports.TransactionAnnounceResponse = TransactionAnnounceResponse;

},{}],747:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Transaction information model included in all transactions
 */
class TransactionInfo {
    /**
     * @param height
     * @param index
     * @param id
     * @param hash
     * @param merkleComponentHash
     */
    constructor(
    /**
     * The block height in which the transaction was included.
     */
    height, 
    /**
     * The index representing either transaction index/position within block or within an aggregate transaction.
     */
    index, 
    /**
     * The transaction db id.
     */
    id, 
    /**
     * The transaction hash.
     */
    hash, 
    /**
     * The transaction merkle hash.
     */
    merkleComponentHash) {
        this.height = height;
        this.index = index;
        this.id = id;
        this.hash = hash;
        this.merkleComponentHash = merkleComponentHash;
    }
}
exports.TransactionInfo = TransactionInfo;

},{}],748:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Transaction status contains basic of a transaction announced to the blockchain.
 */
class TransactionStatus {
    /**
     * @param group
     * @param code
     * @param hash
     * @param deadline
     * @param height
     */
    constructor(
    /**
     * The transaction status group "failed", "unconfirmed", "confirmed", etc...
     */
    group, 
    /**
     * The transaction hash.
     */
    hash, 
    /**
     * The transaction deadline.
     */
    deadline, 
    /**
     * The transaction status code being the error name in case of failure and success otherwise.
     */
    code, 
    /**
     * The height of the block at which it was confirmed or rejected.
     */
    height) {
        this.group = group;
        this.hash = hash;
        this.deadline = deadline;
        this.code = code;
        this.height = height;
    }
}
exports.TransactionStatus = TransactionStatus;

},{}],749:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Transaction status error model returned by listeners
 */
class TransactionStatusError {
    /**
     * @internal
     * @param address
     * @param hash
     * @param code
     * @param deadline
     */
    constructor(
    /**
     *  The address of the account that signed the invalid transaction.
     *  It's the address listened when calling Lister.status.
     */
    address, 
    /**
     * The transaction hash.
     */
    hash, 
    /**
     * The error code.
     */
    code, 
    /**
     * The transaction deadline.
     */
    deadline) {
        this.address = address;
        this.hash = hash;
        this.code = code;
        this.deadline = deadline;
    }
}
exports.TransactionStatusError = TransactionStatusError;

},{}],750:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enum containing transaction type constants.
 */
var TransactionType;
(function (TransactionType) {
    /** Reserved entity type. */
    TransactionType[TransactionType["RESERVED"] = 0] = "RESERVED";
    /**
     * Transfer Transaction transaction type.
     * @type {number}
     */
    TransactionType[TransactionType["TRANSFER"] = 16724] = "TRANSFER";
    /**
     * Register namespace transaction type.
     * @type {number}
     */
    TransactionType[TransactionType["NAMESPACE_REGISTRATION"] = 16718] = "NAMESPACE_REGISTRATION";
    /**
     * Address alias transaction type
     * @type {number}
     */
    TransactionType[TransactionType["ADDRESS_ALIAS"] = 16974] = "ADDRESS_ALIAS";
    /**
     * Mosaic alias transaction type
     * @type {number}
     */
    TransactionType[TransactionType["MOSAIC_ALIAS"] = 17230] = "MOSAIC_ALIAS";
    /**
     * Mosaic definition transaction type.
     * @type {number}
     */
    TransactionType[TransactionType["MOSAIC_DEFINITION"] = 16717] = "MOSAIC_DEFINITION";
    /**
     * Mosaic supply change transaction.
     * @type {number}
     */
    TransactionType[TransactionType["MOSAIC_SUPPLY_CHANGE"] = 16973] = "MOSAIC_SUPPLY_CHANGE";
    /**
     * Modify multisig account transaction type.
     * @type {number}
     */
    TransactionType[TransactionType["MULTISIG_ACCOUNT_MODIFICATION"] = 16725] = "MULTISIG_ACCOUNT_MODIFICATION";
    /**
     * Aggregate complete transaction type.
     * @type {number}
     */
    TransactionType[TransactionType["AGGREGATE_COMPLETE"] = 16705] = "AGGREGATE_COMPLETE";
    /**
     * Aggregate bonded transaction type
     */
    TransactionType[TransactionType["AGGREGATE_BONDED"] = 16961] = "AGGREGATE_BONDED";
    /**
     * Lock transaction type
     * @type {number}
     */
    TransactionType[TransactionType["HASH_LOCK"] = 16712] = "HASH_LOCK";
    /**
     * Secret Lock Transaction type
     * @type {number}
     */
    TransactionType[TransactionType["SECRET_LOCK"] = 16722] = "SECRET_LOCK";
    /**
     * Secret Proof transaction type
     * @type {number}
     */
    TransactionType[TransactionType["SECRET_PROOF"] = 16978] = "SECRET_PROOF";
    /**
     * Account restriction address transaction type
     * @type {number}
     */
    TransactionType[TransactionType["ACCOUNT_ADDRESS_RESTRICTION"] = 16720] = "ACCOUNT_ADDRESS_RESTRICTION";
    /**
     * Account restriction mosaic transaction type
     * @type {number}
     */
    TransactionType[TransactionType["ACCOUNT_MOSAIC_RESTRICTION"] = 16976] = "ACCOUNT_MOSAIC_RESTRICTION";
    /**
     * Account restriction operation transaction type
     * @type {number}
     */
    TransactionType[TransactionType["ACCOUNT_OPERATION_RESTRICTION"] = 17232] = "ACCOUNT_OPERATION_RESTRICTION";
    /**
     * Link account transaction type
     * @type {number}
     */
    TransactionType[TransactionType["ACCOUNT_KEY_LINK"] = 16716] = "ACCOUNT_KEY_LINK";
    /**
     * Mosaic address restriction type
     * @type {number}
     */
    TransactionType[TransactionType["MOSAIC_ADDRESS_RESTRICTION"] = 16977] = "MOSAIC_ADDRESS_RESTRICTION";
    /**
     * Mosaic global restriction type
     * @type {number}
     */
    TransactionType[TransactionType["MOSAIC_GLOBAL_RESTRICTION"] = 16721] = "MOSAIC_GLOBAL_RESTRICTION";
    /**
     * Account metadata transaction
     * @type {number}
     */
    TransactionType[TransactionType["ACCOUNT_METADATA"] = 16708] = "ACCOUNT_METADATA";
    /**
     * Mosaic metadata transaction
     * @type {number}
     */
    TransactionType[TransactionType["MOSAIC_METADATA"] = 16964] = "MOSAIC_METADATA";
    /**
     * Namespace metadata transaction
     * @type {number}
     */
    TransactionType[TransactionType["NAMESPACE_METADATA"] = 17220] = "NAMESPACE_METADATA";
    /**
     * Link vrf key transaction
     * @type {number}
     */
    TransactionType[TransactionType["VRF_KEY_LINK"] = 16963] = "VRF_KEY_LINK";
    /**
     * Link voting key transaction
     * @type {number}
     */
    TransactionType[TransactionType["VOTING_KEY_LINK"] = 16707] = "VOTING_KEY_LINK";
    /**
     * Link node key transaction
     * @type {number}
     */
    TransactionType[TransactionType["NODE_KEY_LINK"] = 16972] = "NODE_KEY_LINK";
})(TransactionType = exports.TransactionType || (exports.TransactionType = {}));

},{}],751:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Static class containing transaction version constants.
 *
 * Transaction format versions are defined in catapult-server in
 * each transaction's plugin source code.
 *
 * In [catapult-server](https://github.com/nemtech/catapult-server), the `DEFINE_TRANSACTION_CONSTANTS` macro
 * is used to define the `TYPE` and `VERSION` of the transaction format.
 *
 * @see https://github.com/nemtech/catapult-server/blob/main/plugins/txes/transfer/src/model/TransferTransaction.h#L37
 */
class TransactionVersion {
}
exports.TransactionVersion = TransactionVersion;
/**
 * Transfer Transaction transaction version.
 * @type {number}
 */
TransactionVersion.TRANSFER = 0x01;
/**
 * Register namespace transaction version.
 * @type {number}
 */
TransactionVersion.NAMESPACE_REGISTRATION = 0x01;
/**
 * Mosaic definition transaction version.
 * @type {number}
 */
TransactionVersion.MOSAIC_DEFINITION = 0x01;
/**
 * Mosaic supply change transaction.
 * @type {number}
 */
TransactionVersion.MOSAIC_SUPPLY_CHANGE = 0x01;
/**
 * Modify multisig account transaction version.
 * @type {number}
 */
TransactionVersion.MULTISIG_ACCOUNT_MODIFICATION = 0x01;
/**
 * Aggregate complete transaction version.
 * @type {number}
 */
TransactionVersion.AGGREGATE_COMPLETE = 0x01;
/**
 * Aggregate bonded transaction version
 */
TransactionVersion.AGGREGATE_BONDED = 0x01;
/**
 * Lock transaction version
 * @type {number}
 */
TransactionVersion.HASH_LOCK = 0x01;
/**
 * Secret Lock transaction version
 * @type {number}
 */
TransactionVersion.SECRET_LOCK = 0x01;
/**
 * Secret Proof transaction version
 * @type {number}
 */
TransactionVersion.SECRET_PROOF = 0x01;
/**
 * Address Alias transaction version
 * @type {number}
 */
TransactionVersion.ADDRESS_ALIAS = 0x01;
/**
 * Mosaic Alias transaction version
 * @type {number}
 */
TransactionVersion.MOSAIC_ALIAS = 0x01;
/**
 * Mosaic global restriction transaction version
 * @type {number}
 */
TransactionVersion.MOSAIC_GLOBAL_RESTRICTION = 0x01;
/**
 * Mosaic address restriction transaction version
 * @type {number}
 */
TransactionVersion.MOSAIC_ADDRESS_RESTRICTION = 0x01;
/**
 * Account Restriction address transaction version
 * @type {number}
 */
TransactionVersion.ACCOUNT_ADDRESS_RESTRICTION = 0x01;
/**
 * Account Restriction mosaic transaction version
 * @type {number}
 */
TransactionVersion.ACCOUNT_MOSAIC_RESTRICTION = 0x01;
/**
 * Account Restriction operation transaction version
 * @type {number}
 */
TransactionVersion.MODIFY_ACCOUNT_RESTRICTION_ENTITY_TYPE = 0x01;
/**
 * Link account transaction version
 * @type {number}
 */
TransactionVersion.ACCOUNT_KEY_LINK = 0x01;
/**
 * Account metadata transaction version
 * @type {number}
 */
TransactionVersion.ACCOUNT_METADATA = 0x01;
/**
 * Mosaic metadata transaction version
 * @type {number}
 */
TransactionVersion.MOSAIC_METADATA = 0x01;
/**
 * Namespace metadata transaction version
 * @type {number}
 */
TransactionVersion.NAMESPACE_METADATA = 0x01;
/**
 * Vrf key link transaction version.
 * @type {number}
 */
TransactionVersion.VRF_KEY_LINK = 0x01;
/**
 * Voting key link transaction version.
 * @type {number}
 */
TransactionVersion.VOTING_KEY_LINK = 0x01;
/**
 * Node key link transaction version.
 * @type {number}
 */
TransactionVersion.NODE_KEY_LINK = 0x01;

},{}],752:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const Long = require("long");
const format_1 = require("../../core/format");
const DtoMapping_1 = require("../../core/utils/DtoMapping");
const UnresolvedMapping_1 = require("../../core/utils/UnresolvedMapping");
const PublicAccount_1 = require("../account/PublicAccount");
const EncryptedMessage_1 = require("../message/EncryptedMessage");
const MessageType_1 = require("../message/MessageType");
const PlainMessage_1 = require("../message/PlainMessage");
const Mosaic_1 = require("../mosaic/Mosaic");
const NamespaceId_1 = require("../namespace/NamespaceId");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
/**
 * Transfer transactions contain data about transfers of mosaics and message to another account.
 */
class TransferTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param recipientAddress
     * @param mosaics
     * @param message
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The address of the recipient address.
     */
    recipientAddress, 
    /**
     * The array of Mosaic objects.
     */
    mosaics, 
    /**
     * The transaction message of 2048 characters.
     */
    message, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.TRANSFER, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.recipientAddress = recipientAddress;
        this.mosaics = mosaics;
        this.message = message;
        this.validate();
    }
    /**
     * Create a transfer transaction object.
     *
     * - This method can also be used to create PersistentDelegationRequestTransaction
     * with `PersistentHarvestingDelegationMessage` provided.
     * @param deadline - The deadline to include the transaction.
     * @param recipientAddress - The recipient address of the transaction.
     * @param mosaics - The array of mosaics.
     * @param message - The transaction message.
     * @param networkType - The network type.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {TransferTransaction}
     */
    static create(deadline, recipientAddress, mosaics, message, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new TransferTransaction(networkType, TransactionVersion_1.TransactionVersion.TRANSFER, deadline, maxFee, recipientAddress, mosaics, message, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedTransferTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.TransferTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const messageType = builder.getMessage()[0];
        const messageHex = format_1.Convert.uint8ToHex(builder.getMessage()).substring(2);
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = TransferTransaction.create(isEmbedded ? Deadline_1.Deadline.create() : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), UnresolvedMapping_1.UnresolvedMapping.toUnresolvedAddress(format_1.Convert.uint8ToHex(builder.getRecipientAddress().unresolvedAddress)), builder.getMosaics().map((mosaic) => {
            const id = new UInt64_1.UInt64(mosaic.mosaicId.unresolvedMosaicId).toHex();
            return new Mosaic_1.Mosaic(UnresolvedMapping_1.UnresolvedMapping.toUnresolvedMosaic(id), new UInt64_1.UInt64(mosaic.amount.amount));
        }), messageType === MessageType_1.MessageType.PlainMessage
            ? PlainMessage_1.PlainMessage.createFromPayload(messageHex)
            : EncryptedMessage_1.EncryptedMessage.createFromPayload(messageHex), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * Validate Transfer transaction creation with provided message
     * @internal
     */
    validate() {
        if (this.message.type === MessageType_1.MessageType.PersistentHarvestingDelegationMessage) {
            if (this.mosaics.length > 0) {
                throw new Error('PersistentDelegationRequestTransaction should be created without Mosaic');
            }
            else if (!/^[0-9a-fA-F]{264}$/.test(this.message.payload)) {
                throw new Error('PersistentDelegationRequestTransaction message is invalid');
            }
        }
    }
    /**
     * Return the string notation for the set recipient
     * @internal
     * @returns {string}
     */
    recipientToString() {
        if (this.recipientAddress instanceof NamespaceId_1.NamespaceId) {
            // namespaceId recipient, return hexadecimal notation
            return this.recipientAddress.toHex();
        }
        // address recipient
        return this.recipientAddress.plain();
    }
    /**
     * Return sorted mosaic arrays
     * @internal
     * @returns {Mosaic[]}
     */
    sortMosaics() {
        return this.mosaics.sort((a, b) => {
            const long_a = Long.fromBits(a.id.id.lower, a.id.id.higher, true);
            const long_b = Long.fromBits(b.id.id.lower, b.id.id.higher, true);
            return long_a.compare(long_b);
        });
    }
    /**
     * Return message buffer
     * @internal
     * @returns {Uint8Array}
     */
    getMessageBuffer() {
        const messgeHex = this.message.type === MessageType_1.MessageType.PersistentHarvestingDelegationMessage
            ? this.message.payload
            : format_1.Convert.utf8ToHex(this.message.payload);
        const payloadBuffer = format_1.Convert.hexToUint8(messgeHex);
        const typeBuffer = catbuffer_typescript_1.GeneratorUtils.uintToBuffer(this.message.type, 1);
        return this.message.type === MessageType_1.MessageType.PersistentHarvestingDelegationMessage
            ? payloadBuffer
            : catbuffer_typescript_1.GeneratorUtils.concatTypedArrays(typeBuffer, payloadBuffer);
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        return new catbuffer_typescript_1.TransferTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.TRANSFER.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.UnresolvedAddressDto(this.recipientAddress.encodeUnresolvedAddress(this.networkType)), this.sortMosaics().map((mosaic) => {
            return new catbuffer_typescript_1.UnresolvedMosaicBuilder(new catbuffer_typescript_1.UnresolvedMosaicIdDto(mosaic.id.id.toDTO()), new catbuffer_typescript_1.AmountDto(mosaic.amount.toDTO()));
        }), this.getMessageBuffer());
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedTransferTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.TRANSFER.valueOf(), new catbuffer_typescript_1.UnresolvedAddressDto(this.recipientAddress.encodeUnresolvedAddress(this.networkType)), this.sortMosaics().map((mosaic) => {
            return new catbuffer_typescript_1.UnresolvedMosaicBuilder(new catbuffer_typescript_1.UnresolvedMosaicIdDto(mosaic.id.id.toDTO()), new catbuffer_typescript_1.AmountDto(mosaic.amount.toDTO()));
        }), this.getMessageBuffer());
    }
    /**
     * @internal
     * @param statement Block receipt statement
     * @param aggregateTransactionIndex Transaction index for aggregated transaction
     * @returns {TransferTransaction}
     */
    resolveAliases(statement, aggregateTransactionIndex = 0) {
        const transactionInfo = this.checkTransactionHeightAndIndex();
        return DtoMapping_1.DtoMapping.assign(this, {
            recipientAddress: statement.resolveAddress(this.recipientAddress, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex),
            mosaics: this.mosaics.map((mosaic) => statement.resolveMosaic(mosaic, transactionInfo.height.toString(), transactionInfo.index, aggregateTransactionIndex)),
        });
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @param alias address alias (names)
     * @returns {boolean}
     */
    shouldNotifyAccount(address, alias) {
        return (super.isSigned(address) ||
            this.recipientAddress.equals(address) ||
            alias.find((name) => this.recipientAddress.equals(name)) !== undefined);
    }
}
exports.TransferTransaction = TransferTransaction;

},{"../../core/format":565,"../../core/utils/DtoMapping":566,"../../core/utils/UnresolvedMapping":569,"../UInt64":609,"../account/PublicAccount":621,"../message/EncryptedMessage":630,"../message/MessageType":633,"../message/PlainMessage":635,"../mosaic/Mosaic":640,"../namespace/NamespaceId":656,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922,"long":349}],753:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
const Address_1 = require("../account/Address");
const FinalizationPointDto_1 = require("catbuffer-typescript/dist/FinalizationPointDto");
class VotingKeyLinkTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param linkedPublicKey
     * @param startPoint
     * @param endPoint
     * @param linkAction
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The public key of the remote account.
     */
    linkedPublicKey, 
    /**
     * The start finalization point.
     */
    startPoint, 
    /**
     * The start finalization point.
     */
    endPoint, 
    /**
     * The account link action.
     */
    linkAction, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.VOTING_KEY_LINK, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.linkedPublicKey = linkedPublicKey;
        this.startPoint = startPoint;
        this.endPoint = endPoint;
        this.linkAction = linkAction;
    }
    /**
     * Create a voting key link transaction object
     * @param deadline - The deadline to include the transaction.
     * @param linkedPublicKey - The public key for voting (48 bytes).
     * @param startPoint - The start finalization point.
     * @param endPoint - The end finalization point.
     * @param linkAction - The account link action.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {VotingKeyLinkTransaction}
     */
    static create(deadline, linkedPublicKey, startPoint, endPoint, linkAction, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new VotingKeyLinkTransaction(networkType, TransactionVersion_1.TransactionVersion.VOTING_KEY_LINK, deadline, maxFee, linkedPublicKey, startPoint, endPoint, linkAction, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedVotingKeyLinkTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.VotingKeyLinkTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = VotingKeyLinkTransaction.create(isEmbedded ? Deadline_1.Deadline.create() : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), format_1.Convert.uint8ToHex(builder.getLinkedPublicKey().votingKey), new UInt64_1.UInt64(builder.getStartPoint().finalizationPoint), new UInt64_1.UInt64(builder.getEndPoint().finalizationPoint), builder.getLinkAction().valueOf(), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.VotingKeyLinkTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.VOTING_KEY_LINK.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.VotingKeyDto(format_1.Convert.hexToUint8(this.linkedPublicKey)), new FinalizationPointDto_1.FinalizationPointDto(this.startPoint.toDTO()), new FinalizationPointDto_1.FinalizationPointDto(this.endPoint.toDTO()), this.linkAction.valueOf());
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedVotingKeyLinkTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.VOTING_KEY_LINK.valueOf(), new catbuffer_typescript_1.VotingKeyDto(format_1.Convert.hexToUint8(this.linkedPublicKey)), new FinalizationPointDto_1.FinalizationPointDto(this.startPoint.toDTO()), new FinalizationPointDto_1.FinalizationPointDto(this.endPoint.toDTO()), this.linkAction.valueOf());
    }
    /**
     * @internal
     * @returns {VotingKeyLinkTransaction}
     */
    resolveAliases() {
        return this;
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @returns {boolean}
     */
    shouldNotifyAccount(address) {
        return super.isSigned(address) || Address_1.Address.createFromPublicKey(this.linkedPublicKey, this.networkType).equals(address);
    }
}
exports.VotingKeyLinkTransaction = VotingKeyLinkTransaction;

},{"../../core/format":565,"../UInt64":609,"../account/Address":618,"../account/PublicAccount":621,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922,"catbuffer-typescript/dist/FinalizationPointDto":832}],754:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const catbuffer_typescript_1 = require("catbuffer-typescript");
const format_1 = require("../../core/format");
const PublicAccount_1 = require("../account/PublicAccount");
const UInt64_1 = require("../UInt64");
const Deadline_1 = require("./Deadline");
const Transaction_1 = require("./Transaction");
const TransactionType_1 = require("./TransactionType");
const TransactionVersion_1 = require("./TransactionVersion");
const Address_1 = require("../account/Address");
class VrfKeyLinkTransaction extends Transaction_1.Transaction {
    /**
     * @param networkType
     * @param version
     * @param deadline
     * @param maxFee
     * @param linkedPublicKey
     * @param linkAction
     * @param signature
     * @param signer
     * @param transactionInfo
     */
    constructor(networkType, version, deadline, maxFee, 
    /**
     * The public key of the remote account.
     */
    linkedPublicKey, 
    /**
     * The account link action.
     */
    linkAction, signature, signer, transactionInfo) {
        super(TransactionType_1.TransactionType.VRF_KEY_LINK, networkType, version, deadline, maxFee, signature, signer, transactionInfo);
        this.linkedPublicKey = linkedPublicKey;
        this.linkAction = linkAction;
    }
    /**
     * Create a vrf key link transaction object
     * @param deadline - The deadline to include the transaction.
     * @param linkedPublicKey - The public key of the remote account.
     * @param linkAction - The account link action.
     * @param maxFee - (Optional) Max fee defined by the sender
     * @param signature - (Optional) Transaction signature
     * @param signer - (Optional) Signer public account
     * @returns {VrfKeyLinkTransaction}
     */
    static create(deadline, linkedPublicKey, linkAction, networkType, maxFee = new UInt64_1.UInt64([0, 0]), signature, signer) {
        return new VrfKeyLinkTransaction(networkType, TransactionVersion_1.TransactionVersion.VRF_KEY_LINK, deadline, maxFee, linkedPublicKey, linkAction, signature, signer);
    }
    /**
     * Create a transaction object from payload
     * @param {string} payload Binary payload
     * @param {Boolean} isEmbedded Is embedded transaction (Default: false)
     * @returns {Transaction | InnerTransaction}
     */
    static createFromPayload(payload, isEmbedded = false) {
        const builder = isEmbedded
            ? catbuffer_typescript_1.EmbeddedVrfKeyLinkTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload))
            : catbuffer_typescript_1.VrfKeyLinkTransactionBuilder.loadFromBinary(format_1.Convert.hexToUint8(payload));
        const signerPublicKey = format_1.Convert.uint8ToHex(builder.getSignerPublicKey().key);
        const networkType = builder.getNetwork().valueOf();
        const signature = payload.substring(16, 144);
        const transaction = VrfKeyLinkTransaction.create(isEmbedded ? Deadline_1.Deadline.create() : Deadline_1.Deadline.createFromDTO(builder.getDeadline().timestamp), format_1.Convert.uint8ToHex(builder.getLinkedPublicKey().key), builder.getLinkAction().valueOf(), networkType, isEmbedded ? new UInt64_1.UInt64([0, 0]) : new UInt64_1.UInt64(builder.fee.amount), isEmbedded || signature.match(`^[0]+$`) ? undefined : signature, signerPublicKey.match(`^[0]+$`) ? undefined : PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType));
        return isEmbedded ? transaction.toAggregate(PublicAccount_1.PublicAccount.createFromPublicKey(signerPublicKey, networkType)) : transaction;
    }
    /**
     * @internal
     * @returns {TransactionBuilder}
     */
    createBuilder() {
        const signerBuffer = this.signer !== undefined ? format_1.Convert.hexToUint8(this.signer.publicKey) : new Uint8Array(32);
        const signatureBuffer = this.signature !== undefined ? format_1.Convert.hexToUint8(this.signature) : new Uint8Array(64);
        const transactionBuilder = new catbuffer_typescript_1.VrfKeyLinkTransactionBuilder(new catbuffer_typescript_1.SignatureDto(signatureBuffer), new catbuffer_typescript_1.KeyDto(signerBuffer), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.VRF_KEY_LINK.valueOf(), new catbuffer_typescript_1.AmountDto(this.maxFee.toDTO()), new catbuffer_typescript_1.TimestampDto(this.deadline.toDTO()), new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.linkedPublicKey)), this.linkAction.valueOf());
        return transactionBuilder;
    }
    /**
     * @internal
     * @returns {EmbeddedTransactionBuilder}
     */
    toEmbeddedTransaction() {
        return new catbuffer_typescript_1.EmbeddedVrfKeyLinkTransactionBuilder(new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.signer.publicKey)), this.versionToDTO(), this.networkType.valueOf(), TransactionType_1.TransactionType.VRF_KEY_LINK.valueOf(), new catbuffer_typescript_1.KeyDto(format_1.Convert.hexToUint8(this.linkedPublicKey)), this.linkAction.valueOf());
    }
    /**
     * @internal
     * @returns {VrfKeyLinkTransaction}
     */
    resolveAliases() {
        return this;
    }
    /**
     * @internal
     * Check a given address should be notified in websocket channels
     * @param address address to be notified
     * @returns {boolean}
     */
    shouldNotifyAccount(address) {
        return super.isSigned(address) || Address_1.Address.createFromPublicKey(this.linkedPublicKey, this.networkType).equals(address);
    }
}
exports.VrfKeyLinkTransaction = VrfKeyLinkTransaction;

},{"../../core/format":565,"../UInt64":609,"../account/Address":618,"../account/PublicAccount":621,"./Deadline":724,"./Transaction":745,"./TransactionType":750,"./TransactionVersion":751,"catbuffer-typescript":922}],755:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Password model
 */
class Password {
    /**
     * Create a password with at least 8 characters
     * @param password
     */
    constructor(password) {
        if (password.length < 8) {
            throw new Error('Password must be at least 8 characters');
        }
        this.value = password;
    }
}
exports.Password = Password;

},{}],756:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("../../core/crypto");
const format_1 = require("../../core/format");
const Account_1 = require("../account/Account");
const Address_1 = require("../account/Address");
const Wallet_1 = require("./Wallet");
class SimpleWallet extends Wallet_1.Wallet {
    /**
     *Creates an instance of SimpleWallet.
     * @param {string} name
     * @param {Address} address
     * @param {string} encryptedPrivateKey
     */
    constructor(name, address, encryptedPrivateKey) {
        super(name, address, 'simple_v2');
        this.encryptedPrivateKey = encryptedPrivateKey;
    }
    /**
     * Create a Simple wallet
     * @param name - Wallet name
     * @param password - Password to encrypt wallet
     * @param network - Network id
     * @returns {SimpleWallet}
     */
    static create(name, password, network) {
        // Create random bytes
        const randomBytesArray = crypto_1.Crypto.randomBytes(32);
        // Hash random bytes with entropy seed
        // Finalize and keep only 32 bytes
        const hashKey = format_1.Convert.uint8ToHex(randomBytesArray); // TODO: derive private key correctly
        // Create KeyPair from hash key
        const { publicKey, privateKey } = crypto_1.KeyPair.createKeyPairFromPrivateKeyString(hashKey);
        // Create address from public key
        const address = Address_1.Address.createFromPublicKey(format_1.Convert.uint8ToHex(publicKey), network);
        // Encrypt private key using password
        const encryptedPrivateKey = crypto_1.Crypto.encrypt(format_1.Convert.uint8ToHex(privateKey), password.value);
        return new SimpleWallet(name, address, encryptedPrivateKey);
    }
    /**
     * Create a SimpleWallet from private key
     * @param name - Wallet name
     * @param password - Password to encrypt wallet
     * @param privateKey - Wallet private key
     * @param network - Network id
     * @returns {SimpleWallet}
     */
    static createFromPrivateKey(name, password, privateKey, network) {
        // Create KeyPair from hash key
        const keyPair = crypto_1.KeyPair.createKeyPairFromPrivateKeyString(privateKey);
        // Create address from public key
        const address = Address_1.Address.createFromPublicKey(format_1.Convert.uint8ToHex(keyPair.publicKey), network);
        // Encrypt private key using password
        const encryptedPrivateKey = crypto_1.Crypto.encrypt(privateKey, password.value);
        return new SimpleWallet(name, address, encryptedPrivateKey);
    }
    /**
     * Instantiate a SimpleWallet from a DTO
     * @param simpleWalletDTO simple wallet without prototype
     * @returns {SimpleWallet}
     */
    static createFromDTO(simpleWalletDTO) {
        return new SimpleWallet(simpleWalletDTO.name, Address_1.Address.createFromRawAddress(simpleWalletDTO.address.address), simpleWalletDTO.encryptedPrivateKey);
    }
    /**
     * Creates a SimpleWallet DTO
     * @returns {ISimpleWalletDTO}
     */
    toDTO() {
        return JSON.parse(JSON.stringify(this));
    }
    /**
     * Open a wallet and generate an Account
     * @param password - Password to decrypt private key
     * @returns {Account}
     */
    open(password) {
        const privateKey = crypto_1.Crypto.decrypt(this.encryptedPrivateKey, password.value);
        return Account_1.Account.createFromPrivateKey(privateKey, this.networkType);
    }
}
exports.SimpleWallet = SimpleWallet;

},{"../../core/crypto":555,"../../core/format":565,"../account/Account":610,"../account/Address":618,"./Wallet":757}],757:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Wallet base model
 */
class Wallet {
    /**
     * @internal
     * @param name
     * @param network
     * @param address
     * @param creationDate
     * @param schema
     */
    constructor(
    /**
     * The wallet's name
     */
    name, 
    /**
     * The wallet's address
     */
    address, 
    /**
     * Wallet schema number
     */
    schema) {
        this.name = name;
        this.address = address;
        this.schema = schema;
    }
    /**
     * The wallet's network type
     * @type {NetworkType}
     */
    get networkType() {
        return this.address.networkType;
    }
}
exports.Wallet = Wallet;

},{}],758:[function(require,module,exports){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const operators_2 = require("rxjs/operators");
const DtoMapping_1 = require("../core/utils/DtoMapping");
const MosaicId_1 = require("../model/mosaic/MosaicId");
const NamespaceId_1 = require("../model/namespace/NamespaceId");
const NamespacePaginationStreamer_1 = require("../infrastructure/paginationStreamer/NamespacePaginationStreamer");
/**
 * Account Service
 */
class AccountService {
    /**
     * Constructor
     * @param repositoryFactory
     */
    constructor(repositoryFactory) {
        this.repositoryFactory = repositoryFactory;
        this.accountRepository = repositoryFactory.createAccountRepository();
        this.namespaceRepository = repositoryFactory.createNamespaceRepository();
    }
    /**
     * Get account info with resolved mosaic
     * @param addresses Array of addresses
     */
    accountInfoWithResolvedMosaic(addresses) {
        const accountInfoObservable = this.accountRepository.getAccountsInfo(addresses);
        const distinctNames = accountInfoObservable.pipe(operators_2.mergeMap((info) => {
            const namespaceIds = this.getDistinctNamespaceIdFromAccountInfos(info);
            if (namespaceIds.length) {
                return this.namespaceRepository.getNamespacesNames(namespaceIds);
            }
            return rxjs_1.of([]);
        }));
        return accountInfoObservable.pipe(operators_1.withLatestFrom(distinctNames), operators_1.map(([infos, names]) => {
            return infos.map((info) => {
                const resolved = this.resolveMosaics(info.mosaics, names);
                return DtoMapping_1.DtoMapping.assign(info, { resolvedMosaics: resolved });
            });
        }));
    }
    /**
     * Get namespace info for account with namespace name
     * @param addresses Namespace owner address
     * @returns {Observable<NamespaceInfoWithName[]>}
     */
    accountNamespacesWithName(address) {
        const steatmer = new NamespacePaginationStreamer_1.NamespacePaginationStreamer(this.namespaceRepository).search({ ownerAddress: address }).pipe(operators_1.toArray());
        return steatmer.pipe(operators_2.mergeMap((infos) => {
            const namespaceIds = infos.map((i) => i.id);
            return this.namespaceRepository.getNamespacesNames(namespaceIds).pipe(operators_1.map((resolved) => {
                return infos.map((info) => {
                    const name = resolved.find((r) => r.namespaceId.equals(info.id));
                    return DtoMapping_1.DtoMapping.assign(info, { namespaceName: name === null || name === void 0 ? void 0 : name.name });
                });
            }));
        }));
    }
    /**
     * Resolve mosaics provided namespace names
     * @param mosaics unresolved mosaics
     * @return {ResolvedMosaic[]}
     */
    resolveMosaics(mosaics, names) {
        return mosaics.map((mosaic) => {
            if (mosaic.id instanceof MosaicId_1.MosaicId) {
                return mosaic;
            }
            else {
                const name = names.find((f) => f.namespaceId.equals(mosaic.id));
                if (name) {
                    return DtoMapping_1.DtoMapping.assign(mosaic, { namespaceName: name });
                }
                else {
                    return mosaic;
                }
            }
        });
    }
    /**
     * Get distinct list of namespaces ids from list of account infos
     * @param accountInfos List of account infos
     * @returns {NamespaceId[]}
     */
    getDistinctNamespaceIdFromAccountInfos(accountInfos) {
        const namespaceIds = [];
        accountInfos.forEach((info) => {
            info.mosaics.forEach((mosaic) => {
                if (mosaic.id instanceof NamespaceId_1.NamespaceId) {
                    if (!namespaceIds.find((n) => n.equals(mosaic.id))) {
                        namespaceIds.push(mosaic.id);
                    }
                }
            });
        });
        return namespaceIds;
    }
}
exports.AccountService = AccountService;

},{"../core/utils/DtoMapping":566,"../infrastructure/paginationStreamer/NamespacePaginationStreamer":596,"../model/mosaic/MosaicId":642,"../model/namespace/NamespaceId":656,"rxjs":"/node_modules/rxjs","rxjs/operators":"/node_modules/rxjs/operators"}],759:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const TransactionMapping_1 = require("../core/utils/TransactionMapping");
const TransactionType_1 = require("../model/transaction/TransactionType");
const Address_1 = require("../model/account/Address");
/**
 * Aggregated Transaction service
 */
class AggregateTransactionService {
    /**
     * Constructor
     * @param repositoryFactory
     */
    constructor(repositoryFactory) {
        this.multisigRepository = repositoryFactory.createMultisigRepository();
        this.networkRepository = repositoryFactory.createNetworkRepository();
    }
    /**
     * Check if an aggregate complete transaction has all cosignatories attached
     * @param signedTransaction - The signed aggregate transaction (complete) to be verified
     * @returns {Observable<boolean>}
     */
    isComplete(signedTransaction) {
        const aggregateTransaction = TransactionMapping_1.TransactionMapping.createFromPayload(signedTransaction.payload);
        /**
         * Include both initiator & cosigners
         */
        const signers = aggregateTransaction.cosignatures.map((cosigner) => cosigner.signer.address);
        if (signedTransaction.signerPublicKey) {
            signers.push(Address_1.Address.createFromPublicKey(signedTransaction.signerPublicKey, aggregateTransaction.networkType));
        }
        return rxjs_1.from(aggregateTransaction.innerTransactions)
            .pipe(operators_1.mergeMap((innerTransaction) => this.multisigRepository.getMultisigAccountInfo(innerTransaction.signer.address).pipe(
        /**
         * For multisig account, we need to get the graph info in case it has multiple levels
         */
        operators_1.mergeMap((_) => _.minApproval !== 0 && _.minRemoval !== 0
            ? this.multisigRepository
                .getMultisigAccountGraphInfo(_.accountAddress)
                .pipe(operators_1.map((graphInfo) => this.validateCosignatories(graphInfo, signers, innerTransaction)))
            : rxjs_1.of(signers.find((s) => s.equals(_.accountAddress)) !== undefined)))), operators_1.toArray())
            .pipe(operators_1.flatMap((results) => {
            return rxjs_1.of(results.every((isComplete) => isComplete));
        }));
    }
    /**
     * Get total multisig account cosigner count
     * @param address multisig account address
     * @returns {Observable<number>}
     */
    getMaxCosignatures(address) {
        return this.multisigRepository.getMultisigAccountGraphInfo(address).pipe(operators_1.map((graph) => {
            const cosignatures = []
                .concat(...Array.from(graph.multisigEntries.values()))
                .map((info) => info.cosignatoryAddresses.map((cosig) => cosig));
            return new Set([].concat(...cosignatures)).size;
        }));
    }
    /**
     * Get max cosignatures allowed per aggregate from network properties
     * @returns {Observable<number>}
     */
    getNetworkMaxCosignaturesPerAggregate() {
        return this.networkRepository.getNetworkProperties().pipe(operators_1.map((properties) => {
            var _a, _b;
            if (!((_a = properties.plugins.aggregate) === null || _a === void 0 ? void 0 : _a.maxCosignaturesPerAggregate)) {
                throw new Error('Cannot get maxCosignaturesPerAggregate from network properties.');
            }
            return parseInt((_b = properties.plugins.aggregate) === null || _b === void 0 ? void 0 : _b.maxCosignaturesPerAggregate.replace(`'`, ''));
        }));
    }
    /**
     * Validate cosignatories against multisig Account(s)
     * @param graphInfo - multisig account graph info
     * @param cosignatories - array of cosignatories extracted from aggregated transaction
     * @param innerTransaction - the inner transaction of the aggregated transaction
     * @returns {boolean}
     */
    validateCosignatories(graphInfo, cosignatories, innerTransaction) {
        /**
         *  Validate cosignatories from bottom level to top
         */
        const sortedKeys = Array.from(graphInfo.multisigEntries.keys()).sort((a, b) => b - a);
        const cosignatoriesReceived = cosignatories.map((cosig) => cosig.plain());
        let validationResult = false;
        let isMultisigRemoval = false;
        /**
         * Check inner transaction. If remove cosigner from multisig account,
         * use minRemoval instead of minApproval for cosignatories validation.
         */
        if (innerTransaction.type === TransactionType_1.TransactionType.MULTISIG_ACCOUNT_MODIFICATION) {
            if (innerTransaction.addressDeletions.length) {
                isMultisigRemoval = true;
            }
        }
        sortedKeys.forEach((key) => {
            const multisigInfo = graphInfo.multisigEntries.get(key);
            if (multisigInfo && !validationResult) {
                multisigInfo.forEach((multisig) => {
                    if (multisig.minApproval >= 1 && multisig.minRemoval) {
                        // To make sure it is multisig account
                        const matchedCosignatories = this.compareArrays(cosignatoriesReceived, multisig.cosignatoryAddresses.map((cosig) => cosig.plain()));
                        /**
                         * if minimal signature requirement met at current level, push the multisig account
                         * into the received signatories array for next level validation.
                         * Otherwise return validation failed.
                         */
                        if ((matchedCosignatories.length >= multisig.minApproval && !isMultisigRemoval) ||
                            (matchedCosignatories.length >= multisig.minRemoval && isMultisigRemoval)) {
                            if (cosignatoriesReceived.indexOf(multisig.accountAddress.plain()) === -1) {
                                cosignatoriesReceived.push(multisig.accountAddress.plain());
                            }
                            validationResult = true;
                        }
                        else {
                            validationResult = false;
                        }
                    }
                });
            }
        });
        return validationResult;
    }
    /**
     * Compare two string arrays
     * @param array1 - base array
     * @param array2 - array to be matched
     * @returns {string[]} - array of matched elements
     */
    compareArrays(array1, array2) {
        const results = [];
        array1.forEach((a1) => array2.forEach((a2) => {
            if (a1 === a2) {
                results.push(a1);
            }
        }));
        return results;
    }
}
exports.AggregateTransactionService = AggregateTransactionService;

},{"../core/utils/TransactionMapping":568,"../model/account/Address":618,"../model/transaction/TransactionType":750,"rxjs":"/node_modules/rxjs","rxjs/operators":"/node_modules/rxjs/operators"}],760:[function(require,module,exports){
(function (Buffer){
"use strict";
/*
 * Copyright 2020 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const js_sha3_1 = require("js-sha3");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const MerklePosition_1 = require("../model/blockchain/MerklePosition");
/**
 * Block Service
 */
class BlockService {
    /**
     * Constructor
     * @param repositoryFactory
     */
    constructor(repositoryFactory) {
        this.repositoryFactory = repositoryFactory;
        this.blockRepository = repositoryFactory.createBlockRepository();
    }
    /**
     * Validate transaction hash in block
     * @param leaf transaction hash
     * @param height block height
     */
    validateTransactionInBlock(leaf, height) {
        const rootHashObservable = this.blockRepository.getBlockByHeight(height);
        const merklePathItemObservable = this.blockRepository.getMerkleTransaction(height, leaf);
        return rxjs_1.combineLatest([rootHashObservable, merklePathItemObservable])
            .pipe(operators_1.map((combined) => this.validateInBlock(leaf, combined[1].merklePath, combined[0].blockTransactionsHash)))
            .pipe(operators_1.catchError(() => rxjs_1.of(false)));
    }
    /**
     * Validate statement hash in block
     * @param leaf statement hash
     * @param height block height
     */
    validateStatementInBlock(leaf, height) {
        const rootHashObservable = this.blockRepository.getBlockByHeight(height);
        const merklePathItemObservable = this.blockRepository.getMerkleReceipts(height, leaf);
        return rxjs_1.combineLatest([rootHashObservable, merklePathItemObservable])
            .pipe(operators_1.map((combined) => this.validateInBlock(leaf, combined[1].merklePath, combined[0].blockReceiptsHash)))
            .pipe(operators_1.catchError(() => rxjs_1.of(false)));
    }
    /**
     * @internal
     * Validate leaf against merkle tree in block
     * @param leaf Leaf hash in merkle tree
     * @param merklePathItem Merkle path item array
     * @param rootHash Block root hash
     */
    validateInBlock(leaf, merklePathItem = [], rootHash) {
        if (merklePathItem.length === 0) {
            return leaf.toUpperCase() === rootHash.toUpperCase();
        }
        const rootToCompare = merklePathItem.reduce((proofHash, pathItem) => {
            const hasher = js_sha3_1.sha3_256.create();
            // Left
            if (pathItem.position !== undefined && pathItem.position === MerklePosition_1.MerklePosition.Left) {
                return hasher.update(Buffer.from(pathItem.hash + proofHash, 'hex')).hex();
            }
            else {
                // Right
                return hasher.update(Buffer.from(proofHash + pathItem.hash, 'hex')).hex();
            }
        }, leaf);
        return rootToCompare.toUpperCase() === rootHash.toUpperCase();
    }
}
exports.BlockService = BlockService;

}).call(this,require("buffer").Buffer)
},{"../model/blockchain/MerklePosition":626,"buffer":47,"js-sha3":"/node_modules/js-sha3","rxjs":"/node_modules/rxjs","rxjs/operators":"/node_modules/rxjs/operators"}],761:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators_1 = require("rxjs/operators");
const Convert_1 = require("../core/format/Convert");
const MetadataType_1 = require("../model/metadata/MetadataType");
const AccountMetadataTransaction_1 = require("../model/transaction/AccountMetadataTransaction");
const MosaicMetadataTransaction_1 = require("../model/transaction/MosaicMetadataTransaction");
const NamespaceMetadataTransaction_1 = require("../model/transaction/NamespaceMetadataTransaction");
/**
 * MetadataTransaction service
 */
class MetadataTransactionService {
    /**
     * Constructor
     * @param metadataRepository
     */
    constructor(metadataRepository) {
        this.metadataRepository = metadataRepository;
    }
    /**
     * Create an Account Metadata Transaction object without knowing previous metadata value
     * @param deadline - Deadline
     * @param networkType - Network identifier
     * @param targetAddress - Target address
     * @param key - Metadata key
     * @param value - New metadata value
     * @param sourceAddress - sender (signer) address
     * @param maxFee - max fee
     * @returns {Observable<AccountMetadataTransaction>}
     */
    createAccountMetadataTransaction(deadline, networkType, targetAddress, key, value, sourceAddress, maxFee) {
        return this.metadataRepository
            .search({ targetAddress, scopedMetadataKey: key.toHex(), sourceAddress: sourceAddress, metadataType: MetadataType_1.MetadataType.Account })
            .pipe(operators_1.map((metadatas) => {
            if (metadatas.data.length > 0) {
                const metadata = metadatas.data[0];
                const currentValueByte = Convert_1.Convert.utf8ToUint8(metadata.metadataEntry.value);
                const newValueBytes = Convert_1.Convert.utf8ToUint8(value);
                return AccountMetadataTransaction_1.AccountMetadataTransaction.create(deadline, targetAddress, key, newValueBytes.length - currentValueByte.length, Convert_1.Convert.decodeHex(Convert_1.Convert.xor(currentValueByte, newValueBytes)), networkType, maxFee);
            }
            const newValueBytes = Convert_1.Convert.utf8ToUint8(value);
            return AccountMetadataTransaction_1.AccountMetadataTransaction.create(deadline, targetAddress, key, newValueBytes.length, value, networkType, maxFee);
        }), operators_1.catchError((err) => {
            throw Error(err.message);
        }));
    }
    /**
     * Create a Mosaic Metadata Transaction object without knowing previous metadata value
     * @param deadline - Deadline
     * @param networkType - Network identifier
     * @param targetAddress - Target Address
     * @param mosaicId - Mosaic Id
     * @param key - Metadata key
     * @param value - New metadata value
     * @param sourceAddress - sender (signer) address
     * @param maxFee - max fee
     * @returns {Observable<MosaicMetadataTransaction>}
     */
    createMosaicMetadataTransaction(deadline, networkType, targetAddress, mosaicId, key, value, sourceAddress, maxFee) {
        return this.metadataRepository
            .search({ targetId: mosaicId, scopedMetadataKey: key.toHex(), sourceAddress: sourceAddress, metadataType: MetadataType_1.MetadataType.Mosaic })
            .pipe(operators_1.map((metadatas) => {
            if (metadatas.data.length > 0) {
                const metadata = metadatas.data[0];
                const currentValueByte = Convert_1.Convert.utf8ToUint8(metadata.metadataEntry.value);
                const newValueBytes = Convert_1.Convert.utf8ToUint8(value);
                return MosaicMetadataTransaction_1.MosaicMetadataTransaction.create(deadline, targetAddress, key, mosaicId, newValueBytes.length - currentValueByte.length, Convert_1.Convert.decodeHex(Convert_1.Convert.xor(currentValueByte, newValueBytes)), networkType, maxFee);
            }
            const newValueBytes = Convert_1.Convert.utf8ToUint8(value);
            return MosaicMetadataTransaction_1.MosaicMetadataTransaction.create(deadline, targetAddress, key, mosaicId, newValueBytes.length, value, networkType, maxFee);
        }), operators_1.catchError((err) => {
            throw Error(err.message);
        }));
    }
    /**
     * Create a Namespace Metadata Transaction object without knowing previous metadata value
     * @param deadline - Deadline
     * @param networkType - Network identifier
     * @param targetAddress - Target address
     * @param namespaceId - Namespace Id
     * @param key - Metadata key
     * @param value - New metadata value
     * @param sourceAddress - sender (signer) address
     * @param maxFee - max fee
     * @returns {Observable<NamespaceMetadataTransaction>}
     */
    createNamespaceMetadataTransaction(deadline, networkType, targetAddress, namespaceId, key, value, sourceAddress, maxFee) {
        return this.metadataRepository
            .search({
            targetId: namespaceId,
            scopedMetadataKey: key.toHex(),
            sourceAddress: sourceAddress,
            metadataType: MetadataType_1.MetadataType.Namespace,
        })
            .pipe(operators_1.map((metadatas) => {
            if (metadatas.data.length > 0) {
                const metadata = metadatas.data[0];
                const currentValueByte = Convert_1.Convert.utf8ToUint8(metadata.metadataEntry.value);
                const newValueBytes = Convert_1.Convert.utf8ToUint8(value);
                return NamespaceMetadataTransaction_1.NamespaceMetadataTransaction.create(deadline, targetAddress, key, namespaceId, newValueBytes.length - currentValueByte.length, Convert_1.Convert.decodeHex(Convert_1.Convert.xor(currentValueByte, newValueBytes)), networkType, maxFee);
            }
            const newValueBytes = Convert_1.Convert.utf8ToUint8(value);
            return NamespaceMetadataTransaction_1.NamespaceMetadataTransaction.create(deadline, targetAddress, key, namespaceId, newValueBytes.length, value, networkType, maxFee);
        }), operators_1.catchError((err) => {
            throw Error(err.message);
        }));
    }
}
exports.MetadataTransactionService = MetadataTransactionService;

},{"../core/format/Convert":558,"../model/metadata/MetadataType":638,"../model/transaction/AccountMetadataTransaction":711,"../model/transaction/MosaicMetadataTransaction":733,"../model/transaction/NamespaceMetadataTransaction":737,"rxjs/operators":"/node_modules/rxjs/operators"}],762:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class representing mosaic view information with amount
 */
class MosaicAmountView {
    /**
     * @param mosaicInfo
     * @param namespaceName
     * @param mosaicName
     * @param amount
     */
    constructor(
    /**
     * The mosaic information
     */
    mosaicInfo, 
    /**
     * The amount of absolute mosaics we have
     */
    amount) {
        this.mosaicInfo = mosaicInfo;
        this.amount = amount;
    }
    /**
     * Relative amount dividing amount by the divisibility
     * @returns {string}
     */
    relativeAmount() {
        if (this.mosaicInfo.divisibility === 0) {
            return this.amount.compact();
        }
        return this.amount.compact() / Math.pow(10, this.mosaicInfo.divisibility);
    }
    /**
     * Namespace and mosaic description
     * @returns {string}
     */
    fullName() {
        return this.mosaicInfo.id.toHex();
    }
}
exports.MosaicAmountView = MosaicAmountView;

},{}],763:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const Address_1 = require("../model/account/Address");
const MosaicId_1 = require("../model/mosaic/MosaicId");
const MosaicRestrictionType_1 = require("../model/restriction/MosaicRestrictionType");
const MosaicAddressRestrictionTransaction_1 = require("../model/transaction/MosaicAddressRestrictionTransaction");
const MosaicGlobalRestrictionTransaction_1 = require("../model/transaction/MosaicGlobalRestrictionTransaction");
const UInt64_1 = require("../model/UInt64");
/**
 * MosaicRestrictionTransactionService service
 */
class MosaicRestrictionTransactionService {
    /**
     * Constructor
     * @param restrictionMosaicRepository
     * @param namespaceRepository
     */
    constructor(restrictionMosaicRepository, namespaceRepository) {
        this.restrictionMosaicRepository = restrictionMosaicRepository;
        this.namespaceRepository = namespaceRepository;
        this.defaultMosaicAddressRestrictionValue = UInt64_1.UInt64.fromHex('FFFFFFFFFFFFFFFF');
        this.defaultMosaicGlobalRestrictionValue = UInt64_1.UInt64.fromUint(0);
    }
    /**
     * Create a MosaicGlobalRestrictionTransaction object without previous restriction data
     * @param deadline - Deadline
     * @param networkType - Network identifier
     * @param mosaicId - Unresolved mosaicId
     * @param restrictionKey - Restriction key
     * @param restrictionValue - New restriction value
     * @param restrictionType - New restriction type
     * @param referenceMosaicId - Reference mosaic Id
     * @param maxFee - Max fee
     */
    createMosaicGlobalRestrictionTransaction(deadline, networkType, mosaicId, restrictionKey, restrictionValue, restrictionType, referenceMosaicId = new MosaicId_1.MosaicId(UInt64_1.UInt64.fromUint(0).toDTO()), maxFee = new UInt64_1.UInt64([0, 0])) {
        this.validateInput(restrictionValue);
        return this.getResolvedMosaicId(mosaicId).pipe(operators_1.mergeMap((resolvedMosaicId) => this.getGlobalRestrictionEntry(resolvedMosaicId, restrictionKey).pipe(operators_1.map((restrictionEntry) => {
            const currentValue = restrictionEntry
                ? UInt64_1.UInt64.fromNumericString(restrictionEntry.restrictionValue)
                : this.defaultMosaicGlobalRestrictionValue;
            const currentType = restrictionEntry ? restrictionEntry.restrictionType : MosaicRestrictionType_1.MosaicRestrictionType.NONE;
            return MosaicGlobalRestrictionTransaction_1.MosaicGlobalRestrictionTransaction.create(deadline, resolvedMosaicId, restrictionKey, currentValue, currentType, UInt64_1.UInt64.fromNumericString(restrictionValue), restrictionType, networkType, referenceMosaicId, maxFee);
        }))));
    }
    /**
     * Create a MosaicAddressRestrictionTransaction object without previous restriction data
     * @param deadline - Deadline
     * @param networkType - Network identifier
     * @param mosaicId - Unresolved mosaicId
     * @param restrictionKey - Restriction key
     * @param targetAddress - Unresolved target address
     * @param restrictionValue - New restriction value
     * @param maxFee - Max fee
     */
    createMosaicAddressRestrictionTransaction(deadline, networkType, mosaicId, restrictionKey, targetAddress, restrictionValue, maxFee = new UInt64_1.UInt64([0, 0])) {
        this.validateInput(restrictionValue);
        const combinedUnresolved = rxjs_1.combineLatest(this.getResolvedMosaicId(mosaicId), this.getResolvedAddress(targetAddress));
        return combinedUnresolved.pipe(operators_1.mergeMap(([resolvedMosaicId, resolvedAddress]) => this.getGlobalRestrictionEntry(resolvedMosaicId, restrictionKey).pipe(operators_1.mergeMap((restrictionEntry) => {
            if (!restrictionEntry) {
                throw new Error('Global restriction is not valid for RestrictionKey: ' + restrictionKey);
            }
            return this.getAddressRestrictionEntry(resolvedMosaicId, restrictionKey, resolvedAddress).pipe(operators_1.map((optionalValue) => {
                const currentValue = optionalValue
                    ? UInt64_1.UInt64.fromNumericString(optionalValue)
                    : this.defaultMosaicAddressRestrictionValue;
                return MosaicAddressRestrictionTransaction_1.MosaicAddressRestrictionTransaction.create(deadline, mosaicId, restrictionKey, targetAddress, UInt64_1.UInt64.fromNumericString(restrictionValue), networkType, currentValue, maxFee);
            }));
        }))));
    }
    /**
     * Get address global restriction previous value and type
     * @param mosaicId - Mosaic identifier
     * @param restrictionKey - Mosaic global restriction key
     * @param targetAddress - The target address
     * @return {Observable<string | undefined>}
     */
    getAddressRestrictionEntry(mosaicId, restrictionKey, targetAddress) {
        return this.restrictionMosaicRepository.getMosaicAddressRestriction(mosaicId, targetAddress).pipe(operators_1.map((mosaicRestriction) => {
            return mosaicRestriction.restrictions.get(restrictionKey.toString());
        }), operators_1.catchError((err) => {
            const error = JSON.parse(err.message);
            if (error && error.statusCode && error.statusCode === 404) {
                return rxjs_1.of(undefined);
            }
            throw new Error(err.message);
        }));
    }
    /**
     * Get mosaic global restriction prvious value and type
     * @param mosaicId - Mosaic identifier
     * @param restrictionKey - Mosaic global restriction key
     * @return {Observable<MosaicGlobalRestrictionItem | undefined>}
     */
    getGlobalRestrictionEntry(mosaicId, restrictionKey) {
        return this.restrictionMosaicRepository.getMosaicGlobalRestriction(mosaicId).pipe(operators_1.map((mosaicRestriction) => {
            return mosaicRestriction.restrictions.get(restrictionKey.toString());
        }), operators_1.catchError((err) => {
            const error = JSON.parse(err.message);
            if (error && error.statusCode && error.statusCode === 404) {
                return rxjs_1.of(undefined);
            }
            throw new Error(err.message);
        }));
    }
    /**
     * Check if input restriction key and value are invalid or not
     * @param value - Restriction value
     */
    validateInput(value) {
        if (!UInt64_1.UInt64.isLongNumericString(value)) {
            throw new Error(`RestrictionValue: ${value} is not a valid numeric string.`);
        }
    }
    /**
     * @internal
     * Get resolved mosaicId from namespace repository
     * @param unresolvedMosaicId unresolved mosaicId
     * @returns {MosaicId}
     */
    getResolvedMosaicId(unresolvedMosaicId) {
        if (unresolvedMosaicId instanceof MosaicId_1.MosaicId) {
            return rxjs_1.of(unresolvedMosaicId);
        }
        return this.namespaceRepository.getLinkedMosaicId(unresolvedMosaicId).pipe(operators_1.map((mosaicId) => {
            if (!mosaicId) {
                throw new Error(`Invalid unresolvedMosaicId: ${unresolvedMosaicId.toHex()}`);
            }
            return mosaicId;
        }), operators_1.catchError((err) => {
            throw new Error(err);
        }));
    }
    /**
     * @internal
     * Get resolved address from namespace repository
     * @param unresolvedAddress unresolved address
     * @returns {Address}
     */
    getResolvedAddress(unresolvedAddress) {
        if (unresolvedAddress instanceof Address_1.Address) {
            return rxjs_1.of(unresolvedAddress);
        }
        return this.namespaceRepository.getLinkedAddress(unresolvedAddress).pipe(operators_1.map((address) => {
            if (!address) {
                throw new Error(`Invalid unresolvedAddress: ${unresolvedAddress.toHex()}`);
            }
            return address;
        }), operators_1.catchError((err) => {
            throw new Error(err);
        }));
    }
}
exports.MosaicRestrictionTransactionService = MosaicRestrictionTransactionService;

},{"../model/UInt64":609,"../model/account/Address":618,"../model/mosaic/MosaicId":642,"../model/restriction/MosaicRestrictionType":707,"../model/transaction/MosaicAddressRestrictionTransaction":729,"../model/transaction/MosaicGlobalRestrictionTransaction":732,"rxjs":"/node_modules/rxjs","rxjs/operators":"/node_modules/rxjs/operators"}],764:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const MosaicId_1 = require("../model/mosaic/MosaicId");
const MosaicAmountView_1 = require("./MosaicAmountView");
const MosaicView_1 = require("./MosaicView");
/**
 * Mosaic service
 */
class MosaicService {
    /**
     * Constructor
     * @param accountRepository
     * @param mosaicRepository
     */
    constructor(accountRepository, mosaicRepository) {
        this.accountRepository = accountRepository;
        this.mosaicRepository = mosaicRepository;
    }
    /**
     * Get mosaic view given mosaicIds
     * @param mosaicIds - The ids of the mosaics
     * @returns {Observable<MosaicView[]>}
     */
    mosaicsView(mosaicIds) {
        return rxjs_1.of(mosaicIds).pipe(operators_1.mergeMap(() => this.mosaicRepository.getMosaics(mosaicIds).pipe(operators_1.mergeMap((info) => info), operators_1.map((mosaicInfo) => {
            return new MosaicView_1.MosaicView(mosaicInfo);
        }), operators_1.toArray())));
    }
    /**
     * Get mosaic amount view given mosaic array
     * @param mosaics
     * @returns {Observable<MosaicAmountView[]>}
     */
    mosaicsAmountView(mosaics) {
        const mosaicIds = mosaics.map((mosaic) => {
            return new MosaicId_1.MosaicId(mosaic.id.toHex());
        });
        return this.mosaicsView(mosaicIds).pipe(operators_1.map((mosaicViews) => {
            const results = [];
            mosaicViews.forEach((view) => {
                const mosaic = mosaics.find((m) => m.id.toHex() === view.mosaicInfo.id.toHex());
                if (mosaic) {
                    results.push(new MosaicAmountView_1.MosaicAmountView(view.mosaicInfo, mosaic.amount));
                }
            });
            return results;
        }));
    }
    /**
     * Get balance mosaics in form of MosaicAmountViews for a given account address
     * @param address - Account address
     * @returns {Observable<MosaicAmountView[]>}
     */
    mosaicsAmountViewFromAddress(address) {
        return rxjs_1.of(address).pipe(operators_1.mergeMap((_) => this.accountRepository.getAccountInfo(_)), operators_1.mergeMap((_) => this.mosaicsAmountView(_.mosaics)));
    }
}
exports.MosaicService = MosaicService;

},{"../model/mosaic/MosaicId":642,"./MosaicAmountView":762,"./MosaicView":765,"rxjs":"/node_modules/rxjs","rxjs/operators":"/node_modules/rxjs/operators"}],765:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class representing mosaic view information
 */
class MosaicView {
    /**
     * @internal
     * @param mosaicInfo
     */
    constructor(
    /**
     * The mosaic information
     */
    mosaicInfo) {
        this.mosaicInfo = mosaicInfo;
    }
}
exports.MosaicView = MosaicView;

},{}],766:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const operators_1 = require("rxjs/operators");
/**
 * Namespace service
 */
class NamespaceService {
    /**
     * Constructor
     * @param namespaceRepository
     */
    constructor(namespaceRepository) {
        this.namespaceRepository = namespaceRepository;
    }
    /**
     * Get namespace info and name from namespace Id
     * @param id
     * @returns {Observable<Namespace>}
     */
    namespace(id) {
        return this.namespaceRepository.getNamespace(id).pipe(operators_1.mergeMap((namespaceInfo) => this.namespaceRepository.getNamespacesNames(namespaceInfo.levels).pipe(operators_1.map((names) => Object.assign({
            __proto__: Object.getPrototypeOf(namespaceInfo),
        }, namespaceInfo, {
            name: this.extractFullNamespace(namespaceInfo, names),
        })))));
    }
    extractFullNamespace(namespace, namespaceNames) {
        return namespace.levels
            .map((level) => {
            const namespaceName = namespaceNames.find((name) => name.namespaceId.equals(level));
            if (namespace === undefined) {
                throw new Error('Not found');
            }
            return namespaceName;
        })
            .map((namespaceName) => namespaceName.name)
            .join('.');
    }
}
exports.NamespaceService = NamespaceService;

},{"rxjs/operators":"/node_modules/rxjs/operators"}],767:[function(require,module,exports){
"use strict";
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const NamespaceId_1 = require("../model/namespace/NamespaceId");
const TransactionStatusError_1 = require("../model/transaction/TransactionStatusError");
const TransactionType_1 = require("../model/transaction/TransactionType");
const TransactionGroup_1 = require("../infrastructure/TransactionGroup");
const ReceiptPaginationStreamer_1 = require("../infrastructure/paginationStreamer/ReceiptPaginationStreamer");
const Statement_1 = require("../model/receipt/Statement");
const rxjs_2 = require("rxjs");
/**
 * Transaction Service
 */
class TransactionService {
    /**
     * Constructor
     * @param transactionRepository
     * @param receiptRepository
     */
    constructor(transactionRepository, receiptRepository) {
        this.transactionRepository = transactionRepository;
        this.receiptRepository = receiptRepository;
    }
    /**
     * Resolve unresolved mosaic / address from array of transactions
     * @param transationHashes List of transaction hashes.
     * @returns Observable<Transaction[]>
     */
    resolveAliases(transationHashes) {
        return this.transactionRepository.getTransactionsById(transationHashes, TransactionGroup_1.TransactionGroup.Confirmed).pipe(operators_1.mergeMap((_) => {
            return _;
        }), operators_1.mergeMap((transaction) => this.resolveTransaction(transaction)), operators_1.toArray());
    }
    /**
     * @param signedTransaction Signed transaction to be announced.
     * @param listener Websocket listener
     * @returns {Observable<Transaction>}
     */
    announce(signedTransaction, listener) {
        const signerAddress = signedTransaction.getSignerAddress();
        this.transactionRepository.announce(signedTransaction);
        return this.getTransactionOrRaiseError(listener, signerAddress, signedTransaction.hash, listener.confirmed(signerAddress, signedTransaction.hash));
    }
    /**
     * Announce aggregate transaction
     * **NOTE** A lock fund transaction for this aggregate bonded should exists
     * @param signedTransaction Signed aggregate bonded transaction.
     * @param listener Websocket listener
     * @returns {Observable<AggregateTransaction>}
     */
    announceAggregateBonded(signedTransaction, listener) {
        const signerAddress = signedTransaction.getSignerAddress();
        const transactionObservable = this.transactionRepository
            .announceAggregateBonded(signedTransaction)
            .pipe(operators_1.flatMap(() => listener.aggregateBondedAdded(signerAddress, signedTransaction.hash)));
        return this.getTransactionOrRaiseError(listener, signerAddress, signedTransaction.hash, transactionObservable);
    }
    /**
     * This method announces an a hash lock transaction followed by a aggregate bonded transaction
     * while waiting for being confirmed by listing to the /confirmed and /aggregateBondedAdded web
     * socket. If an error is sent while processing any of the given transaction an Error is raised.
     *
     * @param signedHashLockTransaction Signed hash lock transaction.
     * @param signedAggregateTransaction Signed aggregate bonded transaction.
     * @param listener Websocket listener
     * @returns {Observable<AggregateTransaction>}
     */
    announceHashLockAggregateBonded(signedHashLockTransaction, signedAggregateTransaction, listener) {
        return this.announce(signedHashLockTransaction, listener).pipe(operators_1.flatMap(() => this.announceAggregateBonded(signedAggregateTransaction, listener)));
    }
    /**
     * @internal
     *
     * This method publishes an error if the listener receives an error code for the given address & transaction hash.
     * Otherwise, it returns the passed transactionObservable
     *
     * @param listener the listener.
     * @param address the signer address
     * @param transactionHash the transaction hash
     * @param transactionObservable the observable with the valid transaction
     */
    getTransactionOrRaiseError(listener, address, transactionHash, transactionObservable) {
        const errorObservable = listener.status(address, transactionHash);
        return rxjs_1.merge(transactionObservable, errorObservable).pipe(operators_1.first(), operators_1.map((errorOrTransaction) => {
            if (errorOrTransaction instanceof TransactionStatusError_1.TransactionStatusError) {
                throw new Error(errorOrTransaction.code);
            }
            else {
                return errorOrTransaction;
            }
        }));
    }
    /**
     * Resolve transaction alias(s)
     * @param transaction Transaction to be resolved
     * @returns {Observable<Transaction>}
     */
    resolveTransaction(transaction) {
        if ([TransactionType_1.TransactionType.AGGREGATE_BONDED, TransactionType_1.TransactionType.AGGREGATE_COMPLETE].includes(transaction.type)) {
            if (transaction.innerTransactions.find((tx) => this.checkShouldResolve(tx))) {
                return this.resolvedFromReceipt(transaction, transaction.transactionInfo.index);
            }
            return rxjs_1.of(transaction);
        }
        return this.checkShouldResolve(transaction) ? this.resolvedFromReceipt(transaction, 0) : rxjs_1.of(transaction);
    }
    /**
     * @internal
     * Check if receiptRepository needs to be called to resolve transaction alias
     * @param transaction Transaction
     * @return {boolean}
     */
    checkShouldResolve(transaction) {
        switch (transaction.type) {
            case TransactionType_1.TransactionType.ACCOUNT_KEY_LINK:
            case TransactionType_1.TransactionType.ACCOUNT_METADATA:
            case TransactionType_1.TransactionType.ACCOUNT_OPERATION_RESTRICTION:
            case TransactionType_1.TransactionType.ADDRESS_ALIAS:
            case TransactionType_1.TransactionType.MOSAIC_ALIAS:
            case TransactionType_1.TransactionType.MOSAIC_DEFINITION:
            case TransactionType_1.TransactionType.MULTISIG_ACCOUNT_MODIFICATION:
            case TransactionType_1.TransactionType.NAMESPACE_METADATA:
            case TransactionType_1.TransactionType.NAMESPACE_REGISTRATION:
                return false;
            case TransactionType_1.TransactionType.ACCOUNT_ADDRESS_RESTRICTION:
                const accountAddressRestriction = transaction;
                return (accountAddressRestriction.restrictionAdditions.find((address) => address instanceof NamespaceId_1.NamespaceId) !== undefined ||
                    accountAddressRestriction.restrictionDeletions.find((address) => address instanceof NamespaceId_1.NamespaceId) !== undefined);
            case TransactionType_1.TransactionType.ACCOUNT_MOSAIC_RESTRICTION:
                const accountMosaicRestriction = transaction;
                return (accountMosaicRestriction.restrictionAdditions.find((mosaicId) => mosaicId instanceof NamespaceId_1.NamespaceId) !== undefined ||
                    accountMosaicRestriction.restrictionDeletions.find((mosaicId) => mosaicId instanceof NamespaceId_1.NamespaceId) !== undefined);
            case TransactionType_1.TransactionType.HASH_LOCK:
                return transaction.mosaic.id instanceof NamespaceId_1.NamespaceId;
            case TransactionType_1.TransactionType.MOSAIC_ADDRESS_RESTRICTION:
                const mosaicAddressRestriction = transaction;
                return (mosaicAddressRestriction.targetAddress instanceof NamespaceId_1.NamespaceId ||
                    mosaicAddressRestriction.mosaicId instanceof NamespaceId_1.NamespaceId);
            case TransactionType_1.TransactionType.MOSAIC_GLOBAL_RESTRICTION:
                const mosaicGlobalRestriction = transaction;
                return (mosaicGlobalRestriction.referenceMosaicId instanceof NamespaceId_1.NamespaceId ||
                    mosaicGlobalRestriction.mosaicId instanceof NamespaceId_1.NamespaceId);
            case TransactionType_1.TransactionType.MOSAIC_METADATA:
                return transaction.targetMosaicId instanceof NamespaceId_1.NamespaceId;
            case TransactionType_1.TransactionType.MOSAIC_SUPPLY_CHANGE:
                return transaction.mosaicId instanceof NamespaceId_1.NamespaceId;
            case TransactionType_1.TransactionType.SECRET_PROOF:
                return transaction.recipientAddress instanceof NamespaceId_1.NamespaceId;
            case TransactionType_1.TransactionType.SECRET_LOCK:
                const secretLock = transaction;
                return secretLock.recipientAddress instanceof NamespaceId_1.NamespaceId || secretLock.mosaic.id instanceof NamespaceId_1.NamespaceId;
            case TransactionType_1.TransactionType.TRANSFER:
                const transfer = transaction;
                return (transfer.recipientAddress instanceof NamespaceId_1.NamespaceId ||
                    transfer.mosaics.find((mosaic) => mosaic.id instanceof NamespaceId_1.NamespaceId) !== undefined);
            default:
                throw new Error('Transaction type not not recogonised.');
        }
    }
    /**
     * @internal
     * Resolve transaction alais(s) from block receipt by calling receiptRepository
     * @param transaction Transaction to be resolved
     * @param aggregateIndex Aggregate transaction index
     * @return {Observable<Transaction>}
     */
    resolvedFromReceipt(transaction, aggregateIndex) {
        const addressResolution = ReceiptPaginationStreamer_1.ReceiptPaginationStreamer.addressResolutionStatements(this.receiptRepository)
            .search({ height: transaction.transactionInfo.height })
            .pipe(operators_1.toArray());
        const mosaicResolution = ReceiptPaginationStreamer_1.ReceiptPaginationStreamer.mosaicResolutionStatements(this.receiptRepository)
            .search({ height: transaction.transactionInfo.height })
            .pipe(operators_1.toArray());
        return rxjs_2.combineLatest(mosaicResolution, addressResolution)
            .pipe(operators_1.map(([mosaic, address]) => {
            return new Statement_1.Statement([], address, mosaic);
        }))
            .pipe(operators_1.map((statement) => transaction.resolveAliases(statement, aggregateIndex)));
    }
}
exports.TransactionService = TransactionService;

},{"../infrastructure/TransactionGroup":588,"../infrastructure/paginationStreamer/ReceiptPaginationStreamer":598,"../model/namespace/NamespaceId":656,"../model/receipt/Statement":695,"../model/transaction/TransactionStatusError":749,"../model/transaction/TransactionType":750,"rxjs":"/node_modules/rxjs","rxjs/operators":"/node_modules/rxjs/operators"}],768:[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./AccountService"));
__export(require("./NamespaceService"));
__export(require("./MosaicService"));
__export(require("./AggregateTransactionService"));
__export(require("./MetadataTransactionService"));
__export(require("./MosaicRestrictionTransactionService"));
__export(require("./TransactionService"));
__export(require("./BlockService"));

},{"./AccountService":758,"./AggregateTransactionService":759,"./BlockService":760,"./MetadataTransactionService":761,"./MosaicRestrictionTransactionService":763,"./MosaicService":764,"./NamespaceService":766,"./TransactionService":767}],769:[function(require,module,exports){
arguments[4][157][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./UnresolvedAddressDto":913,"dup":157}],770:[function(require,module,exports){
arguments[4][158][0].apply(exports,arguments)
},{"./AccountAddressRestrictionTransactionBodyBuilder":769,"./GeneratorUtils":833,"./TransactionBuilder":909,"dup":158}],771:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./KeyDto":848,"dup":160}],772:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"./AccountKeyLinkTransactionBodyBuilder":771,"./GeneratorUtils":833,"./TransactionBuilder":909,"dup":161}],773:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountKeyTypeFlagsDto = void 0;
var AccountKeyTypeFlagsDto;
(function (AccountKeyTypeFlagsDto) {
    AccountKeyTypeFlagsDto[AccountKeyTypeFlagsDto["UNSET"] = 0] = "UNSET";
    AccountKeyTypeFlagsDto[AccountKeyTypeFlagsDto["LINKED"] = 1] = "LINKED";
    AccountKeyTypeFlagsDto[AccountKeyTypeFlagsDto["NODE"] = 2] = "NODE";
    AccountKeyTypeFlagsDto[AccountKeyTypeFlagsDto["VRF"] = 4] = "VRF";
})(AccountKeyTypeFlagsDto = exports.AccountKeyTypeFlagsDto || (exports.AccountKeyTypeFlagsDto = {}));

},{}],774:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./UnresolvedAddressDto":913,"dup":162}],775:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"./AccountMetadataTransactionBodyBuilder":774,"./GeneratorUtils":833,"./TransactionBuilder":909,"dup":163}],776:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./UnresolvedMosaicIdDto":915,"dup":164}],777:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"./AccountMosaicRestrictionTransactionBodyBuilder":776,"./GeneratorUtils":833,"./TransactionBuilder":909,"dup":165}],778:[function(require,module,exports){
arguments[4][166][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":166}],779:[function(require,module,exports){
arguments[4][167][0].apply(exports,arguments)
},{"./AccountOperationRestrictionTransactionBodyBuilder":778,"./GeneratorUtils":833,"./TransactionBuilder":909,"dup":167}],780:[function(require,module,exports){
arguments[4][168][0].apply(exports,arguments)
},{"./AddressDto":790,"./GeneratorUtils":833,"dup":168}],781:[function(require,module,exports){
arguments[4][169][0].apply(exports,arguments)
},{"dup":169}],782:[function(require,module,exports){
arguments[4][170][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicIdDto":865,"dup":170}],783:[function(require,module,exports){
arguments[4][171][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":171}],784:[function(require,module,exports){
arguments[4][172][0].apply(exports,arguments)
},{"./AccountRestrictionsInfoBuilder":785,"./AddressDto":790,"./GeneratorUtils":833,"dup":172}],785:[function(require,module,exports){
arguments[4][173][0].apply(exports,arguments)
},{"./AccountRestrictionAddressValueBuilder":780,"./AccountRestrictionFlagsDto":781,"./AccountRestrictionMosaicValueBuilder":782,"./AccountRestrictionTransactionTypeValueBuilder":783,"./GeneratorUtils":833,"dup":173}],786:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountStateBuilder = void 0;
const AccountKeyTypeFlagsDto_1 = require("./AccountKeyTypeFlagsDto");
const AccountStateFormatDto_1 = require("./AccountStateFormatDto");
const AddressDto_1 = require("./AddressDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const HeightActivityBucketsBuilder_1 = require("./HeightActivityBucketsBuilder");
const HeightDto_1 = require("./HeightDto");
const ImportanceSnapshotBuilder_1 = require("./ImportanceSnapshotBuilder");
const KeyDto_1 = require("./KeyDto");
const MosaicBuilder_1 = require("./MosaicBuilder");
const PinnedVotingKeyBuilder_1 = require("./PinnedVotingKeyBuilder");
class AccountStateBuilder {
    constructor(address, addressHeight, publicKey, publicKeyHeight, accountType, supplementalPublicKeysMask, votingPublicKeys, balances, linkedPublicKey, nodePublicKey, vrfPublicKey, importanceSnapshots, activityBuckets) {
        this.address = address;
        this.addressHeight = addressHeight;
        this.publicKey = publicKey;
        this.publicKeyHeight = publicKeyHeight;
        this.accountType = accountType;
        this.supplementalPublicKeysMask = supplementalPublicKeysMask;
        this.linkedPublicKey = linkedPublicKey;
        this.nodePublicKey = nodePublicKey;
        this.vrfPublicKey = vrfPublicKey;
        this.votingPublicKeys = votingPublicKeys;
        this.importanceSnapshots = importanceSnapshots;
        this.activityBuckets = activityBuckets;
        this.balances = balances;
        if (importanceSnapshots) {
            this.format = AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE;
        }
        else {
            this.format = AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE;
        }
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const address = AddressDto_1.AddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, address.getSize());
        const addressHeight = HeightDto_1.HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, addressHeight.getSize());
        const publicKey = KeyDto_1.KeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, publicKey.getSize());
        const publicKeyHeight = HeightDto_1.HeightDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, publicKeyHeight.getSize());
        const accountType = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const format = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const supplementalPublicKeysMask = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const votingPublicKeysCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const supplementalPublicKeysMaskConditionBytes = Uint8Array.from(byteArray.slice(0, 32));
        byteArray.splice(0, 32);
        const votingPublicKeys = [];
        for (let i = 0; i < (Array.isArray(votingPublicKeysCount) ? GeneratorUtils_1.GeneratorUtils.compact(votingPublicKeysCount) : votingPublicKeysCount); i++) {
            const item = PinnedVotingKeyBuilder_1.PinnedVotingKeyBuilder.loadFromBinary(Uint8Array.from(byteArray));
            votingPublicKeys.push(item);
            byteArray.splice(0, item.getSize());
        }
        const formatConditionBytes = Uint8Array.from(byteArray.slice(0, 1));
        byteArray.splice(0, 1);
        const balancesCount = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const balances = [];
        for (let i = 0; i < (Array.isArray(balancesCount) ? GeneratorUtils_1.GeneratorUtils.compact(balancesCount) : balancesCount); i++) {
            const item = MosaicBuilder_1.MosaicBuilder.loadFromBinary(Uint8Array.from(byteArray));
            balances.push(item);
            byteArray.splice(0, item.getSize());
        }
        let linkedPublicKey;
        if (supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.LINKED) {
            linkedPublicKey = KeyDto_1.KeyDto.loadFromBinary(supplementalPublicKeysMaskConditionBytes);
        }
        let nodePublicKey;
        if (supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.NODE) {
            nodePublicKey = KeyDto_1.KeyDto.loadFromBinary(supplementalPublicKeysMaskConditionBytes);
        }
        let vrfPublicKey;
        if (supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.VRF) {
            vrfPublicKey = KeyDto_1.KeyDto.loadFromBinary(supplementalPublicKeysMaskConditionBytes);
        }
        let importanceSnapshots;
        if (format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            importanceSnapshots = ImportanceSnapshotBuilder_1.ImportanceSnapshotBuilder.loadFromBinary(formatConditionBytes);
        }
        let activityBuckets;
        if (format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            activityBuckets = HeightActivityBucketsBuilder_1.HeightActivityBucketsBuilder.loadFromBinary(formatConditionBytes);
        }
        return new AccountStateBuilder(address, addressHeight, publicKey, publicKeyHeight, accountType, supplementalPublicKeysMask, votingPublicKeys, balances, linkedPublicKey, nodePublicKey, vrfPublicKey, importanceSnapshots, activityBuckets);
    }
    getAddress() {
        return this.address;
    }
    getAddressHeight() {
        return this.addressHeight;
    }
    getPublicKey() {
        return this.publicKey;
    }
    getPublicKeyHeight() {
        return this.publicKeyHeight;
    }
    getAccountType() {
        return this.accountType;
    }
    getFormat() {
        return this.format;
    }
    getSupplementalPublicKeysMask() {
        return this.supplementalPublicKeysMask;
    }
    getLinkedPublicKey() {
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.LINKED) {
            throw new Error('supplementalPublicKeysMask is not set to LINKED.');
        }
        return this.linkedPublicKey;
    }
    getNodePublicKey() {
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.NODE) {
            throw new Error('supplementalPublicKeysMask is not set to NODE.');
        }
        return this.nodePublicKey;
    }
    getVrfPublicKey() {
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.VRF) {
            throw new Error('supplementalPublicKeysMask is not set to VRF.');
        }
        return this.vrfPublicKey;
    }
    getVotingPublicKeys() {
        return this.votingPublicKeys;
    }
    getImportanceSnapshots() {
        if (this.format !== AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            throw new Error('format is not set to HIGH_VALUE.');
        }
        return this.importanceSnapshots;
    }
    getActivityBuckets() {
        if (this.format !== AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            throw new Error('format is not set to HIGH_VALUE.');
        }
        return this.activityBuckets;
    }
    getBalances() {
        return this.balances;
    }
    getSize() {
        let size = 0;
        size += this.address.getSize();
        size += this.addressHeight.getSize();
        size += this.publicKey.getSize();
        size += this.publicKeyHeight.getSize();
        size += 1;
        size += 1;
        size += 1;
        size += 1;
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.LINKED) {
            size += this.linkedPublicKey.getSize();
        }
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.NODE) {
            size += this.nodePublicKey.getSize();
        }
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.VRF) {
            size += this.vrfPublicKey.getSize();
        }
        this.votingPublicKeys.forEach((o) => size += o.getSize());
        if (this.format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            size += this.importanceSnapshots.getSize();
        }
        if (this.format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            size += this.activityBuckets.getSize();
        }
        size += 2;
        this.balances.forEach((o) => size += o.getSize());
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const addressBytes = this.address.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressBytes);
        const addressHeightBytes = this.addressHeight.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, addressHeightBytes);
        const publicKeyBytes = this.publicKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, publicKeyBytes);
        const publicKeyHeightBytes = this.publicKeyHeight.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, publicKeyHeightBytes);
        const accountTypeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.accountType, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, accountTypeBytes);
        const formatBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.format, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, formatBytes);
        const supplementalPublicKeysMaskBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.getSupplementalPublicKeysMask(), 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, supplementalPublicKeysMaskBytes);
        const votingPublicKeysCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.votingPublicKeys.length, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, votingPublicKeysCountBytes);
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.LINKED) {
            const linkedPublicKeyBytes = this.linkedPublicKey.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, linkedPublicKeyBytes);
        }
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.NODE) {
            const nodePublicKeyBytes = this.nodePublicKey.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, nodePublicKeyBytes);
        }
        if (this.supplementalPublicKeysMask & AccountKeyTypeFlagsDto_1.AccountKeyTypeFlagsDto.VRF) {
            const vrfPublicKeyBytes = this.vrfPublicKey.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, vrfPublicKeyBytes);
        }
        this.votingPublicKeys.forEach((item) => {
            const votingPublicKeysBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, votingPublicKeysBytes);
        });
        if (this.format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            const importanceSnapshotsBytes = this.importanceSnapshots.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, importanceSnapshotsBytes);
        }
        if (this.format === AccountStateFormatDto_1.AccountStateFormatDto.HIGH_VALUE) {
            const activityBucketsBytes = this.activityBuckets.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, activityBucketsBytes);
        }
        const balancesCountBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.balances.length, 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, balancesCountBytes);
        this.balances.forEach((item) => {
            const balancesBytes = item.serialize();
            newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, balancesBytes);
        });
        return newArray;
    }
}
exports.AccountStateBuilder = AccountStateBuilder;

},{"./AccountKeyTypeFlagsDto":773,"./AccountStateFormatDto":787,"./AddressDto":790,"./GeneratorUtils":833,"./HeightActivityBucketsBuilder":842,"./HeightDto":843,"./ImportanceSnapshotBuilder":846,"./KeyDto":848,"./MosaicBuilder":856,"./PinnedVotingKeyBuilder":893}],787:[function(require,module,exports){
arguments[4][175][0].apply(exports,arguments)
},{"dup":175}],788:[function(require,module,exports){
arguments[4][176][0].apply(exports,arguments)
},{"./AddressDto":790,"./GeneratorUtils":833,"./NamespaceIdDto":883,"dup":176}],789:[function(require,module,exports){
arguments[4][177][0].apply(exports,arguments)
},{"./AddressAliasTransactionBodyBuilder":788,"./GeneratorUtils":833,"./TransactionBuilder":909,"dup":177}],790:[function(require,module,exports){
arguments[4][178][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":178}],791:[function(require,module,exports){
arguments[4][179][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicRestrictionKeyDto":874,"dup":179}],792:[function(require,module,exports){
arguments[4][180][0].apply(exports,arguments)
},{"./AddressKeyValueBuilder":791,"./GeneratorUtils":833,"dup":180}],793:[function(require,module,exports){
arguments[4][181][0].apply(exports,arguments)
},{"./AddressDto":790,"./GeneratorUtils":833,"./ReceiptSourceBuilder":898,"dup":181}],794:[function(require,module,exports){
arguments[4][182][0].apply(exports,arguments)
},{"./AddressResolutionEntryBuilder":793,"./GeneratorUtils":833,"./ReceiptBuilder":897,"./UnresolvedAddressDto":913,"dup":182}],795:[function(require,module,exports){
arguments[4][183][0].apply(exports,arguments)
},{"./AggregateTransactionBodyBuilder":797,"./GeneratorUtils":833,"./TransactionBuilder":909,"dup":183}],796:[function(require,module,exports){
arguments[4][184][0].apply(exports,arguments)
},{"./AggregateTransactionBodyBuilder":797,"./GeneratorUtils":833,"./TransactionBuilder":909,"dup":184}],797:[function(require,module,exports){
arguments[4][185][0].apply(exports,arguments)
},{"./CosignatureBuilder":804,"./EmbeddedTransactionHelper":827,"./GeneratorUtils":833,"./Hash256Dto":836,"dup":185}],798:[function(require,module,exports){
arguments[4][186][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":186}],799:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"./AddressDto":790,"./GeneratorUtils":833,"./MosaicBuilder":856,"./ReceiptBuilder":897,"dup":187}],800:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"./AddressDto":790,"./GeneratorUtils":833,"./MosaicBuilder":856,"./ReceiptBuilder":897,"dup":188}],801:[function(require,module,exports){
arguments[4][189][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":189}],802:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":190}],803:[function(require,module,exports){
arguments[4][191][0].apply(exports,arguments)
},{"./AddressDto":790,"./BlockFeeMultiplierDto":802,"./DifficultyDto":806,"./GeneratorUtils":833,"./Hash256Dto":836,"./HeightDto":843,"./KeyDto":848,"./SignatureDto":907,"./TimestampDto":908,"./VrfProofBuilder":921,"dup":191}],804:[function(require,module,exports){
arguments[4][192][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./KeyDto":848,"./SignatureDto":907,"dup":192}],805:[function(require,module,exports){
arguments[4][193][0].apply(exports,arguments)
},{"./CosignatureBuilder":804,"./GeneratorUtils":833,"./Hash256Dto":836,"dup":193}],806:[function(require,module,exports){
arguments[4][194][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":194}],807:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"./AccountAddressRestrictionTransactionBodyBuilder":769,"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"dup":195}],808:[function(require,module,exports){
arguments[4][196][0].apply(exports,arguments)
},{"./AccountKeyLinkTransactionBodyBuilder":771,"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"dup":196}],809:[function(require,module,exports){
arguments[4][197][0].apply(exports,arguments)
},{"./AccountMetadataTransactionBodyBuilder":774,"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"dup":197}],810:[function(require,module,exports){
arguments[4][198][0].apply(exports,arguments)
},{"./AccountMosaicRestrictionTransactionBodyBuilder":776,"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"dup":198}],811:[function(require,module,exports){
arguments[4][199][0].apply(exports,arguments)
},{"./AccountOperationRestrictionTransactionBodyBuilder":778,"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"dup":199}],812:[function(require,module,exports){
arguments[4][200][0].apply(exports,arguments)
},{"./AddressAliasTransactionBodyBuilder":788,"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"dup":200}],813:[function(require,module,exports){
arguments[4][201][0].apply(exports,arguments)
},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./HashLockTransactionBodyBuilder":839,"dup":201}],814:[function(require,module,exports){
arguments[4][202][0].apply(exports,arguments)
},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./MosaicAddressRestrictionTransactionBodyBuilder":852,"dup":202}],815:[function(require,module,exports){
arguments[4][203][0].apply(exports,arguments)
},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./MosaicAliasTransactionBodyBuilder":854,"dup":203}],816:[function(require,module,exports){
arguments[4][204][0].apply(exports,arguments)
},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./MosaicDefinitionTransactionBodyBuilder":858,"dup":204}],817:[function(require,module,exports){
arguments[4][205][0].apply(exports,arguments)
},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./MosaicGlobalRestrictionTransactionBodyBuilder":863,"dup":205}],818:[function(require,module,exports){
arguments[4][206][0].apply(exports,arguments)
},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./MosaicMetadataTransactionBodyBuilder":866,"dup":206}],819:[function(require,module,exports){
arguments[4][207][0].apply(exports,arguments)
},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./MosaicSupplyChangeTransactionBodyBuilder":875,"dup":207}],820:[function(require,module,exports){
arguments[4][208][0].apply(exports,arguments)
},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./MultisigAccountModificationTransactionBodyBuilder":877,"dup":208}],821:[function(require,module,exports){
arguments[4][209][0].apply(exports,arguments)
},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./NamespaceMetadataTransactionBodyBuilder":885,"dup":209}],822:[function(require,module,exports){
arguments[4][210][0].apply(exports,arguments)
},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./NamespaceRegistrationTransactionBodyBuilder":888,"dup":210}],823:[function(require,module,exports){
arguments[4][211][0].apply(exports,arguments)
},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./NodeKeyLinkTransactionBodyBuilder":891,"dup":211}],824:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedSecretLockTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const SecretLockTransactionBodyBuilder_1 = require("./SecretLockTransactionBodyBuilder");
class EmbeddedSecretLockTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, recipientAddress, secret, mosaic, duration, hashAlgorithm) {
        super(signerPublicKey, version, network, type);
        this.secretLockTransactionBody = new SecretLockTransactionBodyBuilder_1.SecretLockTransactionBodyBuilder(recipientAddress, secret, mosaic, duration, hashAlgorithm);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const secretLockTransactionBody = SecretLockTransactionBodyBuilder_1.SecretLockTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, secretLockTransactionBody.getSize());
        return new EmbeddedSecretLockTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, secretLockTransactionBody.recipientAddress, secretLockTransactionBody.secret, secretLockTransactionBody.mosaic, secretLockTransactionBody.duration, secretLockTransactionBody.hashAlgorithm);
    }
    getRecipientAddress() {
        return this.secretLockTransactionBody.getRecipientAddress();
    }
    getSecret() {
        return this.secretLockTransactionBody.getSecret();
    }
    getMosaic() {
        return this.secretLockTransactionBody.getMosaic();
    }
    getDuration() {
        return this.secretLockTransactionBody.getDuration();
    }
    getHashAlgorithm() {
        return this.secretLockTransactionBody.getHashAlgorithm();
    }
    getSize() {
        let size = super.getSize();
        size += this.secretLockTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const secretLockTransactionBodyBytes = this.secretLockTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secretLockTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedSecretLockTransactionBuilder = EmbeddedSecretLockTransactionBuilder;

},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./SecretLockTransactionBodyBuilder":903}],825:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedSecretProofTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const SecretProofTransactionBodyBuilder_1 = require("./SecretProofTransactionBodyBuilder");
class EmbeddedSecretProofTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, recipientAddress, secret, hashAlgorithm, proof) {
        super(signerPublicKey, version, network, type);
        this.secretProofTransactionBody = new SecretProofTransactionBodyBuilder_1.SecretProofTransactionBodyBuilder(recipientAddress, secret, hashAlgorithm, proof);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const secretProofTransactionBody = SecretProofTransactionBodyBuilder_1.SecretProofTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, secretProofTransactionBody.getSize());
        return new EmbeddedSecretProofTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, secretProofTransactionBody.recipientAddress, secretProofTransactionBody.secret, secretProofTransactionBody.hashAlgorithm, secretProofTransactionBody.proof);
    }
    getRecipientAddress() {
        return this.secretProofTransactionBody.getRecipientAddress();
    }
    getSecret() {
        return this.secretProofTransactionBody.getSecret();
    }
    getHashAlgorithm() {
        return this.secretProofTransactionBody.getHashAlgorithm();
    }
    getProof() {
        return this.secretProofTransactionBody.getProof();
    }
    getSize() {
        let size = super.getSize();
        size += this.secretProofTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const secretProofTransactionBodyBytes = this.secretProofTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secretProofTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedSecretProofTransactionBuilder = EmbeddedSecretProofTransactionBuilder;

},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./SecretProofTransactionBodyBuilder":905}],826:[function(require,module,exports){
arguments[4][214][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./KeyDto":848,"dup":214}],827:[function(require,module,exports){
arguments[4][215][0].apply(exports,arguments)
},{"./EmbeddedAccountAddressRestrictionTransactionBuilder":807,"./EmbeddedAccountKeyLinkTransactionBuilder":808,"./EmbeddedAccountMetadataTransactionBuilder":809,"./EmbeddedAccountMosaicRestrictionTransactionBuilder":810,"./EmbeddedAccountOperationRestrictionTransactionBuilder":811,"./EmbeddedAddressAliasTransactionBuilder":812,"./EmbeddedHashLockTransactionBuilder":813,"./EmbeddedMosaicAddressRestrictionTransactionBuilder":814,"./EmbeddedMosaicAliasTransactionBuilder":815,"./EmbeddedMosaicDefinitionTransactionBuilder":816,"./EmbeddedMosaicGlobalRestrictionTransactionBuilder":817,"./EmbeddedMosaicMetadataTransactionBuilder":818,"./EmbeddedMosaicSupplyChangeTransactionBuilder":819,"./EmbeddedMultisigAccountModificationTransactionBuilder":820,"./EmbeddedNamespaceMetadataTransactionBuilder":821,"./EmbeddedNamespaceRegistrationTransactionBuilder":822,"./EmbeddedNodeKeyLinkTransactionBuilder":823,"./EmbeddedSecretLockTransactionBuilder":824,"./EmbeddedSecretProofTransactionBuilder":825,"./EmbeddedTransactionBuilder":826,"./EmbeddedTransferTransactionBuilder":828,"./EmbeddedVotingKeyLinkTransactionBuilder":829,"./EmbeddedVrfKeyLinkTransactionBuilder":830,"./EntityTypeDto":831,"./GeneratorUtils":833,"dup":215}],828:[function(require,module,exports){
arguments[4][216][0].apply(exports,arguments)
},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./TransferTransactionBodyBuilder":911,"dup":216}],829:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedVotingKeyLinkTransactionBuilder = void 0;
const EmbeddedTransactionBuilder_1 = require("./EmbeddedTransactionBuilder");
const GeneratorUtils_1 = require("./GeneratorUtils");
const VotingKeyLinkTransactionBodyBuilder_1 = require("./VotingKeyLinkTransactionBodyBuilder");
class EmbeddedVotingKeyLinkTransactionBuilder extends EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder {
    constructor(signerPublicKey, version, network, type, linkedPublicKey, startPoint, endPoint, linkAction) {
        super(signerPublicKey, version, network, type);
        this.votingKeyLinkTransactionBody = new VotingKeyLinkTransactionBodyBuilder_1.VotingKeyLinkTransactionBodyBuilder(linkedPublicKey, startPoint, endPoint, linkAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = EmbeddedTransactionBuilder_1.EmbeddedTransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const votingKeyLinkTransactionBody = VotingKeyLinkTransactionBodyBuilder_1.VotingKeyLinkTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, votingKeyLinkTransactionBody.getSize());
        return new EmbeddedVotingKeyLinkTransactionBuilder(superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, votingKeyLinkTransactionBody.linkedPublicKey, votingKeyLinkTransactionBody.startPoint, votingKeyLinkTransactionBody.endPoint, votingKeyLinkTransactionBody.linkAction);
    }
    getLinkedPublicKey() {
        return this.votingKeyLinkTransactionBody.getLinkedPublicKey();
    }
    getStartPoint() {
        return this.votingKeyLinkTransactionBody.getStartPoint();
    }
    getEndPoint() {
        return this.votingKeyLinkTransactionBody.getEndPoint();
    }
    getLinkAction() {
        return this.votingKeyLinkTransactionBody.getLinkAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.votingKeyLinkTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const votingKeyLinkTransactionBodyBytes = this.votingKeyLinkTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, votingKeyLinkTransactionBodyBytes);
        return newArray;
    }
}
exports.EmbeddedVotingKeyLinkTransactionBuilder = EmbeddedVotingKeyLinkTransactionBuilder;

},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./VotingKeyLinkTransactionBodyBuilder":917}],830:[function(require,module,exports){
arguments[4][218][0].apply(exports,arguments)
},{"./EmbeddedTransactionBuilder":826,"./GeneratorUtils":833,"./VrfKeyLinkTransactionBodyBuilder":919,"dup":218}],831:[function(require,module,exports){
arguments[4][219][0].apply(exports,arguments)
},{"dup":219}],832:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FinalizationPointDto = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
class FinalizationPointDto {
    constructor(finalizationPoint) {
        this.finalizationPoint = finalizationPoint;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const finalizationPoint = GeneratorUtils_1.GeneratorUtils.bufferToUint64(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 8));
        byteArray.splice(0, 8);
        return new FinalizationPointDto(finalizationPoint);
    }
    getFinalizationPoint() {
        return this.finalizationPoint;
    }
    getSize() {
        return 8;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const finalizationPointBytes = GeneratorUtils_1.GeneratorUtils.uint64ToBuffer(this.getFinalizationPoint());
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, finalizationPointBytes);
        return newArray;
    }
}
exports.FinalizationPointDto = FinalizationPointDto;

},{"./GeneratorUtils":833}],833:[function(require,module,exports){
arguments[4][220][0].apply(exports,arguments)
},{"dup":220}],834:[function(require,module,exports){
arguments[4][221][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicRestrictionKeyDto":874,"./RestrictionRuleBuilder":899,"dup":221}],835:[function(require,module,exports){
arguments[4][222][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./GlobalKeyValueBuilder":834,"dup":222}],836:[function(require,module,exports){
arguments[4][223][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":223}],837:[function(require,module,exports){
arguments[4][224][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":224}],838:[function(require,module,exports){
arguments[4][225][0].apply(exports,arguments)
},{"./AddressDto":790,"./GeneratorUtils":833,"./Hash256Dto":836,"./HeightDto":843,"./MosaicBuilder":856,"dup":225}],839:[function(require,module,exports){
arguments[4][226][0].apply(exports,arguments)
},{"./BlockDurationDto":801,"./GeneratorUtils":833,"./Hash256Dto":836,"./UnresolvedMosaicBuilder":914,"dup":226}],840:[function(require,module,exports){
arguments[4][227][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./HashLockTransactionBodyBuilder":839,"./TransactionBuilder":909,"dup":227}],841:[function(require,module,exports){
arguments[4][228][0].apply(exports,arguments)
},{"./AmountDto":798,"./GeneratorUtils":833,"./ImportanceHeightDto":845,"dup":228}],842:[function(require,module,exports){
arguments[4][229][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":229}],843:[function(require,module,exports){
arguments[4][230][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":230}],844:[function(require,module,exports){
arguments[4][231][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":231}],845:[function(require,module,exports){
arguments[4][232][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":232}],846:[function(require,module,exports){
arguments[4][233][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./ImportanceDto":844,"./ImportanceHeightDto":845,"dup":233}],847:[function(require,module,exports){
arguments[4][234][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicBuilder":856,"./ReceiptBuilder":897,"dup":234}],848:[function(require,module,exports){
arguments[4][235][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":235}],849:[function(require,module,exports){
arguments[4][236][0].apply(exports,arguments)
},{"./AddressDto":790,"./GeneratorUtils":833,"./MetadataValueBuilder":850,"./ScopedMetadataKeyDto":901,"dup":236}],850:[function(require,module,exports){
arguments[4][237][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":237}],851:[function(require,module,exports){
arguments[4][238][0].apply(exports,arguments)
},{"./AddressDto":790,"./AddressKeyValueSetBuilder":792,"./GeneratorUtils":833,"./MosaicIdDto":865,"dup":238}],852:[function(require,module,exports){
arguments[4][239][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./UnresolvedAddressDto":913,"./UnresolvedMosaicIdDto":915,"dup":239}],853:[function(require,module,exports){
arguments[4][240][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicAddressRestrictionTransactionBodyBuilder":852,"./TransactionBuilder":909,"dup":240}],854:[function(require,module,exports){
arguments[4][241][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicIdDto":865,"./NamespaceIdDto":883,"dup":241}],855:[function(require,module,exports){
arguments[4][242][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicAliasTransactionBodyBuilder":854,"./TransactionBuilder":909,"dup":242}],856:[function(require,module,exports){
arguments[4][243][0].apply(exports,arguments)
},{"./AmountDto":798,"./GeneratorUtils":833,"./MosaicIdDto":865,"dup":243}],857:[function(require,module,exports){
arguments[4][244][0].apply(exports,arguments)
},{"./AddressDto":790,"./GeneratorUtils":833,"./HeightDto":843,"./MosaicPropertiesBuilder":869,"dup":244}],858:[function(require,module,exports){
arguments[4][245][0].apply(exports,arguments)
},{"./BlockDurationDto":801,"./GeneratorUtils":833,"./MosaicIdDto":865,"./MosaicNonceDto":868,"dup":245}],859:[function(require,module,exports){
arguments[4][246][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicDefinitionTransactionBodyBuilder":858,"./TransactionBuilder":909,"dup":246}],860:[function(require,module,exports){
arguments[4][247][0].apply(exports,arguments)
},{"./AmountDto":798,"./GeneratorUtils":833,"./MosaicDefinitionBuilder":857,"./MosaicIdDto":865,"dup":247}],861:[function(require,module,exports){
arguments[4][248][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicIdDto":865,"./ReceiptBuilder":897,"dup":248}],862:[function(require,module,exports){
arguments[4][249][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./GlobalKeyValueSetBuilder":835,"./MosaicIdDto":865,"dup":249}],863:[function(require,module,exports){
arguments[4][250][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./UnresolvedMosaicIdDto":915,"dup":250}],864:[function(require,module,exports){
arguments[4][251][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicGlobalRestrictionTransactionBodyBuilder":863,"./TransactionBuilder":909,"dup":251}],865:[function(require,module,exports){
arguments[4][252][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":252}],866:[function(require,module,exports){
arguments[4][253][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./UnresolvedAddressDto":913,"./UnresolvedMosaicIdDto":915,"dup":253}],867:[function(require,module,exports){
arguments[4][254][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicMetadataTransactionBodyBuilder":866,"./TransactionBuilder":909,"dup":254}],868:[function(require,module,exports){
arguments[4][255][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":255}],869:[function(require,module,exports){
arguments[4][256][0].apply(exports,arguments)
},{"./BlockDurationDto":801,"./GeneratorUtils":833,"dup":256}],870:[function(require,module,exports){
arguments[4][257][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicIdDto":865,"./ReceiptSourceBuilder":898,"dup":257}],871:[function(require,module,exports){
arguments[4][258][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicResolutionEntryBuilder":870,"./ReceiptBuilder":897,"./UnresolvedMosaicIdDto":915,"dup":258}],872:[function(require,module,exports){
arguments[4][259][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicAddressRestrictionEntryBuilder":851,"./MosaicGlobalRestrictionEntryBuilder":862,"./MosaicRestrictionEntryTypeDto":873,"dup":259}],873:[function(require,module,exports){
arguments[4][260][0].apply(exports,arguments)
},{"dup":260}],874:[function(require,module,exports){
arguments[4][261][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":261}],875:[function(require,module,exports){
arguments[4][262][0].apply(exports,arguments)
},{"./AmountDto":798,"./GeneratorUtils":833,"./UnresolvedMosaicIdDto":915,"dup":262}],876:[function(require,module,exports){
arguments[4][263][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicSupplyChangeTransactionBodyBuilder":875,"./TransactionBuilder":909,"dup":263}],877:[function(require,module,exports){
arguments[4][264][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./UnresolvedAddressDto":913,"dup":264}],878:[function(require,module,exports){
arguments[4][265][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MultisigAccountModificationTransactionBodyBuilder":877,"./TransactionBuilder":909,"dup":265}],879:[function(require,module,exports){
arguments[4][266][0].apply(exports,arguments)
},{"./AddressDto":790,"./GeneratorUtils":833,"dup":266}],880:[function(require,module,exports){
arguments[4][267][0].apply(exports,arguments)
},{"./AddressDto":790,"./GeneratorUtils":833,"./MosaicIdDto":865,"./NamespaceAliasTypeDto":881,"dup":267}],881:[function(require,module,exports){
arguments[4][268][0].apply(exports,arguments)
},{"dup":268}],882:[function(require,module,exports){
arguments[4][269][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./NamespaceIdDto":883,"./ReceiptBuilder":897,"dup":269}],883:[function(require,module,exports){
arguments[4][270][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":270}],884:[function(require,module,exports){
arguments[4][271][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./HeightDto":843,"dup":271}],885:[function(require,module,exports){
arguments[4][272][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./NamespaceIdDto":883,"./UnresolvedAddressDto":913,"dup":272}],886:[function(require,module,exports){
arguments[4][273][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./NamespaceMetadataTransactionBodyBuilder":885,"./TransactionBuilder":909,"dup":273}],887:[function(require,module,exports){
arguments[4][274][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./NamespaceAliasBuilder":880,"dup":274}],888:[function(require,module,exports){
arguments[4][275][0].apply(exports,arguments)
},{"./BlockDurationDto":801,"./GeneratorUtils":833,"./NamespaceIdDto":883,"./NamespaceRegistrationTypeDto":890,"dup":275}],889:[function(require,module,exports){
arguments[4][276][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./NamespaceRegistrationTransactionBodyBuilder":888,"./TransactionBuilder":909,"dup":276}],890:[function(require,module,exports){
arguments[4][277][0].apply(exports,arguments)
},{"dup":277}],891:[function(require,module,exports){
arguments[4][278][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./KeyDto":848,"dup":278}],892:[function(require,module,exports){
arguments[4][279][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./NodeKeyLinkTransactionBodyBuilder":891,"./TransactionBuilder":909,"dup":279}],893:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PinnedVotingKeyBuilder = void 0;
const FinalizationPointDto_1 = require("./FinalizationPointDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const VotingKeyDto_1 = require("./VotingKeyDto");
class PinnedVotingKeyBuilder {
    constructor(votingKey, startPoint, endPoint) {
        this.votingKey = votingKey;
        this.startPoint = startPoint;
        this.endPoint = endPoint;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const votingKey = VotingKeyDto_1.VotingKeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, votingKey.getSize());
        const startPoint = FinalizationPointDto_1.FinalizationPointDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, startPoint.getSize());
        const endPoint = FinalizationPointDto_1.FinalizationPointDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, endPoint.getSize());
        return new PinnedVotingKeyBuilder(votingKey, startPoint, endPoint);
    }
    getVotingKey() {
        return this.votingKey;
    }
    getStartPoint() {
        return this.startPoint;
    }
    getEndPoint() {
        return this.endPoint;
    }
    getSize() {
        let size = 0;
        size += this.votingKey.getSize();
        size += this.startPoint.getSize();
        size += this.endPoint.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const votingKeyBytes = this.votingKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, votingKeyBytes);
        const startPointBytes = this.startPoint.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, startPointBytes);
        const endPointBytes = this.endPoint.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, endPointBytes);
        return newArray;
    }
}
exports.PinnedVotingKeyBuilder = PinnedVotingKeyBuilder;

},{"./FinalizationPointDto":832,"./GeneratorUtils":833,"./VotingKeyDto":916}],894:[function(require,module,exports){
arguments[4][280][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":280}],895:[function(require,module,exports){
arguments[4][281][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":281}],896:[function(require,module,exports){
arguments[4][282][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":282}],897:[function(require,module,exports){
arguments[4][283][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":283}],898:[function(require,module,exports){
arguments[4][284][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":284}],899:[function(require,module,exports){
arguments[4][285][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./MosaicIdDto":865,"dup":285}],900:[function(require,module,exports){
arguments[4][286][0].apply(exports,arguments)
},{"./AddressDto":790,"./GeneratorUtils":833,"./NamespaceIdDto":883,"./NamespaceLifetimeBuilder":884,"./NamespacePathBuilder":887,"dup":286}],901:[function(require,module,exports){
arguments[4][287][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":287}],902:[function(require,module,exports){
arguments[4][288][0].apply(exports,arguments)
},{"./AddressDto":790,"./GeneratorUtils":833,"./Hash256Dto":836,"./HeightDto":843,"./MosaicBuilder":856,"dup":288}],903:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretLockTransactionBodyBuilder = void 0;
const BlockDurationDto_1 = require("./BlockDurationDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const Hash256Dto_1 = require("./Hash256Dto");
const UnresolvedAddressDto_1 = require("./UnresolvedAddressDto");
const UnresolvedMosaicBuilder_1 = require("./UnresolvedMosaicBuilder");
class SecretLockTransactionBodyBuilder {
    constructor(recipientAddress, secret, mosaic, duration, hashAlgorithm) {
        this.recipientAddress = recipientAddress;
        this.secret = secret;
        this.mosaic = mosaic;
        this.duration = duration;
        this.hashAlgorithm = hashAlgorithm;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const recipientAddress = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, recipientAddress.getSize());
        const secret = Hash256Dto_1.Hash256Dto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, secret.getSize());
        const mosaic = UnresolvedMosaicBuilder_1.UnresolvedMosaicBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, mosaic.getSize());
        const duration = BlockDurationDto_1.BlockDurationDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, duration.getSize());
        const hashAlgorithm = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        return new SecretLockTransactionBodyBuilder(recipientAddress, secret, mosaic, duration, hashAlgorithm);
    }
    getRecipientAddress() {
        return this.recipientAddress;
    }
    getSecret() {
        return this.secret;
    }
    getMosaic() {
        return this.mosaic;
    }
    getDuration() {
        return this.duration;
    }
    getHashAlgorithm() {
        return this.hashAlgorithm;
    }
    getSize() {
        let size = 0;
        size += this.recipientAddress.getSize();
        size += this.secret.getSize();
        size += this.mosaic.getSize();
        size += this.duration.getSize();
        size += 1;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const recipientAddressBytes = this.recipientAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, recipientAddressBytes);
        const secretBytes = this.secret.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secretBytes);
        const mosaicBytes = this.mosaic.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, mosaicBytes);
        const durationBytes = this.duration.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, durationBytes);
        const hashAlgorithmBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.hashAlgorithm, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, hashAlgorithmBytes);
        return newArray;
    }
}
exports.SecretLockTransactionBodyBuilder = SecretLockTransactionBodyBuilder;

},{"./BlockDurationDto":801,"./GeneratorUtils":833,"./Hash256Dto":836,"./UnresolvedAddressDto":913,"./UnresolvedMosaicBuilder":914}],904:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretLockTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const SecretLockTransactionBodyBuilder_1 = require("./SecretLockTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class SecretLockTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, recipientAddress, secret, mosaic, duration, hashAlgorithm) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.secretLockTransactionBody = new SecretLockTransactionBodyBuilder_1.SecretLockTransactionBodyBuilder(recipientAddress, secret, mosaic, duration, hashAlgorithm);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const secretLockTransactionBody = SecretLockTransactionBodyBuilder_1.SecretLockTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, secretLockTransactionBody.getSize());
        return new SecretLockTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, secretLockTransactionBody.recipientAddress, secretLockTransactionBody.secret, secretLockTransactionBody.mosaic, secretLockTransactionBody.duration, secretLockTransactionBody.hashAlgorithm);
    }
    getRecipientAddress() {
        return this.secretLockTransactionBody.getRecipientAddress();
    }
    getSecret() {
        return this.secretLockTransactionBody.getSecret();
    }
    getMosaic() {
        return this.secretLockTransactionBody.getMosaic();
    }
    getDuration() {
        return this.secretLockTransactionBody.getDuration();
    }
    getHashAlgorithm() {
        return this.secretLockTransactionBody.getHashAlgorithm();
    }
    getSize() {
        let size = super.getSize();
        size += this.secretLockTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const secretLockTransactionBodyBytes = this.secretLockTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secretLockTransactionBodyBytes);
        return newArray;
    }
}
exports.SecretLockTransactionBuilder = SecretLockTransactionBuilder;

},{"./GeneratorUtils":833,"./SecretLockTransactionBodyBuilder":903,"./TransactionBuilder":909}],905:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretProofTransactionBodyBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const Hash256Dto_1 = require("./Hash256Dto");
const UnresolvedAddressDto_1 = require("./UnresolvedAddressDto");
class SecretProofTransactionBodyBuilder {
    constructor(recipientAddress, secret, hashAlgorithm, proof) {
        this.recipientAddress = recipientAddress;
        this.secret = secret;
        this.hashAlgorithm = hashAlgorithm;
        this.proof = proof;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const recipientAddress = UnresolvedAddressDto_1.UnresolvedAddressDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, recipientAddress.getSize());
        const secret = Hash256Dto_1.Hash256Dto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, secret.getSize());
        const proofSize = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 2));
        byteArray.splice(0, 2);
        const hashAlgorithm = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        const proof = GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), proofSize);
        byteArray.splice(0, proofSize);
        return new SecretProofTransactionBodyBuilder(recipientAddress, secret, hashAlgorithm, proof);
    }
    getRecipientAddress() {
        return this.recipientAddress;
    }
    getSecret() {
        return this.secret;
    }
    getHashAlgorithm() {
        return this.hashAlgorithm;
    }
    getProof() {
        return this.proof;
    }
    getSize() {
        let size = 0;
        size += this.recipientAddress.getSize();
        size += this.secret.getSize();
        size += 2;
        size += 1;
        size += this.proof.length;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const recipientAddressBytes = this.recipientAddress.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, recipientAddressBytes);
        const secretBytes = this.secret.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secretBytes);
        const proofSizeBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.proof.length, 2);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, proofSizeBytes);
        const hashAlgorithmBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.hashAlgorithm, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, hashAlgorithmBytes);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, this.proof);
        return newArray;
    }
}
exports.SecretProofTransactionBodyBuilder = SecretProofTransactionBodyBuilder;

},{"./GeneratorUtils":833,"./Hash256Dto":836,"./UnresolvedAddressDto":913}],906:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretProofTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const SecretProofTransactionBodyBuilder_1 = require("./SecretProofTransactionBodyBuilder");
const TransactionBuilder_1 = require("./TransactionBuilder");
class SecretProofTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, recipientAddress, secret, hashAlgorithm, proof) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.secretProofTransactionBody = new SecretProofTransactionBodyBuilder_1.SecretProofTransactionBodyBuilder(recipientAddress, secret, hashAlgorithm, proof);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const secretProofTransactionBody = SecretProofTransactionBodyBuilder_1.SecretProofTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, secretProofTransactionBody.getSize());
        return new SecretProofTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, secretProofTransactionBody.recipientAddress, secretProofTransactionBody.secret, secretProofTransactionBody.hashAlgorithm, secretProofTransactionBody.proof);
    }
    getRecipientAddress() {
        return this.secretProofTransactionBody.getRecipientAddress();
    }
    getSecret() {
        return this.secretProofTransactionBody.getSecret();
    }
    getHashAlgorithm() {
        return this.secretProofTransactionBody.getHashAlgorithm();
    }
    getProof() {
        return this.secretProofTransactionBody.getProof();
    }
    getSize() {
        let size = super.getSize();
        size += this.secretProofTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const secretProofTransactionBodyBytes = this.secretProofTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, secretProofTransactionBodyBytes);
        return newArray;
    }
}
exports.SecretProofTransactionBuilder = SecretProofTransactionBuilder;

},{"./GeneratorUtils":833,"./SecretProofTransactionBodyBuilder":905,"./TransactionBuilder":909}],907:[function(require,module,exports){
arguments[4][293][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":293}],908:[function(require,module,exports){
arguments[4][294][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":294}],909:[function(require,module,exports){
arguments[4][295][0].apply(exports,arguments)
},{"./AmountDto":798,"./GeneratorUtils":833,"./KeyDto":848,"./SignatureDto":907,"./TimestampDto":908,"dup":295}],910:[function(require,module,exports){
arguments[4][296][0].apply(exports,arguments)
},{"./AccountAddressRestrictionTransactionBuilder":770,"./AccountKeyLinkTransactionBuilder":772,"./AccountMetadataTransactionBuilder":775,"./AccountMosaicRestrictionTransactionBuilder":777,"./AccountOperationRestrictionTransactionBuilder":779,"./AddressAliasTransactionBuilder":789,"./AggregateBondedTransactionBuilder":795,"./AggregateCompleteTransactionBuilder":796,"./EntityTypeDto":831,"./HashLockTransactionBuilder":840,"./MosaicAddressRestrictionTransactionBuilder":853,"./MosaicAliasTransactionBuilder":855,"./MosaicDefinitionTransactionBuilder":859,"./MosaicGlobalRestrictionTransactionBuilder":864,"./MosaicMetadataTransactionBuilder":867,"./MosaicSupplyChangeTransactionBuilder":876,"./MultisigAccountModificationTransactionBuilder":878,"./NamespaceMetadataTransactionBuilder":886,"./NamespaceRegistrationTransactionBuilder":889,"./NodeKeyLinkTransactionBuilder":892,"./SecretLockTransactionBuilder":904,"./SecretProofTransactionBuilder":906,"./TransactionBuilder":909,"./TransferTransactionBuilder":912,"./VotingKeyLinkTransactionBuilder":918,"./VrfKeyLinkTransactionBuilder":920,"dup":296}],911:[function(require,module,exports){
arguments[4][297][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./UnresolvedAddressDto":913,"./UnresolvedMosaicBuilder":914,"dup":297}],912:[function(require,module,exports){
arguments[4][298][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./TransactionBuilder":909,"./TransferTransactionBodyBuilder":911,"dup":298}],913:[function(require,module,exports){
arguments[4][299][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":299}],914:[function(require,module,exports){
arguments[4][300][0].apply(exports,arguments)
},{"./AmountDto":798,"./GeneratorUtils":833,"./UnresolvedMosaicIdDto":915,"dup":300}],915:[function(require,module,exports){
arguments[4][301][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":301}],916:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"dup":302}],917:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VotingKeyLinkTransactionBodyBuilder = void 0;
const FinalizationPointDto_1 = require("./FinalizationPointDto");
const GeneratorUtils_1 = require("./GeneratorUtils");
const VotingKeyDto_1 = require("./VotingKeyDto");
class VotingKeyLinkTransactionBodyBuilder {
    constructor(linkedPublicKey, startPoint, endPoint, linkAction) {
        this.linkedPublicKey = linkedPublicKey;
        this.startPoint = startPoint;
        this.endPoint = endPoint;
        this.linkAction = linkAction;
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const linkedPublicKey = VotingKeyDto_1.VotingKeyDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, linkedPublicKey.getSize());
        const startPoint = FinalizationPointDto_1.FinalizationPointDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, startPoint.getSize());
        const endPoint = FinalizationPointDto_1.FinalizationPointDto.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, endPoint.getSize());
        const linkAction = GeneratorUtils_1.GeneratorUtils.bufferToUint(GeneratorUtils_1.GeneratorUtils.getBytes(Uint8Array.from(byteArray), 1));
        byteArray.splice(0, 1);
        return new VotingKeyLinkTransactionBodyBuilder(linkedPublicKey, startPoint, endPoint, linkAction);
    }
    getLinkedPublicKey() {
        return this.linkedPublicKey;
    }
    getStartPoint() {
        return this.startPoint;
    }
    getEndPoint() {
        return this.endPoint;
    }
    getLinkAction() {
        return this.linkAction;
    }
    getSize() {
        let size = 0;
        size += this.linkedPublicKey.getSize();
        size += this.startPoint.getSize();
        size += this.endPoint.getSize();
        size += 1;
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const linkedPublicKeyBytes = this.linkedPublicKey.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, linkedPublicKeyBytes);
        const startPointBytes = this.startPoint.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, startPointBytes);
        const endPointBytes = this.endPoint.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, endPointBytes);
        const linkActionBytes = GeneratorUtils_1.GeneratorUtils.uintToBuffer(this.linkAction, 1);
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, linkActionBytes);
        return newArray;
    }
}
exports.VotingKeyLinkTransactionBodyBuilder = VotingKeyLinkTransactionBodyBuilder;

},{"./FinalizationPointDto":832,"./GeneratorUtils":833,"./VotingKeyDto":916}],918:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VotingKeyLinkTransactionBuilder = void 0;
const GeneratorUtils_1 = require("./GeneratorUtils");
const TransactionBuilder_1 = require("./TransactionBuilder");
const VotingKeyLinkTransactionBodyBuilder_1 = require("./VotingKeyLinkTransactionBodyBuilder");
class VotingKeyLinkTransactionBuilder extends TransactionBuilder_1.TransactionBuilder {
    constructor(signature, signerPublicKey, version, network, type, fee, deadline, linkedPublicKey, startPoint, endPoint, linkAction) {
        super(signature, signerPublicKey, version, network, type, fee, deadline);
        this.votingKeyLinkTransactionBody = new VotingKeyLinkTransactionBodyBuilder_1.VotingKeyLinkTransactionBodyBuilder(linkedPublicKey, startPoint, endPoint, linkAction);
    }
    static loadFromBinary(payload) {
        const byteArray = Array.from(payload);
        const superObject = TransactionBuilder_1.TransactionBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, superObject.getSize());
        const votingKeyLinkTransactionBody = VotingKeyLinkTransactionBodyBuilder_1.VotingKeyLinkTransactionBodyBuilder.loadFromBinary(Uint8Array.from(byteArray));
        byteArray.splice(0, votingKeyLinkTransactionBody.getSize());
        return new VotingKeyLinkTransactionBuilder(superObject.signature, superObject.signerPublicKey, superObject.version, superObject.network, superObject.type, superObject.fee, superObject.deadline, votingKeyLinkTransactionBody.linkedPublicKey, votingKeyLinkTransactionBody.startPoint, votingKeyLinkTransactionBody.endPoint, votingKeyLinkTransactionBody.linkAction);
    }
    getLinkedPublicKey() {
        return this.votingKeyLinkTransactionBody.getLinkedPublicKey();
    }
    getStartPoint() {
        return this.votingKeyLinkTransactionBody.getStartPoint();
    }
    getEndPoint() {
        return this.votingKeyLinkTransactionBody.getEndPoint();
    }
    getLinkAction() {
        return this.votingKeyLinkTransactionBody.getLinkAction();
    }
    getSize() {
        let size = super.getSize();
        size += this.votingKeyLinkTransactionBody.getSize();
        return size;
    }
    serialize() {
        let newArray = Uint8Array.from([]);
        const superBytes = super.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, superBytes);
        const votingKeyLinkTransactionBodyBytes = this.votingKeyLinkTransactionBody.serialize();
        newArray = GeneratorUtils_1.GeneratorUtils.concatTypedArrays(newArray, votingKeyLinkTransactionBodyBytes);
        return newArray;
    }
}
exports.VotingKeyLinkTransactionBuilder = VotingKeyLinkTransactionBuilder;

},{"./GeneratorUtils":833,"./TransactionBuilder":909,"./VotingKeyLinkTransactionBodyBuilder":917}],919:[function(require,module,exports){
arguments[4][305][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./KeyDto":848,"dup":305}],920:[function(require,module,exports){
arguments[4][306][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./TransactionBuilder":909,"./VrfKeyLinkTransactionBodyBuilder":919,"dup":306}],921:[function(require,module,exports){
arguments[4][307][0].apply(exports,arguments)
},{"./GeneratorUtils":833,"./ProofGammaDto":894,"./ProofScalarDto":895,"./ProofVerificationHashDto":896,"dup":307}],922:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./AmountDto"), exports);
__exportStar(require("./BlockDurationDto"), exports);
__exportStar(require("./BlockFeeMultiplierDto"), exports);
__exportStar(require("./DifficultyDto"), exports);
__exportStar(require("./FinalizationPointDto"), exports);
__exportStar(require("./HeightDto"), exports);
__exportStar(require("./ImportanceDto"), exports);
__exportStar(require("./ImportanceHeightDto"), exports);
__exportStar(require("./UnresolvedMosaicIdDto"), exports);
__exportStar(require("./MosaicIdDto"), exports);
__exportStar(require("./TimestampDto"), exports);
__exportStar(require("./UnresolvedAddressDto"), exports);
__exportStar(require("./AddressDto"), exports);
__exportStar(require("./Hash256Dto"), exports);
__exportStar(require("./Hash512Dto"), exports);
__exportStar(require("./KeyDto"), exports);
__exportStar(require("./VotingKeyDto"), exports);
__exportStar(require("./SignatureDto"), exports);
__exportStar(require("./MosaicBuilder"), exports);
__exportStar(require("./UnresolvedMosaicBuilder"), exports);
__exportStar(require("./ProofGammaDto"), exports);
__exportStar(require("./ProofVerificationHashDto"), exports);
__exportStar(require("./ProofScalarDto"), exports);
__exportStar(require("./VrfProofBuilder"), exports);
__exportStar(require("./BlockHeaderBuilder"), exports);
__exportStar(require("./ReceiptBuilder"), exports);
__exportStar(require("./BalanceTransferReceiptBuilder"), exports);
__exportStar(require("./BalanceChangeReceiptBuilder"), exports);
__exportStar(require("./InflationReceiptBuilder"), exports);
__exportStar(require("./MosaicExpiryReceiptBuilder"), exports);
__exportStar(require("./NamespaceIdDto"), exports);
__exportStar(require("./NamespaceExpiryReceiptBuilder"), exports);
__exportStar(require("./ReceiptSourceBuilder"), exports);
__exportStar(require("./AddressResolutionEntryBuilder"), exports);
__exportStar(require("./MosaicResolutionEntryBuilder"), exports);
__exportStar(require("./MosaicResolutionStatementBuilder"), exports);
__exportStar(require("./AddressResolutionStatementBuilder"), exports);
__exportStar(require("./PinnedVotingKeyBuilder"), exports);
__exportStar(require("./ImportanceSnapshotBuilder"), exports);
__exportStar(require("./HeightActivityBucketBuilder"), exports);
__exportStar(require("./HeightActivityBucketsBuilder"), exports);
__exportStar(require("./AccountStateBuilder"), exports);
__exportStar(require("./HashLockInfoBuilder"), exports);
__exportStar(require("./ScopedMetadataKeyDto"), exports);
__exportStar(require("./MetadataValueBuilder"), exports);
__exportStar(require("./MetadataEntryBuilder"), exports);
__exportStar(require("./MosaicNonceDto"), exports);
__exportStar(require("./MosaicPropertiesBuilder"), exports);
__exportStar(require("./MosaicDefinitionBuilder"), exports);
__exportStar(require("./MosaicEntryBuilder"), exports);
__exportStar(require("./MultisigEntryBuilder"), exports);
__exportStar(require("./TransactionBuilder"), exports);
__exportStar(require("./EmbeddedTransactionBuilder"), exports);
__exportStar(require("./MosaicDefinitionTransactionBodyBuilder"), exports);
__exportStar(require("./MosaicDefinitionTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMosaicDefinitionTransactionBuilder"), exports);
__exportStar(require("./NamespaceLifetimeBuilder"), exports);
__exportStar(require("./NamespaceAliasBuilder"), exports);
__exportStar(require("./NamespacePathBuilder"), exports);
__exportStar(require("./RootNamespaceHistoryBuilder"), exports);
__exportStar(require("./AccountRestrictionAddressValueBuilder"), exports);
__exportStar(require("./AccountRestrictionMosaicValueBuilder"), exports);
__exportStar(require("./AccountRestrictionTransactionTypeValueBuilder"), exports);
__exportStar(require("./AccountRestrictionsInfoBuilder"), exports);
__exportStar(require("./AccountRestrictionsBuilder"), exports);
__exportStar(require("./MosaicRestrictionKeyDto"), exports);
__exportStar(require("./AddressKeyValueBuilder"), exports);
__exportStar(require("./AddressKeyValueSetBuilder"), exports);
__exportStar(require("./RestrictionRuleBuilder"), exports);
__exportStar(require("./GlobalKeyValueBuilder"), exports);
__exportStar(require("./GlobalKeyValueSetBuilder"), exports);
__exportStar(require("./MosaicAddressRestrictionEntryBuilder"), exports);
__exportStar(require("./MosaicGlobalRestrictionEntryBuilder"), exports);
__exportStar(require("./MosaicRestrictionEntryBuilder"), exports);
__exportStar(require("./SecretLockInfoBuilder"), exports);
__exportStar(require("./AccountKeyLinkTransactionBodyBuilder"), exports);
__exportStar(require("./AccountKeyLinkTransactionBuilder"), exports);
__exportStar(require("./EmbeddedAccountKeyLinkTransactionBuilder"), exports);
__exportStar(require("./NodeKeyLinkTransactionBodyBuilder"), exports);
__exportStar(require("./NodeKeyLinkTransactionBuilder"), exports);
__exportStar(require("./EmbeddedNodeKeyLinkTransactionBuilder"), exports);
__exportStar(require("./CosignatureBuilder"), exports);
__exportStar(require("./DetachedCosignatureBuilder"), exports);
__exportStar(require("./AggregateTransactionBodyBuilder"), exports);
__exportStar(require("./AggregateCompleteTransactionBuilder"), exports);
__exportStar(require("./AggregateBondedTransactionBuilder"), exports);
__exportStar(require("./VotingKeyLinkTransactionBodyBuilder"), exports);
__exportStar(require("./VotingKeyLinkTransactionBuilder"), exports);
__exportStar(require("./EmbeddedVotingKeyLinkTransactionBuilder"), exports);
__exportStar(require("./VrfKeyLinkTransactionBodyBuilder"), exports);
__exportStar(require("./VrfKeyLinkTransactionBuilder"), exports);
__exportStar(require("./EmbeddedVrfKeyLinkTransactionBuilder"), exports);
__exportStar(require("./HashLockTransactionBodyBuilder"), exports);
__exportStar(require("./HashLockTransactionBuilder"), exports);
__exportStar(require("./EmbeddedHashLockTransactionBuilder"), exports);
__exportStar(require("./SecretLockTransactionBodyBuilder"), exports);
__exportStar(require("./SecretLockTransactionBuilder"), exports);
__exportStar(require("./EmbeddedSecretLockTransactionBuilder"), exports);
__exportStar(require("./SecretProofTransactionBodyBuilder"), exports);
__exportStar(require("./SecretProofTransactionBuilder"), exports);
__exportStar(require("./EmbeddedSecretProofTransactionBuilder"), exports);
__exportStar(require("./AccountMetadataTransactionBodyBuilder"), exports);
__exportStar(require("./AccountMetadataTransactionBuilder"), exports);
__exportStar(require("./EmbeddedAccountMetadataTransactionBuilder"), exports);
__exportStar(require("./MosaicMetadataTransactionBodyBuilder"), exports);
__exportStar(require("./MosaicMetadataTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMosaicMetadataTransactionBuilder"), exports);
__exportStar(require("./NamespaceMetadataTransactionBodyBuilder"), exports);
__exportStar(require("./NamespaceMetadataTransactionBuilder"), exports);
__exportStar(require("./EmbeddedNamespaceMetadataTransactionBuilder"), exports);
__exportStar(require("./MosaicSupplyChangeTransactionBodyBuilder"), exports);
__exportStar(require("./MosaicSupplyChangeTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMosaicSupplyChangeTransactionBuilder"), exports);
__exportStar(require("./MultisigAccountModificationTransactionBodyBuilder"), exports);
__exportStar(require("./MultisigAccountModificationTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMultisigAccountModificationTransactionBuilder"), exports);
__exportStar(require("./AddressAliasTransactionBodyBuilder"), exports);
__exportStar(require("./AddressAliasTransactionBuilder"), exports);
__exportStar(require("./EmbeddedAddressAliasTransactionBuilder"), exports);
__exportStar(require("./MosaicAliasTransactionBodyBuilder"), exports);
__exportStar(require("./MosaicAliasTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMosaicAliasTransactionBuilder"), exports);
__exportStar(require("./NamespaceRegistrationTransactionBodyBuilder"), exports);
__exportStar(require("./NamespaceRegistrationTransactionBuilder"), exports);
__exportStar(require("./EmbeddedNamespaceRegistrationTransactionBuilder"), exports);
__exportStar(require("./AccountAddressRestrictionTransactionBodyBuilder"), exports);
__exportStar(require("./AccountAddressRestrictionTransactionBuilder"), exports);
__exportStar(require("./EmbeddedAccountAddressRestrictionTransactionBuilder"), exports);
__exportStar(require("./AccountMosaicRestrictionTransactionBodyBuilder"), exports);
__exportStar(require("./AccountMosaicRestrictionTransactionBuilder"), exports);
__exportStar(require("./EmbeddedAccountMosaicRestrictionTransactionBuilder"), exports);
__exportStar(require("./AccountOperationRestrictionTransactionBodyBuilder"), exports);
__exportStar(require("./AccountOperationRestrictionTransactionBuilder"), exports);
__exportStar(require("./EmbeddedAccountOperationRestrictionTransactionBuilder"), exports);
__exportStar(require("./MosaicAddressRestrictionTransactionBodyBuilder"), exports);
__exportStar(require("./MosaicAddressRestrictionTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMosaicAddressRestrictionTransactionBuilder"), exports);
__exportStar(require("./MosaicGlobalRestrictionTransactionBodyBuilder"), exports);
__exportStar(require("./MosaicGlobalRestrictionTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMosaicGlobalRestrictionTransactionBuilder"), exports);
__exportStar(require("./TransferTransactionBodyBuilder"), exports);
__exportStar(require("./TransferTransactionBuilder"), exports);
__exportStar(require("./EmbeddedTransferTransactionBuilder"), exports);
__exportStar(require("./EmbeddedTransactionHelper"), exports);
__exportStar(require("./TransactionHelper"), exports);
__exportStar(require("./GeneratorUtils"), exports);

},{"./AccountAddressRestrictionTransactionBodyBuilder":769,"./AccountAddressRestrictionTransactionBuilder":770,"./AccountKeyLinkTransactionBodyBuilder":771,"./AccountKeyLinkTransactionBuilder":772,"./AccountMetadataTransactionBodyBuilder":774,"./AccountMetadataTransactionBuilder":775,"./AccountMosaicRestrictionTransactionBodyBuilder":776,"./AccountMosaicRestrictionTransactionBuilder":777,"./AccountOperationRestrictionTransactionBodyBuilder":778,"./AccountOperationRestrictionTransactionBuilder":779,"./AccountRestrictionAddressValueBuilder":780,"./AccountRestrictionMosaicValueBuilder":782,"./AccountRestrictionTransactionTypeValueBuilder":783,"./AccountRestrictionsBuilder":784,"./AccountRestrictionsInfoBuilder":785,"./AccountStateBuilder":786,"./AddressAliasTransactionBodyBuilder":788,"./AddressAliasTransactionBuilder":789,"./AddressDto":790,"./AddressKeyValueBuilder":791,"./AddressKeyValueSetBuilder":792,"./AddressResolutionEntryBuilder":793,"./AddressResolutionStatementBuilder":794,"./AggregateBondedTransactionBuilder":795,"./AggregateCompleteTransactionBuilder":796,"./AggregateTransactionBodyBuilder":797,"./AmountDto":798,"./BalanceChangeReceiptBuilder":799,"./BalanceTransferReceiptBuilder":800,"./BlockDurationDto":801,"./BlockFeeMultiplierDto":802,"./BlockHeaderBuilder":803,"./CosignatureBuilder":804,"./DetachedCosignatureBuilder":805,"./DifficultyDto":806,"./EmbeddedAccountAddressRestrictionTransactionBuilder":807,"./EmbeddedAccountKeyLinkTransactionBuilder":808,"./EmbeddedAccountMetadataTransactionBuilder":809,"./EmbeddedAccountMosaicRestrictionTransactionBuilder":810,"./EmbeddedAccountOperationRestrictionTransactionBuilder":811,"./EmbeddedAddressAliasTransactionBuilder":812,"./EmbeddedHashLockTransactionBuilder":813,"./EmbeddedMosaicAddressRestrictionTransactionBuilder":814,"./EmbeddedMosaicAliasTransactionBuilder":815,"./EmbeddedMosaicDefinitionTransactionBuilder":816,"./EmbeddedMosaicGlobalRestrictionTransactionBuilder":817,"./EmbeddedMosaicMetadataTransactionBuilder":818,"./EmbeddedMosaicSupplyChangeTransactionBuilder":819,"./EmbeddedMultisigAccountModificationTransactionBuilder":820,"./EmbeddedNamespaceMetadataTransactionBuilder":821,"./EmbeddedNamespaceRegistrationTransactionBuilder":822,"./EmbeddedNodeKeyLinkTransactionBuilder":823,"./EmbeddedSecretLockTransactionBuilder":824,"./EmbeddedSecretProofTransactionBuilder":825,"./EmbeddedTransactionBuilder":826,"./EmbeddedTransactionHelper":827,"./EmbeddedTransferTransactionBuilder":828,"./EmbeddedVotingKeyLinkTransactionBuilder":829,"./EmbeddedVrfKeyLinkTransactionBuilder":830,"./FinalizationPointDto":832,"./GeneratorUtils":833,"./GlobalKeyValueBuilder":834,"./GlobalKeyValueSetBuilder":835,"./Hash256Dto":836,"./Hash512Dto":837,"./HashLockInfoBuilder":838,"./HashLockTransactionBodyBuilder":839,"./HashLockTransactionBuilder":840,"./HeightActivityBucketBuilder":841,"./HeightActivityBucketsBuilder":842,"./HeightDto":843,"./ImportanceDto":844,"./ImportanceHeightDto":845,"./ImportanceSnapshotBuilder":846,"./InflationReceiptBuilder":847,"./KeyDto":848,"./MetadataEntryBuilder":849,"./MetadataValueBuilder":850,"./MosaicAddressRestrictionEntryBuilder":851,"./MosaicAddressRestrictionTransactionBodyBuilder":852,"./MosaicAddressRestrictionTransactionBuilder":853,"./MosaicAliasTransactionBodyBuilder":854,"./MosaicAliasTransactionBuilder":855,"./MosaicBuilder":856,"./MosaicDefinitionBuilder":857,"./MosaicDefinitionTransactionBodyBuilder":858,"./MosaicDefinitionTransactionBuilder":859,"./MosaicEntryBuilder":860,"./MosaicExpiryReceiptBuilder":861,"./MosaicGlobalRestrictionEntryBuilder":862,"./MosaicGlobalRestrictionTransactionBodyBuilder":863,"./MosaicGlobalRestrictionTransactionBuilder":864,"./MosaicIdDto":865,"./MosaicMetadataTransactionBodyBuilder":866,"./MosaicMetadataTransactionBuilder":867,"./MosaicNonceDto":868,"./MosaicPropertiesBuilder":869,"./MosaicResolutionEntryBuilder":870,"./MosaicResolutionStatementBuilder":871,"./MosaicRestrictionEntryBuilder":872,"./MosaicRestrictionKeyDto":874,"./MosaicSupplyChangeTransactionBodyBuilder":875,"./MosaicSupplyChangeTransactionBuilder":876,"./MultisigAccountModificationTransactionBodyBuilder":877,"./MultisigAccountModificationTransactionBuilder":878,"./MultisigEntryBuilder":879,"./NamespaceAliasBuilder":880,"./NamespaceExpiryReceiptBuilder":882,"./NamespaceIdDto":883,"./NamespaceLifetimeBuilder":884,"./NamespaceMetadataTransactionBodyBuilder":885,"./NamespaceMetadataTransactionBuilder":886,"./NamespacePathBuilder":887,"./NamespaceRegistrationTransactionBodyBuilder":888,"./NamespaceRegistrationTransactionBuilder":889,"./NodeKeyLinkTransactionBodyBuilder":891,"./NodeKeyLinkTransactionBuilder":892,"./PinnedVotingKeyBuilder":893,"./ProofGammaDto":894,"./ProofScalarDto":895,"./ProofVerificationHashDto":896,"./ReceiptBuilder":897,"./ReceiptSourceBuilder":898,"./RestrictionRuleBuilder":899,"./RootNamespaceHistoryBuilder":900,"./ScopedMetadataKeyDto":901,"./SecretLockInfoBuilder":902,"./SecretLockTransactionBodyBuilder":903,"./SecretLockTransactionBuilder":904,"./SecretProofTransactionBodyBuilder":905,"./SecretProofTransactionBuilder":906,"./SignatureDto":907,"./TimestampDto":908,"./TransactionBuilder":909,"./TransactionHelper":910,"./TransferTransactionBodyBuilder":911,"./TransferTransactionBuilder":912,"./UnresolvedAddressDto":913,"./UnresolvedMosaicBuilder":914,"./UnresolvedMosaicIdDto":915,"./VotingKeyDto":916,"./VotingKeyLinkTransactionBodyBuilder":917,"./VotingKeyLinkTransactionBuilder":918,"./VrfKeyLinkTransactionBodyBuilder":919,"./VrfKeyLinkTransactionBuilder":920,"./VrfProofBuilder":921}],923:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class AccountRoutesApi extends runtime.BaseAPI {
    /**
     * Returns the account information.
     * Get account information
     */
    getAccountInfoRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
                throw new runtime.RequiredError('accountId', 'Required parameter requestParameters.accountId was null or undefined when calling getAccountInfo.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/accounts/{accountId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.AccountInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns the account information.
     * Get account information
     */
    getAccountInfo(accountId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getAccountInfoRaw({ accountId: accountId });
            return yield response.value();
        });
    }
    /**
     * Returns the account information for an array of accounts.
     * Get accounts information
     */
    getAccountsInfoRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/accounts`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.AccountIdsToJSON(requestParameters.accountIds),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.AccountInfoDTOFromJSON));
        });
    }
    /**
     * Returns the account information for an array of accounts.
     * Get accounts information
     */
    getAccountsInfo(accountIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getAccountsInfoRaw({ accountIds: accountIds });
            return yield response.value();
        });
    }
    /**
     * Gets an array of accounts.
     * Search accounts
     */
    searchAccountsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            if (requestParameters.orderBy !== undefined) {
                queryParameters['orderBy'] = requestParameters.orderBy;
            }
            if (requestParameters.mosaicId !== undefined) {
                queryParameters['mosaicId'] = requestParameters.mosaicId;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/accounts`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.AccountPageFromJSON(jsonValue));
        });
    }
    /**
     * Gets an array of accounts.
     * Search accounts
     */
    searchAccounts(pageSize, pageNumber, offset, order, orderBy, mosaicId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchAccountsRaw({ pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order, orderBy: orderBy, mosaicId: mosaicId });
            return yield response.value();
        });
    }
}
exports.AccountRoutesApi = AccountRoutesApi;

},{"../models":1157,"../runtime":1158}],924:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class BlockRoutesApi extends runtime.BaseAPI {
    /**
     * Gets a block from the chain that has the given height.
     * Get block information
     */
    getBlockByHeightRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.height === null || requestParameters.height === undefined) {
                throw new runtime.RequiredError('height', 'Required parameter requestParameters.height was null or undefined when calling getBlockByHeight.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/blocks/{height}`.replace(`{${"height"}}`, encodeURIComponent(String(requestParameters.height))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.BlockInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Gets a block from the chain that has the given height.
     * Get block information
     */
    getBlockByHeight(height) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getBlockByHeightRaw({ height: height });
            return yield response.value();
        });
    }
    /**
     * Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block.
     * Get the merkle path for a given a receipt statement hash and block
     */
    getMerkleReceiptsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.height === null || requestParameters.height === undefined) {
                throw new runtime.RequiredError('height', 'Required parameter requestParameters.height was null or undefined when calling getMerkleReceipts.');
            }
            if (requestParameters.hash === null || requestParameters.hash === undefined) {
                throw new runtime.RequiredError('hash', 'Required parameter requestParameters.hash was null or undefined when calling getMerkleReceipts.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/blocks/{height}/statements/{hash}/merkle`.replace(`{${"height"}}`, encodeURIComponent(String(requestParameters.height))).replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.MerkleProofInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block.
     * Get the merkle path for a given a receipt statement hash and block
     */
    getMerkleReceipts(height, hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getMerkleReceiptsRaw({ height: height, hash: hash });
            return yield response.value();
        });
    }
    /**
     * Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block.
     * Get the merkle path for a given a transaction and block
     */
    getMerkleTransactionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.height === null || requestParameters.height === undefined) {
                throw new runtime.RequiredError('height', 'Required parameter requestParameters.height was null or undefined when calling getMerkleTransaction.');
            }
            if (requestParameters.hash === null || requestParameters.hash === undefined) {
                throw new runtime.RequiredError('hash', 'Required parameter requestParameters.hash was null or undefined when calling getMerkleTransaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/blocks/{height}/transactions/{hash}/merkle`.replace(`{${"height"}}`, encodeURIComponent(String(requestParameters.height))).replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.MerkleProofInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block.
     * Get the merkle path for a given a transaction and block
     */
    getMerkleTransaction(height, hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getMerkleTransactionRaw({ height: height, hash: hash });
            return yield response.value();
        });
    }
    /**
     * Gets an array of bocks.
     * Search blocks
     */
    searchBlocksRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.signerPublicKey !== undefined) {
                queryParameters['signerPublicKey'] = requestParameters.signerPublicKey;
            }
            if (requestParameters.beneficiaryAddress !== undefined) {
                queryParameters['beneficiaryAddress'] = requestParameters.beneficiaryAddress;
            }
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            if (requestParameters.orderBy !== undefined) {
                queryParameters['orderBy'] = requestParameters.orderBy;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/blocks`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.BlockPageFromJSON(jsonValue));
        });
    }
    /**
     * Gets an array of bocks.
     * Search blocks
     */
    searchBlocks(signerPublicKey, beneficiaryAddress, pageSize, pageNumber, offset, order, orderBy) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchBlocksRaw({ signerPublicKey: signerPublicKey, beneficiaryAddress: beneficiaryAddress, pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order, orderBy: orderBy });
            return yield response.value();
        });
    }
}
exports.BlockRoutesApi = BlockRoutesApi;

},{"../models":1157,"../runtime":1158}],925:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class ChainRoutesApi extends runtime.BaseAPI {
    /**
     * Returns the current height of the blockchain.
     * Get the current height of the chain
     */
    getChainHeightRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/chain/height`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.HeightInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns the current height of the blockchain.
     * Get the current height of the chain
     */
    getChainHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getChainHeightRaw();
            return yield response.value();
        });
    }
    /**
     * Gets the current score of the blockchain. The higher the score, the better the chain. During synchronization, nodes try to get the best blockchain in the network.  The score for a block is derived from its difficulty and the time (in seconds) that has elapsed since the last block:      block score = difficulty − time elapsed since last block
     * Get the current score of the chain
     */
    getChainScoreRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/chain/score`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.ChainScoreDTOFromJSON(jsonValue));
        });
    }
    /**
     * Gets the current score of the blockchain. The higher the score, the better the chain. During synchronization, nodes try to get the best blockchain in the network.  The score for a block is derived from its difficulty and the time (in seconds) that has elapsed since the last block:      block score = difficulty − time elapsed since last block
     * Get the current score of the chain
     */
    getChainScore() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getChainScoreRaw();
            return yield response.value();
        });
    }
}
exports.ChainRoutesApi = ChainRoutesApi;

},{"../models":1157,"../runtime":1158}],926:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class MetadataRoutesApi extends runtime.BaseAPI {
    /**
     * Returns an array of metadata.
     * Search metadata entries
     */
    searchMetadataEntriesRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.sourceAddress !== undefined) {
                queryParameters['sourceAddress'] = requestParameters.sourceAddress;
            }
            if (requestParameters.targetAddress !== undefined) {
                queryParameters['targetAddress'] = requestParameters.targetAddress;
            }
            if (requestParameters.scopedMetadataKey !== undefined) {
                queryParameters['scopedMetadataKey'] = requestParameters.scopedMetadataKey;
            }
            if (requestParameters.targetId !== undefined) {
                queryParameters['targetId'] = requestParameters.targetId;
            }
            if (requestParameters.metadataType !== undefined) {
                queryParameters['metadataType'] = requestParameters.metadataType;
            }
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/metadata`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.MetadataPageFromJSON(jsonValue));
        });
    }
    /**
     * Returns an array of metadata.
     * Search metadata entries
     */
    searchMetadataEntries(sourceAddress, targetAddress, scopedMetadataKey, targetId, metadataType, pageSize, pageNumber, offset, order) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchMetadataEntriesRaw({ sourceAddress: sourceAddress, targetAddress: targetAddress, scopedMetadataKey: scopedMetadataKey, targetId: targetId, metadataType: metadataType, pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order });
            return yield response.value();
        });
    }
}
exports.MetadataRoutesApi = MetadataRoutesApi;

},{"../models":1157,"../runtime":1158}],927:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class MosaicRoutesApi extends runtime.BaseAPI {
    /**
     * Gets the mosaic definition for a given mosaic identifier.
     * Get mosaic information
     */
    getMosaicRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.mosaicId === null || requestParameters.mosaicId === undefined) {
                throw new runtime.RequiredError('mosaicId', 'Required parameter requestParameters.mosaicId was null or undefined when calling getMosaic.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/mosaics/{mosaicId}`.replace(`{${"mosaicId"}}`, encodeURIComponent(String(requestParameters.mosaicId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.MosaicInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Gets the mosaic definition for a given mosaic identifier.
     * Get mosaic information
     */
    getMosaic(mosaicId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getMosaicRaw({ mosaicId: mosaicId });
            return yield response.value();
        });
    }
    /**
     * Gets an array of mosaic definition.
     * Get mosaics information for an array of mosaics
     */
    getMosaicsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.mosaicIds === null || requestParameters.mosaicIds === undefined) {
                throw new runtime.RequiredError('mosaicIds', 'Required parameter requestParameters.mosaicIds was null or undefined when calling getMosaics.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/mosaics`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.MosaicIdsToJSON(requestParameters.mosaicIds),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.MosaicInfoDTOFromJSON));
        });
    }
    /**
     * Gets an array of mosaic definition.
     * Get mosaics information for an array of mosaics
     */
    getMosaics(mosaicIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getMosaicsRaw({ mosaicIds: mosaicIds });
            return yield response.value();
        });
    }
    /**
     * Gets an array of mosaics.
     * Search mosaics
     */
    searchMosaicsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.ownerAddress !== undefined) {
                queryParameters['ownerAddress'] = requestParameters.ownerAddress;
            }
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/mosaics`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.MosaicPageFromJSON(jsonValue));
        });
    }
    /**
     * Gets an array of mosaics.
     * Search mosaics
     */
    searchMosaics(ownerAddress, pageSize, pageNumber, offset, order) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchMosaicsRaw({ ownerAddress: ownerAddress, pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order });
            return yield response.value();
        });
    }
}
exports.MosaicRoutesApi = MosaicRoutesApi;

},{"../models":1157,"../runtime":1158}],928:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class MultisigRoutesApi extends runtime.BaseAPI {
    /**
     * Returns the multisig account information.
     * Get multisig account information
     */
    getAccountMultisigRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.address === null || requestParameters.address === undefined) {
                throw new runtime.RequiredError('address', 'Required parameter requestParameters.address was null or undefined when calling getAccountMultisig.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/account/{address}/multisig`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters.address))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.MultisigAccountInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns the multisig account information.
     * Get multisig account information
     */
    getAccountMultisig(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getAccountMultisigRaw({ address: address });
            return yield response.value();
        });
    }
    /**
     * Returns the multisig account graph.
     * Get multisig account graph information
     */
    getAccountMultisigGraphRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.address === null || requestParameters.address === undefined) {
                throw new runtime.RequiredError('address', 'Required parameter requestParameters.address was null or undefined when calling getAccountMultisigGraph.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/account/{address}/multisig/graph`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters.address))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.MultisigAccountGraphInfoDTOFromJSON));
        });
    }
    /**
     * Returns the multisig account graph.
     * Get multisig account graph information
     */
    getAccountMultisigGraph(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getAccountMultisigGraphRaw({ address: address });
            return yield response.value();
        });
    }
}
exports.MultisigRoutesApi = MultisigRoutesApi;

},{"../models":1157,"../runtime":1158}],929:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class NamespaceRoutesApi extends runtime.BaseAPI {
    /**
     * Returns friendly names for accounts.
     * Get readable names for a set of accountIds
     */
    getAccountsNamesRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.addresses === null || requestParameters.addresses === undefined) {
                throw new runtime.RequiredError('addresses', 'Required parameter requestParameters.addresses was null or undefined when calling getAccountsNames.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/namespaces/account/names`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.AddressesToJSON(requestParameters.addresses),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.AccountsNamesDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns friendly names for accounts.
     * Get readable names for a set of accountIds
     */
    getAccountsNames(addresses) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getAccountsNamesRaw({ addresses: addresses });
            return yield response.value();
        });
    }
    /**
     * Returns friendly names for mosaics.
     * Get readable names for a set of mosaics
     */
    getMosaicsNamesRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.mosaicIds === null || requestParameters.mosaicIds === undefined) {
                throw new runtime.RequiredError('mosaicIds', 'Required parameter requestParameters.mosaicIds was null or undefined when calling getMosaicsNames.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/namespaces/mosaic/names`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.MosaicIdsToJSON(requestParameters.mosaicIds),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.MosaicsNamesDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns friendly names for mosaics.
     * Get readable names for a set of mosaics
     */
    getMosaicsNames(mosaicIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getMosaicsNamesRaw({ mosaicIds: mosaicIds });
            return yield response.value();
        });
    }
    /**
     * Gets the namespace for a given namespace identifier.
     * Get namespace information
     */
    getNamespaceRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.namespaceId === null || requestParameters.namespaceId === undefined) {
                throw new runtime.RequiredError('namespaceId', 'Required parameter requestParameters.namespaceId was null or undefined when calling getNamespace.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/namespaces/{namespaceId}`.replace(`{${"namespaceId"}}`, encodeURIComponent(String(requestParameters.namespaceId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.NamespaceInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Gets the namespace for a given namespace identifier.
     * Get namespace information
     */
    getNamespace(namespaceId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNamespaceRaw({ namespaceId: namespaceId });
            return yield response.value();
        });
    }
    /**
     * Returns friendly names for namespaces.
     * Get readable names for a set of namespaces
     */
    getNamespacesNamesRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.namespaceIds === null || requestParameters.namespaceIds === undefined) {
                throw new runtime.RequiredError('namespaceIds', 'Required parameter requestParameters.namespaceIds was null or undefined when calling getNamespacesNames.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/namespaces/names`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.NamespaceIdsToJSON(requestParameters.namespaceIds),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.NamespaceNameDTOFromJSON));
        });
    }
    /**
     * Returns friendly names for namespaces.
     * Get readable names for a set of namespaces
     */
    getNamespacesNames(namespaceIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNamespacesNamesRaw({ namespaceIds: namespaceIds });
            return yield response.value();
        });
    }
    /**
     * Gets an array of namespaces.
     * Search namespaces
     */
    searchNamespacesRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.ownerAddress !== undefined) {
                queryParameters['ownerAddress'] = requestParameters.ownerAddress;
            }
            if (requestParameters.registrationType !== undefined) {
                queryParameters['registrationType'] = requestParameters.registrationType;
            }
            if (requestParameters.level0 !== undefined) {
                queryParameters['level0'] = requestParameters.level0;
            }
            if (requestParameters.aliasType !== undefined) {
                queryParameters['aliasType'] = requestParameters.aliasType;
            }
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/namespaces`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.NamespacePageFromJSON(jsonValue));
        });
    }
    /**
     * Gets an array of namespaces.
     * Search namespaces
     */
    searchNamespaces(ownerAddress, registrationType, level0, aliasType, pageSize, pageNumber, offset, order) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchNamespacesRaw({ ownerAddress: ownerAddress, registrationType: registrationType, level0: level0, aliasType: aliasType, pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order });
            return yield response.value();
        });
    }
}
exports.NamespaceRoutesApi = NamespaceRoutesApi;

},{"../models":1157,"../runtime":1158}],930:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class NetworkRoutesApi extends runtime.BaseAPI {
    /**
     * Returns the content from a catapult-server network configuration file (resources/config-network.properties). To enable this feature, the REST setting \"network.propertiesFilePath\" must define where the file is located. This is adjustable via the configuration file (rest/resources/rest.json) per REST instance.
     * Get the network properties
     */
    getNetworkPropertiesRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/network/properties`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.NetworkConfigurationDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns the content from a catapult-server network configuration file (resources/config-network.properties). To enable this feature, the REST setting \"network.propertiesFilePath\" must define where the file is located. This is adjustable via the configuration file (rest/resources/rest.json) per REST instance.
     * Get the network properties
     */
    getNetworkProperties() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNetworkPropertiesRaw();
            return yield response.value();
        });
    }
    /**
     * Returns the current network type.
     * Get the current network type of the chain
     */
    getNetworkTypeRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/network`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.NetworkTypeDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns the current network type.
     * Get the current network type of the chain
     */
    getNetworkType() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNetworkTypeRaw();
            return yield response.value();
        });
    }
    /**
     * Returns the estimated effective rental fees for namespaces and mosaics. This endpoint is only available if the REST instance has access to catapult-server ``resources/config-network.properties`` file. To activate this feature, add the setting \"network.propertiesFilePath\" in the configuration file (rest/resources/rest.json).
     * Get rental fees information
     */
    getRentalFeesRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/network/fees/rental`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.RentalFeesDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns the estimated effective rental fees for namespaces and mosaics. This endpoint is only available if the REST instance has access to catapult-server ``resources/config-network.properties`` file. To activate this feature, add the setting \"network.propertiesFilePath\" in the configuration file (rest/resources/rest.json).
     * Get rental fees information
     */
    getRentalFees() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getRentalFeesRaw();
            return yield response.value();
        });
    }
    /**
     * Returns the average, median, highest and lower fee multiplier over the last \"numBlocksTransactionFeeStats\". The setting \"numBlocksTransactionFeeStats\" is adjustable via the configuration file (rest/resources/rest.json) per REST instance.
     * Get transaction fees information
     */
    getTransactionFeesRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/network/fees/transaction`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionFeesDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns the average, median, highest and lower fee multiplier over the last \"numBlocksTransactionFeeStats\". The setting \"numBlocksTransactionFeeStats\" is adjustable via the configuration file (rest/resources/rest.json) per REST instance.
     * Get transaction fees information
     */
    getTransactionFees() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getTransactionFeesRaw();
            return yield response.value();
        });
    }
}
exports.NetworkRoutesApi = NetworkRoutesApi;

},{"../models":1157,"../runtime":1158}],931:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class NodeRoutesApi extends runtime.BaseAPI {
    /**
     * Supplies information regarding the connection and services status.
     * Get the node health information
     */
    getNodeHealthRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/node/health`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.NodeHealthInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Supplies information regarding the connection and services status.
     * Get the node health information
     */
    getNodeHealth() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNodeHealthRaw();
            return yield response.value();
        });
    }
    /**
     * Supplies additional information about the application running on a node.
     * Get the node information
     */
    getNodeInfoRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/node/info`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.NodeInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Supplies additional information about the application running on a node.
     * Get the node information
     */
    getNodeInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNodeInfoRaw();
            return yield response.value();
        });
    }
    /**
     * Gets the list of peers visible by the node.
     * Get peers information
     */
    getNodePeersRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/node/peers`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.NodeInfoDTOFromJSON));
        });
    }
    /**
     * Gets the list of peers visible by the node.
     * Get peers information
     */
    getNodePeers() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNodePeersRaw();
            return yield response.value();
        });
    }
    /**
     * Returns storage information about the node.
     * Get the storage information of the node
     */
    getNodeStorageRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/node/storage`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.StorageInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns storage information about the node.
     * Get the storage information of the node
     */
    getNodeStorage() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNodeStorageRaw();
            return yield response.value();
        });
    }
    /**
     * Gets the node time at the moment the reply was sent and received.
     * Get the node time
     */
    getNodeTimeRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/node/time`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.NodeTimeDTOFromJSON(jsonValue));
        });
    }
    /**
     * Gets the node time at the moment the reply was sent and received.
     * Get the node time
     */
    getNodeTime() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getNodeTimeRaw();
            return yield response.value();
        });
    }
    /**
     * Returns the version of the running catapult-rest component.
     * Get the version of the running REST component
     */
    getServerInfoRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/node/server`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.ServerInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns the version of the running catapult-rest component.
     * Get the version of the running REST component
     */
    getServerInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getServerInfoRaw();
            return yield response.value();
        });
    }
}
exports.NodeRoutesApi = NodeRoutesApi;

},{"../models":1157,"../runtime":1158}],932:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReceiptRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class ReceiptRoutesApi extends runtime.BaseAPI {
    /**
     * Gets an array of address resolution statements.
     * Get receipts address resolution statements
     */
    searchAddressResolutionStatementsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.height !== undefined) {
                queryParameters['height'] = requestParameters.height;
            }
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/statements/resolutions/address`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.ResolutionStatementPageFromJSON(jsonValue));
        });
    }
    /**
     * Gets an array of address resolution statements.
     * Get receipts address resolution statements
     */
    searchAddressResolutionStatements(height, pageSize, pageNumber, offset, order) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchAddressResolutionStatementsRaw({ height: height, pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order });
            return yield response.value();
        });
    }
    /**
     * Gets an array of mosaic resolution statements.
     * Get receipts mosaic resolution statements
     */
    searchMosaicResolutionStatementsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.height !== undefined) {
                queryParameters['height'] = requestParameters.height;
            }
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/statements/resolutions/mosaic`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.ResolutionStatementPageFromJSON(jsonValue));
        });
    }
    /**
     * Gets an array of mosaic resolution statements.
     * Get receipts mosaic resolution statements
     */
    searchMosaicResolutionStatements(height, pageSize, pageNumber, offset, order) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchMosaicResolutionStatementsRaw({ height: height, pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order });
            return yield response.value();
        });
    }
    /**
     * Gets an array of transaction statements.
     * Search transaction statements
     */
    searchReceiptsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.height !== undefined) {
                queryParameters['height'] = requestParameters.height;
            }
            if (requestParameters.receiptType) {
                queryParameters['receiptType'] = requestParameters.receiptType;
            }
            if (requestParameters.recipientAddress !== undefined) {
                queryParameters['recipientAddress'] = requestParameters.recipientAddress;
            }
            if (requestParameters.senderAddress !== undefined) {
                queryParameters['senderAddress'] = requestParameters.senderAddress;
            }
            if (requestParameters.targetAddress !== undefined) {
                queryParameters['targetAddress'] = requestParameters.targetAddress;
            }
            if (requestParameters.artifactId !== undefined) {
                queryParameters['artifactId'] = requestParameters.artifactId;
            }
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/statements/transaction`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionStatementPageFromJSON(jsonValue));
        });
    }
    /**
     * Gets an array of transaction statements.
     * Search transaction statements
     */
    searchReceipts(height, receiptType, recipientAddress, senderAddress, targetAddress, artifactId, pageSize, pageNumber, offset, order) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchReceiptsRaw({ height: height, receiptType: receiptType, recipientAddress: recipientAddress, senderAddress: senderAddress, targetAddress: targetAddress, artifactId: artifactId, pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order });
            return yield response.value();
        });
    }
}
exports.ReceiptRoutesApi = ReceiptRoutesApi;

},{"../models":1157,"../runtime":1158}],933:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestrictionAccountRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class RestrictionAccountRoutesApi extends runtime.BaseAPI {
    /**
     * Returns the account restrictions for a given account.
     * Get the account restrictions
     */
    getAccountRestrictionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
                throw new runtime.RequiredError('accountId', 'Required parameter requestParameters.accountId was null or undefined when calling getAccountRestrictions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/restrictions/account/{accountId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.AccountRestrictionsInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns the account restrictions for a given account.
     * Get the account restrictions
     */
    getAccountRestrictions(accountId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getAccountRestrictionsRaw({ accountId: accountId });
            return yield response.value();
        });
    }
    /**
     * Returns the account restrictions for a given array of addresses.
     * Get account restrictions for given array of addresses
     */
    getAccountRestrictionsFromAccountsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/restrictions/account`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.AccountIdsToJSON(requestParameters.accountIds),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.AccountRestrictionsInfoDTOFromJSON));
        });
    }
    /**
     * Returns the account restrictions for a given array of addresses.
     * Get account restrictions for given array of addresses
     */
    getAccountRestrictionsFromAccounts(accountIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getAccountRestrictionsFromAccountsRaw({ accountIds: accountIds });
            return yield response.value();
        });
    }
}
exports.RestrictionAccountRoutesApi = RestrictionAccountRoutesApi;

},{"../models":1157,"../runtime":1158}],934:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestrictionMosaicRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class RestrictionMosaicRoutesApi extends runtime.BaseAPI {
    /**
     * Get mosaic address restriction.
     * Get mosaic address restrictions for a given mosaic and account address.
     */
    getMosaicAddressRestrictionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.mosaicId === null || requestParameters.mosaicId === undefined) {
                throw new runtime.RequiredError('mosaicId', 'Required parameter requestParameters.mosaicId was null or undefined when calling getMosaicAddressRestriction.');
            }
            if (requestParameters.address === null || requestParameters.address === undefined) {
                throw new runtime.RequiredError('address', 'Required parameter requestParameters.address was null or undefined when calling getMosaicAddressRestriction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/restrictions/mosaic/{mosaicId}/address/{address}`.replace(`{${"mosaicId"}}`, encodeURIComponent(String(requestParameters.mosaicId))).replace(`{${"address"}}`, encodeURIComponent(String(requestParameters.address))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.MosaicAddressRestrictionDTOFromJSON(jsonValue));
        });
    }
    /**
     * Get mosaic address restriction.
     * Get mosaic address restrictions for a given mosaic and account address.
     */
    getMosaicAddressRestriction(mosaicId, address) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getMosaicAddressRestrictionRaw({ mosaicId: mosaicId, address: address });
            return yield response.value();
        });
    }
    /**
     * Get mosaic address restrictions.
     * Get mosaic address restrictions for a given mosaic and account identifiers array.
     */
    getMosaicAddressRestrictionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.mosaicId === null || requestParameters.mosaicId === undefined) {
                throw new runtime.RequiredError('mosaicId', 'Required parameter requestParameters.mosaicId was null or undefined when calling getMosaicAddressRestrictions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/restrictions/mosaic/{mosaicId}`.replace(`{${"mosaicId"}}`, encodeURIComponent(String(requestParameters.mosaicId))),
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.AccountIdsToJSON(requestParameters.accountIds),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.MosaicAddressRestrictionDTOFromJSON));
        });
    }
    /**
     * Get mosaic address restrictions.
     * Get mosaic address restrictions for a given mosaic and account identifiers array.
     */
    getMosaicAddressRestrictions(mosaicId, accountIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getMosaicAddressRestrictionsRaw({ mosaicId: mosaicId, accountIds: accountIds });
            return yield response.value();
        });
    }
    /**
     * Get mosaic global restriction.
     * Get mosaic global restriction for a given mosaic identifier.
     */
    getMosaicGlobalRestrictionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.mosaicId === null || requestParameters.mosaicId === undefined) {
                throw new runtime.RequiredError('mosaicId', 'Required parameter requestParameters.mosaicId was null or undefined when calling getMosaicGlobalRestriction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/restrictions/mosaic/{mosaicId}`.replace(`{${"mosaicId"}}`, encodeURIComponent(String(requestParameters.mosaicId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.MosaicGlobalRestrictionDTOFromJSON(jsonValue));
        });
    }
    /**
     * Get mosaic global restriction.
     * Get mosaic global restriction for a given mosaic identifier.
     */
    getMosaicGlobalRestriction(mosaicId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getMosaicGlobalRestrictionRaw({ mosaicId: mosaicId });
            return yield response.value();
        });
    }
    /**
     * Get mosaic global restrictions.
     * Get mosaic global restrictions for an array of mosaics.
     */
    getMosaicGlobalRestrictionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.mosaicIds === null || requestParameters.mosaicIds === undefined) {
                throw new runtime.RequiredError('mosaicIds', 'Required parameter requestParameters.mosaicIds was null or undefined when calling getMosaicGlobalRestrictions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/restrictions/mosaic`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.MosaicIdsToJSON(requestParameters.mosaicIds),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.MosaicGlobalRestrictionDTOFromJSON));
        });
    }
    /**
     * Get mosaic global restrictions.
     * Get mosaic global restrictions for an array of mosaics.
     */
    getMosaicGlobalRestrictions(mosaicIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getMosaicGlobalRestrictionsRaw({ mosaicIds: mosaicIds });
            return yield response.value();
        });
    }
}
exports.RestrictionMosaicRoutesApi = RestrictionMosaicRoutesApi;

},{"../models":1157,"../runtime":1158}],935:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class TransactionRoutesApi extends runtime.BaseAPI {
    /**
     * Announces a cosignature transaction to the network.
     * Announce a cosignature transaction
     */
    announceCosignatureTransactionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.cosignature === null || requestParameters.cosignature === undefined) {
                throw new runtime.RequiredError('cosignature', 'Required parameter requestParameters.cosignature was null or undefined when calling announceCosignatureTransaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/transactions/cosignature`,
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.CosignatureToJSON(requestParameters.cosignature),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.AnnounceTransactionInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Announces a cosignature transaction to the network.
     * Announce a cosignature transaction
     */
    announceCosignatureTransaction(cosignature) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.announceCosignatureTransactionRaw({ cosignature: cosignature });
            return yield response.value();
        });
    }
    /**
     * Announces an aggregate bonded transaction to the network.
     * Announce an aggregate bonded transaction
     */
    announcePartialTransactionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionPayload === null || requestParameters.transactionPayload === undefined) {
                throw new runtime.RequiredError('transactionPayload', 'Required parameter requestParameters.transactionPayload was null or undefined when calling announcePartialTransaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/transactions/partial`,
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.TransactionPayloadToJSON(requestParameters.transactionPayload),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.AnnounceTransactionInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Announces an aggregate bonded transaction to the network.
     * Announce an aggregate bonded transaction
     */
    announcePartialTransaction(transactionPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.announcePartialTransactionRaw({ transactionPayload: transactionPayload });
            return yield response.value();
        });
    }
    /**
     * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions.
     * Announce a new transaction
     */
    announceTransactionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionPayload === null || requestParameters.transactionPayload === undefined) {
                throw new runtime.RequiredError('transactionPayload', 'Required parameter requestParameters.transactionPayload was null or undefined when calling announceTransaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/transactions`,
                method: 'PUT',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.TransactionPayloadToJSON(requestParameters.transactionPayload),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.AnnounceTransactionInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions.
     * Announce a new transaction
     */
    announceTransaction(transactionPayload) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.announceTransactionRaw({ transactionPayload: transactionPayload });
            return yield response.value();
        });
    }
    /**
     * Returns confirmed transaction information given a transactionId or hash.
     * Get confirmed transaction information
     */
    getConfirmedTransactionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionId === null || requestParameters.transactionId === undefined) {
                throw new runtime.RequiredError('transactionId', 'Required parameter requestParameters.transactionId was null or undefined when calling getConfirmedTransaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/transactions/confirmed/{transactionId}`.replace(`{${"transactionId"}}`, encodeURIComponent(String(requestParameters.transactionId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns confirmed transaction information given a transactionId or hash.
     * Get confirmed transaction information
     */
    getConfirmedTransaction(transactionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getConfirmedTransactionRaw({ transactionId: transactionId });
            return yield response.value();
        });
    }
    /**
     * Returns confirmed transactions information for a given array of transactionIds.
     * Get confirmed trasactions information
     */
    getConfirmedTransactionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionIds === null || requestParameters.transactionIds === undefined) {
                throw new runtime.RequiredError('transactionIds', 'Required parameter requestParameters.transactionIds was null or undefined when calling getConfirmedTransactions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/transactions/confirmed`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.TransactionIdsToJSON(requestParameters.transactionIds),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.TransactionInfoDTOFromJSON));
        });
    }
    /**
     * Returns confirmed transactions information for a given array of transactionIds.
     * Get confirmed trasactions information
     */
    getConfirmedTransactions(transactionIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getConfirmedTransactionsRaw({ transactionIds: transactionIds });
            return yield response.value();
        });
    }
    /**
     * Returns partial transaction information given a transactionId or hash.
     * Get partial transaction information
     */
    getPartialTransactionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionId === null || requestParameters.transactionId === undefined) {
                throw new runtime.RequiredError('transactionId', 'Required parameter requestParameters.transactionId was null or undefined when calling getPartialTransaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/transactions/partial/{transactionId}`.replace(`{${"transactionId"}}`, encodeURIComponent(String(requestParameters.transactionId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns partial transaction information given a transactionId or hash.
     * Get partial transaction information
     */
    getPartialTransaction(transactionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getPartialTransactionRaw({ transactionId: transactionId });
            return yield response.value();
        });
    }
    /**
     * Returns partial transactions information for a given array of transactionIds.
     * Get partial trasactions information
     */
    getPartialTransactionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionIds === null || requestParameters.transactionIds === undefined) {
                throw new runtime.RequiredError('transactionIds', 'Required parameter requestParameters.transactionIds was null or undefined when calling getPartialTransactions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/transactions/partial`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.TransactionIdsToJSON(requestParameters.transactionIds),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.TransactionInfoDTOFromJSON));
        });
    }
    /**
     * Returns partial transactions information for a given array of transactionIds.
     * Get partial trasactions information
     */
    getPartialTransactions(transactionIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getPartialTransactionsRaw({ transactionIds: transactionIds });
            return yield response.value();
        });
    }
    /**
     * Returns unconfirmed transaction information given a transactionId or hash.
     * Get unconfirmed transaction information
     */
    getUnconfirmedTransactionRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionId === null || requestParameters.transactionId === undefined) {
                throw new runtime.RequiredError('transactionId', 'Required parameter requestParameters.transactionId was null or undefined when calling getUnconfirmedTransaction.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/transactions/unconfirmed/{transactionId}`.replace(`{${"transactionId"}}`, encodeURIComponent(String(requestParameters.transactionId))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionInfoDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns unconfirmed transaction information given a transactionId or hash.
     * Get unconfirmed transaction information
     */
    getUnconfirmedTransaction(transactionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getUnconfirmedTransactionRaw({ transactionId: transactionId });
            return yield response.value();
        });
    }
    /**
     * Returns unconfirmed transactions information for a given array of transactionIds.
     * Get unconfirmed trasactions information
     */
    getUnconfirmedTransactionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionIds === null || requestParameters.transactionIds === undefined) {
                throw new runtime.RequiredError('transactionIds', 'Required parameter requestParameters.transactionIds was null or undefined when calling getUnconfirmedTransactions.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/transactions/unconfirmed`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.TransactionIdsToJSON(requestParameters.transactionIds),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.TransactionInfoDTOFromJSON));
        });
    }
    /**
     * Returns unconfirmed transactions information for a given array of transactionIds.
     * Get unconfirmed trasactions information
     */
    getUnconfirmedTransactions(transactionIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getUnconfirmedTransactionsRaw({ transactionIds: transactionIds });
            return yield response.value();
        });
    }
    /**
     * Returns an array of confirmed transactions.
     * Search confirmed transactions
     */
    searchConfirmedTransactionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.address !== undefined) {
                queryParameters['address'] = requestParameters.address;
            }
            if (requestParameters.recipientAddress !== undefined) {
                queryParameters['recipientAddress'] = requestParameters.recipientAddress;
            }
            if (requestParameters.signerPublicKey !== undefined) {
                queryParameters['signerPublicKey'] = requestParameters.signerPublicKey;
            }
            if (requestParameters.height !== undefined) {
                queryParameters['height'] = requestParameters.height;
            }
            if (requestParameters.type) {
                queryParameters['type'] = requestParameters.type;
            }
            if (requestParameters.embedded !== undefined) {
                queryParameters['embedded'] = requestParameters.embedded;
            }
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/transactions/confirmed`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionPageFromJSON(jsonValue));
        });
    }
    /**
     * Returns an array of confirmed transactions.
     * Search confirmed transactions
     */
    searchConfirmedTransactions(address, recipientAddress, signerPublicKey, height, type, embedded, pageSize, pageNumber, offset, order) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchConfirmedTransactionsRaw({ address: address, recipientAddress: recipientAddress, signerPublicKey: signerPublicKey, height: height, type: type, embedded: embedded, pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order });
            return yield response.value();
        });
    }
    /**
     * Returns an array of partial transactions.
     * Search partial transactions
     */
    searchPartialTransactionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.address !== undefined) {
                queryParameters['address'] = requestParameters.address;
            }
            if (requestParameters.recipientAddress !== undefined) {
                queryParameters['recipientAddress'] = requestParameters.recipientAddress;
            }
            if (requestParameters.signerPublicKey !== undefined) {
                queryParameters['signerPublicKey'] = requestParameters.signerPublicKey;
            }
            if (requestParameters.height !== undefined) {
                queryParameters['height'] = requestParameters.height;
            }
            if (requestParameters.type) {
                queryParameters['type'] = requestParameters.type;
            }
            if (requestParameters.embedded !== undefined) {
                queryParameters['embedded'] = requestParameters.embedded;
            }
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/transactions/partial`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionPageFromJSON(jsonValue));
        });
    }
    /**
     * Returns an array of partial transactions.
     * Search partial transactions
     */
    searchPartialTransactions(address, recipientAddress, signerPublicKey, height, type, embedded, pageSize, pageNumber, offset, order) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchPartialTransactionsRaw({ address: address, recipientAddress: recipientAddress, signerPublicKey: signerPublicKey, height: height, type: type, embedded: embedded, pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order });
            return yield response.value();
        });
    }
    /**
     * Returns an array of unconfirmed transactions.
     * Search unconfirmed transactions
     */
    searchUnconfirmedTransactionsRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryParameters = {};
            if (requestParameters.address !== undefined) {
                queryParameters['address'] = requestParameters.address;
            }
            if (requestParameters.recipientAddress !== undefined) {
                queryParameters['recipientAddress'] = requestParameters.recipientAddress;
            }
            if (requestParameters.signerPublicKey !== undefined) {
                queryParameters['signerPublicKey'] = requestParameters.signerPublicKey;
            }
            if (requestParameters.height !== undefined) {
                queryParameters['height'] = requestParameters.height;
            }
            if (requestParameters.type) {
                queryParameters['type'] = requestParameters.type;
            }
            if (requestParameters.embedded !== undefined) {
                queryParameters['embedded'] = requestParameters.embedded;
            }
            if (requestParameters.pageSize !== undefined) {
                queryParameters['pageSize'] = requestParameters.pageSize;
            }
            if (requestParameters.pageNumber !== undefined) {
                queryParameters['pageNumber'] = requestParameters.pageNumber;
            }
            if (requestParameters.offset !== undefined) {
                queryParameters['offset'] = requestParameters.offset;
            }
            if (requestParameters.order !== undefined) {
                queryParameters['order'] = requestParameters.order;
            }
            const headerParameters = {};
            const response = yield this.request({
                path: `/transactions/unconfirmed`,
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionPageFromJSON(jsonValue));
        });
    }
    /**
     * Returns an array of unconfirmed transactions.
     * Search unconfirmed transactions
     */
    searchUnconfirmedTransactions(address, recipientAddress, signerPublicKey, height, type, embedded, pageSize, pageNumber, offset, order) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.searchUnconfirmedTransactionsRaw({ address: address, recipientAddress: recipientAddress, signerPublicKey: signerPublicKey, height: height, type: type, embedded: embedded, pageSize: pageSize, pageNumber: pageNumber, offset: offset, order: order });
            return yield response.value();
        });
    }
}
exports.TransactionRoutesApi = TransactionRoutesApi;

},{"../models":1157,"../runtime":1158}],936:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionStatusRoutesApi = void 0;
const runtime = require("../runtime");
const models_1 = require("../models");
/**
 *
 */
class TransactionStatusRoutesApi extends runtime.BaseAPI {
    /**
     * Returns the transaction status for a given hash.
     * Get transaction status
     */
    getTransactionStatusRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.hash === null || requestParameters.hash === undefined) {
                throw new runtime.RequiredError('hash', 'Required parameter requestParameters.hash was null or undefined when calling getTransactionStatus.');
            }
            const queryParameters = {};
            const headerParameters = {};
            const response = yield this.request({
                path: `/transactionStatus/{hash}`.replace(`{${"hash"}}`, encodeURIComponent(String(requestParameters.hash))),
                method: 'GET',
                headers: headerParameters,
                query: queryParameters,
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => models_1.TransactionStatusDTOFromJSON(jsonValue));
        });
    }
    /**
     * Returns the transaction status for a given hash.
     * Get transaction status
     */
    getTransactionStatus(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getTransactionStatusRaw({ hash: hash });
            return yield response.value();
        });
    }
    /**
     * Returns an array of transaction statuses for a given array of transaction hashes.
     * Get transaction statuses
     */
    getTransactionStatusesRaw(requestParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            if (requestParameters.transactionHashes === null || requestParameters.transactionHashes === undefined) {
                throw new runtime.RequiredError('transactionHashes', 'Required parameter requestParameters.transactionHashes was null or undefined when calling getTransactionStatuses.');
            }
            const queryParameters = {};
            const headerParameters = {};
            headerParameters['Content-Type'] = 'application/json';
            const response = yield this.request({
                path: `/transactionStatus`,
                method: 'POST',
                headers: headerParameters,
                query: queryParameters,
                body: models_1.TransactionHashesToJSON(requestParameters.transactionHashes),
            });
            return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(models_1.TransactionStatusDTOFromJSON));
        });
    }
    /**
     * Returns an array of transaction statuses for a given array of transaction hashes.
     * Get transaction statuses
     */
    getTransactionStatuses(transactionHashes) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getTransactionStatusesRaw({ transactionHashes: transactionHashes });
            return yield response.value();
        });
    }
}
exports.TransactionStatusRoutesApi = TransactionStatusRoutesApi;

},{"../models":1157,"../runtime":1158}],937:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./AccountRoutesApi"), exports);
__exportStar(require("./BlockRoutesApi"), exports);
__exportStar(require("./ChainRoutesApi"), exports);
__exportStar(require("./MetadataRoutesApi"), exports);
__exportStar(require("./MosaicRoutesApi"), exports);
__exportStar(require("./MultisigRoutesApi"), exports);
__exportStar(require("./NamespaceRoutesApi"), exports);
__exportStar(require("./NetworkRoutesApi"), exports);
__exportStar(require("./NodeRoutesApi"), exports);
__exportStar(require("./ReceiptRoutesApi"), exports);
__exportStar(require("./RestrictionAccountRoutesApi"), exports);
__exportStar(require("./RestrictionMosaicRoutesApi"), exports);
__exportStar(require("./TransactionRoutesApi"), exports);
__exportStar(require("./TransactionStatusRoutesApi"), exports);

},{"./AccountRoutesApi":923,"./BlockRoutesApi":924,"./ChainRoutesApi":925,"./MetadataRoutesApi":926,"./MosaicRoutesApi":927,"./MultisigRoutesApi":928,"./NamespaceRoutesApi":929,"./NetworkRoutesApi":930,"./NodeRoutesApi":931,"./ReceiptRoutesApi":932,"./RestrictionAccountRoutesApi":933,"./RestrictionMosaicRoutesApi":934,"./TransactionRoutesApi":935,"./TransactionStatusRoutesApi":936}],938:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./runtime"), exports);
__exportStar(require("./apis"), exports);
__exportStar(require("./models"), exports);

},{"./apis":937,"./models":1157,"./runtime":1158}],939:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountAddressRestrictionTransactionBodyDTOToJSON = exports.AccountAddressRestrictionTransactionBodyDTOFromJSONTyped = exports.AccountAddressRestrictionTransactionBodyDTOFromJSON = void 0;
function AccountAddressRestrictionTransactionBodyDTOFromJSON(json) {
    return AccountAddressRestrictionTransactionBodyDTOFromJSONTyped(json, false);
}
exports.AccountAddressRestrictionTransactionBodyDTOFromJSON = AccountAddressRestrictionTransactionBodyDTOFromJSON;
function AccountAddressRestrictionTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'restrictionFlags': json['restrictionFlags'],
        'restrictionAdditions': json['restrictionAdditions'],
        'restrictionDeletions': json['restrictionDeletions'],
    };
}
exports.AccountAddressRestrictionTransactionBodyDTOFromJSONTyped = AccountAddressRestrictionTransactionBodyDTOFromJSONTyped;
function AccountAddressRestrictionTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'restrictionFlags': value.restrictionFlags,
        'restrictionAdditions': value.restrictionAdditions,
        'restrictionDeletions': value.restrictionDeletions,
    };
}
exports.AccountAddressRestrictionTransactionBodyDTOToJSON = AccountAddressRestrictionTransactionBodyDTOToJSON;

},{}],940:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountAddressRestrictionTransactionDTOToJSON = exports.AccountAddressRestrictionTransactionDTOFromJSONTyped = exports.AccountAddressRestrictionTransactionDTOFromJSON = void 0;
function AccountAddressRestrictionTransactionDTOFromJSON(json) {
    return AccountAddressRestrictionTransactionDTOFromJSONTyped(json, false);
}
exports.AccountAddressRestrictionTransactionDTOFromJSON = AccountAddressRestrictionTransactionDTOFromJSON;
function AccountAddressRestrictionTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'restrictionFlags': json['restrictionFlags'],
        'restrictionAdditions': json['restrictionAdditions'],
        'restrictionDeletions': json['restrictionDeletions'],
    };
}
exports.AccountAddressRestrictionTransactionDTOFromJSONTyped = AccountAddressRestrictionTransactionDTOFromJSONTyped;
function AccountAddressRestrictionTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'restrictionFlags': value.restrictionFlags,
        'restrictionAdditions': value.restrictionAdditions,
        'restrictionDeletions': value.restrictionDeletions,
    };
}
exports.AccountAddressRestrictionTransactionDTOToJSON = AccountAddressRestrictionTransactionDTOToJSON;

},{}],941:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountDTOToJSON = exports.AccountDTOFromJSONTyped = exports.AccountDTOFromJSON = void 0;
function AccountDTOFromJSON(json) {
    return AccountDTOFromJSONTyped(json, false);
}
exports.AccountDTOFromJSON = AccountDTOFromJSON;
function AccountDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'address': json['address'],
        'addressHeight': json['addressHeight'],
        'publicKey': json['publicKey'],
        'publicKeyHeight': json['publicKeyHeight'],
        'accountType': json['accountType'],
        'supplementalPublicKeys': json['supplementalPublicKeys'],
        'activityBuckets': json['activityBuckets'],
        'mosaics': json['mosaics'],
        'importance': json['importance'],
        'importanceHeight': json['importanceHeight'],
    };
}
exports.AccountDTOFromJSONTyped = AccountDTOFromJSONTyped;
function AccountDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'address': value.address,
        'addressHeight': value.addressHeight,
        'publicKey': value.publicKey,
        'publicKeyHeight': value.publicKeyHeight,
        'accountType': value.accountType,
        'supplementalPublicKeys': value.supplementalPublicKeys,
        'activityBuckets': value.activityBuckets,
        'mosaics': value.mosaics,
        'importance': value.importance,
        'importanceHeight': value.importanceHeight,
    };
}
exports.AccountDTOToJSON = AccountDTOToJSON;

},{}],942:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountIdsToJSON = exports.AccountIdsFromJSONTyped = exports.AccountIdsFromJSON = void 0;
const runtime_1 = require("../runtime");
function AccountIdsFromJSON(json) {
    return AccountIdsFromJSONTyped(json, false);
}
exports.AccountIdsFromJSON = AccountIdsFromJSON;
function AccountIdsFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'publicKeys': !runtime_1.exists(json, 'publicKeys') ? undefined : json['publicKeys'],
        'addresses': !runtime_1.exists(json, 'addresses') ? undefined : json['addresses'],
    };
}
exports.AccountIdsFromJSONTyped = AccountIdsFromJSONTyped;
function AccountIdsToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'publicKeys': value.publicKeys,
        'addresses': value.addresses,
    };
}
exports.AccountIdsToJSON = AccountIdsToJSON;

},{"../runtime":1158}],943:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountInfoDTOToJSON = exports.AccountInfoDTOFromJSONTyped = exports.AccountInfoDTOFromJSON = void 0;
function AccountInfoDTOFromJSON(json) {
    return AccountInfoDTOFromJSONTyped(json, false);
}
exports.AccountInfoDTOFromJSON = AccountInfoDTOFromJSON;
function AccountInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'account': json['account'],
    };
}
exports.AccountInfoDTOFromJSONTyped = AccountInfoDTOFromJSONTyped;
function AccountInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'account': value.account,
    };
}
exports.AccountInfoDTOToJSON = AccountInfoDTOToJSON;

},{}],944:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountKeyLinkNetworkPropertiesDTOToJSON = exports.AccountKeyLinkNetworkPropertiesDTOFromJSONTyped = exports.AccountKeyLinkNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function AccountKeyLinkNetworkPropertiesDTOFromJSON(json) {
    return AccountKeyLinkNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.AccountKeyLinkNetworkPropertiesDTOFromJSON = AccountKeyLinkNetworkPropertiesDTOFromJSON;
function AccountKeyLinkNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'dummy': !runtime_1.exists(json, 'dummy') ? undefined : json['dummy'],
    };
}
exports.AccountKeyLinkNetworkPropertiesDTOFromJSONTyped = AccountKeyLinkNetworkPropertiesDTOFromJSONTyped;
function AccountKeyLinkNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'dummy': value.dummy,
    };
}
exports.AccountKeyLinkNetworkPropertiesDTOToJSON = AccountKeyLinkNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],945:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountKeyLinkTransactionBodyDTOToJSON = exports.AccountKeyLinkTransactionBodyDTOFromJSONTyped = exports.AccountKeyLinkTransactionBodyDTOFromJSON = void 0;
function AccountKeyLinkTransactionBodyDTOFromJSON(json) {
    return AccountKeyLinkTransactionBodyDTOFromJSONTyped(json, false);
}
exports.AccountKeyLinkTransactionBodyDTOFromJSON = AccountKeyLinkTransactionBodyDTOFromJSON;
function AccountKeyLinkTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'linkedPublicKey': json['linkedPublicKey'],
        'linkAction': json['linkAction'],
    };
}
exports.AccountKeyLinkTransactionBodyDTOFromJSONTyped = AccountKeyLinkTransactionBodyDTOFromJSONTyped;
function AccountKeyLinkTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'linkedPublicKey': value.linkedPublicKey,
        'linkAction': value.linkAction,
    };
}
exports.AccountKeyLinkTransactionBodyDTOToJSON = AccountKeyLinkTransactionBodyDTOToJSON;

},{}],946:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountKeyLinkTransactionDTOToJSON = exports.AccountKeyLinkTransactionDTOFromJSONTyped = exports.AccountKeyLinkTransactionDTOFromJSON = void 0;
function AccountKeyLinkTransactionDTOFromJSON(json) {
    return AccountKeyLinkTransactionDTOFromJSONTyped(json, false);
}
exports.AccountKeyLinkTransactionDTOFromJSON = AccountKeyLinkTransactionDTOFromJSON;
function AccountKeyLinkTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'linkedPublicKey': json['linkedPublicKey'],
        'linkAction': json['linkAction'],
    };
}
exports.AccountKeyLinkTransactionDTOFromJSONTyped = AccountKeyLinkTransactionDTOFromJSONTyped;
function AccountKeyLinkTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'linkedPublicKey': value.linkedPublicKey,
        'linkAction': value.linkAction,
    };
}
exports.AccountKeyLinkTransactionDTOToJSON = AccountKeyLinkTransactionDTOToJSON;

},{}],947:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountKeyTypeFlagsEnumToJSON = exports.AccountKeyTypeFlagsEnumFromJSONTyped = exports.AccountKeyTypeFlagsEnumFromJSON = exports.AccountKeyTypeFlagsEnum = void 0;
/**
 * Type of account key:
 * * 0 - Unset.
 * * 1 - Linked account public key.
 * * 2 - Node public key on which remote is allowed to harvest.
 * * 4 - VRF public key.
 * @export
 * @enum {string}
 */
var AccountKeyTypeFlagsEnum;
(function (AccountKeyTypeFlagsEnum) {
    AccountKeyTypeFlagsEnum[AccountKeyTypeFlagsEnum["NUMBER_0"] = 0] = "NUMBER_0";
    AccountKeyTypeFlagsEnum[AccountKeyTypeFlagsEnum["NUMBER_1"] = 1] = "NUMBER_1";
    AccountKeyTypeFlagsEnum[AccountKeyTypeFlagsEnum["NUMBER_2"] = 2] = "NUMBER_2";
    AccountKeyTypeFlagsEnum[AccountKeyTypeFlagsEnum["NUMBER_4"] = 4] = "NUMBER_4";
})(AccountKeyTypeFlagsEnum = exports.AccountKeyTypeFlagsEnum || (exports.AccountKeyTypeFlagsEnum = {}));
function AccountKeyTypeFlagsEnumFromJSON(json) {
    return AccountKeyTypeFlagsEnumFromJSONTyped(json, false);
}
exports.AccountKeyTypeFlagsEnumFromJSON = AccountKeyTypeFlagsEnumFromJSON;
function AccountKeyTypeFlagsEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.AccountKeyTypeFlagsEnumFromJSONTyped = AccountKeyTypeFlagsEnumFromJSONTyped;
function AccountKeyTypeFlagsEnumToJSON(value) {
    return value;
}
exports.AccountKeyTypeFlagsEnumToJSON = AccountKeyTypeFlagsEnumToJSON;

},{}],948:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountLinkPublicKeyDTOToJSON = exports.AccountLinkPublicKeyDTOFromJSONTyped = exports.AccountLinkPublicKeyDTOFromJSON = void 0;
function AccountLinkPublicKeyDTOFromJSON(json) {
    return AccountLinkPublicKeyDTOFromJSONTyped(json, false);
}
exports.AccountLinkPublicKeyDTOFromJSON = AccountLinkPublicKeyDTOFromJSON;
function AccountLinkPublicKeyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'publicKey': json['publicKey'],
    };
}
exports.AccountLinkPublicKeyDTOFromJSONTyped = AccountLinkPublicKeyDTOFromJSONTyped;
function AccountLinkPublicKeyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'publicKey': value.publicKey,
    };
}
exports.AccountLinkPublicKeyDTOToJSON = AccountLinkPublicKeyDTOToJSON;

},{}],949:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountLinkVotingKeyDTOToJSON = exports.AccountLinkVotingKeyDTOFromJSONTyped = exports.AccountLinkVotingKeyDTOFromJSON = void 0;
function AccountLinkVotingKeyDTOFromJSON(json) {
    return AccountLinkVotingKeyDTOFromJSONTyped(json, false);
}
exports.AccountLinkVotingKeyDTOFromJSON = AccountLinkVotingKeyDTOFromJSON;
function AccountLinkVotingKeyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'publicKey': json['publicKey'],
        'startPoint': json['startPoint'],
        'endPoint': json['endPoint'],
    };
}
exports.AccountLinkVotingKeyDTOFromJSONTyped = AccountLinkVotingKeyDTOFromJSONTyped;
function AccountLinkVotingKeyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'publicKey': value.publicKey,
        'startPoint': value.startPoint,
        'endPoint': value.endPoint,
    };
}
exports.AccountLinkVotingKeyDTOToJSON = AccountLinkVotingKeyDTOToJSON;

},{}],950:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountLinkVotingKeysDTOToJSON = exports.AccountLinkVotingKeysDTOFromJSONTyped = exports.AccountLinkVotingKeysDTOFromJSON = void 0;
function AccountLinkVotingKeysDTOFromJSON(json) {
    return AccountLinkVotingKeysDTOFromJSONTyped(json, false);
}
exports.AccountLinkVotingKeysDTOFromJSON = AccountLinkVotingKeysDTOFromJSON;
function AccountLinkVotingKeysDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'publicKeys': json['publicKeys'],
    };
}
exports.AccountLinkVotingKeysDTOFromJSONTyped = AccountLinkVotingKeysDTOFromJSONTyped;
function AccountLinkVotingKeysDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'publicKeys': value.publicKeys,
    };
}
exports.AccountLinkVotingKeysDTOToJSON = AccountLinkVotingKeysDTOToJSON;

},{}],951:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountMetadataTransactionBodyDTOToJSON = exports.AccountMetadataTransactionBodyDTOFromJSONTyped = exports.AccountMetadataTransactionBodyDTOFromJSON = void 0;
function AccountMetadataTransactionBodyDTOFromJSON(json) {
    return AccountMetadataTransactionBodyDTOFromJSONTyped(json, false);
}
exports.AccountMetadataTransactionBodyDTOFromJSON = AccountMetadataTransactionBodyDTOFromJSON;
function AccountMetadataTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'targetAddress': json['targetAddress'],
        'scopedMetadataKey': json['scopedMetadataKey'],
        'valueSizeDelta': json['valueSizeDelta'],
        'valueSize': json['valueSize'],
        'value': json['value'],
    };
}
exports.AccountMetadataTransactionBodyDTOFromJSONTyped = AccountMetadataTransactionBodyDTOFromJSONTyped;
function AccountMetadataTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'targetAddress': value.targetAddress,
        'scopedMetadataKey': value.scopedMetadataKey,
        'valueSizeDelta': value.valueSizeDelta,
        'valueSize': value.valueSize,
        'value': value.value,
    };
}
exports.AccountMetadataTransactionBodyDTOToJSON = AccountMetadataTransactionBodyDTOToJSON;

},{}],952:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountMetadataTransactionDTOToJSON = exports.AccountMetadataTransactionDTOFromJSONTyped = exports.AccountMetadataTransactionDTOFromJSON = void 0;
function AccountMetadataTransactionDTOFromJSON(json) {
    return AccountMetadataTransactionDTOFromJSONTyped(json, false);
}
exports.AccountMetadataTransactionDTOFromJSON = AccountMetadataTransactionDTOFromJSON;
function AccountMetadataTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'targetAddress': json['targetAddress'],
        'scopedMetadataKey': json['scopedMetadataKey'],
        'valueSizeDelta': json['valueSizeDelta'],
        'valueSize': json['valueSize'],
        'value': json['value'],
    };
}
exports.AccountMetadataTransactionDTOFromJSONTyped = AccountMetadataTransactionDTOFromJSONTyped;
function AccountMetadataTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'targetAddress': value.targetAddress,
        'scopedMetadataKey': value.scopedMetadataKey,
        'valueSizeDelta': value.valueSizeDelta,
        'valueSize': value.valueSize,
        'value': value.value,
    };
}
exports.AccountMetadataTransactionDTOToJSON = AccountMetadataTransactionDTOToJSON;

},{}],953:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountMosaicRestrictionTransactionBodyDTOToJSON = exports.AccountMosaicRestrictionTransactionBodyDTOFromJSONTyped = exports.AccountMosaicRestrictionTransactionBodyDTOFromJSON = void 0;
function AccountMosaicRestrictionTransactionBodyDTOFromJSON(json) {
    return AccountMosaicRestrictionTransactionBodyDTOFromJSONTyped(json, false);
}
exports.AccountMosaicRestrictionTransactionBodyDTOFromJSON = AccountMosaicRestrictionTransactionBodyDTOFromJSON;
function AccountMosaicRestrictionTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'restrictionFlags': json['restrictionFlags'],
        'restrictionAdditions': json['restrictionAdditions'],
        'restrictionDeletions': json['restrictionDeletions'],
    };
}
exports.AccountMosaicRestrictionTransactionBodyDTOFromJSONTyped = AccountMosaicRestrictionTransactionBodyDTOFromJSONTyped;
function AccountMosaicRestrictionTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'restrictionFlags': value.restrictionFlags,
        'restrictionAdditions': value.restrictionAdditions,
        'restrictionDeletions': value.restrictionDeletions,
    };
}
exports.AccountMosaicRestrictionTransactionBodyDTOToJSON = AccountMosaicRestrictionTransactionBodyDTOToJSON;

},{}],954:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountMosaicRestrictionTransactionDTOToJSON = exports.AccountMosaicRestrictionTransactionDTOFromJSONTyped = exports.AccountMosaicRestrictionTransactionDTOFromJSON = void 0;
function AccountMosaicRestrictionTransactionDTOFromJSON(json) {
    return AccountMosaicRestrictionTransactionDTOFromJSONTyped(json, false);
}
exports.AccountMosaicRestrictionTransactionDTOFromJSON = AccountMosaicRestrictionTransactionDTOFromJSON;
function AccountMosaicRestrictionTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'restrictionFlags': json['restrictionFlags'],
        'restrictionAdditions': json['restrictionAdditions'],
        'restrictionDeletions': json['restrictionDeletions'],
    };
}
exports.AccountMosaicRestrictionTransactionDTOFromJSONTyped = AccountMosaicRestrictionTransactionDTOFromJSONTyped;
function AccountMosaicRestrictionTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'restrictionFlags': value.restrictionFlags,
        'restrictionAdditions': value.restrictionAdditions,
        'restrictionDeletions': value.restrictionDeletions,
    };
}
exports.AccountMosaicRestrictionTransactionDTOToJSON = AccountMosaicRestrictionTransactionDTOToJSON;

},{}],955:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountNamesDTOToJSON = exports.AccountNamesDTOFromJSONTyped = exports.AccountNamesDTOFromJSON = void 0;
function AccountNamesDTOFromJSON(json) {
    return AccountNamesDTOFromJSONTyped(json, false);
}
exports.AccountNamesDTOFromJSON = AccountNamesDTOFromJSON;
function AccountNamesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'address': json['address'],
        'names': json['names'],
    };
}
exports.AccountNamesDTOFromJSONTyped = AccountNamesDTOFromJSONTyped;
function AccountNamesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'address': value.address,
        'names': value.names,
    };
}
exports.AccountNamesDTOToJSON = AccountNamesDTOToJSON;

},{}],956:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountOperationRestrictionTransactionBodyDTOToJSON = exports.AccountOperationRestrictionTransactionBodyDTOFromJSONTyped = exports.AccountOperationRestrictionTransactionBodyDTOFromJSON = void 0;
function AccountOperationRestrictionTransactionBodyDTOFromJSON(json) {
    return AccountOperationRestrictionTransactionBodyDTOFromJSONTyped(json, false);
}
exports.AccountOperationRestrictionTransactionBodyDTOFromJSON = AccountOperationRestrictionTransactionBodyDTOFromJSON;
function AccountOperationRestrictionTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'restrictionFlags': json['restrictionFlags'],
        'restrictionAdditions': json['restrictionAdditions'],
        'restrictionDeletions': json['restrictionDeletions'],
    };
}
exports.AccountOperationRestrictionTransactionBodyDTOFromJSONTyped = AccountOperationRestrictionTransactionBodyDTOFromJSONTyped;
function AccountOperationRestrictionTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'restrictionFlags': value.restrictionFlags,
        'restrictionAdditions': value.restrictionAdditions,
        'restrictionDeletions': value.restrictionDeletions,
    };
}
exports.AccountOperationRestrictionTransactionBodyDTOToJSON = AccountOperationRestrictionTransactionBodyDTOToJSON;

},{}],957:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountOperationRestrictionTransactionDTOToJSON = exports.AccountOperationRestrictionTransactionDTOFromJSONTyped = exports.AccountOperationRestrictionTransactionDTOFromJSON = void 0;
function AccountOperationRestrictionTransactionDTOFromJSON(json) {
    return AccountOperationRestrictionTransactionDTOFromJSONTyped(json, false);
}
exports.AccountOperationRestrictionTransactionDTOFromJSON = AccountOperationRestrictionTransactionDTOFromJSON;
function AccountOperationRestrictionTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'restrictionFlags': json['restrictionFlags'],
        'restrictionAdditions': json['restrictionAdditions'],
        'restrictionDeletions': json['restrictionDeletions'],
    };
}
exports.AccountOperationRestrictionTransactionDTOFromJSONTyped = AccountOperationRestrictionTransactionDTOFromJSONTyped;
function AccountOperationRestrictionTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'restrictionFlags': value.restrictionFlags,
        'restrictionAdditions': value.restrictionAdditions,
        'restrictionDeletions': value.restrictionDeletions,
    };
}
exports.AccountOperationRestrictionTransactionDTOToJSON = AccountOperationRestrictionTransactionDTOToJSON;

},{}],958:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountOrderByEnumToJSON = exports.AccountOrderByEnumFromJSONTyped = exports.AccountOrderByEnumFromJSON = exports.AccountOrderByEnum = void 0;
/**
 *
 * @export
 * @enum {string}
 */
var AccountOrderByEnum;
(function (AccountOrderByEnum) {
    AccountOrderByEnum["Id"] = "id";
    AccountOrderByEnum["Balance"] = "balance";
})(AccountOrderByEnum = exports.AccountOrderByEnum || (exports.AccountOrderByEnum = {}));
function AccountOrderByEnumFromJSON(json) {
    return AccountOrderByEnumFromJSONTyped(json, false);
}
exports.AccountOrderByEnumFromJSON = AccountOrderByEnumFromJSON;
function AccountOrderByEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.AccountOrderByEnumFromJSONTyped = AccountOrderByEnumFromJSONTyped;
function AccountOrderByEnumToJSON(value) {
    return value;
}
exports.AccountOrderByEnumToJSON = AccountOrderByEnumToJSON;

},{}],959:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountPageToJSON = exports.AccountPageFromJSONTyped = exports.AccountPageFromJSON = void 0;
function AccountPageFromJSON(json) {
    return AccountPageFromJSONTyped(json, false);
}
exports.AccountPageFromJSON = AccountPageFromJSON;
function AccountPageFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'data': json['data'],
        'pagination': json['pagination'],
    };
}
exports.AccountPageFromJSONTyped = AccountPageFromJSONTyped;
function AccountPageToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'data': value.data,
        'pagination': value.pagination,
    };
}
exports.AccountPageToJSON = AccountPageToJSON;

},{}],960:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountRestrictionDTOToJSON = exports.AccountRestrictionDTOFromJSONTyped = exports.AccountRestrictionDTOFromJSON = void 0;
function AccountRestrictionDTOFromJSON(json) {
    return AccountRestrictionDTOFromJSONTyped(json, false);
}
exports.AccountRestrictionDTOFromJSON = AccountRestrictionDTOFromJSON;
function AccountRestrictionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'restrictionFlags': json['restrictionFlags'],
        'values': json['values'],
    };
}
exports.AccountRestrictionDTOFromJSONTyped = AccountRestrictionDTOFromJSONTyped;
function AccountRestrictionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'restrictionFlags': value.restrictionFlags,
        'values': value.values,
    };
}
exports.AccountRestrictionDTOToJSON = AccountRestrictionDTOToJSON;

},{}],961:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountRestrictionFlagsEnumToJSON = exports.AccountRestrictionFlagsEnumFromJSONTyped = exports.AccountRestrictionFlagsEnumFromJSON = exports.AccountRestrictionFlagsEnum = void 0;
/**
 * Type of account restriction:
 * * 0x0001 (1 decimal) - Allow only incoming transactions from a given address.
 * * 0x0002 (2 decimal) - Allow only incoming transactions containing a given mosaic identifier.
 * * 0x4001 (16385 decimal) - Allow only outgoing transactions to a given address.
 * * 0x4004 (16388 decimal) - Allow only outgoing transactions with a given transaction type.
 * * 0x8001 (32769 decimal) - Block incoming transactions from a given address.
 * * 0x8002 (32770 decimal) - Block incoming transactions containing a given mosaic identifier.
 * * 0xC001 (49153 decimal) - Block outgoing transactions to a given address.
 * * 0xC004 (49156 decimal) - Block outgoing transactions with a given transaction type.
 * @export
 * @enum {string}
 */
var AccountRestrictionFlagsEnum;
(function (AccountRestrictionFlagsEnum) {
    AccountRestrictionFlagsEnum[AccountRestrictionFlagsEnum["NUMBER_1"] = 1] = "NUMBER_1";
    AccountRestrictionFlagsEnum[AccountRestrictionFlagsEnum["NUMBER_2"] = 2] = "NUMBER_2";
    AccountRestrictionFlagsEnum[AccountRestrictionFlagsEnum["NUMBER_16385"] = 16385] = "NUMBER_16385";
    AccountRestrictionFlagsEnum[AccountRestrictionFlagsEnum["NUMBER_16388"] = 16388] = "NUMBER_16388";
    AccountRestrictionFlagsEnum[AccountRestrictionFlagsEnum["NUMBER_32769"] = 32769] = "NUMBER_32769";
    AccountRestrictionFlagsEnum[AccountRestrictionFlagsEnum["NUMBER_32770"] = 32770] = "NUMBER_32770";
    AccountRestrictionFlagsEnum[AccountRestrictionFlagsEnum["NUMBER_49153"] = 49153] = "NUMBER_49153";
    AccountRestrictionFlagsEnum[AccountRestrictionFlagsEnum["NUMBER_49156"] = 49156] = "NUMBER_49156";
})(AccountRestrictionFlagsEnum = exports.AccountRestrictionFlagsEnum || (exports.AccountRestrictionFlagsEnum = {}));
function AccountRestrictionFlagsEnumFromJSON(json) {
    return AccountRestrictionFlagsEnumFromJSONTyped(json, false);
}
exports.AccountRestrictionFlagsEnumFromJSON = AccountRestrictionFlagsEnumFromJSON;
function AccountRestrictionFlagsEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.AccountRestrictionFlagsEnumFromJSONTyped = AccountRestrictionFlagsEnumFromJSONTyped;
function AccountRestrictionFlagsEnumToJSON(value) {
    return value;
}
exports.AccountRestrictionFlagsEnumToJSON = AccountRestrictionFlagsEnumToJSON;

},{}],962:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountRestrictionNetworkPropertiesDTOToJSON = exports.AccountRestrictionNetworkPropertiesDTOFromJSONTyped = exports.AccountRestrictionNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function AccountRestrictionNetworkPropertiesDTOFromJSON(json) {
    return AccountRestrictionNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.AccountRestrictionNetworkPropertiesDTOFromJSON = AccountRestrictionNetworkPropertiesDTOFromJSON;
function AccountRestrictionNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'maxAccountRestrictionValues': !runtime_1.exists(json, 'maxAccountRestrictionValues') ? undefined : json['maxAccountRestrictionValues'],
    };
}
exports.AccountRestrictionNetworkPropertiesDTOFromJSONTyped = AccountRestrictionNetworkPropertiesDTOFromJSONTyped;
function AccountRestrictionNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'maxAccountRestrictionValues': value.maxAccountRestrictionValues,
    };
}
exports.AccountRestrictionNetworkPropertiesDTOToJSON = AccountRestrictionNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],963:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountRestrictionsDTOToJSON = exports.AccountRestrictionsDTOFromJSONTyped = exports.AccountRestrictionsDTOFromJSON = void 0;
function AccountRestrictionsDTOFromJSON(json) {
    return AccountRestrictionsDTOFromJSONTyped(json, false);
}
exports.AccountRestrictionsDTOFromJSON = AccountRestrictionsDTOFromJSON;
function AccountRestrictionsDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'address': json['address'],
        'restrictions': json['restrictions'],
    };
}
exports.AccountRestrictionsDTOFromJSONTyped = AccountRestrictionsDTOFromJSONTyped;
function AccountRestrictionsDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'address': value.address,
        'restrictions': value.restrictions,
    };
}
exports.AccountRestrictionsDTOToJSON = AccountRestrictionsDTOToJSON;

},{}],964:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountRestrictionsInfoDTOToJSON = exports.AccountRestrictionsInfoDTOFromJSONTyped = exports.AccountRestrictionsInfoDTOFromJSON = void 0;
function AccountRestrictionsInfoDTOFromJSON(json) {
    return AccountRestrictionsInfoDTOFromJSONTyped(json, false);
}
exports.AccountRestrictionsInfoDTOFromJSON = AccountRestrictionsInfoDTOFromJSON;
function AccountRestrictionsInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'accountRestrictions': json['accountRestrictions'],
    };
}
exports.AccountRestrictionsInfoDTOFromJSONTyped = AccountRestrictionsInfoDTOFromJSONTyped;
function AccountRestrictionsInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'accountRestrictions': value.accountRestrictions,
    };
}
exports.AccountRestrictionsInfoDTOToJSON = AccountRestrictionsInfoDTOToJSON;

},{}],965:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountTypeEnumToJSON = exports.AccountTypeEnumFromJSONTyped = exports.AccountTypeEnumFromJSON = exports.AccountTypeEnum = void 0;
/**
 * * 0 - Unlinked.
 * * 1 - Balance-holding account that is linked to a remote harvester account.
 * * 2 - Remote harvester account that is linked to a balance-holding account.
 * * 3 - Remote harvester eligible account that is unlinked.
 * @export
 * @enum {string}
 */
var AccountTypeEnum;
(function (AccountTypeEnum) {
    AccountTypeEnum[AccountTypeEnum["NUMBER_0"] = 0] = "NUMBER_0";
    AccountTypeEnum[AccountTypeEnum["NUMBER_1"] = 1] = "NUMBER_1";
    AccountTypeEnum[AccountTypeEnum["NUMBER_2"] = 2] = "NUMBER_2";
    AccountTypeEnum[AccountTypeEnum["NUMBER_3"] = 3] = "NUMBER_3";
})(AccountTypeEnum = exports.AccountTypeEnum || (exports.AccountTypeEnum = {}));
function AccountTypeEnumFromJSON(json) {
    return AccountTypeEnumFromJSONTyped(json, false);
}
exports.AccountTypeEnumFromJSON = AccountTypeEnumFromJSON;
function AccountTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.AccountTypeEnumFromJSONTyped = AccountTypeEnumFromJSONTyped;
function AccountTypeEnumToJSON(value) {
    return value;
}
exports.AccountTypeEnumToJSON = AccountTypeEnumToJSON;

},{}],966:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountsNamesDTOToJSON = exports.AccountsNamesDTOFromJSONTyped = exports.AccountsNamesDTOFromJSON = void 0;
function AccountsNamesDTOFromJSON(json) {
    return AccountsNamesDTOFromJSONTyped(json, false);
}
exports.AccountsNamesDTOFromJSON = AccountsNamesDTOFromJSON;
function AccountsNamesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'accountNames': json['accountNames'],
    };
}
exports.AccountsNamesDTOFromJSONTyped = AccountsNamesDTOFromJSONTyped;
function AccountsNamesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'accountNames': value.accountNames,
    };
}
exports.AccountsNamesDTOToJSON = AccountsNamesDTOToJSON;

},{}],967:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActivityBucketDTOToJSON = exports.ActivityBucketDTOFromJSONTyped = exports.ActivityBucketDTOFromJSON = void 0;
function ActivityBucketDTOFromJSON(json) {
    return ActivityBucketDTOFromJSONTyped(json, false);
}
exports.ActivityBucketDTOFromJSON = ActivityBucketDTOFromJSON;
function ActivityBucketDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'startHeight': json['startHeight'],
        'totalFeesPaid': json['totalFeesPaid'],
        'beneficiaryCount': json['beneficiaryCount'],
        'rawScore': json['rawScore'],
    };
}
exports.ActivityBucketDTOFromJSONTyped = ActivityBucketDTOFromJSONTyped;
function ActivityBucketDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'startHeight': value.startHeight,
        'totalFeesPaid': value.totalFeesPaid,
        'beneficiaryCount': value.beneficiaryCount,
        'rawScore': value.rawScore,
    };
}
exports.ActivityBucketDTOToJSON = ActivityBucketDTOToJSON;

},{}],968:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressAliasTransactionBodyDTOToJSON = exports.AddressAliasTransactionBodyDTOFromJSONTyped = exports.AddressAliasTransactionBodyDTOFromJSON = void 0;
function AddressAliasTransactionBodyDTOFromJSON(json) {
    return AddressAliasTransactionBodyDTOFromJSONTyped(json, false);
}
exports.AddressAliasTransactionBodyDTOFromJSON = AddressAliasTransactionBodyDTOFromJSON;
function AddressAliasTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'namespaceId': json['namespaceId'],
        'address': json['address'],
        'aliasAction': json['aliasAction'],
    };
}
exports.AddressAliasTransactionBodyDTOFromJSONTyped = AddressAliasTransactionBodyDTOFromJSONTyped;
function AddressAliasTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'namespaceId': value.namespaceId,
        'address': value.address,
        'aliasAction': value.aliasAction,
    };
}
exports.AddressAliasTransactionBodyDTOToJSON = AddressAliasTransactionBodyDTOToJSON;

},{}],969:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressAliasTransactionDTOToJSON = exports.AddressAliasTransactionDTOFromJSONTyped = exports.AddressAliasTransactionDTOFromJSON = void 0;
function AddressAliasTransactionDTOFromJSON(json) {
    return AddressAliasTransactionDTOFromJSONTyped(json, false);
}
exports.AddressAliasTransactionDTOFromJSON = AddressAliasTransactionDTOFromJSON;
function AddressAliasTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'namespaceId': json['namespaceId'],
        'address': json['address'],
        'aliasAction': json['aliasAction'],
    };
}
exports.AddressAliasTransactionDTOFromJSONTyped = AddressAliasTransactionDTOFromJSONTyped;
function AddressAliasTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'namespaceId': value.namespaceId,
        'address': value.address,
        'aliasAction': value.aliasAction,
    };
}
exports.AddressAliasTransactionDTOToJSON = AddressAliasTransactionDTOToJSON;

},{}],970:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressesToJSON = exports.AddressesFromJSONTyped = exports.AddressesFromJSON = void 0;
const runtime_1 = require("../runtime");
function AddressesFromJSON(json) {
    return AddressesFromJSONTyped(json, false);
}
exports.AddressesFromJSON = AddressesFromJSON;
function AddressesFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'addresses': !runtime_1.exists(json, 'addresses') ? undefined : json['addresses'],
    };
}
exports.AddressesFromJSONTyped = AddressesFromJSONTyped;
function AddressesToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'addresses': value.addresses,
    };
}
exports.AddressesToJSON = AddressesToJSON;

},{"../runtime":1158}],971:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregateNetworkPropertiesDTOToJSON = exports.AggregateNetworkPropertiesDTOFromJSONTyped = exports.AggregateNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function AggregateNetworkPropertiesDTOFromJSON(json) {
    return AggregateNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.AggregateNetworkPropertiesDTOFromJSON = AggregateNetworkPropertiesDTOFromJSON;
function AggregateNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'maxTransactionsPerAggregate': !runtime_1.exists(json, 'maxTransactionsPerAggregate') ? undefined : json['maxTransactionsPerAggregate'],
        'maxCosignaturesPerAggregate': !runtime_1.exists(json, 'maxCosignaturesPerAggregate') ? undefined : json['maxCosignaturesPerAggregate'],
        'enableStrictCosignatureCheck': !runtime_1.exists(json, 'enableStrictCosignatureCheck') ? undefined : json['enableStrictCosignatureCheck'],
        'enableBondedAggregateSupport': !runtime_1.exists(json, 'enableBondedAggregateSupport') ? undefined : json['enableBondedAggregateSupport'],
        'maxBondedTransactionLifetime': !runtime_1.exists(json, 'maxBondedTransactionLifetime') ? undefined : json['maxBondedTransactionLifetime'],
    };
}
exports.AggregateNetworkPropertiesDTOFromJSONTyped = AggregateNetworkPropertiesDTOFromJSONTyped;
function AggregateNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'maxTransactionsPerAggregate': value.maxTransactionsPerAggregate,
        'maxCosignaturesPerAggregate': value.maxCosignaturesPerAggregate,
        'enableStrictCosignatureCheck': value.enableStrictCosignatureCheck,
        'enableBondedAggregateSupport': value.enableBondedAggregateSupport,
        'maxBondedTransactionLifetime': value.maxBondedTransactionLifetime,
    };
}
exports.AggregateNetworkPropertiesDTOToJSON = AggregateNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],972:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregateTransactionBodyDTOToJSON = exports.AggregateTransactionBodyDTOFromJSONTyped = exports.AggregateTransactionBodyDTOFromJSON = void 0;
function AggregateTransactionBodyDTOFromJSON(json) {
    return AggregateTransactionBodyDTOFromJSONTyped(json, false);
}
exports.AggregateTransactionBodyDTOFromJSON = AggregateTransactionBodyDTOFromJSON;
function AggregateTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'transactionsHash': json['transactionsHash'],
        'cosignatures': json['cosignatures'],
    };
}
exports.AggregateTransactionBodyDTOFromJSONTyped = AggregateTransactionBodyDTOFromJSONTyped;
function AggregateTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'transactionsHash': value.transactionsHash,
        'cosignatures': value.cosignatures,
    };
}
exports.AggregateTransactionBodyDTOToJSON = AggregateTransactionBodyDTOToJSON;

},{}],973:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregateTransactionBodyExtendedDTOToJSON = exports.AggregateTransactionBodyExtendedDTOFromJSONTyped = exports.AggregateTransactionBodyExtendedDTOFromJSON = void 0;
function AggregateTransactionBodyExtendedDTOFromJSON(json) {
    return AggregateTransactionBodyExtendedDTOFromJSONTyped(json, false);
}
exports.AggregateTransactionBodyExtendedDTOFromJSON = AggregateTransactionBodyExtendedDTOFromJSON;
function AggregateTransactionBodyExtendedDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'transactionsHash': json['transactionsHash'],
        'cosignatures': json['cosignatures'],
        'transactions': json['transactions'],
    };
}
exports.AggregateTransactionBodyExtendedDTOFromJSONTyped = AggregateTransactionBodyExtendedDTOFromJSONTyped;
function AggregateTransactionBodyExtendedDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'transactionsHash': value.transactionsHash,
        'cosignatures': value.cosignatures,
        'transactions': value.transactions,
    };
}
exports.AggregateTransactionBodyExtendedDTOToJSON = AggregateTransactionBodyExtendedDTOToJSON;

},{}],974:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregateTransactionDTOToJSON = exports.AggregateTransactionDTOFromJSONTyped = exports.AggregateTransactionDTOFromJSON = void 0;
function AggregateTransactionDTOFromJSON(json) {
    return AggregateTransactionDTOFromJSONTyped(json, false);
}
exports.AggregateTransactionDTOFromJSON = AggregateTransactionDTOFromJSON;
function AggregateTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'transactionsHash': json['transactionsHash'],
        'cosignatures': json['cosignatures'],
    };
}
exports.AggregateTransactionDTOFromJSONTyped = AggregateTransactionDTOFromJSONTyped;
function AggregateTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'transactionsHash': value.transactionsHash,
        'cosignatures': value.cosignatures,
    };
}
exports.AggregateTransactionDTOToJSON = AggregateTransactionDTOToJSON;

},{}],975:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregateTransactionExtendedDTOToJSON = exports.AggregateTransactionExtendedDTOFromJSONTyped = exports.AggregateTransactionExtendedDTOFromJSON = void 0;
function AggregateTransactionExtendedDTOFromJSON(json) {
    return AggregateTransactionExtendedDTOFromJSONTyped(json, false);
}
exports.AggregateTransactionExtendedDTOFromJSON = AggregateTransactionExtendedDTOFromJSON;
function AggregateTransactionExtendedDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'transactionsHash': json['transactionsHash'],
        'cosignatures': json['cosignatures'],
        'transactions': json['transactions'],
    };
}
exports.AggregateTransactionExtendedDTOFromJSONTyped = AggregateTransactionExtendedDTOFromJSONTyped;
function AggregateTransactionExtendedDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'transactionsHash': value.transactionsHash,
        'cosignatures': value.cosignatures,
        'transactions': value.transactions,
    };
}
exports.AggregateTransactionExtendedDTOToJSON = AggregateTransactionExtendedDTOToJSON;

},{}],976:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AliasActionEnumToJSON = exports.AliasActionEnumFromJSONTyped = exports.AliasActionEnumFromJSON = exports.AliasActionEnum = void 0;
/**
 * Alias action:
 * * 0 - Unlink alias.
 * * 1 - Link alias.
 * @export
 * @enum {string}
 */
var AliasActionEnum;
(function (AliasActionEnum) {
    AliasActionEnum[AliasActionEnum["NUMBER_0"] = 0] = "NUMBER_0";
    AliasActionEnum[AliasActionEnum["NUMBER_1"] = 1] = "NUMBER_1";
})(AliasActionEnum = exports.AliasActionEnum || (exports.AliasActionEnum = {}));
function AliasActionEnumFromJSON(json) {
    return AliasActionEnumFromJSONTyped(json, false);
}
exports.AliasActionEnumFromJSON = AliasActionEnumFromJSON;
function AliasActionEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.AliasActionEnumFromJSONTyped = AliasActionEnumFromJSONTyped;
function AliasActionEnumToJSON(value) {
    return value;
}
exports.AliasActionEnumToJSON = AliasActionEnumToJSON;

},{}],977:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AliasDTOToJSON = exports.AliasDTOFromJSONTyped = exports.AliasDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function AliasDTOFromJSON(json) {
    return AliasDTOFromJSONTyped(json, false);
}
exports.AliasDTOFromJSON = AliasDTOFromJSON;
function AliasDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'type': json['type'],
        'mosaicId': !runtime_1.exists(json, 'mosaicId') ? undefined : json['mosaicId'],
        'address': !runtime_1.exists(json, 'address') ? undefined : json['address'],
    };
}
exports.AliasDTOFromJSONTyped = AliasDTOFromJSONTyped;
function AliasDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'type': value.type,
        'mosaicId': value.mosaicId,
        'address': value.address,
    };
}
exports.AliasDTOToJSON = AliasDTOToJSON;

},{"../runtime":1158}],978:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AliasTypeEnumToJSON = exports.AliasTypeEnumFromJSONTyped = exports.AliasTypeEnumFromJSON = exports.AliasTypeEnum = void 0;
/**
 * Type of alias:
 * * 0 - No alias.
 * * 1 - Mosaic id alias.
 * * 2 - Addres alias.
 * @export
 * @enum {string}
 */
var AliasTypeEnum;
(function (AliasTypeEnum) {
    AliasTypeEnum[AliasTypeEnum["NUMBER_0"] = 0] = "NUMBER_0";
    AliasTypeEnum[AliasTypeEnum["NUMBER_1"] = 1] = "NUMBER_1";
    AliasTypeEnum[AliasTypeEnum["NUMBER_2"] = 2] = "NUMBER_2";
})(AliasTypeEnum = exports.AliasTypeEnum || (exports.AliasTypeEnum = {}));
function AliasTypeEnumFromJSON(json) {
    return AliasTypeEnumFromJSONTyped(json, false);
}
exports.AliasTypeEnumFromJSON = AliasTypeEnumFromJSON;
function AliasTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.AliasTypeEnumFromJSONTyped = AliasTypeEnumFromJSONTyped;
function AliasTypeEnumToJSON(value) {
    return value;
}
exports.AliasTypeEnumToJSON = AliasTypeEnumToJSON;

},{}],979:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnnounceTransactionInfoDTOToJSON = exports.AnnounceTransactionInfoDTOFromJSONTyped = exports.AnnounceTransactionInfoDTOFromJSON = void 0;
function AnnounceTransactionInfoDTOFromJSON(json) {
    return AnnounceTransactionInfoDTOFromJSONTyped(json, false);
}
exports.AnnounceTransactionInfoDTOFromJSON = AnnounceTransactionInfoDTOFromJSON;
function AnnounceTransactionInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'message': json['message'],
    };
}
exports.AnnounceTransactionInfoDTOFromJSONTyped = AnnounceTransactionInfoDTOFromJSONTyped;
function AnnounceTransactionInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'message': value.message,
    };
}
exports.AnnounceTransactionInfoDTOToJSON = AnnounceTransactionInfoDTOToJSON;

},{}],980:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BalanceChangeReceiptDTOToJSON = exports.BalanceChangeReceiptDTOFromJSONTyped = exports.BalanceChangeReceiptDTOFromJSON = void 0;
function BalanceChangeReceiptDTOFromJSON(json) {
    return BalanceChangeReceiptDTOFromJSONTyped(json, false);
}
exports.BalanceChangeReceiptDTOFromJSON = BalanceChangeReceiptDTOFromJSON;
function BalanceChangeReceiptDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'version': json['version'],
        'type': json['type'],
        'mosaicId': json['mosaicId'],
        'amount': json['amount'],
        'targetAddress': json['targetAddress'],
    };
}
exports.BalanceChangeReceiptDTOFromJSONTyped = BalanceChangeReceiptDTOFromJSONTyped;
function BalanceChangeReceiptDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'version': value.version,
        'type': value.type,
        'mosaicId': value.mosaicId,
        'amount': value.amount,
        'targetAddress': value.targetAddress,
    };
}
exports.BalanceChangeReceiptDTOToJSON = BalanceChangeReceiptDTOToJSON;

},{}],981:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BalanceChangeReceiptDTOAllOfToJSON = exports.BalanceChangeReceiptDTOAllOfFromJSONTyped = exports.BalanceChangeReceiptDTOAllOfFromJSON = void 0;
function BalanceChangeReceiptDTOAllOfFromJSON(json) {
    return BalanceChangeReceiptDTOAllOfFromJSONTyped(json, false);
}
exports.BalanceChangeReceiptDTOAllOfFromJSON = BalanceChangeReceiptDTOAllOfFromJSON;
function BalanceChangeReceiptDTOAllOfFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'mosaicId': json['mosaicId'],
        'amount': json['amount'],
        'targetAddress': json['targetAddress'],
    };
}
exports.BalanceChangeReceiptDTOAllOfFromJSONTyped = BalanceChangeReceiptDTOAllOfFromJSONTyped;
function BalanceChangeReceiptDTOAllOfToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'mosaicId': value.mosaicId,
        'amount': value.amount,
        'targetAddress': value.targetAddress,
    };
}
exports.BalanceChangeReceiptDTOAllOfToJSON = BalanceChangeReceiptDTOAllOfToJSON;

},{}],982:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BalanceTransferReceiptDTOToJSON = exports.BalanceTransferReceiptDTOFromJSONTyped = exports.BalanceTransferReceiptDTOFromJSON = void 0;
function BalanceTransferReceiptDTOFromJSON(json) {
    return BalanceTransferReceiptDTOFromJSONTyped(json, false);
}
exports.BalanceTransferReceiptDTOFromJSON = BalanceTransferReceiptDTOFromJSON;
function BalanceTransferReceiptDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'version': json['version'],
        'type': json['type'],
        'mosaicId': json['mosaicId'],
        'amount': json['amount'],
        'senderAddress': json['senderAddress'],
        'recipientAddress': json['recipientAddress'],
    };
}
exports.BalanceTransferReceiptDTOFromJSONTyped = BalanceTransferReceiptDTOFromJSONTyped;
function BalanceTransferReceiptDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'version': value.version,
        'type': value.type,
        'mosaicId': value.mosaicId,
        'amount': value.amount,
        'senderAddress': value.senderAddress,
        'recipientAddress': value.recipientAddress,
    };
}
exports.BalanceTransferReceiptDTOToJSON = BalanceTransferReceiptDTOToJSON;

},{}],983:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BalanceTransferReceiptDTOAllOfToJSON = exports.BalanceTransferReceiptDTOAllOfFromJSONTyped = exports.BalanceTransferReceiptDTOAllOfFromJSON = void 0;
function BalanceTransferReceiptDTOAllOfFromJSON(json) {
    return BalanceTransferReceiptDTOAllOfFromJSONTyped(json, false);
}
exports.BalanceTransferReceiptDTOAllOfFromJSON = BalanceTransferReceiptDTOAllOfFromJSON;
function BalanceTransferReceiptDTOAllOfFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'mosaicId': json['mosaicId'],
        'amount': json['amount'],
        'senderAddress': json['senderAddress'],
        'recipientAddress': json['recipientAddress'],
    };
}
exports.BalanceTransferReceiptDTOAllOfFromJSONTyped = BalanceTransferReceiptDTOAllOfFromJSONTyped;
function BalanceTransferReceiptDTOAllOfToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'mosaicId': value.mosaicId,
        'amount': value.amount,
        'senderAddress': value.senderAddress,
        'recipientAddress': value.recipientAddress,
    };
}
exports.BalanceTransferReceiptDTOAllOfToJSON = BalanceTransferReceiptDTOAllOfToJSON;

},{}],984:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockDTOToJSON = exports.BlockDTOFromJSONTyped = exports.BlockDTOFromJSON = void 0;
function BlockDTOFromJSON(json) {
    return BlockDTOFromJSONTyped(json, false);
}
exports.BlockDTOFromJSON = BlockDTOFromJSON;
function BlockDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'height': json['height'],
        'timestamp': json['timestamp'],
        'difficulty': json['difficulty'],
        'proofGamma': json['proofGamma'],
        'proofVerificationHash': json['proofVerificationHash'],
        'proofScalar': json['proofScalar'],
        'previousBlockHash': json['previousBlockHash'],
        'transactionsHash': json['transactionsHash'],
        'receiptsHash': json['receiptsHash'],
        'stateHash': json['stateHash'],
        'beneficiaryAddress': json['beneficiaryAddress'],
        'feeMultiplier': json['feeMultiplier'],
    };
}
exports.BlockDTOFromJSONTyped = BlockDTOFromJSONTyped;
function BlockDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'height': value.height,
        'timestamp': value.timestamp,
        'difficulty': value.difficulty,
        'proofGamma': value.proofGamma,
        'proofVerificationHash': value.proofVerificationHash,
        'proofScalar': value.proofScalar,
        'previousBlockHash': value.previousBlockHash,
        'transactionsHash': value.transactionsHash,
        'receiptsHash': value.receiptsHash,
        'stateHash': value.stateHash,
        'beneficiaryAddress': value.beneficiaryAddress,
        'feeMultiplier': value.feeMultiplier,
    };
}
exports.BlockDTOToJSON = BlockDTOToJSON;

},{}],985:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockDTOAllOfToJSON = exports.BlockDTOAllOfFromJSONTyped = exports.BlockDTOAllOfFromJSON = void 0;
function BlockDTOAllOfFromJSON(json) {
    return BlockDTOAllOfFromJSONTyped(json, false);
}
exports.BlockDTOAllOfFromJSON = BlockDTOAllOfFromJSON;
function BlockDTOAllOfFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'height': json['height'],
        'timestamp': json['timestamp'],
        'difficulty': json['difficulty'],
        'proofGamma': json['proofGamma'],
        'proofVerificationHash': json['proofVerificationHash'],
        'proofScalar': json['proofScalar'],
        'previousBlockHash': json['previousBlockHash'],
        'transactionsHash': json['transactionsHash'],
        'receiptsHash': json['receiptsHash'],
        'stateHash': json['stateHash'],
        'beneficiaryAddress': json['beneficiaryAddress'],
        'feeMultiplier': json['feeMultiplier'],
    };
}
exports.BlockDTOAllOfFromJSONTyped = BlockDTOAllOfFromJSONTyped;
function BlockDTOAllOfToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'height': value.height,
        'timestamp': value.timestamp,
        'difficulty': value.difficulty,
        'proofGamma': value.proofGamma,
        'proofVerificationHash': value.proofVerificationHash,
        'proofScalar': value.proofScalar,
        'previousBlockHash': value.previousBlockHash,
        'transactionsHash': value.transactionsHash,
        'receiptsHash': value.receiptsHash,
        'stateHash': value.stateHash,
        'beneficiaryAddress': value.beneficiaryAddress,
        'feeMultiplier': value.feeMultiplier,
    };
}
exports.BlockDTOAllOfToJSON = BlockDTOAllOfToJSON;

},{}],986:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockInfoDTOToJSON = exports.BlockInfoDTOFromJSONTyped = exports.BlockInfoDTOFromJSON = void 0;
function BlockInfoDTOFromJSON(json) {
    return BlockInfoDTOFromJSONTyped(json, false);
}
exports.BlockInfoDTOFromJSON = BlockInfoDTOFromJSON;
function BlockInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'meta': json['meta'],
        'block': json['block'],
    };
}
exports.BlockInfoDTOFromJSONTyped = BlockInfoDTOFromJSONTyped;
function BlockInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'meta': value.meta,
        'block': value.block,
    };
}
exports.BlockInfoDTOToJSON = BlockInfoDTOToJSON;

},{}],987:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockMetaDTOToJSON = exports.BlockMetaDTOFromJSONTyped = exports.BlockMetaDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function BlockMetaDTOFromJSON(json) {
    return BlockMetaDTOFromJSONTyped(json, false);
}
exports.BlockMetaDTOFromJSON = BlockMetaDTOFromJSON;
function BlockMetaDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'hash': json['hash'],
        'totalFee': json['totalFee'],
        'generationHash': json['generationHash'],
        'stateHashSubCacheMerkleRoots': json['stateHashSubCacheMerkleRoots'],
        'numTransactions': json['numTransactions'],
        'numStatements': !runtime_1.exists(json, 'numStatements') ? undefined : json['numStatements'],
    };
}
exports.BlockMetaDTOFromJSONTyped = BlockMetaDTOFromJSONTyped;
function BlockMetaDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'hash': value.hash,
        'totalFee': value.totalFee,
        'generationHash': value.generationHash,
        'stateHashSubCacheMerkleRoots': value.stateHashSubCacheMerkleRoots,
        'numTransactions': value.numTransactions,
        'numStatements': value.numStatements,
    };
}
exports.BlockMetaDTOToJSON = BlockMetaDTOToJSON;

},{"../runtime":1158}],988:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockOrderByEnumToJSON = exports.BlockOrderByEnumFromJSONTyped = exports.BlockOrderByEnumFromJSON = exports.BlockOrderByEnum = void 0;
/**
 *
 * @export
 * @enum {string}
 */
var BlockOrderByEnum;
(function (BlockOrderByEnum) {
    BlockOrderByEnum["Id"] = "id";
    BlockOrderByEnum["Height"] = "height";
})(BlockOrderByEnum = exports.BlockOrderByEnum || (exports.BlockOrderByEnum = {}));
function BlockOrderByEnumFromJSON(json) {
    return BlockOrderByEnumFromJSONTyped(json, false);
}
exports.BlockOrderByEnumFromJSON = BlockOrderByEnumFromJSON;
function BlockOrderByEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.BlockOrderByEnumFromJSONTyped = BlockOrderByEnumFromJSONTyped;
function BlockOrderByEnumToJSON(value) {
    return value;
}
exports.BlockOrderByEnumToJSON = BlockOrderByEnumToJSON;

},{}],989:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockPageToJSON = exports.BlockPageFromJSONTyped = exports.BlockPageFromJSON = void 0;
function BlockPageFromJSON(json) {
    return BlockPageFromJSONTyped(json, false);
}
exports.BlockPageFromJSON = BlockPageFromJSON;
function BlockPageFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'data': json['data'],
        'pagination': json['pagination'],
    };
}
exports.BlockPageFromJSONTyped = BlockPageFromJSONTyped;
function BlockPageToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'data': value.data,
        'pagination': value.pagination,
    };
}
exports.BlockPageToJSON = BlockPageToJSON;

},{}],990:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainPropertiesDTOToJSON = exports.ChainPropertiesDTOFromJSONTyped = exports.ChainPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function ChainPropertiesDTOFromJSON(json) {
    return ChainPropertiesDTOFromJSONTyped(json, false);
}
exports.ChainPropertiesDTOFromJSON = ChainPropertiesDTOFromJSON;
function ChainPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'enableVerifiableState': !runtime_1.exists(json, 'enableVerifiableState') ? undefined : json['enableVerifiableState'],
        'enableVerifiableReceipts': !runtime_1.exists(json, 'enableVerifiableReceipts') ? undefined : json['enableVerifiableReceipts'],
        'currencyMosaicId': !runtime_1.exists(json, 'currencyMosaicId') ? undefined : json['currencyMosaicId'],
        'harvestingMosaicId': !runtime_1.exists(json, 'harvestingMosaicId') ? undefined : json['harvestingMosaicId'],
        'blockGenerationTargetTime': !runtime_1.exists(json, 'blockGenerationTargetTime') ? undefined : json['blockGenerationTargetTime'],
        'blockTimeSmoothingFactor': !runtime_1.exists(json, 'blockTimeSmoothingFactor') ? undefined : json['blockTimeSmoothingFactor'],
        'blockFinalizationInterval': !runtime_1.exists(json, 'blockFinalizationInterval') ? undefined : json['blockFinalizationInterval'],
        'importanceGrouping': !runtime_1.exists(json, 'importanceGrouping') ? undefined : json['importanceGrouping'],
        'importanceActivityPercentage': !runtime_1.exists(json, 'importanceActivityPercentage') ? undefined : json['importanceActivityPercentage'],
        'maxRollbackBlocks': !runtime_1.exists(json, 'maxRollbackBlocks') ? undefined : json['maxRollbackBlocks'],
        'maxDifficultyBlocks': !runtime_1.exists(json, 'maxDifficultyBlocks') ? undefined : json['maxDifficultyBlocks'],
        'defaultDynamicFeeMultiplier': !runtime_1.exists(json, 'defaultDynamicFeeMultiplier') ? undefined : json['defaultDynamicFeeMultiplier'],
        'maxTransactionLifetime': !runtime_1.exists(json, 'maxTransactionLifetime') ? undefined : json['maxTransactionLifetime'],
        'maxBlockFutureTime': !runtime_1.exists(json, 'maxBlockFutureTime') ? undefined : json['maxBlockFutureTime'],
        'initialCurrencyAtomicUnits': !runtime_1.exists(json, 'initialCurrencyAtomicUnits') ? undefined : json['initialCurrencyAtomicUnits'],
        'maxMosaicAtomicUnits': !runtime_1.exists(json, 'maxMosaicAtomicUnits') ? undefined : json['maxMosaicAtomicUnits'],
        'totalChainImportance': !runtime_1.exists(json, 'totalChainImportance') ? undefined : json['totalChainImportance'],
        'minHarvesterBalance': !runtime_1.exists(json, 'minHarvesterBalance') ? undefined : json['minHarvesterBalance'],
        'maxHarvesterBalance': !runtime_1.exists(json, 'maxHarvesterBalance') ? undefined : json['maxHarvesterBalance'],
        'minVoterBalance': !runtime_1.exists(json, 'minVoterBalance') ? undefined : json['minVoterBalance'],
        'maxVotingKeysPerAccount': !runtime_1.exists(json, 'maxVotingKeysPerAccount') ? undefined : json['maxVotingKeysPerAccount'],
        'minVotingKeyLifetime': !runtime_1.exists(json, 'minVotingKeyLifetime') ? undefined : json['minVotingKeyLifetime'],
        'maxVotingKeyLifetime': !runtime_1.exists(json, 'maxVotingKeyLifetime') ? undefined : json['maxVotingKeyLifetime'],
        'harvestBeneficiaryPercentage': !runtime_1.exists(json, 'harvestBeneficiaryPercentage') ? undefined : json['harvestBeneficiaryPercentage'],
        'harvestNetworkPercentage': !runtime_1.exists(json, 'harvestNetworkPercentage') ? undefined : json['harvestNetworkPercentage'],
        'harvestNetworkFeeSinkAddress': !runtime_1.exists(json, 'harvestNetworkFeeSinkAddress') ? undefined : json['harvestNetworkFeeSinkAddress'],
        'blockPruneInterval': !runtime_1.exists(json, 'blockPruneInterval') ? undefined : json['blockPruneInterval'],
        'maxTransactionsPerBlock': !runtime_1.exists(json, 'maxTransactionsPerBlock') ? undefined : json['maxTransactionsPerBlock'],
    };
}
exports.ChainPropertiesDTOFromJSONTyped = ChainPropertiesDTOFromJSONTyped;
function ChainPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'enableVerifiableState': value.enableVerifiableState,
        'enableVerifiableReceipts': value.enableVerifiableReceipts,
        'currencyMosaicId': value.currencyMosaicId,
        'harvestingMosaicId': value.harvestingMosaicId,
        'blockGenerationTargetTime': value.blockGenerationTargetTime,
        'blockTimeSmoothingFactor': value.blockTimeSmoothingFactor,
        'blockFinalizationInterval': value.blockFinalizationInterval,
        'importanceGrouping': value.importanceGrouping,
        'importanceActivityPercentage': value.importanceActivityPercentage,
        'maxRollbackBlocks': value.maxRollbackBlocks,
        'maxDifficultyBlocks': value.maxDifficultyBlocks,
        'defaultDynamicFeeMultiplier': value.defaultDynamicFeeMultiplier,
        'maxTransactionLifetime': value.maxTransactionLifetime,
        'maxBlockFutureTime': value.maxBlockFutureTime,
        'initialCurrencyAtomicUnits': value.initialCurrencyAtomicUnits,
        'maxMosaicAtomicUnits': value.maxMosaicAtomicUnits,
        'totalChainImportance': value.totalChainImportance,
        'minHarvesterBalance': value.minHarvesterBalance,
        'maxHarvesterBalance': value.maxHarvesterBalance,
        'minVoterBalance': value.minVoterBalance,
        'maxVotingKeysPerAccount': value.maxVotingKeysPerAccount,
        'minVotingKeyLifetime': value.minVotingKeyLifetime,
        'maxVotingKeyLifetime': value.maxVotingKeyLifetime,
        'harvestBeneficiaryPercentage': value.harvestBeneficiaryPercentage,
        'harvestNetworkPercentage': value.harvestNetworkPercentage,
        'harvestNetworkFeeSinkAddress': value.harvestNetworkFeeSinkAddress,
        'blockPruneInterval': value.blockPruneInterval,
        'maxTransactionsPerBlock': value.maxTransactionsPerBlock,
    };
}
exports.ChainPropertiesDTOToJSON = ChainPropertiesDTOToJSON;

},{"../runtime":1158}],991:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainScoreDTOToJSON = exports.ChainScoreDTOFromJSONTyped = exports.ChainScoreDTOFromJSON = void 0;
function ChainScoreDTOFromJSON(json) {
    return ChainScoreDTOFromJSONTyped(json, false);
}
exports.ChainScoreDTOFromJSON = ChainScoreDTOFromJSON;
function ChainScoreDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'scoreHigh': json['scoreHigh'],
        'scoreLow': json['scoreLow'],
    };
}
exports.ChainScoreDTOFromJSONTyped = ChainScoreDTOFromJSONTyped;
function ChainScoreDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'scoreHigh': value.scoreHigh,
        'scoreLow': value.scoreLow,
    };
}
exports.ChainScoreDTOToJSON = ChainScoreDTOToJSON;

},{}],992:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommunicationTimestampsDTOToJSON = exports.CommunicationTimestampsDTOFromJSONTyped = exports.CommunicationTimestampsDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function CommunicationTimestampsDTOFromJSON(json) {
    return CommunicationTimestampsDTOFromJSONTyped(json, false);
}
exports.CommunicationTimestampsDTOFromJSON = CommunicationTimestampsDTOFromJSON;
function CommunicationTimestampsDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'sendTimestamp': !runtime_1.exists(json, 'sendTimestamp') ? undefined : json['sendTimestamp'],
        'receiveTimestamp': !runtime_1.exists(json, 'receiveTimestamp') ? undefined : json['receiveTimestamp'],
    };
}
exports.CommunicationTimestampsDTOFromJSONTyped = CommunicationTimestampsDTOFromJSONTyped;
function CommunicationTimestampsDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'sendTimestamp': value.sendTimestamp,
        'receiveTimestamp': value.receiveTimestamp,
    };
}
exports.CommunicationTimestampsDTOToJSON = CommunicationTimestampsDTOToJSON;

},{"../runtime":1158}],993:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosignatureToJSON = exports.CosignatureFromJSONTyped = exports.CosignatureFromJSON = void 0;
const runtime_1 = require("../runtime");
function CosignatureFromJSON(json) {
    return CosignatureFromJSONTyped(json, false);
}
exports.CosignatureFromJSON = CosignatureFromJSON;
function CosignatureFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'parentHash': !runtime_1.exists(json, 'parentHash') ? undefined : json['parentHash'],
        'signature': !runtime_1.exists(json, 'signature') ? undefined : json['signature'],
        'signerPublicKey': !runtime_1.exists(json, 'signerPublicKey') ? undefined : json['signerPublicKey'],
        'version': !runtime_1.exists(json, 'version') ? undefined : json['version'],
    };
}
exports.CosignatureFromJSONTyped = CosignatureFromJSONTyped;
function CosignatureToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'parentHash': value.parentHash,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
    };
}
exports.CosignatureToJSON = CosignatureToJSON;

},{"../runtime":1158}],994:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosignatureDTOToJSON = exports.CosignatureDTOFromJSONTyped = exports.CosignatureDTOFromJSON = void 0;
function CosignatureDTOFromJSON(json) {
    return CosignatureDTOFromJSONTyped(json, false);
}
exports.CosignatureDTOFromJSON = CosignatureDTOFromJSON;
function CosignatureDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signature': json['signature'],
        'version': json['version'],
        'signerPublicKey': json['signerPublicKey'],
    };
}
exports.CosignatureDTOFromJSONTyped = CosignatureDTOFromJSONTyped;
function CosignatureDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signature': value.signature,
        'version': value.version,
        'signerPublicKey': value.signerPublicKey,
    };
}
exports.CosignatureDTOToJSON = CosignatureDTOToJSON;

},{}],995:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosignatureDTOAllOfToJSON = exports.CosignatureDTOAllOfFromJSONTyped = exports.CosignatureDTOAllOfFromJSON = void 0;
function CosignatureDTOAllOfFromJSON(json) {
    return CosignatureDTOAllOfFromJSONTyped(json, false);
}
exports.CosignatureDTOAllOfFromJSON = CosignatureDTOAllOfFromJSON;
function CosignatureDTOAllOfFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'version': json['version'],
        'signerPublicKey': json['signerPublicKey'],
    };
}
exports.CosignatureDTOAllOfFromJSONTyped = CosignatureDTOAllOfFromJSONTyped;
function CosignatureDTOAllOfToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'version': value.version,
        'signerPublicKey': value.signerPublicKey,
    };
}
exports.CosignatureDTOAllOfToJSON = CosignatureDTOAllOfToJSON;

},{}],996:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedAccountAddressRestrictionTransactionDTOToJSON = exports.EmbeddedAccountAddressRestrictionTransactionDTOFromJSONTyped = exports.EmbeddedAccountAddressRestrictionTransactionDTOFromJSON = void 0;
function EmbeddedAccountAddressRestrictionTransactionDTOFromJSON(json) {
    return EmbeddedAccountAddressRestrictionTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedAccountAddressRestrictionTransactionDTOFromJSON = EmbeddedAccountAddressRestrictionTransactionDTOFromJSON;
function EmbeddedAccountAddressRestrictionTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'restrictionFlags': json['restrictionFlags'],
        'restrictionAdditions': json['restrictionAdditions'],
        'restrictionDeletions': json['restrictionDeletions'],
    };
}
exports.EmbeddedAccountAddressRestrictionTransactionDTOFromJSONTyped = EmbeddedAccountAddressRestrictionTransactionDTOFromJSONTyped;
function EmbeddedAccountAddressRestrictionTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'restrictionFlags': value.restrictionFlags,
        'restrictionAdditions': value.restrictionAdditions,
        'restrictionDeletions': value.restrictionDeletions,
    };
}
exports.EmbeddedAccountAddressRestrictionTransactionDTOToJSON = EmbeddedAccountAddressRestrictionTransactionDTOToJSON;

},{}],997:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedAccountKeyLinkTransactionDTOToJSON = exports.EmbeddedAccountKeyLinkTransactionDTOFromJSONTyped = exports.EmbeddedAccountKeyLinkTransactionDTOFromJSON = void 0;
function EmbeddedAccountKeyLinkTransactionDTOFromJSON(json) {
    return EmbeddedAccountKeyLinkTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedAccountKeyLinkTransactionDTOFromJSON = EmbeddedAccountKeyLinkTransactionDTOFromJSON;
function EmbeddedAccountKeyLinkTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'linkedPublicKey': json['linkedPublicKey'],
        'linkAction': json['linkAction'],
    };
}
exports.EmbeddedAccountKeyLinkTransactionDTOFromJSONTyped = EmbeddedAccountKeyLinkTransactionDTOFromJSONTyped;
function EmbeddedAccountKeyLinkTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'linkedPublicKey': value.linkedPublicKey,
        'linkAction': value.linkAction,
    };
}
exports.EmbeddedAccountKeyLinkTransactionDTOToJSON = EmbeddedAccountKeyLinkTransactionDTOToJSON;

},{}],998:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedAccountMetadataTransactionDTOToJSON = exports.EmbeddedAccountMetadataTransactionDTOFromJSONTyped = exports.EmbeddedAccountMetadataTransactionDTOFromJSON = void 0;
function EmbeddedAccountMetadataTransactionDTOFromJSON(json) {
    return EmbeddedAccountMetadataTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedAccountMetadataTransactionDTOFromJSON = EmbeddedAccountMetadataTransactionDTOFromJSON;
function EmbeddedAccountMetadataTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'targetAddress': json['targetAddress'],
        'scopedMetadataKey': json['scopedMetadataKey'],
        'valueSizeDelta': json['valueSizeDelta'],
        'valueSize': json['valueSize'],
        'value': json['value'],
    };
}
exports.EmbeddedAccountMetadataTransactionDTOFromJSONTyped = EmbeddedAccountMetadataTransactionDTOFromJSONTyped;
function EmbeddedAccountMetadataTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'targetAddress': value.targetAddress,
        'scopedMetadataKey': value.scopedMetadataKey,
        'valueSizeDelta': value.valueSizeDelta,
        'valueSize': value.valueSize,
        'value': value.value,
    };
}
exports.EmbeddedAccountMetadataTransactionDTOToJSON = EmbeddedAccountMetadataTransactionDTOToJSON;

},{}],999:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedAccountMosaicRestrictionTransactionDTOToJSON = exports.EmbeddedAccountMosaicRestrictionTransactionDTOFromJSONTyped = exports.EmbeddedAccountMosaicRestrictionTransactionDTOFromJSON = void 0;
function EmbeddedAccountMosaicRestrictionTransactionDTOFromJSON(json) {
    return EmbeddedAccountMosaicRestrictionTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedAccountMosaicRestrictionTransactionDTOFromJSON = EmbeddedAccountMosaicRestrictionTransactionDTOFromJSON;
function EmbeddedAccountMosaicRestrictionTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'restrictionFlags': json['restrictionFlags'],
        'restrictionAdditions': json['restrictionAdditions'],
        'restrictionDeletions': json['restrictionDeletions'],
    };
}
exports.EmbeddedAccountMosaicRestrictionTransactionDTOFromJSONTyped = EmbeddedAccountMosaicRestrictionTransactionDTOFromJSONTyped;
function EmbeddedAccountMosaicRestrictionTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'restrictionFlags': value.restrictionFlags,
        'restrictionAdditions': value.restrictionAdditions,
        'restrictionDeletions': value.restrictionDeletions,
    };
}
exports.EmbeddedAccountMosaicRestrictionTransactionDTOToJSON = EmbeddedAccountMosaicRestrictionTransactionDTOToJSON;

},{}],1000:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedAccountOperationRestrictionTransactionDTOToJSON = exports.EmbeddedAccountOperationRestrictionTransactionDTOFromJSONTyped = exports.EmbeddedAccountOperationRestrictionTransactionDTOFromJSON = void 0;
function EmbeddedAccountOperationRestrictionTransactionDTOFromJSON(json) {
    return EmbeddedAccountOperationRestrictionTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedAccountOperationRestrictionTransactionDTOFromJSON = EmbeddedAccountOperationRestrictionTransactionDTOFromJSON;
function EmbeddedAccountOperationRestrictionTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'restrictionFlags': json['restrictionFlags'],
        'restrictionAdditions': json['restrictionAdditions'],
        'restrictionDeletions': json['restrictionDeletions'],
    };
}
exports.EmbeddedAccountOperationRestrictionTransactionDTOFromJSONTyped = EmbeddedAccountOperationRestrictionTransactionDTOFromJSONTyped;
function EmbeddedAccountOperationRestrictionTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'restrictionFlags': value.restrictionFlags,
        'restrictionAdditions': value.restrictionAdditions,
        'restrictionDeletions': value.restrictionDeletions,
    };
}
exports.EmbeddedAccountOperationRestrictionTransactionDTOToJSON = EmbeddedAccountOperationRestrictionTransactionDTOToJSON;

},{}],1001:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedAddressAliasTransactionDTOToJSON = exports.EmbeddedAddressAliasTransactionDTOFromJSONTyped = exports.EmbeddedAddressAliasTransactionDTOFromJSON = void 0;
function EmbeddedAddressAliasTransactionDTOFromJSON(json) {
    return EmbeddedAddressAliasTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedAddressAliasTransactionDTOFromJSON = EmbeddedAddressAliasTransactionDTOFromJSON;
function EmbeddedAddressAliasTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'namespaceId': json['namespaceId'],
        'address': json['address'],
        'aliasAction': json['aliasAction'],
    };
}
exports.EmbeddedAddressAliasTransactionDTOFromJSONTyped = EmbeddedAddressAliasTransactionDTOFromJSONTyped;
function EmbeddedAddressAliasTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'namespaceId': value.namespaceId,
        'address': value.address,
        'aliasAction': value.aliasAction,
    };
}
exports.EmbeddedAddressAliasTransactionDTOToJSON = EmbeddedAddressAliasTransactionDTOToJSON;

},{}],1002:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedHashLockTransactionDTOToJSON = exports.EmbeddedHashLockTransactionDTOFromJSONTyped = exports.EmbeddedHashLockTransactionDTOFromJSON = void 0;
function EmbeddedHashLockTransactionDTOFromJSON(json) {
    return EmbeddedHashLockTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedHashLockTransactionDTOFromJSON = EmbeddedHashLockTransactionDTOFromJSON;
function EmbeddedHashLockTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'mosaicId': json['mosaicId'],
        'amount': json['amount'],
        'duration': json['duration'],
        'hash': json['hash'],
    };
}
exports.EmbeddedHashLockTransactionDTOFromJSONTyped = EmbeddedHashLockTransactionDTOFromJSONTyped;
function EmbeddedHashLockTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'mosaicId': value.mosaicId,
        'amount': value.amount,
        'duration': value.duration,
        'hash': value.hash,
    };
}
exports.EmbeddedHashLockTransactionDTOToJSON = EmbeddedHashLockTransactionDTOToJSON;

},{}],1003:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMosaicAddressRestrictionTransactionDTOToJSON = exports.EmbeddedMosaicAddressRestrictionTransactionDTOFromJSONTyped = exports.EmbeddedMosaicAddressRestrictionTransactionDTOFromJSON = void 0;
function EmbeddedMosaicAddressRestrictionTransactionDTOFromJSON(json) {
    return EmbeddedMosaicAddressRestrictionTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedMosaicAddressRestrictionTransactionDTOFromJSON = EmbeddedMosaicAddressRestrictionTransactionDTOFromJSON;
function EmbeddedMosaicAddressRestrictionTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'mosaicId': json['mosaicId'],
        'restrictionKey': json['restrictionKey'],
        'previousRestrictionValue': json['previousRestrictionValue'],
        'newRestrictionValue': json['newRestrictionValue'],
        'targetAddress': json['targetAddress'],
    };
}
exports.EmbeddedMosaicAddressRestrictionTransactionDTOFromJSONTyped = EmbeddedMosaicAddressRestrictionTransactionDTOFromJSONTyped;
function EmbeddedMosaicAddressRestrictionTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'mosaicId': value.mosaicId,
        'restrictionKey': value.restrictionKey,
        'previousRestrictionValue': value.previousRestrictionValue,
        'newRestrictionValue': value.newRestrictionValue,
        'targetAddress': value.targetAddress,
    };
}
exports.EmbeddedMosaicAddressRestrictionTransactionDTOToJSON = EmbeddedMosaicAddressRestrictionTransactionDTOToJSON;

},{}],1004:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMosaicAliasTransactionDTOToJSON = exports.EmbeddedMosaicAliasTransactionDTOFromJSONTyped = exports.EmbeddedMosaicAliasTransactionDTOFromJSON = void 0;
function EmbeddedMosaicAliasTransactionDTOFromJSON(json) {
    return EmbeddedMosaicAliasTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedMosaicAliasTransactionDTOFromJSON = EmbeddedMosaicAliasTransactionDTOFromJSON;
function EmbeddedMosaicAliasTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'namespaceId': json['namespaceId'],
        'mosaicId': json['mosaicId'],
        'aliasAction': json['aliasAction'],
    };
}
exports.EmbeddedMosaicAliasTransactionDTOFromJSONTyped = EmbeddedMosaicAliasTransactionDTOFromJSONTyped;
function EmbeddedMosaicAliasTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'namespaceId': value.namespaceId,
        'mosaicId': value.mosaicId,
        'aliasAction': value.aliasAction,
    };
}
exports.EmbeddedMosaicAliasTransactionDTOToJSON = EmbeddedMosaicAliasTransactionDTOToJSON;

},{}],1005:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMosaicDefinitionTransactionDTOToJSON = exports.EmbeddedMosaicDefinitionTransactionDTOFromJSONTyped = exports.EmbeddedMosaicDefinitionTransactionDTOFromJSON = void 0;
function EmbeddedMosaicDefinitionTransactionDTOFromJSON(json) {
    return EmbeddedMosaicDefinitionTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedMosaicDefinitionTransactionDTOFromJSON = EmbeddedMosaicDefinitionTransactionDTOFromJSON;
function EmbeddedMosaicDefinitionTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'id': json['id'],
        'duration': json['duration'],
        'nonce': json['nonce'],
        'flags': json['flags'],
        'divisibility': json['divisibility'],
    };
}
exports.EmbeddedMosaicDefinitionTransactionDTOFromJSONTyped = EmbeddedMosaicDefinitionTransactionDTOFromJSONTyped;
function EmbeddedMosaicDefinitionTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'id': value.id,
        'duration': value.duration,
        'nonce': value.nonce,
        'flags': value.flags,
        'divisibility': value.divisibility,
    };
}
exports.EmbeddedMosaicDefinitionTransactionDTOToJSON = EmbeddedMosaicDefinitionTransactionDTOToJSON;

},{}],1006:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMosaicGlobalRestrictionTransactionDTOToJSON = exports.EmbeddedMosaicGlobalRestrictionTransactionDTOFromJSONTyped = exports.EmbeddedMosaicGlobalRestrictionTransactionDTOFromJSON = void 0;
function EmbeddedMosaicGlobalRestrictionTransactionDTOFromJSON(json) {
    return EmbeddedMosaicGlobalRestrictionTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedMosaicGlobalRestrictionTransactionDTOFromJSON = EmbeddedMosaicGlobalRestrictionTransactionDTOFromJSON;
function EmbeddedMosaicGlobalRestrictionTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'mosaicId': json['mosaicId'],
        'referenceMosaicId': json['referenceMosaicId'],
        'restrictionKey': json['restrictionKey'],
        'previousRestrictionValue': json['previousRestrictionValue'],
        'newRestrictionValue': json['newRestrictionValue'],
        'previousRestrictionType': json['previousRestrictionType'],
        'newRestrictionType': json['newRestrictionType'],
    };
}
exports.EmbeddedMosaicGlobalRestrictionTransactionDTOFromJSONTyped = EmbeddedMosaicGlobalRestrictionTransactionDTOFromJSONTyped;
function EmbeddedMosaicGlobalRestrictionTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'mosaicId': value.mosaicId,
        'referenceMosaicId': value.referenceMosaicId,
        'restrictionKey': value.restrictionKey,
        'previousRestrictionValue': value.previousRestrictionValue,
        'newRestrictionValue': value.newRestrictionValue,
        'previousRestrictionType': value.previousRestrictionType,
        'newRestrictionType': value.newRestrictionType,
    };
}
exports.EmbeddedMosaicGlobalRestrictionTransactionDTOToJSON = EmbeddedMosaicGlobalRestrictionTransactionDTOToJSON;

},{}],1007:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMosaicMetadataTransactionDTOToJSON = exports.EmbeddedMosaicMetadataTransactionDTOFromJSONTyped = exports.EmbeddedMosaicMetadataTransactionDTOFromJSON = void 0;
function EmbeddedMosaicMetadataTransactionDTOFromJSON(json) {
    return EmbeddedMosaicMetadataTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedMosaicMetadataTransactionDTOFromJSON = EmbeddedMosaicMetadataTransactionDTOFromJSON;
function EmbeddedMosaicMetadataTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'targetAddress': json['targetAddress'],
        'scopedMetadataKey': json['scopedMetadataKey'],
        'targetMosaicId': json['targetMosaicId'],
        'valueSizeDelta': json['valueSizeDelta'],
        'valueSize': json['valueSize'],
        'value': json['value'],
    };
}
exports.EmbeddedMosaicMetadataTransactionDTOFromJSONTyped = EmbeddedMosaicMetadataTransactionDTOFromJSONTyped;
function EmbeddedMosaicMetadataTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'targetAddress': value.targetAddress,
        'scopedMetadataKey': value.scopedMetadataKey,
        'targetMosaicId': value.targetMosaicId,
        'valueSizeDelta': value.valueSizeDelta,
        'valueSize': value.valueSize,
        'value': value.value,
    };
}
exports.EmbeddedMosaicMetadataTransactionDTOToJSON = EmbeddedMosaicMetadataTransactionDTOToJSON;

},{}],1008:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMosaicSupplyChangeTransactionDTOToJSON = exports.EmbeddedMosaicSupplyChangeTransactionDTOFromJSONTyped = exports.EmbeddedMosaicSupplyChangeTransactionDTOFromJSON = void 0;
function EmbeddedMosaicSupplyChangeTransactionDTOFromJSON(json) {
    return EmbeddedMosaicSupplyChangeTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedMosaicSupplyChangeTransactionDTOFromJSON = EmbeddedMosaicSupplyChangeTransactionDTOFromJSON;
function EmbeddedMosaicSupplyChangeTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'mosaicId': json['mosaicId'],
        'delta': json['delta'],
        'action': json['action'],
    };
}
exports.EmbeddedMosaicSupplyChangeTransactionDTOFromJSONTyped = EmbeddedMosaicSupplyChangeTransactionDTOFromJSONTyped;
function EmbeddedMosaicSupplyChangeTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'mosaicId': value.mosaicId,
        'delta': value.delta,
        'action': value.action,
    };
}
exports.EmbeddedMosaicSupplyChangeTransactionDTOToJSON = EmbeddedMosaicSupplyChangeTransactionDTOToJSON;

},{}],1009:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedMultisigAccountModificationTransactionDTOToJSON = exports.EmbeddedMultisigAccountModificationTransactionDTOFromJSONTyped = exports.EmbeddedMultisigAccountModificationTransactionDTOFromJSON = void 0;
function EmbeddedMultisigAccountModificationTransactionDTOFromJSON(json) {
    return EmbeddedMultisigAccountModificationTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedMultisigAccountModificationTransactionDTOFromJSON = EmbeddedMultisigAccountModificationTransactionDTOFromJSON;
function EmbeddedMultisigAccountModificationTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'minRemovalDelta': json['minRemovalDelta'],
        'minApprovalDelta': json['minApprovalDelta'],
        'addressAdditions': json['addressAdditions'],
        'addressDeletions': json['addressDeletions'],
    };
}
exports.EmbeddedMultisigAccountModificationTransactionDTOFromJSONTyped = EmbeddedMultisigAccountModificationTransactionDTOFromJSONTyped;
function EmbeddedMultisigAccountModificationTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'minRemovalDelta': value.minRemovalDelta,
        'minApprovalDelta': value.minApprovalDelta,
        'addressAdditions': value.addressAdditions,
        'addressDeletions': value.addressDeletions,
    };
}
exports.EmbeddedMultisigAccountModificationTransactionDTOToJSON = EmbeddedMultisigAccountModificationTransactionDTOToJSON;

},{}],1010:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedNamespaceMetadataTransactionDTOToJSON = exports.EmbeddedNamespaceMetadataTransactionDTOFromJSONTyped = exports.EmbeddedNamespaceMetadataTransactionDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function EmbeddedNamespaceMetadataTransactionDTOFromJSON(json) {
    return EmbeddedNamespaceMetadataTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedNamespaceMetadataTransactionDTOFromJSON = EmbeddedNamespaceMetadataTransactionDTOFromJSON;
function EmbeddedNamespaceMetadataTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'targetAddress': json['targetAddress'],
        'scopedMetadataKey': json['scopedMetadataKey'],
        'targetNamespaceId': !runtime_1.exists(json, 'targetNamespaceId') ? undefined : json['targetNamespaceId'],
        'valueSizeDelta': json['valueSizeDelta'],
        'valueSize': json['valueSize'],
        'value': json['value'],
    };
}
exports.EmbeddedNamespaceMetadataTransactionDTOFromJSONTyped = EmbeddedNamespaceMetadataTransactionDTOFromJSONTyped;
function EmbeddedNamespaceMetadataTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'targetAddress': value.targetAddress,
        'scopedMetadataKey': value.scopedMetadataKey,
        'targetNamespaceId': value.targetNamespaceId,
        'valueSizeDelta': value.valueSizeDelta,
        'valueSize': value.valueSize,
        'value': value.value,
    };
}
exports.EmbeddedNamespaceMetadataTransactionDTOToJSON = EmbeddedNamespaceMetadataTransactionDTOToJSON;

},{"../runtime":1158}],1011:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedNamespaceRegistrationTransactionDTOToJSON = exports.EmbeddedNamespaceRegistrationTransactionDTOFromJSONTyped = exports.EmbeddedNamespaceRegistrationTransactionDTOFromJSON = void 0;
function EmbeddedNamespaceRegistrationTransactionDTOFromJSON(json) {
    return EmbeddedNamespaceRegistrationTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedNamespaceRegistrationTransactionDTOFromJSON = EmbeddedNamespaceRegistrationTransactionDTOFromJSON;
function EmbeddedNamespaceRegistrationTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'duration': json['duration'],
        'parentId': json['parentId'],
        'id': json['id'],
        'registrationType': json['registrationType'],
        'name': json['name'],
    };
}
exports.EmbeddedNamespaceRegistrationTransactionDTOFromJSONTyped = EmbeddedNamespaceRegistrationTransactionDTOFromJSONTyped;
function EmbeddedNamespaceRegistrationTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'duration': value.duration,
        'parentId': value.parentId,
        'id': value.id,
        'registrationType': value.registrationType,
        'name': value.name,
    };
}
exports.EmbeddedNamespaceRegistrationTransactionDTOToJSON = EmbeddedNamespaceRegistrationTransactionDTOToJSON;

},{}],1012:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedNodeKeyLinkTransactionDTOToJSON = exports.EmbeddedNodeKeyLinkTransactionDTOFromJSONTyped = exports.EmbeddedNodeKeyLinkTransactionDTOFromJSON = void 0;
function EmbeddedNodeKeyLinkTransactionDTOFromJSON(json) {
    return EmbeddedNodeKeyLinkTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedNodeKeyLinkTransactionDTOFromJSON = EmbeddedNodeKeyLinkTransactionDTOFromJSON;
function EmbeddedNodeKeyLinkTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'linkedPublicKey': json['linkedPublicKey'],
        'linkAction': json['linkAction'],
    };
}
exports.EmbeddedNodeKeyLinkTransactionDTOFromJSONTyped = EmbeddedNodeKeyLinkTransactionDTOFromJSONTyped;
function EmbeddedNodeKeyLinkTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'linkedPublicKey': value.linkedPublicKey,
        'linkAction': value.linkAction,
    };
}
exports.EmbeddedNodeKeyLinkTransactionDTOToJSON = EmbeddedNodeKeyLinkTransactionDTOToJSON;

},{}],1013:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedSecretLockTransactionDTOToJSON = exports.EmbeddedSecretLockTransactionDTOFromJSONTyped = exports.EmbeddedSecretLockTransactionDTOFromJSON = void 0;
function EmbeddedSecretLockTransactionDTOFromJSON(json) {
    return EmbeddedSecretLockTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedSecretLockTransactionDTOFromJSON = EmbeddedSecretLockTransactionDTOFromJSON;
function EmbeddedSecretLockTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'recipientAddress': json['recipientAddress'],
        'secret': json['secret'],
        'mosaicId': json['mosaicId'],
        'amount': json['amount'],
        'duration': json['duration'],
        'hashAlgorithm': json['hashAlgorithm'],
    };
}
exports.EmbeddedSecretLockTransactionDTOFromJSONTyped = EmbeddedSecretLockTransactionDTOFromJSONTyped;
function EmbeddedSecretLockTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'recipientAddress': value.recipientAddress,
        'secret': value.secret,
        'mosaicId': value.mosaicId,
        'amount': value.amount,
        'duration': value.duration,
        'hashAlgorithm': value.hashAlgorithm,
    };
}
exports.EmbeddedSecretLockTransactionDTOToJSON = EmbeddedSecretLockTransactionDTOToJSON;

},{}],1014:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedSecretProofTransactionDTOToJSON = exports.EmbeddedSecretProofTransactionDTOFromJSONTyped = exports.EmbeddedSecretProofTransactionDTOFromJSON = void 0;
function EmbeddedSecretProofTransactionDTOFromJSON(json) {
    return EmbeddedSecretProofTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedSecretProofTransactionDTOFromJSON = EmbeddedSecretProofTransactionDTOFromJSON;
function EmbeddedSecretProofTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'recipientAddress': json['recipientAddress'],
        'secret': json['secret'],
        'hashAlgorithm': json['hashAlgorithm'],
        'proof': json['proof'],
    };
}
exports.EmbeddedSecretProofTransactionDTOFromJSONTyped = EmbeddedSecretProofTransactionDTOFromJSONTyped;
function EmbeddedSecretProofTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'recipientAddress': value.recipientAddress,
        'secret': value.secret,
        'hashAlgorithm': value.hashAlgorithm,
        'proof': value.proof,
    };
}
exports.EmbeddedSecretProofTransactionDTOToJSON = EmbeddedSecretProofTransactionDTOToJSON;

},{}],1015:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedTransactionBodyDTOToJSON = exports.EmbeddedTransactionBodyDTOFromJSONTyped = exports.EmbeddedTransactionBodyDTOFromJSON = void 0;
function EmbeddedTransactionBodyDTOFromJSON(json) {
    return EmbeddedTransactionBodyDTOFromJSONTyped(json, false);
}
exports.EmbeddedTransactionBodyDTOFromJSON = EmbeddedTransactionBodyDTOFromJSON;
function EmbeddedTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'transactions': json['transactions'],
    };
}
exports.EmbeddedTransactionBodyDTOFromJSONTyped = EmbeddedTransactionBodyDTOFromJSONTyped;
function EmbeddedTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'transactions': value.transactions,
    };
}
exports.EmbeddedTransactionBodyDTOToJSON = EmbeddedTransactionBodyDTOToJSON;

},{}],1016:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedTransactionDTOToJSON = exports.EmbeddedTransactionDTOFromJSONTyped = exports.EmbeddedTransactionDTOFromJSON = void 0;
function EmbeddedTransactionDTOFromJSON(json) {
    return EmbeddedTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedTransactionDTOFromJSON = EmbeddedTransactionDTOFromJSON;
function EmbeddedTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.EmbeddedTransactionDTOFromJSONTyped = EmbeddedTransactionDTOFromJSONTyped;
function EmbeddedTransactionDTOToJSON(value) {
    return value;
}
exports.EmbeddedTransactionDTOToJSON = EmbeddedTransactionDTOToJSON;

},{}],1017:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedTransactionInfoDTOToJSON = exports.EmbeddedTransactionInfoDTOFromJSONTyped = exports.EmbeddedTransactionInfoDTOFromJSON = void 0;
function EmbeddedTransactionInfoDTOFromJSON(json) {
    return EmbeddedTransactionInfoDTOFromJSONTyped(json, false);
}
exports.EmbeddedTransactionInfoDTOFromJSON = EmbeddedTransactionInfoDTOFromJSON;
function EmbeddedTransactionInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'meta': json['meta'],
        'transaction': json['transaction'],
    };
}
exports.EmbeddedTransactionInfoDTOFromJSONTyped = EmbeddedTransactionInfoDTOFromJSONTyped;
function EmbeddedTransactionInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'meta': value.meta,
        'transaction': value.transaction,
    };
}
exports.EmbeddedTransactionInfoDTOToJSON = EmbeddedTransactionInfoDTOToJSON;

},{}],1018:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedTransactionMetaDTOToJSON = exports.EmbeddedTransactionMetaDTOFromJSONTyped = exports.EmbeddedTransactionMetaDTOFromJSON = void 0;
function EmbeddedTransactionMetaDTOFromJSON(json) {
    return EmbeddedTransactionMetaDTOFromJSONTyped(json, false);
}
exports.EmbeddedTransactionMetaDTOFromJSON = EmbeddedTransactionMetaDTOFromJSON;
function EmbeddedTransactionMetaDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'height': json['height'],
        'aggregateHash': json['aggregateHash'],
        'aggregateId': json['aggregateId'],
        'index': json['index'],
    };
}
exports.EmbeddedTransactionMetaDTOFromJSONTyped = EmbeddedTransactionMetaDTOFromJSONTyped;
function EmbeddedTransactionMetaDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'height': value.height,
        'aggregateHash': value.aggregateHash,
        'aggregateId': value.aggregateId,
        'index': value.index,
    };
}
exports.EmbeddedTransactionMetaDTOToJSON = EmbeddedTransactionMetaDTOToJSON;

},{}],1019:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedTransferTransactionDTOToJSON = exports.EmbeddedTransferTransactionDTOFromJSONTyped = exports.EmbeddedTransferTransactionDTOFromJSON = void 0;
function EmbeddedTransferTransactionDTOFromJSON(json) {
    return EmbeddedTransferTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedTransferTransactionDTOFromJSON = EmbeddedTransferTransactionDTOFromJSON;
function EmbeddedTransferTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'recipientAddress': json['recipientAddress'],
        'mosaics': json['mosaics'],
        'message': json['message'],
    };
}
exports.EmbeddedTransferTransactionDTOFromJSONTyped = EmbeddedTransferTransactionDTOFromJSONTyped;
function EmbeddedTransferTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'recipientAddress': value.recipientAddress,
        'mosaics': value.mosaics,
        'message': value.message,
    };
}
exports.EmbeddedTransferTransactionDTOToJSON = EmbeddedTransferTransactionDTOToJSON;

},{}],1020:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedVotingKeyLinkTransactionDTOToJSON = exports.EmbeddedVotingKeyLinkTransactionDTOFromJSONTyped = exports.EmbeddedVotingKeyLinkTransactionDTOFromJSON = void 0;
function EmbeddedVotingKeyLinkTransactionDTOFromJSON(json) {
    return EmbeddedVotingKeyLinkTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedVotingKeyLinkTransactionDTOFromJSON = EmbeddedVotingKeyLinkTransactionDTOFromJSON;
function EmbeddedVotingKeyLinkTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'linkedPublicKey': json['linkedPublicKey'],
        'startPoint': json['startPoint'],
        'endPoint': json['endPoint'],
        'linkAction': json['linkAction'],
    };
}
exports.EmbeddedVotingKeyLinkTransactionDTOFromJSONTyped = EmbeddedVotingKeyLinkTransactionDTOFromJSONTyped;
function EmbeddedVotingKeyLinkTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'linkedPublicKey': value.linkedPublicKey,
        'startPoint': value.startPoint,
        'endPoint': value.endPoint,
        'linkAction': value.linkAction,
    };
}
exports.EmbeddedVotingKeyLinkTransactionDTOToJSON = EmbeddedVotingKeyLinkTransactionDTOToJSON;

},{}],1021:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedVrfKeyLinkTransactionDTOToJSON = exports.EmbeddedVrfKeyLinkTransactionDTOFromJSONTyped = exports.EmbeddedVrfKeyLinkTransactionDTOFromJSON = void 0;
function EmbeddedVrfKeyLinkTransactionDTOFromJSON(json) {
    return EmbeddedVrfKeyLinkTransactionDTOFromJSONTyped(json, false);
}
exports.EmbeddedVrfKeyLinkTransactionDTOFromJSON = EmbeddedVrfKeyLinkTransactionDTOFromJSON;
function EmbeddedVrfKeyLinkTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'linkedPublicKey': json['linkedPublicKey'],
        'linkAction': json['linkAction'],
    };
}
exports.EmbeddedVrfKeyLinkTransactionDTOFromJSONTyped = EmbeddedVrfKeyLinkTransactionDTOFromJSONTyped;
function EmbeddedVrfKeyLinkTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'linkedPublicKey': value.linkedPublicKey,
        'linkAction': value.linkAction,
    };
}
exports.EmbeddedVrfKeyLinkTransactionDTOToJSON = EmbeddedVrfKeyLinkTransactionDTOToJSON;

},{}],1022:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityDTOToJSON = exports.EntityDTOFromJSONTyped = exports.EntityDTOFromJSON = void 0;
function EntityDTOFromJSON(json) {
    return EntityDTOFromJSONTyped(json, false);
}
exports.EntityDTOFromJSON = EntityDTOFromJSON;
function EntityDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
    };
}
exports.EntityDTOFromJSONTyped = EntityDTOFromJSONTyped;
function EntityDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
    };
}
exports.EntityDTOToJSON = EntityDTOToJSON;

},{}],1023:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HashLockNetworkPropertiesDTOToJSON = exports.HashLockNetworkPropertiesDTOFromJSONTyped = exports.HashLockNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function HashLockNetworkPropertiesDTOFromJSON(json) {
    return HashLockNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.HashLockNetworkPropertiesDTOFromJSON = HashLockNetworkPropertiesDTOFromJSON;
function HashLockNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'lockedFundsPerAggregate': !runtime_1.exists(json, 'lockedFundsPerAggregate') ? undefined : json['lockedFundsPerAggregate'],
        'maxHashLockDuration': !runtime_1.exists(json, 'maxHashLockDuration') ? undefined : json['maxHashLockDuration'],
    };
}
exports.HashLockNetworkPropertiesDTOFromJSONTyped = HashLockNetworkPropertiesDTOFromJSONTyped;
function HashLockNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'lockedFundsPerAggregate': value.lockedFundsPerAggregate,
        'maxHashLockDuration': value.maxHashLockDuration,
    };
}
exports.HashLockNetworkPropertiesDTOToJSON = HashLockNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],1024:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HashLockTransactionBodyDTOToJSON = exports.HashLockTransactionBodyDTOFromJSONTyped = exports.HashLockTransactionBodyDTOFromJSON = void 0;
function HashLockTransactionBodyDTOFromJSON(json) {
    return HashLockTransactionBodyDTOFromJSONTyped(json, false);
}
exports.HashLockTransactionBodyDTOFromJSON = HashLockTransactionBodyDTOFromJSON;
function HashLockTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'mosaicId': json['mosaicId'],
        'amount': json['amount'],
        'duration': json['duration'],
        'hash': json['hash'],
    };
}
exports.HashLockTransactionBodyDTOFromJSONTyped = HashLockTransactionBodyDTOFromJSONTyped;
function HashLockTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'mosaicId': value.mosaicId,
        'amount': value.amount,
        'duration': value.duration,
        'hash': value.hash,
    };
}
exports.HashLockTransactionBodyDTOToJSON = HashLockTransactionBodyDTOToJSON;

},{}],1025:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HashLockTransactionDTOToJSON = exports.HashLockTransactionDTOFromJSONTyped = exports.HashLockTransactionDTOFromJSON = void 0;
function HashLockTransactionDTOFromJSON(json) {
    return HashLockTransactionDTOFromJSONTyped(json, false);
}
exports.HashLockTransactionDTOFromJSON = HashLockTransactionDTOFromJSON;
function HashLockTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'mosaicId': json['mosaicId'],
        'amount': json['amount'],
        'duration': json['duration'],
        'hash': json['hash'],
    };
}
exports.HashLockTransactionDTOFromJSONTyped = HashLockTransactionDTOFromJSONTyped;
function HashLockTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'mosaicId': value.mosaicId,
        'amount': value.amount,
        'duration': value.duration,
        'hash': value.hash,
    };
}
exports.HashLockTransactionDTOToJSON = HashLockTransactionDTOToJSON;

},{}],1026:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HeightInfoDTOToJSON = exports.HeightInfoDTOFromJSONTyped = exports.HeightInfoDTOFromJSON = void 0;
function HeightInfoDTOFromJSON(json) {
    return HeightInfoDTOFromJSONTyped(json, false);
}
exports.HeightInfoDTOFromJSON = HeightInfoDTOFromJSON;
function HeightInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'height': json['height'],
    };
}
exports.HeightInfoDTOFromJSONTyped = HeightInfoDTOFromJSONTyped;
function HeightInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'height': value.height,
    };
}
exports.HeightInfoDTOToJSON = HeightInfoDTOToJSON;

},{}],1027:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InflationReceiptDTOToJSON = exports.InflationReceiptDTOFromJSONTyped = exports.InflationReceiptDTOFromJSON = void 0;
function InflationReceiptDTOFromJSON(json) {
    return InflationReceiptDTOFromJSONTyped(json, false);
}
exports.InflationReceiptDTOFromJSON = InflationReceiptDTOFromJSON;
function InflationReceiptDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'version': json['version'],
        'type': json['type'],
        'mosaicId': json['mosaicId'],
        'amount': json['amount'],
    };
}
exports.InflationReceiptDTOFromJSONTyped = InflationReceiptDTOFromJSONTyped;
function InflationReceiptDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'version': value.version,
        'type': value.type,
        'mosaicId': value.mosaicId,
        'amount': value.amount,
    };
}
exports.InflationReceiptDTOToJSON = InflationReceiptDTOToJSON;

},{}],1028:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InflationReceiptDTOAllOfToJSON = exports.InflationReceiptDTOAllOfFromJSONTyped = exports.InflationReceiptDTOAllOfFromJSON = void 0;
function InflationReceiptDTOAllOfFromJSON(json) {
    return InflationReceiptDTOAllOfFromJSONTyped(json, false);
}
exports.InflationReceiptDTOAllOfFromJSON = InflationReceiptDTOAllOfFromJSON;
function InflationReceiptDTOAllOfFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'mosaicId': json['mosaicId'],
        'amount': json['amount'],
    };
}
exports.InflationReceiptDTOAllOfFromJSONTyped = InflationReceiptDTOAllOfFromJSONTyped;
function InflationReceiptDTOAllOfToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'mosaicId': value.mosaicId,
        'amount': value.amount,
    };
}
exports.InflationReceiptDTOAllOfToJSON = InflationReceiptDTOAllOfToJSON;

},{}],1029:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkActionEnumToJSON = exports.LinkActionEnumFromJSONTyped = exports.LinkActionEnumFromJSON = exports.LinkActionEnum = void 0;
/**
 * Type of action:
 * * 0 - Unlink.
 * * 1 - Link.
 * @export
 * @enum {string}
 */
var LinkActionEnum;
(function (LinkActionEnum) {
    LinkActionEnum[LinkActionEnum["NUMBER_0"] = 0] = "NUMBER_0";
    LinkActionEnum[LinkActionEnum["NUMBER_1"] = 1] = "NUMBER_1";
})(LinkActionEnum = exports.LinkActionEnum || (exports.LinkActionEnum = {}));
function LinkActionEnumFromJSON(json) {
    return LinkActionEnumFromJSONTyped(json, false);
}
exports.LinkActionEnumFromJSON = LinkActionEnumFromJSON;
function LinkActionEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.LinkActionEnumFromJSONTyped = LinkActionEnumFromJSONTyped;
function LinkActionEnumToJSON(value) {
    return value;
}
exports.LinkActionEnumToJSON = LinkActionEnumToJSON;

},{}],1030:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LockHashAlgorithmEnumToJSON = exports.LockHashAlgorithmEnumFromJSONTyped = exports.LockHashAlgorithmEnumFromJSON = exports.LockHashAlgorithmEnum = void 0;
/**
 * Algorithm used to hash the proof:
 * * 0 (Op_Sha3_256) - Proof is hashed using SHA3-256.
 * * 1 (Op_Hash_160) - Proof is hashed twice: first with SHA-256 and then with RIPEMD-160 (bitcoin's OP_HASH160).
 * * 2 (Op_Hash_256) - Proof is hashed twice with SHA3-256 (bitcoin's OP_HASH256).
 * @export
 * @enum {string}
 */
var LockHashAlgorithmEnum;
(function (LockHashAlgorithmEnum) {
    LockHashAlgorithmEnum[LockHashAlgorithmEnum["NUMBER_0"] = 0] = "NUMBER_0";
    LockHashAlgorithmEnum[LockHashAlgorithmEnum["NUMBER_1"] = 1] = "NUMBER_1";
    LockHashAlgorithmEnum[LockHashAlgorithmEnum["NUMBER_2"] = 2] = "NUMBER_2";
})(LockHashAlgorithmEnum = exports.LockHashAlgorithmEnum || (exports.LockHashAlgorithmEnum = {}));
function LockHashAlgorithmEnumFromJSON(json) {
    return LockHashAlgorithmEnumFromJSONTyped(json, false);
}
exports.LockHashAlgorithmEnumFromJSON = LockHashAlgorithmEnumFromJSON;
function LockHashAlgorithmEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.LockHashAlgorithmEnumFromJSONTyped = LockHashAlgorithmEnumFromJSONTyped;
function LockHashAlgorithmEnumToJSON(value) {
    return value;
}
exports.LockHashAlgorithmEnumToJSON = LockHashAlgorithmEnumToJSON;

},{}],1031:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MerklePathItemDTOToJSON = exports.MerklePathItemDTOFromJSONTyped = exports.MerklePathItemDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function MerklePathItemDTOFromJSON(json) {
    return MerklePathItemDTOFromJSONTyped(json, false);
}
exports.MerklePathItemDTOFromJSON = MerklePathItemDTOFromJSON;
function MerklePathItemDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'position': !runtime_1.exists(json, 'position') ? undefined : json['position'],
        'hash': !runtime_1.exists(json, 'hash') ? undefined : json['hash'],
    };
}
exports.MerklePathItemDTOFromJSONTyped = MerklePathItemDTOFromJSONTyped;
function MerklePathItemDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'position': value.position,
        'hash': value.hash,
    };
}
exports.MerklePathItemDTOToJSON = MerklePathItemDTOToJSON;

},{"../runtime":1158}],1032:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MerkleProofInfoDTOToJSON = exports.MerkleProofInfoDTOFromJSONTyped = exports.MerkleProofInfoDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function MerkleProofInfoDTOFromJSON(json) {
    return MerkleProofInfoDTOFromJSONTyped(json, false);
}
exports.MerkleProofInfoDTOFromJSON = MerkleProofInfoDTOFromJSON;
function MerkleProofInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'merklePath': !runtime_1.exists(json, 'merklePath') ? undefined : json['merklePath'],
    };
}
exports.MerkleProofInfoDTOFromJSONTyped = MerkleProofInfoDTOFromJSONTyped;
function MerkleProofInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'merklePath': value.merklePath === undefined ? undefined : value.merklePath,
    };
}
exports.MerkleProofInfoDTOToJSON = MerkleProofInfoDTOToJSON;

},{"../runtime":1158}],1033:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageDTOToJSON = exports.MessageDTOFromJSONTyped = exports.MessageDTOFromJSON = void 0;
function MessageDTOFromJSON(json) {
    return MessageDTOFromJSONTyped(json, false);
}
exports.MessageDTOFromJSON = MessageDTOFromJSON;
function MessageDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'type': json['type'],
        'payload': json['payload'],
    };
}
exports.MessageDTOFromJSONTyped = MessageDTOFromJSONTyped;
function MessageDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'type': value.type,
        'payload': value.payload,
    };
}
exports.MessageDTOToJSON = MessageDTOToJSON;

},{}],1034:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageTypeEnumToJSON = exports.MessageTypeEnumFromJSONTyped = exports.MessageTypeEnumFromJSON = exports.MessageTypeEnum = void 0;
/**
 * Type of message:
 * * 0 - Regular message.
 * * 1 - Encrypted message.
 * * 254 - Persistent harvesting delegation.
 * @export
 * @enum {string}
 */
var MessageTypeEnum;
(function (MessageTypeEnum) {
    MessageTypeEnum[MessageTypeEnum["NUMBER_0"] = 0] = "NUMBER_0";
    MessageTypeEnum[MessageTypeEnum["NUMBER_1"] = 1] = "NUMBER_1";
    MessageTypeEnum[MessageTypeEnum["NUMBER_254"] = 254] = "NUMBER_254";
})(MessageTypeEnum = exports.MessageTypeEnum || (exports.MessageTypeEnum = {}));
function MessageTypeEnumFromJSON(json) {
    return MessageTypeEnumFromJSONTyped(json, false);
}
exports.MessageTypeEnumFromJSON = MessageTypeEnumFromJSON;
function MessageTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.MessageTypeEnumFromJSONTyped = MessageTypeEnumFromJSONTyped;
function MessageTypeEnumToJSON(value) {
    return value;
}
exports.MessageTypeEnumToJSON = MessageTypeEnumToJSON;

},{}],1035:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataEntryDTOToJSON = exports.MetadataEntryDTOFromJSONTyped = exports.MetadataEntryDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function MetadataEntryDTOFromJSON(json) {
    return MetadataEntryDTOFromJSONTyped(json, false);
}
exports.MetadataEntryDTOFromJSON = MetadataEntryDTOFromJSON;
function MetadataEntryDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'compositeHash': json['compositeHash'],
        'sourceAddress': json['sourceAddress'],
        'targetAddress': json['targetAddress'],
        'scopedMetadataKey': json['scopedMetadataKey'],
        'targetId': !runtime_1.exists(json, 'targetId') ? undefined : json['targetId'],
        'metadataType': json['metadataType'],
        'value': json['value'],
    };
}
exports.MetadataEntryDTOFromJSONTyped = MetadataEntryDTOFromJSONTyped;
function MetadataEntryDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'compositeHash': value.compositeHash,
        'sourceAddress': value.sourceAddress,
        'targetAddress': value.targetAddress,
        'scopedMetadataKey': value.scopedMetadataKey,
        'targetId': value.targetId,
        'metadataType': value.metadataType,
        'value': value.value,
    };
}
exports.MetadataEntryDTOToJSON = MetadataEntryDTOToJSON;

},{"../runtime":1158}],1036:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataInfoDTOToJSON = exports.MetadataInfoDTOFromJSONTyped = exports.MetadataInfoDTOFromJSON = void 0;
function MetadataInfoDTOFromJSON(json) {
    return MetadataInfoDTOFromJSONTyped(json, false);
}
exports.MetadataInfoDTOFromJSON = MetadataInfoDTOFromJSON;
function MetadataInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'metadataEntry': json['metadataEntry'],
    };
}
exports.MetadataInfoDTOFromJSONTyped = MetadataInfoDTOFromJSONTyped;
function MetadataInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'metadataEntry': value.metadataEntry,
    };
}
exports.MetadataInfoDTOToJSON = MetadataInfoDTOToJSON;

},{}],1037:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataNetworkPropertiesDTOToJSON = exports.MetadataNetworkPropertiesDTOFromJSONTyped = exports.MetadataNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function MetadataNetworkPropertiesDTOFromJSON(json) {
    return MetadataNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.MetadataNetworkPropertiesDTOFromJSON = MetadataNetworkPropertiesDTOFromJSON;
function MetadataNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'maxValueSize': !runtime_1.exists(json, 'maxValueSize') ? undefined : json['maxValueSize'],
    };
}
exports.MetadataNetworkPropertiesDTOFromJSONTyped = MetadataNetworkPropertiesDTOFromJSONTyped;
function MetadataNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'maxValueSize': value.maxValueSize,
    };
}
exports.MetadataNetworkPropertiesDTOToJSON = MetadataNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],1038:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataPageToJSON = exports.MetadataPageFromJSONTyped = exports.MetadataPageFromJSON = void 0;
function MetadataPageFromJSON(json) {
    return MetadataPageFromJSONTyped(json, false);
}
exports.MetadataPageFromJSON = MetadataPageFromJSON;
function MetadataPageFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'data': json['data'],
        'pagination': json['pagination'],
    };
}
exports.MetadataPageFromJSONTyped = MetadataPageFromJSONTyped;
function MetadataPageToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'data': value.data,
        'pagination': value.pagination,
    };
}
exports.MetadataPageToJSON = MetadataPageToJSON;

},{}],1039:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataTypeEnumToJSON = exports.MetadataTypeEnumFromJSONTyped = exports.MetadataTypeEnumFromJSON = exports.MetadataTypeEnum = void 0;
/**
 * Metadata type:
 * * 0 - Account.
 * * 1 - Mosaic.
 * * 2 - Namespace.
 * @export
 * @enum {string}
 */
var MetadataTypeEnum;
(function (MetadataTypeEnum) {
    MetadataTypeEnum[MetadataTypeEnum["NUMBER_0"] = 0] = "NUMBER_0";
    MetadataTypeEnum[MetadataTypeEnum["NUMBER_1"] = 1] = "NUMBER_1";
    MetadataTypeEnum[MetadataTypeEnum["NUMBER_2"] = 2] = "NUMBER_2";
})(MetadataTypeEnum = exports.MetadataTypeEnum || (exports.MetadataTypeEnum = {}));
function MetadataTypeEnumFromJSON(json) {
    return MetadataTypeEnumFromJSONTyped(json, false);
}
exports.MetadataTypeEnumFromJSON = MetadataTypeEnumFromJSON;
function MetadataTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.MetadataTypeEnumFromJSONTyped = MetadataTypeEnumFromJSONTyped;
function MetadataTypeEnumToJSON(value) {
    return value;
}
exports.MetadataTypeEnumToJSON = MetadataTypeEnumToJSON;

},{}],1040:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelErrorToJSON = exports.ModelErrorFromJSONTyped = exports.ModelErrorFromJSON = void 0;
function ModelErrorFromJSON(json) {
    return ModelErrorFromJSONTyped(json, false);
}
exports.ModelErrorFromJSON = ModelErrorFromJSON;
function ModelErrorFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'code': json['code'],
        'message': json['message'],
    };
}
exports.ModelErrorFromJSONTyped = ModelErrorFromJSONTyped;
function ModelErrorToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'code': value.code,
        'message': value.message,
    };
}
exports.ModelErrorToJSON = ModelErrorToJSON;

},{}],1041:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicToJSON = exports.MosaicFromJSONTyped = exports.MosaicFromJSON = void 0;
function MosaicFromJSON(json) {
    return MosaicFromJSONTyped(json, false);
}
exports.MosaicFromJSON = MosaicFromJSON;
function MosaicFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'amount': json['amount'],
    };
}
exports.MosaicFromJSONTyped = MosaicFromJSONTyped;
function MosaicToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'amount': value.amount,
    };
}
exports.MosaicToJSON = MosaicToJSON;

},{}],1042:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicAddressRestrictionDTOToJSON = exports.MosaicAddressRestrictionDTOFromJSONTyped = exports.MosaicAddressRestrictionDTOFromJSON = void 0;
function MosaicAddressRestrictionDTOFromJSON(json) {
    return MosaicAddressRestrictionDTOFromJSONTyped(json, false);
}
exports.MosaicAddressRestrictionDTOFromJSON = MosaicAddressRestrictionDTOFromJSON;
function MosaicAddressRestrictionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'mosaicRestrictionEntry': json['mosaicRestrictionEntry'],
    };
}
exports.MosaicAddressRestrictionDTOFromJSONTyped = MosaicAddressRestrictionDTOFromJSONTyped;
function MosaicAddressRestrictionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'mosaicRestrictionEntry': value.mosaicRestrictionEntry,
    };
}
exports.MosaicAddressRestrictionDTOToJSON = MosaicAddressRestrictionDTOToJSON;

},{}],1043:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicAddressRestrictionEntryDTOToJSON = exports.MosaicAddressRestrictionEntryDTOFromJSONTyped = exports.MosaicAddressRestrictionEntryDTOFromJSON = void 0;
function MosaicAddressRestrictionEntryDTOFromJSON(json) {
    return MosaicAddressRestrictionEntryDTOFromJSONTyped(json, false);
}
exports.MosaicAddressRestrictionEntryDTOFromJSON = MosaicAddressRestrictionEntryDTOFromJSON;
function MosaicAddressRestrictionEntryDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'key': json['key'],
        'value': json['value'],
    };
}
exports.MosaicAddressRestrictionEntryDTOFromJSONTyped = MosaicAddressRestrictionEntryDTOFromJSONTyped;
function MosaicAddressRestrictionEntryDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'key': value.key,
        'value': value.value,
    };
}
exports.MosaicAddressRestrictionEntryDTOToJSON = MosaicAddressRestrictionEntryDTOToJSON;

},{}],1044:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicAddressRestrictionEntryWrapperDTOToJSON = exports.MosaicAddressRestrictionEntryWrapperDTOFromJSONTyped = exports.MosaicAddressRestrictionEntryWrapperDTOFromJSON = void 0;
function MosaicAddressRestrictionEntryWrapperDTOFromJSON(json) {
    return MosaicAddressRestrictionEntryWrapperDTOFromJSONTyped(json, false);
}
exports.MosaicAddressRestrictionEntryWrapperDTOFromJSON = MosaicAddressRestrictionEntryWrapperDTOFromJSON;
function MosaicAddressRestrictionEntryWrapperDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'compositeHash': json['compositeHash'],
        'entryType': json['entryType'],
        'mosaicId': json['mosaicId'],
        'targetAddress': json['targetAddress'],
        'restrictions': json['restrictions'],
    };
}
exports.MosaicAddressRestrictionEntryWrapperDTOFromJSONTyped = MosaicAddressRestrictionEntryWrapperDTOFromJSONTyped;
function MosaicAddressRestrictionEntryWrapperDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'compositeHash': value.compositeHash,
        'entryType': value.entryType,
        'mosaicId': value.mosaicId,
        'targetAddress': value.targetAddress,
        'restrictions': value.restrictions,
    };
}
exports.MosaicAddressRestrictionEntryWrapperDTOToJSON = MosaicAddressRestrictionEntryWrapperDTOToJSON;

},{}],1045:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicAddressRestrictionTransactionBodyDTOToJSON = exports.MosaicAddressRestrictionTransactionBodyDTOFromJSONTyped = exports.MosaicAddressRestrictionTransactionBodyDTOFromJSON = void 0;
function MosaicAddressRestrictionTransactionBodyDTOFromJSON(json) {
    return MosaicAddressRestrictionTransactionBodyDTOFromJSONTyped(json, false);
}
exports.MosaicAddressRestrictionTransactionBodyDTOFromJSON = MosaicAddressRestrictionTransactionBodyDTOFromJSON;
function MosaicAddressRestrictionTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'mosaicId': json['mosaicId'],
        'restrictionKey': json['restrictionKey'],
        'previousRestrictionValue': json['previousRestrictionValue'],
        'newRestrictionValue': json['newRestrictionValue'],
        'targetAddress': json['targetAddress'],
    };
}
exports.MosaicAddressRestrictionTransactionBodyDTOFromJSONTyped = MosaicAddressRestrictionTransactionBodyDTOFromJSONTyped;
function MosaicAddressRestrictionTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'mosaicId': value.mosaicId,
        'restrictionKey': value.restrictionKey,
        'previousRestrictionValue': value.previousRestrictionValue,
        'newRestrictionValue': value.newRestrictionValue,
        'targetAddress': value.targetAddress,
    };
}
exports.MosaicAddressRestrictionTransactionBodyDTOToJSON = MosaicAddressRestrictionTransactionBodyDTOToJSON;

},{}],1046:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicAddressRestrictionTransactionDTOToJSON = exports.MosaicAddressRestrictionTransactionDTOFromJSONTyped = exports.MosaicAddressRestrictionTransactionDTOFromJSON = void 0;
function MosaicAddressRestrictionTransactionDTOFromJSON(json) {
    return MosaicAddressRestrictionTransactionDTOFromJSONTyped(json, false);
}
exports.MosaicAddressRestrictionTransactionDTOFromJSON = MosaicAddressRestrictionTransactionDTOFromJSON;
function MosaicAddressRestrictionTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'mosaicId': json['mosaicId'],
        'restrictionKey': json['restrictionKey'],
        'previousRestrictionValue': json['previousRestrictionValue'],
        'newRestrictionValue': json['newRestrictionValue'],
        'targetAddress': json['targetAddress'],
    };
}
exports.MosaicAddressRestrictionTransactionDTOFromJSONTyped = MosaicAddressRestrictionTransactionDTOFromJSONTyped;
function MosaicAddressRestrictionTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'mosaicId': value.mosaicId,
        'restrictionKey': value.restrictionKey,
        'previousRestrictionValue': value.previousRestrictionValue,
        'newRestrictionValue': value.newRestrictionValue,
        'targetAddress': value.targetAddress,
    };
}
exports.MosaicAddressRestrictionTransactionDTOToJSON = MosaicAddressRestrictionTransactionDTOToJSON;

},{}],1047:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicAliasTransactionBodyDTOToJSON = exports.MosaicAliasTransactionBodyDTOFromJSONTyped = exports.MosaicAliasTransactionBodyDTOFromJSON = void 0;
function MosaicAliasTransactionBodyDTOFromJSON(json) {
    return MosaicAliasTransactionBodyDTOFromJSONTyped(json, false);
}
exports.MosaicAliasTransactionBodyDTOFromJSON = MosaicAliasTransactionBodyDTOFromJSON;
function MosaicAliasTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'namespaceId': json['namespaceId'],
        'mosaicId': json['mosaicId'],
        'aliasAction': json['aliasAction'],
    };
}
exports.MosaicAliasTransactionBodyDTOFromJSONTyped = MosaicAliasTransactionBodyDTOFromJSONTyped;
function MosaicAliasTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'namespaceId': value.namespaceId,
        'mosaicId': value.mosaicId,
        'aliasAction': value.aliasAction,
    };
}
exports.MosaicAliasTransactionBodyDTOToJSON = MosaicAliasTransactionBodyDTOToJSON;

},{}],1048:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicAliasTransactionDTOToJSON = exports.MosaicAliasTransactionDTOFromJSONTyped = exports.MosaicAliasTransactionDTOFromJSON = void 0;
function MosaicAliasTransactionDTOFromJSON(json) {
    return MosaicAliasTransactionDTOFromJSONTyped(json, false);
}
exports.MosaicAliasTransactionDTOFromJSON = MosaicAliasTransactionDTOFromJSON;
function MosaicAliasTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'namespaceId': json['namespaceId'],
        'mosaicId': json['mosaicId'],
        'aliasAction': json['aliasAction'],
    };
}
exports.MosaicAliasTransactionDTOFromJSONTyped = MosaicAliasTransactionDTOFromJSONTyped;
function MosaicAliasTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'namespaceId': value.namespaceId,
        'mosaicId': value.mosaicId,
        'aliasAction': value.aliasAction,
    };
}
exports.MosaicAliasTransactionDTOToJSON = MosaicAliasTransactionDTOToJSON;

},{}],1049:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicDTOToJSON = exports.MosaicDTOFromJSONTyped = exports.MosaicDTOFromJSON = void 0;
function MosaicDTOFromJSON(json) {
    return MosaicDTOFromJSONTyped(json, false);
}
exports.MosaicDTOFromJSON = MosaicDTOFromJSON;
function MosaicDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'supply': json['supply'],
        'startHeight': json['startHeight'],
        'ownerAddress': json['ownerAddress'],
        'revision': json['revision'],
        'flags': json['flags'],
        'divisibility': json['divisibility'],
        'duration': json['duration'],
    };
}
exports.MosaicDTOFromJSONTyped = MosaicDTOFromJSONTyped;
function MosaicDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'supply': value.supply,
        'startHeight': value.startHeight,
        'ownerAddress': value.ownerAddress,
        'revision': value.revision,
        'flags': value.flags,
        'divisibility': value.divisibility,
        'duration': value.duration,
    };
}
exports.MosaicDTOToJSON = MosaicDTOToJSON;

},{}],1050:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicDefinitionTransactionBodyDTOToJSON = exports.MosaicDefinitionTransactionBodyDTOFromJSONTyped = exports.MosaicDefinitionTransactionBodyDTOFromJSON = void 0;
function MosaicDefinitionTransactionBodyDTOFromJSON(json) {
    return MosaicDefinitionTransactionBodyDTOFromJSONTyped(json, false);
}
exports.MosaicDefinitionTransactionBodyDTOFromJSON = MosaicDefinitionTransactionBodyDTOFromJSON;
function MosaicDefinitionTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'duration': json['duration'],
        'nonce': json['nonce'],
        'flags': json['flags'],
        'divisibility': json['divisibility'],
    };
}
exports.MosaicDefinitionTransactionBodyDTOFromJSONTyped = MosaicDefinitionTransactionBodyDTOFromJSONTyped;
function MosaicDefinitionTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'duration': value.duration,
        'nonce': value.nonce,
        'flags': value.flags,
        'divisibility': value.divisibility,
    };
}
exports.MosaicDefinitionTransactionBodyDTOToJSON = MosaicDefinitionTransactionBodyDTOToJSON;

},{}],1051:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicDefinitionTransactionDTOToJSON = exports.MosaicDefinitionTransactionDTOFromJSONTyped = exports.MosaicDefinitionTransactionDTOFromJSON = void 0;
function MosaicDefinitionTransactionDTOFromJSON(json) {
    return MosaicDefinitionTransactionDTOFromJSONTyped(json, false);
}
exports.MosaicDefinitionTransactionDTOFromJSON = MosaicDefinitionTransactionDTOFromJSON;
function MosaicDefinitionTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'id': json['id'],
        'duration': json['duration'],
        'nonce': json['nonce'],
        'flags': json['flags'],
        'divisibility': json['divisibility'],
    };
}
exports.MosaicDefinitionTransactionDTOFromJSONTyped = MosaicDefinitionTransactionDTOFromJSONTyped;
function MosaicDefinitionTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'id': value.id,
        'duration': value.duration,
        'nonce': value.nonce,
        'flags': value.flags,
        'divisibility': value.divisibility,
    };
}
exports.MosaicDefinitionTransactionDTOToJSON = MosaicDefinitionTransactionDTOToJSON;

},{}],1052:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicExpiryReceiptDTOToJSON = exports.MosaicExpiryReceiptDTOFromJSONTyped = exports.MosaicExpiryReceiptDTOFromJSON = void 0;
function MosaicExpiryReceiptDTOFromJSON(json) {
    return MosaicExpiryReceiptDTOFromJSONTyped(json, false);
}
exports.MosaicExpiryReceiptDTOFromJSON = MosaicExpiryReceiptDTOFromJSON;
function MosaicExpiryReceiptDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'version': json['version'],
        'type': json['type'],
        'artifactId': json['artifactId'],
    };
}
exports.MosaicExpiryReceiptDTOFromJSONTyped = MosaicExpiryReceiptDTOFromJSONTyped;
function MosaicExpiryReceiptDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'version': value.version,
        'type': value.type,
        'artifactId': value.artifactId,
    };
}
exports.MosaicExpiryReceiptDTOToJSON = MosaicExpiryReceiptDTOToJSON;

},{}],1053:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicExpiryReceiptDTOAllOfToJSON = exports.MosaicExpiryReceiptDTOAllOfFromJSONTyped = exports.MosaicExpiryReceiptDTOAllOfFromJSON = void 0;
function MosaicExpiryReceiptDTOAllOfFromJSON(json) {
    return MosaicExpiryReceiptDTOAllOfFromJSONTyped(json, false);
}
exports.MosaicExpiryReceiptDTOAllOfFromJSON = MosaicExpiryReceiptDTOAllOfFromJSON;
function MosaicExpiryReceiptDTOAllOfFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'artifactId': json['artifactId'],
    };
}
exports.MosaicExpiryReceiptDTOAllOfFromJSONTyped = MosaicExpiryReceiptDTOAllOfFromJSONTyped;
function MosaicExpiryReceiptDTOAllOfToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'artifactId': value.artifactId,
    };
}
exports.MosaicExpiryReceiptDTOAllOfToJSON = MosaicExpiryReceiptDTOAllOfToJSON;

},{}],1054:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicGlobalRestrictionDTOToJSON = exports.MosaicGlobalRestrictionDTOFromJSONTyped = exports.MosaicGlobalRestrictionDTOFromJSON = void 0;
function MosaicGlobalRestrictionDTOFromJSON(json) {
    return MosaicGlobalRestrictionDTOFromJSONTyped(json, false);
}
exports.MosaicGlobalRestrictionDTOFromJSON = MosaicGlobalRestrictionDTOFromJSON;
function MosaicGlobalRestrictionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'mosaicRestrictionEntry': json['mosaicRestrictionEntry'],
    };
}
exports.MosaicGlobalRestrictionDTOFromJSONTyped = MosaicGlobalRestrictionDTOFromJSONTyped;
function MosaicGlobalRestrictionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'mosaicRestrictionEntry': value.mosaicRestrictionEntry,
    };
}
exports.MosaicGlobalRestrictionDTOToJSON = MosaicGlobalRestrictionDTOToJSON;

},{}],1055:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicGlobalRestrictionEntryDTOToJSON = exports.MosaicGlobalRestrictionEntryDTOFromJSONTyped = exports.MosaicGlobalRestrictionEntryDTOFromJSON = void 0;
function MosaicGlobalRestrictionEntryDTOFromJSON(json) {
    return MosaicGlobalRestrictionEntryDTOFromJSONTyped(json, false);
}
exports.MosaicGlobalRestrictionEntryDTOFromJSON = MosaicGlobalRestrictionEntryDTOFromJSON;
function MosaicGlobalRestrictionEntryDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'key': json['key'],
        'restriction': json['restriction'],
    };
}
exports.MosaicGlobalRestrictionEntryDTOFromJSONTyped = MosaicGlobalRestrictionEntryDTOFromJSONTyped;
function MosaicGlobalRestrictionEntryDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'key': value.key,
        'restriction': value.restriction,
    };
}
exports.MosaicGlobalRestrictionEntryDTOToJSON = MosaicGlobalRestrictionEntryDTOToJSON;

},{}],1056:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicGlobalRestrictionEntryRestrictionDTOToJSON = exports.MosaicGlobalRestrictionEntryRestrictionDTOFromJSONTyped = exports.MosaicGlobalRestrictionEntryRestrictionDTOFromJSON = void 0;
function MosaicGlobalRestrictionEntryRestrictionDTOFromJSON(json) {
    return MosaicGlobalRestrictionEntryRestrictionDTOFromJSONTyped(json, false);
}
exports.MosaicGlobalRestrictionEntryRestrictionDTOFromJSON = MosaicGlobalRestrictionEntryRestrictionDTOFromJSON;
function MosaicGlobalRestrictionEntryRestrictionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'referenceMosaicId': json['referenceMosaicId'],
        'restrictionValue': json['restrictionValue'],
        'restrictionType': json['restrictionType'],
    };
}
exports.MosaicGlobalRestrictionEntryRestrictionDTOFromJSONTyped = MosaicGlobalRestrictionEntryRestrictionDTOFromJSONTyped;
function MosaicGlobalRestrictionEntryRestrictionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'referenceMosaicId': value.referenceMosaicId,
        'restrictionValue': value.restrictionValue,
        'restrictionType': value.restrictionType,
    };
}
exports.MosaicGlobalRestrictionEntryRestrictionDTOToJSON = MosaicGlobalRestrictionEntryRestrictionDTOToJSON;

},{}],1057:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicGlobalRestrictionEntryWrapperDTOToJSON = exports.MosaicGlobalRestrictionEntryWrapperDTOFromJSONTyped = exports.MosaicGlobalRestrictionEntryWrapperDTOFromJSON = void 0;
function MosaicGlobalRestrictionEntryWrapperDTOFromJSON(json) {
    return MosaicGlobalRestrictionEntryWrapperDTOFromJSONTyped(json, false);
}
exports.MosaicGlobalRestrictionEntryWrapperDTOFromJSON = MosaicGlobalRestrictionEntryWrapperDTOFromJSON;
function MosaicGlobalRestrictionEntryWrapperDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'compositeHash': json['compositeHash'],
        'entryType': json['entryType'],
        'mosaicId': json['mosaicId'],
        'restrictions': json['restrictions'],
    };
}
exports.MosaicGlobalRestrictionEntryWrapperDTOFromJSONTyped = MosaicGlobalRestrictionEntryWrapperDTOFromJSONTyped;
function MosaicGlobalRestrictionEntryWrapperDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'compositeHash': value.compositeHash,
        'entryType': value.entryType,
        'mosaicId': value.mosaicId,
        'restrictions': value.restrictions,
    };
}
exports.MosaicGlobalRestrictionEntryWrapperDTOToJSON = MosaicGlobalRestrictionEntryWrapperDTOToJSON;

},{}],1058:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicGlobalRestrictionTransactionBodyDTOToJSON = exports.MosaicGlobalRestrictionTransactionBodyDTOFromJSONTyped = exports.MosaicGlobalRestrictionTransactionBodyDTOFromJSON = void 0;
function MosaicGlobalRestrictionTransactionBodyDTOFromJSON(json) {
    return MosaicGlobalRestrictionTransactionBodyDTOFromJSONTyped(json, false);
}
exports.MosaicGlobalRestrictionTransactionBodyDTOFromJSON = MosaicGlobalRestrictionTransactionBodyDTOFromJSON;
function MosaicGlobalRestrictionTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'mosaicId': json['mosaicId'],
        'referenceMosaicId': json['referenceMosaicId'],
        'restrictionKey': json['restrictionKey'],
        'previousRestrictionValue': json['previousRestrictionValue'],
        'newRestrictionValue': json['newRestrictionValue'],
        'previousRestrictionType': json['previousRestrictionType'],
        'newRestrictionType': json['newRestrictionType'],
    };
}
exports.MosaicGlobalRestrictionTransactionBodyDTOFromJSONTyped = MosaicGlobalRestrictionTransactionBodyDTOFromJSONTyped;
function MosaicGlobalRestrictionTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'mosaicId': value.mosaicId,
        'referenceMosaicId': value.referenceMosaicId,
        'restrictionKey': value.restrictionKey,
        'previousRestrictionValue': value.previousRestrictionValue,
        'newRestrictionValue': value.newRestrictionValue,
        'previousRestrictionType': value.previousRestrictionType,
        'newRestrictionType': value.newRestrictionType,
    };
}
exports.MosaicGlobalRestrictionTransactionBodyDTOToJSON = MosaicGlobalRestrictionTransactionBodyDTOToJSON;

},{}],1059:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicGlobalRestrictionTransactionDTOToJSON = exports.MosaicGlobalRestrictionTransactionDTOFromJSONTyped = exports.MosaicGlobalRestrictionTransactionDTOFromJSON = void 0;
function MosaicGlobalRestrictionTransactionDTOFromJSON(json) {
    return MosaicGlobalRestrictionTransactionDTOFromJSONTyped(json, false);
}
exports.MosaicGlobalRestrictionTransactionDTOFromJSON = MosaicGlobalRestrictionTransactionDTOFromJSON;
function MosaicGlobalRestrictionTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'mosaicId': json['mosaicId'],
        'referenceMosaicId': json['referenceMosaicId'],
        'restrictionKey': json['restrictionKey'],
        'previousRestrictionValue': json['previousRestrictionValue'],
        'newRestrictionValue': json['newRestrictionValue'],
        'previousRestrictionType': json['previousRestrictionType'],
        'newRestrictionType': json['newRestrictionType'],
    };
}
exports.MosaicGlobalRestrictionTransactionDTOFromJSONTyped = MosaicGlobalRestrictionTransactionDTOFromJSONTyped;
function MosaicGlobalRestrictionTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'mosaicId': value.mosaicId,
        'referenceMosaicId': value.referenceMosaicId,
        'restrictionKey': value.restrictionKey,
        'previousRestrictionValue': value.previousRestrictionValue,
        'newRestrictionValue': value.newRestrictionValue,
        'previousRestrictionType': value.previousRestrictionType,
        'newRestrictionType': value.newRestrictionType,
    };
}
exports.MosaicGlobalRestrictionTransactionDTOToJSON = MosaicGlobalRestrictionTransactionDTOToJSON;

},{}],1060:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicIdsToJSON = exports.MosaicIdsFromJSONTyped = exports.MosaicIdsFromJSON = void 0;
const runtime_1 = require("../runtime");
function MosaicIdsFromJSON(json) {
    return MosaicIdsFromJSONTyped(json, false);
}
exports.MosaicIdsFromJSON = MosaicIdsFromJSON;
function MosaicIdsFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'mosaicIds': !runtime_1.exists(json, 'mosaicIds') ? undefined : json['mosaicIds'],
    };
}
exports.MosaicIdsFromJSONTyped = MosaicIdsFromJSONTyped;
function MosaicIdsToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'mosaicIds': value.mosaicIds,
    };
}
exports.MosaicIdsToJSON = MosaicIdsToJSON;

},{"../runtime":1158}],1061:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicInfoDTOToJSON = exports.MosaicInfoDTOFromJSONTyped = exports.MosaicInfoDTOFromJSON = void 0;
function MosaicInfoDTOFromJSON(json) {
    return MosaicInfoDTOFromJSONTyped(json, false);
}
exports.MosaicInfoDTOFromJSON = MosaicInfoDTOFromJSON;
function MosaicInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'mosaic': json['mosaic'],
    };
}
exports.MosaicInfoDTOFromJSONTyped = MosaicInfoDTOFromJSONTyped;
function MosaicInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'mosaic': value.mosaic,
    };
}
exports.MosaicInfoDTOToJSON = MosaicInfoDTOToJSON;

},{}],1062:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicMetadataTransactionBodyDTOToJSON = exports.MosaicMetadataTransactionBodyDTOFromJSONTyped = exports.MosaicMetadataTransactionBodyDTOFromJSON = void 0;
function MosaicMetadataTransactionBodyDTOFromJSON(json) {
    return MosaicMetadataTransactionBodyDTOFromJSONTyped(json, false);
}
exports.MosaicMetadataTransactionBodyDTOFromJSON = MosaicMetadataTransactionBodyDTOFromJSON;
function MosaicMetadataTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'targetAddress': json['targetAddress'],
        'scopedMetadataKey': json['scopedMetadataKey'],
        'targetMosaicId': json['targetMosaicId'],
        'valueSizeDelta': json['valueSizeDelta'],
        'valueSize': json['valueSize'],
        'value': json['value'],
    };
}
exports.MosaicMetadataTransactionBodyDTOFromJSONTyped = MosaicMetadataTransactionBodyDTOFromJSONTyped;
function MosaicMetadataTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'targetAddress': value.targetAddress,
        'scopedMetadataKey': value.scopedMetadataKey,
        'targetMosaicId': value.targetMosaicId,
        'valueSizeDelta': value.valueSizeDelta,
        'valueSize': value.valueSize,
        'value': value.value,
    };
}
exports.MosaicMetadataTransactionBodyDTOToJSON = MosaicMetadataTransactionBodyDTOToJSON;

},{}],1063:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicMetadataTransactionDTOToJSON = exports.MosaicMetadataTransactionDTOFromJSONTyped = exports.MosaicMetadataTransactionDTOFromJSON = void 0;
function MosaicMetadataTransactionDTOFromJSON(json) {
    return MosaicMetadataTransactionDTOFromJSONTyped(json, false);
}
exports.MosaicMetadataTransactionDTOFromJSON = MosaicMetadataTransactionDTOFromJSON;
function MosaicMetadataTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'targetAddress': json['targetAddress'],
        'scopedMetadataKey': json['scopedMetadataKey'],
        'targetMosaicId': json['targetMosaicId'],
        'valueSizeDelta': json['valueSizeDelta'],
        'valueSize': json['valueSize'],
        'value': json['value'],
    };
}
exports.MosaicMetadataTransactionDTOFromJSONTyped = MosaicMetadataTransactionDTOFromJSONTyped;
function MosaicMetadataTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'targetAddress': value.targetAddress,
        'scopedMetadataKey': value.scopedMetadataKey,
        'targetMosaicId': value.targetMosaicId,
        'valueSizeDelta': value.valueSizeDelta,
        'valueSize': value.valueSize,
        'value': value.value,
    };
}
exports.MosaicMetadataTransactionDTOToJSON = MosaicMetadataTransactionDTOToJSON;

},{}],1064:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicNamesDTOToJSON = exports.MosaicNamesDTOFromJSONTyped = exports.MosaicNamesDTOFromJSON = void 0;
function MosaicNamesDTOFromJSON(json) {
    return MosaicNamesDTOFromJSONTyped(json, false);
}
exports.MosaicNamesDTOFromJSON = MosaicNamesDTOFromJSON;
function MosaicNamesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'mosaicId': json['mosaicId'],
        'names': json['names'],
    };
}
exports.MosaicNamesDTOFromJSONTyped = MosaicNamesDTOFromJSONTyped;
function MosaicNamesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'mosaicId': value.mosaicId,
        'names': value.names,
    };
}
exports.MosaicNamesDTOToJSON = MosaicNamesDTOToJSON;

},{}],1065:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicNetworkPropertiesDTOToJSON = exports.MosaicNetworkPropertiesDTOFromJSONTyped = exports.MosaicNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function MosaicNetworkPropertiesDTOFromJSON(json) {
    return MosaicNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.MosaicNetworkPropertiesDTOFromJSON = MosaicNetworkPropertiesDTOFromJSON;
function MosaicNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'maxMosaicsPerAccount': !runtime_1.exists(json, 'maxMosaicsPerAccount') ? undefined : json['maxMosaicsPerAccount'],
        'maxMosaicDuration': !runtime_1.exists(json, 'maxMosaicDuration') ? undefined : json['maxMosaicDuration'],
        'maxMosaicDivisibility': !runtime_1.exists(json, 'maxMosaicDivisibility') ? undefined : json['maxMosaicDivisibility'],
        'mosaicRentalFeeSinkAddress': !runtime_1.exists(json, 'mosaicRentalFeeSinkAddress') ? undefined : json['mosaicRentalFeeSinkAddress'],
        'mosaicRentalFee': !runtime_1.exists(json, 'mosaicRentalFee') ? undefined : json['mosaicRentalFee'],
    };
}
exports.MosaicNetworkPropertiesDTOFromJSONTyped = MosaicNetworkPropertiesDTOFromJSONTyped;
function MosaicNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'maxMosaicsPerAccount': value.maxMosaicsPerAccount,
        'maxMosaicDuration': value.maxMosaicDuration,
        'maxMosaicDivisibility': value.maxMosaicDivisibility,
        'mosaicRentalFeeSinkAddress': value.mosaicRentalFeeSinkAddress,
        'mosaicRentalFee': value.mosaicRentalFee,
    };
}
exports.MosaicNetworkPropertiesDTOToJSON = MosaicNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],1066:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicPageToJSON = exports.MosaicPageFromJSONTyped = exports.MosaicPageFromJSON = void 0;
function MosaicPageFromJSON(json) {
    return MosaicPageFromJSONTyped(json, false);
}
exports.MosaicPageFromJSON = MosaicPageFromJSON;
function MosaicPageFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'data': json['data'],
        'pagination': json['pagination'],
    };
}
exports.MosaicPageFromJSONTyped = MosaicPageFromJSONTyped;
function MosaicPageToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'data': value.data,
        'pagination': value.pagination,
    };
}
exports.MosaicPageToJSON = MosaicPageToJSON;

},{}],1067:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicRestrictionEntryTypeEnumToJSON = exports.MosaicRestrictionEntryTypeEnumFromJSONTyped = exports.MosaicRestrictionEntryTypeEnumFromJSON = exports.MosaicRestrictionEntryTypeEnum = void 0;
/**
 * - 0 - Mosaic address restriction.
 * - 1 - Mosaic global restriction.
 * @export
 * @enum {string}
 */
var MosaicRestrictionEntryTypeEnum;
(function (MosaicRestrictionEntryTypeEnum) {
    MosaicRestrictionEntryTypeEnum[MosaicRestrictionEntryTypeEnum["NUMBER_0"] = 0] = "NUMBER_0";
    MosaicRestrictionEntryTypeEnum[MosaicRestrictionEntryTypeEnum["NUMBER_1"] = 1] = "NUMBER_1";
})(MosaicRestrictionEntryTypeEnum = exports.MosaicRestrictionEntryTypeEnum || (exports.MosaicRestrictionEntryTypeEnum = {}));
function MosaicRestrictionEntryTypeEnumFromJSON(json) {
    return MosaicRestrictionEntryTypeEnumFromJSONTyped(json, false);
}
exports.MosaicRestrictionEntryTypeEnumFromJSON = MosaicRestrictionEntryTypeEnumFromJSON;
function MosaicRestrictionEntryTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.MosaicRestrictionEntryTypeEnumFromJSONTyped = MosaicRestrictionEntryTypeEnumFromJSONTyped;
function MosaicRestrictionEntryTypeEnumToJSON(value) {
    return value;
}
exports.MosaicRestrictionEntryTypeEnumToJSON = MosaicRestrictionEntryTypeEnumToJSON;

},{}],1068:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicRestrictionNetworkPropertiesDTOToJSON = exports.MosaicRestrictionNetworkPropertiesDTOFromJSONTyped = exports.MosaicRestrictionNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function MosaicRestrictionNetworkPropertiesDTOFromJSON(json) {
    return MosaicRestrictionNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.MosaicRestrictionNetworkPropertiesDTOFromJSON = MosaicRestrictionNetworkPropertiesDTOFromJSON;
function MosaicRestrictionNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'maxMosaicRestrictionValues': !runtime_1.exists(json, 'maxMosaicRestrictionValues') ? undefined : json['maxMosaicRestrictionValues'],
    };
}
exports.MosaicRestrictionNetworkPropertiesDTOFromJSONTyped = MosaicRestrictionNetworkPropertiesDTOFromJSONTyped;
function MosaicRestrictionNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'maxMosaicRestrictionValues': value.maxMosaicRestrictionValues,
    };
}
exports.MosaicRestrictionNetworkPropertiesDTOToJSON = MosaicRestrictionNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],1069:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicRestrictionTypeEnumToJSON = exports.MosaicRestrictionTypeEnumFromJSONTyped = exports.MosaicRestrictionTypeEnumFromJSON = exports.MosaicRestrictionTypeEnum = void 0;
/**
 * Type of mosaic restriction.
 * * 0 - Uninitialized value indicating no restriction.
 * * 1 (EQ) - Allow if equal.
 * * 2 (NE) - Allow if not equal.
 * * 3 (LT) - Allow if less than.
 * * 4 (LE) - Allow if less than or equal.
 * * 5 (GT) - Allow if greater than.
 * * 6 (GE) - Allow if greater than or equal.
 * @export
 * @enum {string}
 */
var MosaicRestrictionTypeEnum;
(function (MosaicRestrictionTypeEnum) {
    MosaicRestrictionTypeEnum[MosaicRestrictionTypeEnum["NUMBER_0"] = 0] = "NUMBER_0";
    MosaicRestrictionTypeEnum[MosaicRestrictionTypeEnum["NUMBER_1"] = 1] = "NUMBER_1";
    MosaicRestrictionTypeEnum[MosaicRestrictionTypeEnum["NUMBER_2"] = 2] = "NUMBER_2";
    MosaicRestrictionTypeEnum[MosaicRestrictionTypeEnum["NUMBER_3"] = 3] = "NUMBER_3";
    MosaicRestrictionTypeEnum[MosaicRestrictionTypeEnum["NUMBER_4"] = 4] = "NUMBER_4";
    MosaicRestrictionTypeEnum[MosaicRestrictionTypeEnum["NUMBER_5"] = 5] = "NUMBER_5";
    MosaicRestrictionTypeEnum[MosaicRestrictionTypeEnum["NUMBER_6"] = 6] = "NUMBER_6";
})(MosaicRestrictionTypeEnum = exports.MosaicRestrictionTypeEnum || (exports.MosaicRestrictionTypeEnum = {}));
function MosaicRestrictionTypeEnumFromJSON(json) {
    return MosaicRestrictionTypeEnumFromJSONTyped(json, false);
}
exports.MosaicRestrictionTypeEnumFromJSON = MosaicRestrictionTypeEnumFromJSON;
function MosaicRestrictionTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.MosaicRestrictionTypeEnumFromJSONTyped = MosaicRestrictionTypeEnumFromJSONTyped;
function MosaicRestrictionTypeEnumToJSON(value) {
    return value;
}
exports.MosaicRestrictionTypeEnumToJSON = MosaicRestrictionTypeEnumToJSON;

},{}],1070:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicSupplyChangeActionEnumToJSON = exports.MosaicSupplyChangeActionEnumFromJSONTyped = exports.MosaicSupplyChangeActionEnumFromJSON = exports.MosaicSupplyChangeActionEnum = void 0;
/**
 * Direction of the supply change:
 * * 0  - Decrease.
 * * 1  - Increase.
 * @export
 * @enum {string}
 */
var MosaicSupplyChangeActionEnum;
(function (MosaicSupplyChangeActionEnum) {
    MosaicSupplyChangeActionEnum[MosaicSupplyChangeActionEnum["NUMBER_0"] = 0] = "NUMBER_0";
    MosaicSupplyChangeActionEnum[MosaicSupplyChangeActionEnum["NUMBER_1"] = 1] = "NUMBER_1";
})(MosaicSupplyChangeActionEnum = exports.MosaicSupplyChangeActionEnum || (exports.MosaicSupplyChangeActionEnum = {}));
function MosaicSupplyChangeActionEnumFromJSON(json) {
    return MosaicSupplyChangeActionEnumFromJSONTyped(json, false);
}
exports.MosaicSupplyChangeActionEnumFromJSON = MosaicSupplyChangeActionEnumFromJSON;
function MosaicSupplyChangeActionEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.MosaicSupplyChangeActionEnumFromJSONTyped = MosaicSupplyChangeActionEnumFromJSONTyped;
function MosaicSupplyChangeActionEnumToJSON(value) {
    return value;
}
exports.MosaicSupplyChangeActionEnumToJSON = MosaicSupplyChangeActionEnumToJSON;

},{}],1071:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicSupplyChangeTransactionBodyDTOToJSON = exports.MosaicSupplyChangeTransactionBodyDTOFromJSONTyped = exports.MosaicSupplyChangeTransactionBodyDTOFromJSON = void 0;
function MosaicSupplyChangeTransactionBodyDTOFromJSON(json) {
    return MosaicSupplyChangeTransactionBodyDTOFromJSONTyped(json, false);
}
exports.MosaicSupplyChangeTransactionBodyDTOFromJSON = MosaicSupplyChangeTransactionBodyDTOFromJSON;
function MosaicSupplyChangeTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'mosaicId': json['mosaicId'],
        'delta': json['delta'],
        'action': json['action'],
    };
}
exports.MosaicSupplyChangeTransactionBodyDTOFromJSONTyped = MosaicSupplyChangeTransactionBodyDTOFromJSONTyped;
function MosaicSupplyChangeTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'mosaicId': value.mosaicId,
        'delta': value.delta,
        'action': value.action,
    };
}
exports.MosaicSupplyChangeTransactionBodyDTOToJSON = MosaicSupplyChangeTransactionBodyDTOToJSON;

},{}],1072:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicSupplyChangeTransactionDTOToJSON = exports.MosaicSupplyChangeTransactionDTOFromJSONTyped = exports.MosaicSupplyChangeTransactionDTOFromJSON = void 0;
function MosaicSupplyChangeTransactionDTOFromJSON(json) {
    return MosaicSupplyChangeTransactionDTOFromJSONTyped(json, false);
}
exports.MosaicSupplyChangeTransactionDTOFromJSON = MosaicSupplyChangeTransactionDTOFromJSON;
function MosaicSupplyChangeTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'mosaicId': json['mosaicId'],
        'delta': json['delta'],
        'action': json['action'],
    };
}
exports.MosaicSupplyChangeTransactionDTOFromJSONTyped = MosaicSupplyChangeTransactionDTOFromJSONTyped;
function MosaicSupplyChangeTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'mosaicId': value.mosaicId,
        'delta': value.delta,
        'action': value.action,
    };
}
exports.MosaicSupplyChangeTransactionDTOToJSON = MosaicSupplyChangeTransactionDTOToJSON;

},{}],1073:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MosaicsNamesDTOToJSON = exports.MosaicsNamesDTOFromJSONTyped = exports.MosaicsNamesDTOFromJSON = void 0;
function MosaicsNamesDTOFromJSON(json) {
    return MosaicsNamesDTOFromJSONTyped(json, false);
}
exports.MosaicsNamesDTOFromJSON = MosaicsNamesDTOFromJSON;
function MosaicsNamesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'mosaicNames': json['mosaicNames'],
    };
}
exports.MosaicsNamesDTOFromJSONTyped = MosaicsNamesDTOFromJSONTyped;
function MosaicsNamesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'mosaicNames': value.mosaicNames,
    };
}
exports.MosaicsNamesDTOToJSON = MosaicsNamesDTOToJSON;

},{}],1074:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigAccountGraphInfoDTOToJSON = exports.MultisigAccountGraphInfoDTOFromJSONTyped = exports.MultisigAccountGraphInfoDTOFromJSON = void 0;
function MultisigAccountGraphInfoDTOFromJSON(json) {
    return MultisigAccountGraphInfoDTOFromJSONTyped(json, false);
}
exports.MultisigAccountGraphInfoDTOFromJSON = MultisigAccountGraphInfoDTOFromJSON;
function MultisigAccountGraphInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'level': json['level'],
        'multisigEntries': json['multisigEntries'],
    };
}
exports.MultisigAccountGraphInfoDTOFromJSONTyped = MultisigAccountGraphInfoDTOFromJSONTyped;
function MultisigAccountGraphInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'level': value.level,
        'multisigEntries': value.multisigEntries,
    };
}
exports.MultisigAccountGraphInfoDTOToJSON = MultisigAccountGraphInfoDTOToJSON;

},{}],1075:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigAccountInfoDTOToJSON = exports.MultisigAccountInfoDTOFromJSONTyped = exports.MultisigAccountInfoDTOFromJSON = void 0;
function MultisigAccountInfoDTOFromJSON(json) {
    return MultisigAccountInfoDTOFromJSONTyped(json, false);
}
exports.MultisigAccountInfoDTOFromJSON = MultisigAccountInfoDTOFromJSON;
function MultisigAccountInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'multisig': json['multisig'],
    };
}
exports.MultisigAccountInfoDTOFromJSONTyped = MultisigAccountInfoDTOFromJSONTyped;
function MultisigAccountInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'multisig': value.multisig,
    };
}
exports.MultisigAccountInfoDTOToJSON = MultisigAccountInfoDTOToJSON;

},{}],1076:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigAccountModificationTransactionBodyDTOToJSON = exports.MultisigAccountModificationTransactionBodyDTOFromJSONTyped = exports.MultisigAccountModificationTransactionBodyDTOFromJSON = void 0;
function MultisigAccountModificationTransactionBodyDTOFromJSON(json) {
    return MultisigAccountModificationTransactionBodyDTOFromJSONTyped(json, false);
}
exports.MultisigAccountModificationTransactionBodyDTOFromJSON = MultisigAccountModificationTransactionBodyDTOFromJSON;
function MultisigAccountModificationTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'minRemovalDelta': json['minRemovalDelta'],
        'minApprovalDelta': json['minApprovalDelta'],
        'addressAdditions': json['addressAdditions'],
        'addressDeletions': json['addressDeletions'],
    };
}
exports.MultisigAccountModificationTransactionBodyDTOFromJSONTyped = MultisigAccountModificationTransactionBodyDTOFromJSONTyped;
function MultisigAccountModificationTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'minRemovalDelta': value.minRemovalDelta,
        'minApprovalDelta': value.minApprovalDelta,
        'addressAdditions': value.addressAdditions,
        'addressDeletions': value.addressDeletions,
    };
}
exports.MultisigAccountModificationTransactionBodyDTOToJSON = MultisigAccountModificationTransactionBodyDTOToJSON;

},{}],1077:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigAccountModificationTransactionDTOToJSON = exports.MultisigAccountModificationTransactionDTOFromJSONTyped = exports.MultisigAccountModificationTransactionDTOFromJSON = void 0;
function MultisigAccountModificationTransactionDTOFromJSON(json) {
    return MultisigAccountModificationTransactionDTOFromJSONTyped(json, false);
}
exports.MultisigAccountModificationTransactionDTOFromJSON = MultisigAccountModificationTransactionDTOFromJSON;
function MultisigAccountModificationTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'minRemovalDelta': json['minRemovalDelta'],
        'minApprovalDelta': json['minApprovalDelta'],
        'addressAdditions': json['addressAdditions'],
        'addressDeletions': json['addressDeletions'],
    };
}
exports.MultisigAccountModificationTransactionDTOFromJSONTyped = MultisigAccountModificationTransactionDTOFromJSONTyped;
function MultisigAccountModificationTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'minRemovalDelta': value.minRemovalDelta,
        'minApprovalDelta': value.minApprovalDelta,
        'addressAdditions': value.addressAdditions,
        'addressDeletions': value.addressDeletions,
    };
}
exports.MultisigAccountModificationTransactionDTOToJSON = MultisigAccountModificationTransactionDTOToJSON;

},{}],1078:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigDTOToJSON = exports.MultisigDTOFromJSONTyped = exports.MultisigDTOFromJSON = void 0;
function MultisigDTOFromJSON(json) {
    return MultisigDTOFromJSONTyped(json, false);
}
exports.MultisigDTOFromJSON = MultisigDTOFromJSON;
function MultisigDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'accountAddress': json['accountAddress'],
        'minApproval': json['minApproval'],
        'minRemoval': json['minRemoval'],
        'cosignatoryAddresses': json['cosignatoryAddresses'],
        'multisigAddresses': json['multisigAddresses'],
    };
}
exports.MultisigDTOFromJSONTyped = MultisigDTOFromJSONTyped;
function MultisigDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'accountAddress': value.accountAddress,
        'minApproval': value.minApproval,
        'minRemoval': value.minRemoval,
        'cosignatoryAddresses': value.cosignatoryAddresses,
        'multisigAddresses': value.multisigAddresses,
    };
}
exports.MultisigDTOToJSON = MultisigDTOToJSON;

},{}],1079:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigNetworkPropertiesDTOToJSON = exports.MultisigNetworkPropertiesDTOFromJSONTyped = exports.MultisigNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function MultisigNetworkPropertiesDTOFromJSON(json) {
    return MultisigNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.MultisigNetworkPropertiesDTOFromJSON = MultisigNetworkPropertiesDTOFromJSON;
function MultisigNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'maxMultisigDepth': !runtime_1.exists(json, 'maxMultisigDepth') ? undefined : json['maxMultisigDepth'],
        'maxCosignatoriesPerAccount': !runtime_1.exists(json, 'maxCosignatoriesPerAccount') ? undefined : json['maxCosignatoriesPerAccount'],
        'maxCosignedAccountsPerAccount': !runtime_1.exists(json, 'maxCosignedAccountsPerAccount') ? undefined : json['maxCosignedAccountsPerAccount'],
    };
}
exports.MultisigNetworkPropertiesDTOFromJSONTyped = MultisigNetworkPropertiesDTOFromJSONTyped;
function MultisigNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'maxMultisigDepth': value.maxMultisigDepth,
        'maxCosignatoriesPerAccount': value.maxCosignatoriesPerAccount,
        'maxCosignedAccountsPerAccount': value.maxCosignedAccountsPerAccount,
    };
}
exports.MultisigNetworkPropertiesDTOToJSON = MultisigNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],1080:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceDTOToJSON = exports.NamespaceDTOFromJSONTyped = exports.NamespaceDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function NamespaceDTOFromJSON(json) {
    return NamespaceDTOFromJSONTyped(json, false);
}
exports.NamespaceDTOFromJSON = NamespaceDTOFromJSON;
function NamespaceDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'registrationType': json['registrationType'],
        'depth': json['depth'],
        'level0': json['level0'],
        'level1': !runtime_1.exists(json, 'level1') ? undefined : json['level1'],
        'level2': !runtime_1.exists(json, 'level2') ? undefined : json['level2'],
        'alias': json['alias'],
        'parentId': json['parentId'],
        'ownerAddress': json['ownerAddress'],
        'startHeight': json['startHeight'],
        'endHeight': json['endHeight'],
    };
}
exports.NamespaceDTOFromJSONTyped = NamespaceDTOFromJSONTyped;
function NamespaceDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'registrationType': value.registrationType,
        'depth': value.depth,
        'level0': value.level0,
        'level1': value.level1,
        'level2': value.level2,
        'alias': value.alias,
        'parentId': value.parentId,
        'ownerAddress': value.ownerAddress,
        'startHeight': value.startHeight,
        'endHeight': value.endHeight,
    };
}
exports.NamespaceDTOToJSON = NamespaceDTOToJSON;

},{"../runtime":1158}],1081:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceExpiryReceiptDTOToJSON = exports.NamespaceExpiryReceiptDTOFromJSONTyped = exports.NamespaceExpiryReceiptDTOFromJSON = void 0;
function NamespaceExpiryReceiptDTOFromJSON(json) {
    return NamespaceExpiryReceiptDTOFromJSONTyped(json, false);
}
exports.NamespaceExpiryReceiptDTOFromJSON = NamespaceExpiryReceiptDTOFromJSON;
function NamespaceExpiryReceiptDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'version': json['version'],
        'type': json['type'],
        'artifactId': json['artifactId'],
    };
}
exports.NamespaceExpiryReceiptDTOFromJSONTyped = NamespaceExpiryReceiptDTOFromJSONTyped;
function NamespaceExpiryReceiptDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'version': value.version,
        'type': value.type,
        'artifactId': value.artifactId,
    };
}
exports.NamespaceExpiryReceiptDTOToJSON = NamespaceExpiryReceiptDTOToJSON;

},{}],1082:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceExpiryReceiptDTOAllOfToJSON = exports.NamespaceExpiryReceiptDTOAllOfFromJSONTyped = exports.NamespaceExpiryReceiptDTOAllOfFromJSON = void 0;
function NamespaceExpiryReceiptDTOAllOfFromJSON(json) {
    return NamespaceExpiryReceiptDTOAllOfFromJSONTyped(json, false);
}
exports.NamespaceExpiryReceiptDTOAllOfFromJSON = NamespaceExpiryReceiptDTOAllOfFromJSON;
function NamespaceExpiryReceiptDTOAllOfFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'artifactId': json['artifactId'],
    };
}
exports.NamespaceExpiryReceiptDTOAllOfFromJSONTyped = NamespaceExpiryReceiptDTOAllOfFromJSONTyped;
function NamespaceExpiryReceiptDTOAllOfToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'artifactId': value.artifactId,
    };
}
exports.NamespaceExpiryReceiptDTOAllOfToJSON = NamespaceExpiryReceiptDTOAllOfToJSON;

},{}],1083:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceIdsToJSON = exports.NamespaceIdsFromJSONTyped = exports.NamespaceIdsFromJSON = void 0;
const runtime_1 = require("../runtime");
function NamespaceIdsFromJSON(json) {
    return NamespaceIdsFromJSONTyped(json, false);
}
exports.NamespaceIdsFromJSON = NamespaceIdsFromJSON;
function NamespaceIdsFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'namespaceIds': !runtime_1.exists(json, 'namespaceIds') ? undefined : json['namespaceIds'],
    };
}
exports.NamespaceIdsFromJSONTyped = NamespaceIdsFromJSONTyped;
function NamespaceIdsToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'namespaceIds': value.namespaceIds,
    };
}
exports.NamespaceIdsToJSON = NamespaceIdsToJSON;

},{"../runtime":1158}],1084:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceInfoDTOToJSON = exports.NamespaceInfoDTOFromJSONTyped = exports.NamespaceInfoDTOFromJSON = void 0;
function NamespaceInfoDTOFromJSON(json) {
    return NamespaceInfoDTOFromJSONTyped(json, false);
}
exports.NamespaceInfoDTOFromJSON = NamespaceInfoDTOFromJSON;
function NamespaceInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'meta': json['meta'],
        'namespace': json['namespace'],
    };
}
exports.NamespaceInfoDTOFromJSONTyped = NamespaceInfoDTOFromJSONTyped;
function NamespaceInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'meta': value.meta,
        'namespace': value.namespace,
    };
}
exports.NamespaceInfoDTOToJSON = NamespaceInfoDTOToJSON;

},{}],1085:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceMetaDTOToJSON = exports.NamespaceMetaDTOFromJSONTyped = exports.NamespaceMetaDTOFromJSON = void 0;
function NamespaceMetaDTOFromJSON(json) {
    return NamespaceMetaDTOFromJSONTyped(json, false);
}
exports.NamespaceMetaDTOFromJSON = NamespaceMetaDTOFromJSON;
function NamespaceMetaDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'active': json['active'],
        'index': json['index'],
    };
}
exports.NamespaceMetaDTOFromJSONTyped = NamespaceMetaDTOFromJSONTyped;
function NamespaceMetaDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'active': value.active,
        'index': value.index,
    };
}
exports.NamespaceMetaDTOToJSON = NamespaceMetaDTOToJSON;

},{}],1086:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceMetadataTransactionBodyDTOToJSON = exports.NamespaceMetadataTransactionBodyDTOFromJSONTyped = exports.NamespaceMetadataTransactionBodyDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function NamespaceMetadataTransactionBodyDTOFromJSON(json) {
    return NamespaceMetadataTransactionBodyDTOFromJSONTyped(json, false);
}
exports.NamespaceMetadataTransactionBodyDTOFromJSON = NamespaceMetadataTransactionBodyDTOFromJSON;
function NamespaceMetadataTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'targetAddress': json['targetAddress'],
        'scopedMetadataKey': json['scopedMetadataKey'],
        'targetNamespaceId': !runtime_1.exists(json, 'targetNamespaceId') ? undefined : json['targetNamespaceId'],
        'valueSizeDelta': json['valueSizeDelta'],
        'valueSize': json['valueSize'],
        'value': json['value'],
    };
}
exports.NamespaceMetadataTransactionBodyDTOFromJSONTyped = NamespaceMetadataTransactionBodyDTOFromJSONTyped;
function NamespaceMetadataTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'targetAddress': value.targetAddress,
        'scopedMetadataKey': value.scopedMetadataKey,
        'targetNamespaceId': value.targetNamespaceId,
        'valueSizeDelta': value.valueSizeDelta,
        'valueSize': value.valueSize,
        'value': value.value,
    };
}
exports.NamespaceMetadataTransactionBodyDTOToJSON = NamespaceMetadataTransactionBodyDTOToJSON;

},{"../runtime":1158}],1087:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceMetadataTransactionDTOToJSON = exports.NamespaceMetadataTransactionDTOFromJSONTyped = exports.NamespaceMetadataTransactionDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function NamespaceMetadataTransactionDTOFromJSON(json) {
    return NamespaceMetadataTransactionDTOFromJSONTyped(json, false);
}
exports.NamespaceMetadataTransactionDTOFromJSON = NamespaceMetadataTransactionDTOFromJSON;
function NamespaceMetadataTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'targetAddress': json['targetAddress'],
        'scopedMetadataKey': json['scopedMetadataKey'],
        'targetNamespaceId': !runtime_1.exists(json, 'targetNamespaceId') ? undefined : json['targetNamespaceId'],
        'valueSizeDelta': json['valueSizeDelta'],
        'valueSize': json['valueSize'],
        'value': json['value'],
    };
}
exports.NamespaceMetadataTransactionDTOFromJSONTyped = NamespaceMetadataTransactionDTOFromJSONTyped;
function NamespaceMetadataTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'targetAddress': value.targetAddress,
        'scopedMetadataKey': value.scopedMetadataKey,
        'targetNamespaceId': value.targetNamespaceId,
        'valueSizeDelta': value.valueSizeDelta,
        'valueSize': value.valueSize,
        'value': value.value,
    };
}
exports.NamespaceMetadataTransactionDTOToJSON = NamespaceMetadataTransactionDTOToJSON;

},{"../runtime":1158}],1088:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceNameDTOToJSON = exports.NamespaceNameDTOFromJSONTyped = exports.NamespaceNameDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function NamespaceNameDTOFromJSON(json) {
    return NamespaceNameDTOFromJSONTyped(json, false);
}
exports.NamespaceNameDTOFromJSON = NamespaceNameDTOFromJSON;
function NamespaceNameDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'parentId': !runtime_1.exists(json, 'parentId') ? undefined : json['parentId'],
        'id': json['id'],
        'name': json['name'],
    };
}
exports.NamespaceNameDTOFromJSONTyped = NamespaceNameDTOFromJSONTyped;
function NamespaceNameDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'parentId': value.parentId,
        'id': value.id,
        'name': value.name,
    };
}
exports.NamespaceNameDTOToJSON = NamespaceNameDTOToJSON;

},{"../runtime":1158}],1089:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceNetworkPropertiesDTOToJSON = exports.NamespaceNetworkPropertiesDTOFromJSONTyped = exports.NamespaceNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function NamespaceNetworkPropertiesDTOFromJSON(json) {
    return NamespaceNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.NamespaceNetworkPropertiesDTOFromJSON = NamespaceNetworkPropertiesDTOFromJSON;
function NamespaceNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'maxNameSize': !runtime_1.exists(json, 'maxNameSize') ? undefined : json['maxNameSize'],
        'maxChildNamespaces': !runtime_1.exists(json, 'maxChildNamespaces') ? undefined : json['maxChildNamespaces'],
        'maxNamespaceDepth': !runtime_1.exists(json, 'maxNamespaceDepth') ? undefined : json['maxNamespaceDepth'],
        'minNamespaceDuration': !runtime_1.exists(json, 'minNamespaceDuration') ? undefined : json['minNamespaceDuration'],
        'maxNamespaceDuration': !runtime_1.exists(json, 'maxNamespaceDuration') ? undefined : json['maxNamespaceDuration'],
        'namespaceGracePeriodDuration': !runtime_1.exists(json, 'namespaceGracePeriodDuration') ? undefined : json['namespaceGracePeriodDuration'],
        'reservedRootNamespaceNames': !runtime_1.exists(json, 'reservedRootNamespaceNames') ? undefined : json['reservedRootNamespaceNames'],
        'namespaceRentalFeeSinkAddress': !runtime_1.exists(json, 'namespaceRentalFeeSinkAddress') ? undefined : json['namespaceRentalFeeSinkAddress'],
        'rootNamespaceRentalFeePerBlock': !runtime_1.exists(json, 'rootNamespaceRentalFeePerBlock') ? undefined : json['rootNamespaceRentalFeePerBlock'],
        'childNamespaceRentalFee': !runtime_1.exists(json, 'childNamespaceRentalFee') ? undefined : json['childNamespaceRentalFee'],
    };
}
exports.NamespaceNetworkPropertiesDTOFromJSONTyped = NamespaceNetworkPropertiesDTOFromJSONTyped;
function NamespaceNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'maxNameSize': value.maxNameSize,
        'maxChildNamespaces': value.maxChildNamespaces,
        'maxNamespaceDepth': value.maxNamespaceDepth,
        'minNamespaceDuration': value.minNamespaceDuration,
        'maxNamespaceDuration': value.maxNamespaceDuration,
        'namespaceGracePeriodDuration': value.namespaceGracePeriodDuration,
        'reservedRootNamespaceNames': value.reservedRootNamespaceNames,
        'namespaceRentalFeeSinkAddress': value.namespaceRentalFeeSinkAddress,
        'rootNamespaceRentalFeePerBlock': value.rootNamespaceRentalFeePerBlock,
        'childNamespaceRentalFee': value.childNamespaceRentalFee,
    };
}
exports.NamespaceNetworkPropertiesDTOToJSON = NamespaceNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],1090:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespacePageToJSON = exports.NamespacePageFromJSONTyped = exports.NamespacePageFromJSON = void 0;
function NamespacePageFromJSON(json) {
    return NamespacePageFromJSONTyped(json, false);
}
exports.NamespacePageFromJSON = NamespacePageFromJSON;
function NamespacePageFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'data': json['data'],
        'pagination': json['pagination'],
    };
}
exports.NamespacePageFromJSONTyped = NamespacePageFromJSONTyped;
function NamespacePageToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'data': value.data,
        'pagination': value.pagination,
    };
}
exports.NamespacePageToJSON = NamespacePageToJSON;

},{}],1091:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceRegistrationTransactionBodyDTOToJSON = exports.NamespaceRegistrationTransactionBodyDTOFromJSONTyped = exports.NamespaceRegistrationTransactionBodyDTOFromJSON = void 0;
function NamespaceRegistrationTransactionBodyDTOFromJSON(json) {
    return NamespaceRegistrationTransactionBodyDTOFromJSONTyped(json, false);
}
exports.NamespaceRegistrationTransactionBodyDTOFromJSON = NamespaceRegistrationTransactionBodyDTOFromJSON;
function NamespaceRegistrationTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'duration': json['duration'],
        'parentId': json['parentId'],
        'id': json['id'],
        'registrationType': json['registrationType'],
        'name': json['name'],
    };
}
exports.NamespaceRegistrationTransactionBodyDTOFromJSONTyped = NamespaceRegistrationTransactionBodyDTOFromJSONTyped;
function NamespaceRegistrationTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'duration': value.duration,
        'parentId': value.parentId,
        'id': value.id,
        'registrationType': value.registrationType,
        'name': value.name,
    };
}
exports.NamespaceRegistrationTransactionBodyDTOToJSON = NamespaceRegistrationTransactionBodyDTOToJSON;

},{}],1092:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceRegistrationTransactionDTOToJSON = exports.NamespaceRegistrationTransactionDTOFromJSONTyped = exports.NamespaceRegistrationTransactionDTOFromJSON = void 0;
function NamespaceRegistrationTransactionDTOFromJSON(json) {
    return NamespaceRegistrationTransactionDTOFromJSONTyped(json, false);
}
exports.NamespaceRegistrationTransactionDTOFromJSON = NamespaceRegistrationTransactionDTOFromJSON;
function NamespaceRegistrationTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'duration': json['duration'],
        'parentId': json['parentId'],
        'id': json['id'],
        'registrationType': json['registrationType'],
        'name': json['name'],
    };
}
exports.NamespaceRegistrationTransactionDTOFromJSONTyped = NamespaceRegistrationTransactionDTOFromJSONTyped;
function NamespaceRegistrationTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'duration': value.duration,
        'parentId': value.parentId,
        'id': value.id,
        'registrationType': value.registrationType,
        'name': value.name,
    };
}
exports.NamespaceRegistrationTransactionDTOToJSON = NamespaceRegistrationTransactionDTOToJSON;

},{}],1093:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamespaceRegistrationTypeEnumToJSON = exports.NamespaceRegistrationTypeEnumFromJSONTyped = exports.NamespaceRegistrationTypeEnumFromJSON = exports.NamespaceRegistrationTypeEnum = void 0;
/**
 * Type of namespace:
 * * 0 - Root namespace.
 * * 1 - Subnamespace.
 * @export
 * @enum {string}
 */
var NamespaceRegistrationTypeEnum;
(function (NamespaceRegistrationTypeEnum) {
    NamespaceRegistrationTypeEnum[NamespaceRegistrationTypeEnum["NUMBER_0"] = 0] = "NUMBER_0";
    NamespaceRegistrationTypeEnum[NamespaceRegistrationTypeEnum["NUMBER_1"] = 1] = "NUMBER_1";
})(NamespaceRegistrationTypeEnum = exports.NamespaceRegistrationTypeEnum || (exports.NamespaceRegistrationTypeEnum = {}));
function NamespaceRegistrationTypeEnumFromJSON(json) {
    return NamespaceRegistrationTypeEnumFromJSONTyped(json, false);
}
exports.NamespaceRegistrationTypeEnumFromJSON = NamespaceRegistrationTypeEnumFromJSON;
function NamespaceRegistrationTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.NamespaceRegistrationTypeEnumFromJSONTyped = NamespaceRegistrationTypeEnumFromJSONTyped;
function NamespaceRegistrationTypeEnumToJSON(value) {
    return value;
}
exports.NamespaceRegistrationTypeEnumToJSON = NamespaceRegistrationTypeEnumToJSON;

},{}],1094:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkConfigurationDTOToJSON = exports.NetworkConfigurationDTOFromJSONTyped = exports.NetworkConfigurationDTOFromJSON = void 0;
function NetworkConfigurationDTOFromJSON(json) {
    return NetworkConfigurationDTOFromJSONTyped(json, false);
}
exports.NetworkConfigurationDTOFromJSON = NetworkConfigurationDTOFromJSON;
function NetworkConfigurationDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'network': json['network'],
        'chain': json['chain'],
        'plugins': json['plugins'],
    };
}
exports.NetworkConfigurationDTOFromJSONTyped = NetworkConfigurationDTOFromJSONTyped;
function NetworkConfigurationDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'network': value.network,
        'chain': value.chain,
        'plugins': value.plugins,
    };
}
exports.NetworkConfigurationDTOToJSON = NetworkConfigurationDTOToJSON;

},{}],1095:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkPropertiesDTOToJSON = exports.NetworkPropertiesDTOFromJSONTyped = exports.NetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function NetworkPropertiesDTOFromJSON(json) {
    return NetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.NetworkPropertiesDTOFromJSON = NetworkPropertiesDTOFromJSON;
function NetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'identifier': !runtime_1.exists(json, 'identifier') ? undefined : json['identifier'],
        'nodeEqualityStrategy': !runtime_1.exists(json, 'nodeEqualityStrategy') ? undefined : json['nodeEqualityStrategy'],
        'nemesisSignerPublicKey': !runtime_1.exists(json, 'nemesisSignerPublicKey') ? undefined : json['nemesisSignerPublicKey'],
        'generationHashSeed': !runtime_1.exists(json, 'generationHashSeed') ? undefined : json['generationHashSeed'],
        'epochAdjustment': !runtime_1.exists(json, 'epochAdjustment') ? undefined : json['epochAdjustment'],
    };
}
exports.NetworkPropertiesDTOFromJSONTyped = NetworkPropertiesDTOFromJSONTyped;
function NetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'identifier': value.identifier,
        'nodeEqualityStrategy': value.nodeEqualityStrategy,
        'nemesisSignerPublicKey': value.nemesisSignerPublicKey,
        'generationHashSeed': value.generationHashSeed,
        'epochAdjustment': value.epochAdjustment,
    };
}
exports.NetworkPropertiesDTOToJSON = NetworkPropertiesDTOToJSON;

},{"../runtime":1158}],1096:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkTypeDTOToJSON = exports.NetworkTypeDTOFromJSONTyped = exports.NetworkTypeDTOFromJSON = void 0;
function NetworkTypeDTOFromJSON(json) {
    return NetworkTypeDTOFromJSONTyped(json, false);
}
exports.NetworkTypeDTOFromJSON = NetworkTypeDTOFromJSON;
function NetworkTypeDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'name': json['name'],
        'description': json['description'],
    };
}
exports.NetworkTypeDTOFromJSONTyped = NetworkTypeDTOFromJSONTyped;
function NetworkTypeDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'name': value.name,
        'description': value.description,
    };
}
exports.NetworkTypeDTOToJSON = NetworkTypeDTOToJSON;

},{}],1097:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkTypeEnumToJSON = exports.NetworkTypeEnumFromJSONTyped = exports.NetworkTypeEnumFromJSON = exports.NetworkTypeEnum = void 0;
/**
 * Network type:
 * * 0x60 (96 decimal) - Private network.
 * * 0x90 (144 decimal) - Private test network.
 * * 0x68 (104 decimal) - Public main network.
 * * 0x98 (152 decimal) - Public test network.
 * @export
 * @enum {string}
 */
var NetworkTypeEnum;
(function (NetworkTypeEnum) {
    NetworkTypeEnum[NetworkTypeEnum["NUMBER_104"] = 104] = "NUMBER_104";
    NetworkTypeEnum[NetworkTypeEnum["NUMBER_152"] = 152] = "NUMBER_152";
    NetworkTypeEnum[NetworkTypeEnum["NUMBER_96"] = 96] = "NUMBER_96";
    NetworkTypeEnum[NetworkTypeEnum["NUMBER_144"] = 144] = "NUMBER_144";
})(NetworkTypeEnum = exports.NetworkTypeEnum || (exports.NetworkTypeEnum = {}));
function NetworkTypeEnumFromJSON(json) {
    return NetworkTypeEnumFromJSONTyped(json, false);
}
exports.NetworkTypeEnumFromJSON = NetworkTypeEnumFromJSON;
function NetworkTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.NetworkTypeEnumFromJSONTyped = NetworkTypeEnumFromJSONTyped;
function NetworkTypeEnumToJSON(value) {
    return value;
}
exports.NetworkTypeEnumToJSON = NetworkTypeEnumToJSON;

},{}],1098:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeHealthDTOToJSON = exports.NodeHealthDTOFromJSONTyped = exports.NodeHealthDTOFromJSON = void 0;
function NodeHealthDTOFromJSON(json) {
    return NodeHealthDTOFromJSONTyped(json, false);
}
exports.NodeHealthDTOFromJSON = NodeHealthDTOFromJSON;
function NodeHealthDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'apiNode': json['apiNode'],
        'db': json['db'],
    };
}
exports.NodeHealthDTOFromJSONTyped = NodeHealthDTOFromJSONTyped;
function NodeHealthDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'apiNode': value.apiNode,
        'db': value.db,
    };
}
exports.NodeHealthDTOToJSON = NodeHealthDTOToJSON;

},{}],1099:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeHealthInfoDTOToJSON = exports.NodeHealthInfoDTOFromJSONTyped = exports.NodeHealthInfoDTOFromJSON = void 0;
function NodeHealthInfoDTOFromJSON(json) {
    return NodeHealthInfoDTOFromJSONTyped(json, false);
}
exports.NodeHealthInfoDTOFromJSON = NodeHealthInfoDTOFromJSON;
function NodeHealthInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'status': json['status'],
    };
}
exports.NodeHealthInfoDTOFromJSONTyped = NodeHealthInfoDTOFromJSONTyped;
function NodeHealthInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'status': value.status,
    };
}
exports.NodeHealthInfoDTOToJSON = NodeHealthInfoDTOToJSON;

},{}],1100:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeIdentityEqualityStrategyToJSON = exports.NodeIdentityEqualityStrategyFromJSONTyped = exports.NodeIdentityEqualityStrategyFromJSON = exports.NodeIdentityEqualityStrategy = void 0;
/**
 * Node equality strategy. Defines if the identifier for the node must be its public key or host.
 * @export
 * @enum {string}
 */
var NodeIdentityEqualityStrategy;
(function (NodeIdentityEqualityStrategy) {
    NodeIdentityEqualityStrategy["Host"] = "host";
    NodeIdentityEqualityStrategy["PublicKey"] = "public-key";
})(NodeIdentityEqualityStrategy = exports.NodeIdentityEqualityStrategy || (exports.NodeIdentityEqualityStrategy = {}));
function NodeIdentityEqualityStrategyFromJSON(json) {
    return NodeIdentityEqualityStrategyFromJSONTyped(json, false);
}
exports.NodeIdentityEqualityStrategyFromJSON = NodeIdentityEqualityStrategyFromJSON;
function NodeIdentityEqualityStrategyFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.NodeIdentityEqualityStrategyFromJSONTyped = NodeIdentityEqualityStrategyFromJSONTyped;
function NodeIdentityEqualityStrategyToJSON(value) {
    return value;
}
exports.NodeIdentityEqualityStrategyToJSON = NodeIdentityEqualityStrategyToJSON;

},{}],1101:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeInfoDTOToJSON = exports.NodeInfoDTOFromJSONTyped = exports.NodeInfoDTOFromJSON = void 0;
function NodeInfoDTOFromJSON(json) {
    return NodeInfoDTOFromJSONTyped(json, false);
}
exports.NodeInfoDTOFromJSON = NodeInfoDTOFromJSON;
function NodeInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'version': json['version'],
        'publicKey': json['publicKey'],
        'networkGenerationHashSeed': json['networkGenerationHashSeed'],
        'roles': json['roles'],
        'port': json['port'],
        'networkIdentifier': json['networkIdentifier'],
        'friendlyName': json['friendlyName'],
        'host': json['host'],
    };
}
exports.NodeInfoDTOFromJSONTyped = NodeInfoDTOFromJSONTyped;
function NodeInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'version': value.version,
        'publicKey': value.publicKey,
        'networkGenerationHashSeed': value.networkGenerationHashSeed,
        'roles': value.roles,
        'port': value.port,
        'networkIdentifier': value.networkIdentifier,
        'friendlyName': value.friendlyName,
        'host': value.host,
    };
}
exports.NodeInfoDTOToJSON = NodeInfoDTOToJSON;

},{}],1102:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeKeyLinkNetworkPropertiesDTOToJSON = exports.NodeKeyLinkNetworkPropertiesDTOFromJSONTyped = exports.NodeKeyLinkNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function NodeKeyLinkNetworkPropertiesDTOFromJSON(json) {
    return NodeKeyLinkNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.NodeKeyLinkNetworkPropertiesDTOFromJSON = NodeKeyLinkNetworkPropertiesDTOFromJSON;
function NodeKeyLinkNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'dummy': !runtime_1.exists(json, 'dummy') ? undefined : json['dummy'],
    };
}
exports.NodeKeyLinkNetworkPropertiesDTOFromJSONTyped = NodeKeyLinkNetworkPropertiesDTOFromJSONTyped;
function NodeKeyLinkNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'dummy': value.dummy,
    };
}
exports.NodeKeyLinkNetworkPropertiesDTOToJSON = NodeKeyLinkNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],1103:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeKeyLinkTransactionBodyDTOToJSON = exports.NodeKeyLinkTransactionBodyDTOFromJSONTyped = exports.NodeKeyLinkTransactionBodyDTOFromJSON = void 0;
function NodeKeyLinkTransactionBodyDTOFromJSON(json) {
    return NodeKeyLinkTransactionBodyDTOFromJSONTyped(json, false);
}
exports.NodeKeyLinkTransactionBodyDTOFromJSON = NodeKeyLinkTransactionBodyDTOFromJSON;
function NodeKeyLinkTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'linkedPublicKey': json['linkedPublicKey'],
        'linkAction': json['linkAction'],
    };
}
exports.NodeKeyLinkTransactionBodyDTOFromJSONTyped = NodeKeyLinkTransactionBodyDTOFromJSONTyped;
function NodeKeyLinkTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'linkedPublicKey': value.linkedPublicKey,
        'linkAction': value.linkAction,
    };
}
exports.NodeKeyLinkTransactionBodyDTOToJSON = NodeKeyLinkTransactionBodyDTOToJSON;

},{}],1104:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeKeyLinkTransactionDTOToJSON = exports.NodeKeyLinkTransactionDTOFromJSONTyped = exports.NodeKeyLinkTransactionDTOFromJSON = void 0;
function NodeKeyLinkTransactionDTOFromJSON(json) {
    return NodeKeyLinkTransactionDTOFromJSONTyped(json, false);
}
exports.NodeKeyLinkTransactionDTOFromJSON = NodeKeyLinkTransactionDTOFromJSON;
function NodeKeyLinkTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'linkedPublicKey': json['linkedPublicKey'],
        'linkAction': json['linkAction'],
    };
}
exports.NodeKeyLinkTransactionDTOFromJSONTyped = NodeKeyLinkTransactionDTOFromJSONTyped;
function NodeKeyLinkTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'linkedPublicKey': value.linkedPublicKey,
        'linkAction': value.linkAction,
    };
}
exports.NodeKeyLinkTransactionDTOToJSON = NodeKeyLinkTransactionDTOToJSON;

},{}],1105:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeStatusEnumToJSON = exports.NodeStatusEnumFromJSONTyped = exports.NodeStatusEnumFromJSON = exports.NodeStatusEnum = void 0;
/**
 *
 * @export
 * @enum {string}
 */
var NodeStatusEnum;
(function (NodeStatusEnum) {
    NodeStatusEnum["Up"] = "up";
    NodeStatusEnum["Down"] = "down";
})(NodeStatusEnum = exports.NodeStatusEnum || (exports.NodeStatusEnum = {}));
function NodeStatusEnumFromJSON(json) {
    return NodeStatusEnumFromJSONTyped(json, false);
}
exports.NodeStatusEnumFromJSON = NodeStatusEnumFromJSON;
function NodeStatusEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.NodeStatusEnumFromJSONTyped = NodeStatusEnumFromJSONTyped;
function NodeStatusEnumToJSON(value) {
    return value;
}
exports.NodeStatusEnumToJSON = NodeStatusEnumToJSON;

},{}],1106:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeTimeDTOToJSON = exports.NodeTimeDTOFromJSONTyped = exports.NodeTimeDTOFromJSON = void 0;
function NodeTimeDTOFromJSON(json) {
    return NodeTimeDTOFromJSONTyped(json, false);
}
exports.NodeTimeDTOFromJSON = NodeTimeDTOFromJSON;
function NodeTimeDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'communicationTimestamps': json['communicationTimestamps'],
    };
}
exports.NodeTimeDTOFromJSONTyped = NodeTimeDTOFromJSONTyped;
function NodeTimeDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'communicationTimestamps': value.communicationTimestamps,
    };
}
exports.NodeTimeDTOToJSON = NodeTimeDTOToJSON;

},{}],1107:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderToJSON = exports.OrderFromJSONTyped = exports.OrderFromJSON = exports.Order = void 0;
/**
 * Indicates how to sort the results:
 * * ``asc`` - ascending
 * * ``desc`` - descending
 * @export
 * @enum {string}
 */
var Order;
(function (Order) {
    Order["Asc"] = "asc";
    Order["Desc"] = "desc";
})(Order = exports.Order || (exports.Order = {}));
function OrderFromJSON(json) {
    return OrderFromJSONTyped(json, false);
}
exports.OrderFromJSON = OrderFromJSON;
function OrderFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.OrderFromJSONTyped = OrderFromJSONTyped;
function OrderToJSON(value) {
    return value;
}
exports.OrderToJSON = OrderToJSON;

},{}],1108:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaginationToJSON = exports.PaginationFromJSONTyped = exports.PaginationFromJSON = void 0;
function PaginationFromJSON(json) {
    return PaginationFromJSONTyped(json, false);
}
exports.PaginationFromJSON = PaginationFromJSON;
function PaginationFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'pageNumber': json['pageNumber'],
        'pageSize': json['pageSize'],
        'totalEntries': json['totalEntries'],
        'totalPages': json['totalPages'],
    };
}
exports.PaginationFromJSONTyped = PaginationFromJSONTyped;
function PaginationToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'pageNumber': value.pageNumber,
        'pageSize': value.pageSize,
        'totalEntries': value.totalEntries,
        'totalPages': value.totalPages,
    };
}
exports.PaginationToJSON = PaginationToJSON;

},{}],1109:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginsPropertiesDTOToJSON = exports.PluginsPropertiesDTOFromJSONTyped = exports.PluginsPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function PluginsPropertiesDTOFromJSON(json) {
    return PluginsPropertiesDTOFromJSONTyped(json, false);
}
exports.PluginsPropertiesDTOFromJSON = PluginsPropertiesDTOFromJSON;
function PluginsPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'accountlink': !runtime_1.exists(json, 'accountlink') ? undefined : json['accountlink'],
        'aggregate': !runtime_1.exists(json, 'aggregate') ? undefined : json['aggregate'],
        'lockhash': !runtime_1.exists(json, 'lockhash') ? undefined : json['lockhash'],
        'locksecret': !runtime_1.exists(json, 'locksecret') ? undefined : json['locksecret'],
        'metadata': !runtime_1.exists(json, 'metadata') ? undefined : json['metadata'],
        'mosaic': !runtime_1.exists(json, 'mosaic') ? undefined : json['mosaic'],
        'multisig': !runtime_1.exists(json, 'multisig') ? undefined : json['multisig'],
        'namespace': !runtime_1.exists(json, 'namespace') ? undefined : json['namespace'],
        'restrictionaccount': !runtime_1.exists(json, 'restrictionaccount') ? undefined : json['restrictionaccount'],
        'restrictionmosaic': !runtime_1.exists(json, 'restrictionmosaic') ? undefined : json['restrictionmosaic'],
        'transfer': !runtime_1.exists(json, 'transfer') ? undefined : json['transfer'],
    };
}
exports.PluginsPropertiesDTOFromJSONTyped = PluginsPropertiesDTOFromJSONTyped;
function PluginsPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'accountlink': value.accountlink,
        'aggregate': value.aggregate,
        'lockhash': value.lockhash,
        'locksecret': value.locksecret,
        'metadata': value.metadata,
        'mosaic': value.mosaic,
        'multisig': value.multisig,
        'namespace': value.namespace,
        'restrictionaccount': value.restrictionaccount,
        'restrictionmosaic': value.restrictionmosaic,
        'transfer': value.transfer,
    };
}
exports.PluginsPropertiesDTOToJSON = PluginsPropertiesDTOToJSON;

},{"../runtime":1158}],1110:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PositionEnumToJSON = exports.PositionEnumFromJSONTyped = exports.PositionEnumFromJSON = exports.PositionEnum = void 0;
/**
 * Position relative to the proofHash being evaluated.
 * @export
 * @enum {string}
 */
var PositionEnum;
(function (PositionEnum) {
    PositionEnum["Left"] = "left";
    PositionEnum["Right"] = "right";
})(PositionEnum = exports.PositionEnum || (exports.PositionEnum = {}));
function PositionEnumFromJSON(json) {
    return PositionEnumFromJSONTyped(json, false);
}
exports.PositionEnumFromJSON = PositionEnumFromJSON;
function PositionEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.PositionEnumFromJSONTyped = PositionEnumFromJSONTyped;
function PositionEnumToJSON(value) {
    return value;
}
exports.PositionEnumToJSON = PositionEnumToJSON;

},{}],1111:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReceiptDTOToJSON = exports.ReceiptDTOFromJSONTyped = exports.ReceiptDTOFromJSON = void 0;
function ReceiptDTOFromJSON(json) {
    return ReceiptDTOFromJSONTyped(json, false);
}
exports.ReceiptDTOFromJSON = ReceiptDTOFromJSON;
function ReceiptDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'version': json['version'],
        'type': json['type'],
    };
}
exports.ReceiptDTOFromJSONTyped = ReceiptDTOFromJSONTyped;
function ReceiptDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'version': value.version,
        'type': value.type,
    };
}
exports.ReceiptDTOToJSON = ReceiptDTOToJSON;

},{}],1112:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReceiptTypeEnumToJSON = exports.ReceiptTypeEnumFromJSONTyped = exports.ReceiptTypeEnumFromJSON = exports.ReceiptTypeEnum = void 0;
/**
 * Type of receipt:
 * * 0x124D (4685 decimal) - Mosaic_Rental_Fee.
 * * 0x134E (4942 decimal) - Namespace_Rental_Fee.
 * * 0x2143 (8515 decimal) - Harvest_Fee.
 * * 0x2248 (8776 decimal) - LockHash_Completed.
 * * 0x2348 (9032 decimal) - LockHash_Expired.
 * * 0x2252 (8786 decimal) - LockSecret_Completed.
 * * 0x2352 (9042 decimal) - LockSecret_Expired.
 * * 0x3148 (12616 decimal) - LockHash_Created.
 * * 0x3152 (12626 decimal) - LockSecret_Created.
 * * 0x414D (16717 decimal) - Mosaic_Expired.
 * * 0x414E (16718 decimal) - Namespace_Expired.
 * * 0x424E (16974 decimal) - Namespace_Deleted.
 * * 0x5143 (20803 decimal) - Inflation.
 * * 0xE143 (57667 decimal) - Transaction_Group.
 * * 0xF143 (61763 decimal) - Address_Alias_Resolution.
 * * 0xF243 (62019 decimal) - Mosaic_Alias_Resolution.
 * @export
 * @enum {string}
 */
var ReceiptTypeEnum;
(function (ReceiptTypeEnum) {
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_4685"] = 4685] = "NUMBER_4685";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_4942"] = 4942] = "NUMBER_4942";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_8515"] = 8515] = "NUMBER_8515";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_8776"] = 8776] = "NUMBER_8776";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_9032"] = 9032] = "NUMBER_9032";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_8786"] = 8786] = "NUMBER_8786";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_9042"] = 9042] = "NUMBER_9042";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_12616"] = 12616] = "NUMBER_12616";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_12626"] = 12626] = "NUMBER_12626";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_16717"] = 16717] = "NUMBER_16717";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_16718"] = 16718] = "NUMBER_16718";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_16974"] = 16974] = "NUMBER_16974";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_20803"] = 20803] = "NUMBER_20803";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_57667"] = 57667] = "NUMBER_57667";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_61763"] = 61763] = "NUMBER_61763";
    ReceiptTypeEnum[ReceiptTypeEnum["NUMBER_62019"] = 62019] = "NUMBER_62019";
})(ReceiptTypeEnum = exports.ReceiptTypeEnum || (exports.ReceiptTypeEnum = {}));
function ReceiptTypeEnumFromJSON(json) {
    return ReceiptTypeEnumFromJSONTyped(json, false);
}
exports.ReceiptTypeEnumFromJSON = ReceiptTypeEnumFromJSON;
function ReceiptTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.ReceiptTypeEnumFromJSONTyped = ReceiptTypeEnumFromJSONTyped;
function ReceiptTypeEnumToJSON(value) {
    return value;
}
exports.ReceiptTypeEnumToJSON = ReceiptTypeEnumToJSON;

},{}],1113:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RentalFeesDTOToJSON = exports.RentalFeesDTOFromJSONTyped = exports.RentalFeesDTOFromJSON = void 0;
function RentalFeesDTOFromJSON(json) {
    return RentalFeesDTOFromJSONTyped(json, false);
}
exports.RentalFeesDTOFromJSON = RentalFeesDTOFromJSON;
function RentalFeesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'effectiveRootNamespaceRentalFeePerBlock': json['effectiveRootNamespaceRentalFeePerBlock'],
        'effectiveChildNamespaceRentalFee': json['effectiveChildNamespaceRentalFee'],
        'effectiveMosaicRentalFee': json['effectiveMosaicRentalFee'],
    };
}
exports.RentalFeesDTOFromJSONTyped = RentalFeesDTOFromJSONTyped;
function RentalFeesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'effectiveRootNamespaceRentalFeePerBlock': value.effectiveRootNamespaceRentalFeePerBlock,
        'effectiveChildNamespaceRentalFee': value.effectiveChildNamespaceRentalFee,
        'effectiveMosaicRentalFee': value.effectiveMosaicRentalFee,
    };
}
exports.RentalFeesDTOToJSON = RentalFeesDTOToJSON;

},{}],1114:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResolutionEntryDTOToJSON = exports.ResolutionEntryDTOFromJSONTyped = exports.ResolutionEntryDTOFromJSON = void 0;
function ResolutionEntryDTOFromJSON(json) {
    return ResolutionEntryDTOFromJSONTyped(json, false);
}
exports.ResolutionEntryDTOFromJSON = ResolutionEntryDTOFromJSON;
function ResolutionEntryDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'source': json['source'],
        'resolved': json['resolved'],
    };
}
exports.ResolutionEntryDTOFromJSONTyped = ResolutionEntryDTOFromJSONTyped;
function ResolutionEntryDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'source': value.source,
        'resolved': value.resolved,
    };
}
exports.ResolutionEntryDTOToJSON = ResolutionEntryDTOToJSON;

},{}],1115:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResolutionStatementDTOToJSON = exports.ResolutionStatementDTOFromJSONTyped = exports.ResolutionStatementDTOFromJSON = void 0;
function ResolutionStatementDTOFromJSON(json) {
    return ResolutionStatementDTOFromJSONTyped(json, false);
}
exports.ResolutionStatementDTOFromJSON = ResolutionStatementDTOFromJSON;
function ResolutionStatementDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'height': json['height'],
        'unresolved': json['unresolved'],
        'resolutionEntries': json['resolutionEntries'],
    };
}
exports.ResolutionStatementDTOFromJSONTyped = ResolutionStatementDTOFromJSONTyped;
function ResolutionStatementDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'height': value.height,
        'unresolved': value.unresolved,
        'resolutionEntries': value.resolutionEntries,
    };
}
exports.ResolutionStatementDTOToJSON = ResolutionStatementDTOToJSON;

},{}],1116:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResolutionStatementInfoDTOToJSON = exports.ResolutionStatementInfoDTOFromJSONTyped = exports.ResolutionStatementInfoDTOFromJSON = void 0;
function ResolutionStatementInfoDTOFromJSON(json) {
    return ResolutionStatementInfoDTOFromJSONTyped(json, false);
}
exports.ResolutionStatementInfoDTOFromJSON = ResolutionStatementInfoDTOFromJSON;
function ResolutionStatementInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'statement': json['statement'],
    };
}
exports.ResolutionStatementInfoDTOFromJSONTyped = ResolutionStatementInfoDTOFromJSONTyped;
function ResolutionStatementInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'statement': value.statement,
    };
}
exports.ResolutionStatementInfoDTOToJSON = ResolutionStatementInfoDTOToJSON;

},{}],1117:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResolutionStatementPageToJSON = exports.ResolutionStatementPageFromJSONTyped = exports.ResolutionStatementPageFromJSON = void 0;
function ResolutionStatementPageFromJSON(json) {
    return ResolutionStatementPageFromJSONTyped(json, false);
}
exports.ResolutionStatementPageFromJSON = ResolutionStatementPageFromJSON;
function ResolutionStatementPageFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'data': json['data'],
        'pagination': json['pagination'],
    };
}
exports.ResolutionStatementPageFromJSONTyped = ResolutionStatementPageFromJSONTyped;
function ResolutionStatementPageToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'data': value.data,
        'pagination': value.pagination,
    };
}
exports.ResolutionStatementPageToJSON = ResolutionStatementPageToJSON;

},{}],1118:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RolesTypeEnumToJSON = exports.RolesTypeEnumFromJSONTyped = exports.RolesTypeEnumFromJSON = exports.RolesTypeEnum = void 0;
/**
 * Role of the node:
 * * 1 - Peer node.
 * * 2 - Api node.
 * * 3 - Dual node.
 * @export
 * @enum {string}
 */
var RolesTypeEnum;
(function (RolesTypeEnum) {
    RolesTypeEnum[RolesTypeEnum["NUMBER_1"] = 1] = "NUMBER_1";
    RolesTypeEnum[RolesTypeEnum["NUMBER_2"] = 2] = "NUMBER_2";
    RolesTypeEnum[RolesTypeEnum["NUMBER_3"] = 3] = "NUMBER_3";
})(RolesTypeEnum = exports.RolesTypeEnum || (exports.RolesTypeEnum = {}));
function RolesTypeEnumFromJSON(json) {
    return RolesTypeEnumFromJSONTyped(json, false);
}
exports.RolesTypeEnumFromJSON = RolesTypeEnumFromJSON;
function RolesTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.RolesTypeEnumFromJSONTyped = RolesTypeEnumFromJSONTyped;
function RolesTypeEnumToJSON(value) {
    return value;
}
exports.RolesTypeEnumToJSON = RolesTypeEnumToJSON;

},{}],1119:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretLockNetworkPropertiesDTOToJSON = exports.SecretLockNetworkPropertiesDTOFromJSONTyped = exports.SecretLockNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function SecretLockNetworkPropertiesDTOFromJSON(json) {
    return SecretLockNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.SecretLockNetworkPropertiesDTOFromJSON = SecretLockNetworkPropertiesDTOFromJSON;
function SecretLockNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'maxSecretLockDuration': !runtime_1.exists(json, 'maxSecretLockDuration') ? undefined : json['maxSecretLockDuration'],
        'minProofSize': !runtime_1.exists(json, 'minProofSize') ? undefined : json['minProofSize'],
        'maxProofSize': !runtime_1.exists(json, 'maxProofSize') ? undefined : json['maxProofSize'],
    };
}
exports.SecretLockNetworkPropertiesDTOFromJSONTyped = SecretLockNetworkPropertiesDTOFromJSONTyped;
function SecretLockNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'maxSecretLockDuration': value.maxSecretLockDuration,
        'minProofSize': value.minProofSize,
        'maxProofSize': value.maxProofSize,
    };
}
exports.SecretLockNetworkPropertiesDTOToJSON = SecretLockNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],1120:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretLockTransactionBodyDTOToJSON = exports.SecretLockTransactionBodyDTOFromJSONTyped = exports.SecretLockTransactionBodyDTOFromJSON = void 0;
function SecretLockTransactionBodyDTOFromJSON(json) {
    return SecretLockTransactionBodyDTOFromJSONTyped(json, false);
}
exports.SecretLockTransactionBodyDTOFromJSON = SecretLockTransactionBodyDTOFromJSON;
function SecretLockTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'recipientAddress': json['recipientAddress'],
        'secret': json['secret'],
        'mosaicId': json['mosaicId'],
        'amount': json['amount'],
        'duration': json['duration'],
        'hashAlgorithm': json['hashAlgorithm'],
    };
}
exports.SecretLockTransactionBodyDTOFromJSONTyped = SecretLockTransactionBodyDTOFromJSONTyped;
function SecretLockTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'recipientAddress': value.recipientAddress,
        'secret': value.secret,
        'mosaicId': value.mosaicId,
        'amount': value.amount,
        'duration': value.duration,
        'hashAlgorithm': value.hashAlgorithm,
    };
}
exports.SecretLockTransactionBodyDTOToJSON = SecretLockTransactionBodyDTOToJSON;

},{}],1121:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretLockTransactionDTOToJSON = exports.SecretLockTransactionDTOFromJSONTyped = exports.SecretLockTransactionDTOFromJSON = void 0;
function SecretLockTransactionDTOFromJSON(json) {
    return SecretLockTransactionDTOFromJSONTyped(json, false);
}
exports.SecretLockTransactionDTOFromJSON = SecretLockTransactionDTOFromJSON;
function SecretLockTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'recipientAddress': json['recipientAddress'],
        'secret': json['secret'],
        'mosaicId': json['mosaicId'],
        'amount': json['amount'],
        'duration': json['duration'],
        'hashAlgorithm': json['hashAlgorithm'],
    };
}
exports.SecretLockTransactionDTOFromJSONTyped = SecretLockTransactionDTOFromJSONTyped;
function SecretLockTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'recipientAddress': value.recipientAddress,
        'secret': value.secret,
        'mosaicId': value.mosaicId,
        'amount': value.amount,
        'duration': value.duration,
        'hashAlgorithm': value.hashAlgorithm,
    };
}
exports.SecretLockTransactionDTOToJSON = SecretLockTransactionDTOToJSON;

},{}],1122:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretProofTransactionBodyDTOToJSON = exports.SecretProofTransactionBodyDTOFromJSONTyped = exports.SecretProofTransactionBodyDTOFromJSON = void 0;
function SecretProofTransactionBodyDTOFromJSON(json) {
    return SecretProofTransactionBodyDTOFromJSONTyped(json, false);
}
exports.SecretProofTransactionBodyDTOFromJSON = SecretProofTransactionBodyDTOFromJSON;
function SecretProofTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'recipientAddress': json['recipientAddress'],
        'secret': json['secret'],
        'hashAlgorithm': json['hashAlgorithm'],
        'proof': json['proof'],
    };
}
exports.SecretProofTransactionBodyDTOFromJSONTyped = SecretProofTransactionBodyDTOFromJSONTyped;
function SecretProofTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'recipientAddress': value.recipientAddress,
        'secret': value.secret,
        'hashAlgorithm': value.hashAlgorithm,
        'proof': value.proof,
    };
}
exports.SecretProofTransactionBodyDTOToJSON = SecretProofTransactionBodyDTOToJSON;

},{}],1123:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretProofTransactionDTOToJSON = exports.SecretProofTransactionDTOFromJSONTyped = exports.SecretProofTransactionDTOFromJSON = void 0;
function SecretProofTransactionDTOFromJSON(json) {
    return SecretProofTransactionDTOFromJSONTyped(json, false);
}
exports.SecretProofTransactionDTOFromJSON = SecretProofTransactionDTOFromJSON;
function SecretProofTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'recipientAddress': json['recipientAddress'],
        'secret': json['secret'],
        'hashAlgorithm': json['hashAlgorithm'],
        'proof': json['proof'],
    };
}
exports.SecretProofTransactionDTOFromJSONTyped = SecretProofTransactionDTOFromJSONTyped;
function SecretProofTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'recipientAddress': value.recipientAddress,
        'secret': value.secret,
        'hashAlgorithm': value.hashAlgorithm,
        'proof': value.proof,
    };
}
exports.SecretProofTransactionDTOToJSON = SecretProofTransactionDTOToJSON;

},{}],1124:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerDTOToJSON = exports.ServerDTOFromJSONTyped = exports.ServerDTOFromJSON = void 0;
function ServerDTOFromJSON(json) {
    return ServerDTOFromJSONTyped(json, false);
}
exports.ServerDTOFromJSON = ServerDTOFromJSON;
function ServerDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'restVersion': json['restVersion'],
        'sdkVersion': json['sdkVersion'],
    };
}
exports.ServerDTOFromJSONTyped = ServerDTOFromJSONTyped;
function ServerDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'restVersion': value.restVersion,
        'sdkVersion': value.sdkVersion,
    };
}
exports.ServerDTOToJSON = ServerDTOToJSON;

},{}],1125:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerInfoDTOToJSON = exports.ServerInfoDTOFromJSONTyped = exports.ServerInfoDTOFromJSON = void 0;
function ServerInfoDTOFromJSON(json) {
    return ServerInfoDTOFromJSONTyped(json, false);
}
exports.ServerInfoDTOFromJSON = ServerInfoDTOFromJSON;
function ServerInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'serverInfo': json['serverInfo'],
    };
}
exports.ServerInfoDTOFromJSONTyped = ServerInfoDTOFromJSONTyped;
function ServerInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'serverInfo': value.serverInfo,
    };
}
exports.ServerInfoDTOToJSON = ServerInfoDTOToJSON;

},{}],1126:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SizePrefixedEntityDTOToJSON = exports.SizePrefixedEntityDTOFromJSONTyped = exports.SizePrefixedEntityDTOFromJSON = void 0;
function SizePrefixedEntityDTOFromJSON(json) {
    return SizePrefixedEntityDTOFromJSONTyped(json, false);
}
exports.SizePrefixedEntityDTOFromJSON = SizePrefixedEntityDTOFromJSON;
function SizePrefixedEntityDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
    };
}
exports.SizePrefixedEntityDTOFromJSONTyped = SizePrefixedEntityDTOFromJSONTyped;
function SizePrefixedEntityDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
    };
}
exports.SizePrefixedEntityDTOToJSON = SizePrefixedEntityDTOToJSON;

},{}],1127:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceDTOToJSON = exports.SourceDTOFromJSONTyped = exports.SourceDTOFromJSON = void 0;
function SourceDTOFromJSON(json) {
    return SourceDTOFromJSONTyped(json, false);
}
exports.SourceDTOFromJSON = SourceDTOFromJSON;
function SourceDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'primaryId': json['primaryId'],
        'secondaryId': json['secondaryId'],
    };
}
exports.SourceDTOFromJSONTyped = SourceDTOFromJSONTyped;
function SourceDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'primaryId': value.primaryId,
        'secondaryId': value.secondaryId,
    };
}
exports.SourceDTOToJSON = SourceDTOToJSON;

},{}],1128:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageInfoDTOToJSON = exports.StorageInfoDTOFromJSONTyped = exports.StorageInfoDTOFromJSON = void 0;
function StorageInfoDTOFromJSON(json) {
    return StorageInfoDTOFromJSONTyped(json, false);
}
exports.StorageInfoDTOFromJSON = StorageInfoDTOFromJSON;
function StorageInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'numBlocks': json['numBlocks'],
        'numTransactions': json['numTransactions'],
        'numAccounts': json['numAccounts'],
    };
}
exports.StorageInfoDTOFromJSONTyped = StorageInfoDTOFromJSONTyped;
function StorageInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'numBlocks': value.numBlocks,
        'numTransactions': value.numTransactions,
        'numAccounts': value.numAccounts,
    };
}
exports.StorageInfoDTOToJSON = StorageInfoDTOToJSON;

},{}],1129:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SupplementalPublicKeysDTOToJSON = exports.SupplementalPublicKeysDTOFromJSONTyped = exports.SupplementalPublicKeysDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function SupplementalPublicKeysDTOFromJSON(json) {
    return SupplementalPublicKeysDTOFromJSONTyped(json, false);
}
exports.SupplementalPublicKeysDTOFromJSON = SupplementalPublicKeysDTOFromJSON;
function SupplementalPublicKeysDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'linked': !runtime_1.exists(json, 'linked') ? undefined : json['linked'],
        'node': !runtime_1.exists(json, 'node') ? undefined : json['node'],
        'vrf': !runtime_1.exists(json, 'vrf') ? undefined : json['vrf'],
        'voting': !runtime_1.exists(json, 'voting') ? undefined : json['voting'],
    };
}
exports.SupplementalPublicKeysDTOFromJSONTyped = SupplementalPublicKeysDTOFromJSONTyped;
function SupplementalPublicKeysDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'linked': value.linked,
        'node': value.node,
        'vrf': value.vrf,
        'voting': value.voting,
    };
}
exports.SupplementalPublicKeysDTOToJSON = SupplementalPublicKeysDTOToJSON;

},{"../runtime":1158}],1130:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBodyDTOToJSON = exports.TransactionBodyDTOFromJSONTyped = exports.TransactionBodyDTOFromJSON = void 0;
function TransactionBodyDTOFromJSON(json) {
    return TransactionBodyDTOFromJSONTyped(json, false);
}
exports.TransactionBodyDTOFromJSON = TransactionBodyDTOFromJSON;
function TransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
    };
}
exports.TransactionBodyDTOFromJSONTyped = TransactionBodyDTOFromJSONTyped;
function TransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'maxFee': value.maxFee,
        'deadline': value.deadline,
    };
}
exports.TransactionBodyDTOToJSON = TransactionBodyDTOToJSON;

},{}],1131:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionDTOToJSON = exports.TransactionDTOFromJSONTyped = exports.TransactionDTOFromJSON = void 0;
function TransactionDTOFromJSON(json) {
    return TransactionDTOFromJSONTyped(json, false);
}
exports.TransactionDTOFromJSON = TransactionDTOFromJSON;
function TransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
    };
}
exports.TransactionDTOFromJSONTyped = TransactionDTOFromJSONTyped;
function TransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
    };
}
exports.TransactionDTOToJSON = TransactionDTOToJSON;

},{}],1132:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionFeesDTOToJSON = exports.TransactionFeesDTOFromJSONTyped = exports.TransactionFeesDTOFromJSON = void 0;
function TransactionFeesDTOFromJSON(json) {
    return TransactionFeesDTOFromJSONTyped(json, false);
}
exports.TransactionFeesDTOFromJSON = TransactionFeesDTOFromJSON;
function TransactionFeesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'averageFeeMultiplier': json['averageFeeMultiplier'],
        'medianFeeMultiplier': json['medianFeeMultiplier'],
        'highestFeeMultiplier': json['highestFeeMultiplier'],
        'lowestFeeMultiplier': json['lowestFeeMultiplier'],
    };
}
exports.TransactionFeesDTOFromJSONTyped = TransactionFeesDTOFromJSONTyped;
function TransactionFeesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'averageFeeMultiplier': value.averageFeeMultiplier,
        'medianFeeMultiplier': value.medianFeeMultiplier,
        'highestFeeMultiplier': value.highestFeeMultiplier,
        'lowestFeeMultiplier': value.lowestFeeMultiplier,
    };
}
exports.TransactionFeesDTOToJSON = TransactionFeesDTOToJSON;

},{}],1133:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionGroupEnumToJSON = exports.TransactionGroupEnumFromJSONTyped = exports.TransactionGroupEnumFromJSON = exports.TransactionGroupEnum = void 0;
/**
 * A transaction could be classified in the following groups:
 * * Unconfirmed: The transaction reached the P2P network. At this point, it is not guaranteed that the transaction will be included in a block.
 * * Confirmed: The transaction is included in a block.
 * * Partial: The transaction requires to be cosigned by other transaction participants in order to be included in a block.
 * * Failed: The transaction did not pass the network validation, and it was rejected.
 * @export
 * @enum {string}
 */
var TransactionGroupEnum;
(function (TransactionGroupEnum) {
    TransactionGroupEnum["Unconfirmed"] = "unconfirmed";
    TransactionGroupEnum["Confirmed"] = "confirmed";
    TransactionGroupEnum["Failed"] = "failed";
    TransactionGroupEnum["Partial"] = "partial";
})(TransactionGroupEnum = exports.TransactionGroupEnum || (exports.TransactionGroupEnum = {}));
function TransactionGroupEnumFromJSON(json) {
    return TransactionGroupEnumFromJSONTyped(json, false);
}
exports.TransactionGroupEnumFromJSON = TransactionGroupEnumFromJSON;
function TransactionGroupEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.TransactionGroupEnumFromJSONTyped = TransactionGroupEnumFromJSONTyped;
function TransactionGroupEnumToJSON(value) {
    return value;
}
exports.TransactionGroupEnumToJSON = TransactionGroupEnumToJSON;

},{}],1134:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionHashesToJSON = exports.TransactionHashesFromJSONTyped = exports.TransactionHashesFromJSON = void 0;
const runtime_1 = require("../runtime");
function TransactionHashesFromJSON(json) {
    return TransactionHashesFromJSONTyped(json, false);
}
exports.TransactionHashesFromJSON = TransactionHashesFromJSON;
function TransactionHashesFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'hashes': !runtime_1.exists(json, 'hashes') ? undefined : json['hashes'],
    };
}
exports.TransactionHashesFromJSONTyped = TransactionHashesFromJSONTyped;
function TransactionHashesToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'hashes': value.hashes,
    };
}
exports.TransactionHashesToJSON = TransactionHashesToJSON;

},{"../runtime":1158}],1135:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionIdsToJSON = exports.TransactionIdsFromJSONTyped = exports.TransactionIdsFromJSON = void 0;
const runtime_1 = require("../runtime");
function TransactionIdsFromJSON(json) {
    return TransactionIdsFromJSONTyped(json, false);
}
exports.TransactionIdsFromJSON = TransactionIdsFromJSON;
function TransactionIdsFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'transactionIds': !runtime_1.exists(json, 'transactionIds') ? undefined : json['transactionIds'],
    };
}
exports.TransactionIdsFromJSONTyped = TransactionIdsFromJSONTyped;
function TransactionIdsToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'transactionIds': value.transactionIds,
    };
}
exports.TransactionIdsToJSON = TransactionIdsToJSON;

},{"../runtime":1158}],1136:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionInfoDTOToJSON = exports.TransactionInfoDTOFromJSONTyped = exports.TransactionInfoDTOFromJSON = void 0;
function TransactionInfoDTOFromJSON(json) {
    return TransactionInfoDTOFromJSONTyped(json, false);
}
exports.TransactionInfoDTOFromJSON = TransactionInfoDTOFromJSON;
function TransactionInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'meta': json['meta'],
        'transaction': json['transaction'],
    };
}
exports.TransactionInfoDTOFromJSONTyped = TransactionInfoDTOFromJSONTyped;
function TransactionInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'meta': value.meta,
        'transaction': value.transaction,
    };
}
exports.TransactionInfoDTOToJSON = TransactionInfoDTOToJSON;

},{}],1137:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionMetaDTOToJSON = exports.TransactionMetaDTOFromJSONTyped = exports.TransactionMetaDTOFromJSON = void 0;
function TransactionMetaDTOFromJSON(json) {
    return TransactionMetaDTOFromJSONTyped(json, false);
}
exports.TransactionMetaDTOFromJSON = TransactionMetaDTOFromJSON;
function TransactionMetaDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'height': json['height'],
        'hash': json['hash'],
        'merkleComponentHash': json['merkleComponentHash'],
        'index': json['index'],
    };
}
exports.TransactionMetaDTOFromJSONTyped = TransactionMetaDTOFromJSONTyped;
function TransactionMetaDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'height': value.height,
        'hash': value.hash,
        'merkleComponentHash': value.merkleComponentHash,
        'index': value.index,
    };
}
exports.TransactionMetaDTOToJSON = TransactionMetaDTOToJSON;

},{}],1138:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionPageToJSON = exports.TransactionPageFromJSONTyped = exports.TransactionPageFromJSON = void 0;
function TransactionPageFromJSON(json) {
    return TransactionPageFromJSONTyped(json, false);
}
exports.TransactionPageFromJSON = TransactionPageFromJSON;
function TransactionPageFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'data': json['data'],
        'pagination': json['pagination'],
    };
}
exports.TransactionPageFromJSONTyped = TransactionPageFromJSONTyped;
function TransactionPageToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'data': value.data,
        'pagination': value.pagination,
    };
}
exports.TransactionPageToJSON = TransactionPageToJSON;

},{}],1139:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionPayloadToJSON = exports.TransactionPayloadFromJSONTyped = exports.TransactionPayloadFromJSON = void 0;
const runtime_1 = require("../runtime");
function TransactionPayloadFromJSON(json) {
    return TransactionPayloadFromJSONTyped(json, false);
}
exports.TransactionPayloadFromJSON = TransactionPayloadFromJSON;
function TransactionPayloadFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'payload': !runtime_1.exists(json, 'payload') ? undefined : json['payload'],
    };
}
exports.TransactionPayloadFromJSONTyped = TransactionPayloadFromJSONTyped;
function TransactionPayloadToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'payload': value.payload,
    };
}
exports.TransactionPayloadToJSON = TransactionPayloadToJSON;

},{"../runtime":1158}],1140:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionStatementDTOToJSON = exports.TransactionStatementDTOFromJSONTyped = exports.TransactionStatementDTOFromJSON = void 0;
function TransactionStatementDTOFromJSON(json) {
    return TransactionStatementDTOFromJSONTyped(json, false);
}
exports.TransactionStatementDTOFromJSON = TransactionStatementDTOFromJSON;
function TransactionStatementDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'height': json['height'],
        'source': json['source'],
        'receipts': json['receipts'],
    };
}
exports.TransactionStatementDTOFromJSONTyped = TransactionStatementDTOFromJSONTyped;
function TransactionStatementDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'height': value.height,
        'source': value.source,
        'receipts': value.receipts,
    };
}
exports.TransactionStatementDTOToJSON = TransactionStatementDTOToJSON;

},{}],1141:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionStatementInfoDTOToJSON = exports.TransactionStatementInfoDTOFromJSONTyped = exports.TransactionStatementInfoDTOFromJSON = void 0;
function TransactionStatementInfoDTOFromJSON(json) {
    return TransactionStatementInfoDTOFromJSONTyped(json, false);
}
exports.TransactionStatementInfoDTOFromJSON = TransactionStatementInfoDTOFromJSON;
function TransactionStatementInfoDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'statement': json['statement'],
    };
}
exports.TransactionStatementInfoDTOFromJSONTyped = TransactionStatementInfoDTOFromJSONTyped;
function TransactionStatementInfoDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'statement': value.statement,
    };
}
exports.TransactionStatementInfoDTOToJSON = TransactionStatementInfoDTOToJSON;

},{}],1142:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionStatementPageToJSON = exports.TransactionStatementPageFromJSONTyped = exports.TransactionStatementPageFromJSON = void 0;
function TransactionStatementPageFromJSON(json) {
    return TransactionStatementPageFromJSONTyped(json, false);
}
exports.TransactionStatementPageFromJSON = TransactionStatementPageFromJSON;
function TransactionStatementPageFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'data': json['data'],
        'pagination': json['pagination'],
    };
}
exports.TransactionStatementPageFromJSONTyped = TransactionStatementPageFromJSONTyped;
function TransactionStatementPageToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'data': value.data,
        'pagination': value.pagination,
    };
}
exports.TransactionStatementPageToJSON = TransactionStatementPageToJSON;

},{}],1143:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionStatusDTOToJSON = exports.TransactionStatusDTOFromJSONTyped = exports.TransactionStatusDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function TransactionStatusDTOFromJSON(json) {
    return TransactionStatusDTOFromJSONTyped(json, false);
}
exports.TransactionStatusDTOFromJSON = TransactionStatusDTOFromJSON;
function TransactionStatusDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'group': json['group'],
        'code': !runtime_1.exists(json, 'code') ? undefined : json['code'],
        'hash': json['hash'],
        'deadline': json['deadline'],
        'height': !runtime_1.exists(json, 'height') ? undefined : json['height'],
    };
}
exports.TransactionStatusDTOFromJSONTyped = TransactionStatusDTOFromJSONTyped;
function TransactionStatusDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'group': value.group,
        'code': value.code,
        'hash': value.hash,
        'deadline': value.deadline,
        'height': value.height,
    };
}
exports.TransactionStatusDTOToJSON = TransactionStatusDTOToJSON;

},{"../runtime":1158}],1144:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionStatusEnumToJSON = exports.TransactionStatusEnumFromJSONTyped = exports.TransactionStatusEnumFromJSON = exports.TransactionStatusEnum = void 0;
/**
 * List of status errors that can be returned via the status channel after announcing a transaction:
 * * Success
 * * Neutral
 * * Failure
 * * Failure_Core_Past_Deadline - Validation failed because the deadline passed.
 * * Failure_Core_Future_Deadline - Validation failed because the deadline is too far in the future.
 * * Failure_Core_Insufficient_Balance - Validation failed because the account has an insufficient balance.
 * * Failure_Core_Too_Many_Transactions - Validation failed because there are too many transactions in a block.
 * * Failure_Core_Nemesis_Account_Signed_After_Nemesis_Block - Validation failed because an entity originated from the nemesis account after the nemesis block.
 * * Failure_Core_Wrong_Network - Validation failed because the entity has the wrong network specified.
 * * Failure_Core_Invalid_Address - Validation failed because an address is invalid.
 * * Failure_Core_Invalid_Version - Validation failed because entity version is invalid.
 * * Failure_Core_Invalid_Transaction_Fee - Validation failed because a transaction fee is invalid.
 * * Failure_Core_Block_Harvester_Ineligible - Validation failed because a block was harvested by an ineligible harvester.
 * * Failure_Core_Zero_Address - Validation failed because an address is zero.
 * * Failure_Core_Zero_Public_Key - Validation failed because a public key is zero.
 * * Failure_Core_Nonzero_Internal_Padding - Validation failed because internal padding is nonzero.
 * * Failure_Core_Address_Collision - Validation failed because an address collision is detected.
 * * Failure_Core_Invalid_Link_Action - Validation failed because link action is invalid.
 * * Failure_Core_Link_Already_Exists - Validation failed because main account is already linked to another account.
 * * Failure_Core_Inconsistent_Unlink_Data - Validation failed because unlink data is not consistent with existing account link.
 * * Failure_Core_Invalid_Link_Range - Validation failed because link range is invalid.
 * * Failure_Core_Too_Many_Links - Validation failed because main account has too many links of the specified type.
 * * Failure_Hash_Already_Exists
 * * Failure_Signature_Not_Verifiable - Validation failed because the verification of the signature failed.
 * * Failure_AccountLink_Link_Already_Exists - Validation failed because main account is already linked to another account.
 * * Failure_AccountLink_Inconsistent_Unlink_Data - Validation failed because unlink data is not consistent with existing account link.
 * * Failure_AccountLink_Unknown_Link - Validation failed because main account is not linked to another account.
 * * Failure_AccountLink_Remote_Account_Ineligible - Validation failed because link is attempting to convert ineligible account to remote.
 * * Failure_AccountLink_Remote_Account_Signer_Prohibited - Validation failed because remote is not allowed to sign a transaction.
 * * Failure_AccountLink_Remote_Account_Participant_Prohibited - Validation failed because remote is not allowed to participate in the transaction.
 * * Failure_Aggregate_Too_Many_Transactions - Validation failed because aggregate has too many transactions.
 * * Failure_Aggregate_No_Transactions - Validation failed because aggregate does not have any transactions.
 * * Failure_Aggregate_Too_Many_Cosignatures - Validation failed because aggregate has too many cosignatures.
 * * Failure_Aggregate_Redundant_Cosignatures - Validation failed because redundant cosignatures are present.
 * * Failure_Aggregate_Ineligible_Cosignatories - Validation failed because at least one cosignatory is ineligible.
 * * Failure_Aggregate_Missing_Cosignatures - Validation failed because at least one required cosignature is missing.
 * * Failure_Aggregate_Transactions_Hash_Mismatch - Validation failed because the aggregate transactions hash does not match the calculated value.
 * * Failure_LockHash_Invalid_Mosaic_Id - Validation failed because lock does not allow the specified mosaic.
 * * Failure_LockHash_Invalid_Mosaic_Amount - Validation failed because lock does not allow the specified amount.
 * * Failure_LockHash_Hash_Already_Exists - Validation failed because hash is already present in cache.
 * * Failure_LockHash_Unknown_Hash - Validation failed because hash is not present in cache.
 * * Failure_LockHash_Inactive_Hash - Validation failed because hash is inactive.
 * * Failure_LockHash_Invalid_Duration - Validation failed because duration is too long.
 * * Failure_LockSecret_Invalid_Hash_Algorithm - Validation failed because hash algorithm for lock type secret is invalid.
 * * Failure_LockSecret_Hash_Already_Exists - Validation failed because hash is already present in cache.
 * * Failure_LockSecret_Proof_Size_Out_Of_Bounds - Validation failed because proof is too small or too large.
 * * Failure_LockSecret_Secret_Mismatch - Validation failed because secret does not match proof.
 * * Failure_LockSecret_Unknown_Composite_Key - Validation failed because composite key is unknown.
 * * Failure_LockSecret_Inactive_Secret - Validation failed because secret is inactive.
 * * Failure_LockSecret_Hash_Algorithm_Mismatch - Validation failed because hash algorithm does not match.
 * * Failure_LockSecret_Invalid_Duration - Validation failed because duration is too long.
 * * Failure_Metadata_Value_Too_Small - Validation failed because the metadata value is too small.
 * * Failure_Metadata_Value_Too_Large - Validation failed because the metadata value is too large.
 * * Failure_Metadata_Value_Size_Delta_Too_Large - Validation failed because the metadata value size delta is larger in magnitude than the value size.
 * * Failure_Metadata_Value_Size_Delta_Mismatch - Validation failed because the metadata value size delta does not match expected value based on the current state.
 * * Failure_Metadata_Value_Change_Irreversible - Validation failed because a metadata value change (truncation) is irreversible.
 * * Failure_Mosaic_Invalid_Duration - Validation failed because the duration has an invalid value.
 * * Failure_Mosaic_Invalid_Name - Validation failed because the name is invalid.
 * * Failure_Mosaic_Name_Id_Mismatch - Validation failed because the name and id don't match.
 * * Failure_Mosaic_Expired - Validation failed because the parent is expired.
 * * Failure_Mosaic_Owner_Conflict - Validation failed because the parent owner conflicts with the child owner.
 * * Failure_Mosaic_Id_Mismatch - Validation failed because the id is not the expected id generated from signer and nonce.
 * * Failure_Mosaic_Parent_Id_Conflict - Validation failed because the existing parent id does not match the supplied parent id.
 * * Failure_Mosaic_Invalid_Property - Validation failed because a mosaic property is invalid.
 * * Failure_Mosaic_Invalid_Flags - Validation failed because the mosaic flags are invalid.
 * * Failure_Mosaic_Invalid_Divisibility - Validation failed because the mosaic divisibility is invalid.
 * * Failure_Mosaic_Invalid_Supply_Change_Action - Validation failed because the mosaic supply change action is invalid.
 * * Failure_Mosaic_Invalid_Supply_Change_Amount - Validation failed because the mosaic supply change amount is invalid.
 * * Failure_Mosaic_Invalid_Id - Validation failed because the mosaic id is invalid.
 * * Failure_Mosaic_Modification_Disallowed - Validation failed because mosaic modification is not allowed.
 * * Failure_Mosaic_Modification_No_Changes - Validation failed because mosaic modification would not result in any changes.
 * * Failure_Mosaic_Supply_Immutable - Validation failed because the mosaic supply is immutable.
 * * Failure_Mosaic_Supply_Negative - Validation failed because the resulting mosaic supply is negative.
 * * Failure_Mosaic_Supply_Exceeded - Validation failed because the resulting mosaic supply exceeds the maximum allowed value.
 * * Failure_Mosaic_Non_Transferable - Validation failed because the mosaic is not transferable.
 * * Failure_Mosaic_Max_Mosaics_Exceeded - Validation failed because the credit of the mosaic would exceed the maximum of different mosaics an account is allowed to own.
 * * Failure_Mosaic_Required_Property_Flag_Unset - Validation failed because the mosaic has at least one required property flag unset.
 * * Failure_Multisig_Account_In_Both_Sets - Validation failed because account is specified to be both added and removed.
 * * Failure_Multisig_Multiple_Deletes - Validation failed because multiple removals are present.
 * * Failure_Multisig_Redundant_Modification - Validation failed because a modification is redundant.
 * * Failure_Multisig_Unknown_Multisig_Account - Validation failed because account is not in multisig cache.
 * * Failure_Multisig_Not_A_Cosignatory - Validation failed because account to be removed is not present.
 * * Failure_Multisig_Already_A_Cosignatory - Validation failed because account to be added is already a cosignatory.
 * * Failure_Multisig_Min_Setting_Out_Of_Range - Validation failed because new minimum settings are out of range.
 * * Failure_Multisig_Min_Setting_Larger_Than_Num_Cosignatories - Validation failed because min settings are larger than number of cosignatories.
 * * Failure_Multisig_Invalid_Modification_Action - Validation failed because the modification action is invalid.
 * * Failure_Multisig_Max_Cosigned_Accounts - Validation failed because the cosignatory already cosigns the maximum number of accounts.
 * * Failure_Multisig_Max_Cosignatories - Validation failed because the multisig account already has the maximum number of cosignatories.
 * * Failure_Multisig_Loop - Validation failed because a multisig loop is created.
 * * Failure_Multisig_Max_Multisig_Depth - Validation failed because the max multisig depth is exceeded.
 * * Failure_Multisig_Operation_Prohibited_By_Account - Validation failed because an operation is not permitted by a multisig account.
 * * Failure_Namespace_Invalid_Duration - Validation failed because the duration has an invalid value.
 * * Failure_Namespace_Invalid_Name - Validation failed because the name is invalid.
 * * Failure_Namespace_Name_Id_Mismatch - Validation failed because the name and id don't match.
 * * Failure_Namespace_Expired - Validation failed because the parent is expired.
 * * Failure_Namespace_Owner_Conflict - Validation failed because the parent owner conflicts with the child owner.
 * * Failure_Namespace_Id_Mismatch - Validation failed because the id is not the expected id generated from signer and nonce.
 * * Failure_Namespace_Invalid_Registration_Type - Validation failed because the namespace registration type is invalid.
 * * Failure_Namespace_Root_Name_Reserved - Validation failed because the root namespace has a reserved name.
 * * Failure_Namespace_Too_Deep - Validation failed because the resulting namespace would exceed the maximum allowed namespace depth.
 * * Failure_Namespace_Unknown_Parent - Validation failed because the namespace parent is unknown.
 * * Failure_Namespace_Already_Exists - Validation failed because the namespace already exists.
 * * Failure_Namespace_Already_Active - Validation failed because the namespace is already active.
 * * Failure_Namespace_Eternal_After_Nemesis_Block - Validation failed because an eternal namespace was received after the nemesis block.
 * * Failure_Namespace_Max_Children_Exceeded - Validation failed because the maximum number of children for a root namespace was exceeded.
 * * Failure_Namespace_Alias_Invalid_Action - Validation failed because alias action is invalid.
 * * Failure_Namespace_Unknown - Validation failed because namespace does not exist.
 * * Failure_Namespace_Alias_Already_Exists - Validation failed because namespace is already linked to an alias.
 * * Failure_Namespace_Unknown_Alias - Validation failed because namespace is not linked to an alias.
 * * Failure_Namespace_Alias_Inconsistent_Unlink_Type - Validation failed because unlink type is not consistent with existing alias.
 * * Failure_Namespace_Alias_Inconsistent_Unlink_Data - Validation failed because unlink data is not consistent with existing alias.
 * * Failure_Namespace_Alias_Invalid_Address - Validation failed because aliased address is invalid.
 * * Failure_RestrictionAccount_Invalid_Restriction_Flags - Validation failed because the account restriction flags are invalid.
 * * Failure_RestrictionAccount_Invalid_Modification_Action - Validation failed because a modification action is invalid.
 * * Failure_RestrictionAccount_Invalid_Modification_Address - Validation failed because a modification address is invalid.
 * * Failure_RestrictionAccount_Modification_Operation_Type_Incompatible - Validation failed because the operation type is incompatible. *Note*: This indicates that the existing restrictions have a different operation type than that specified in the notification.
 * * Failure_RestrictionAccount_Redundant_Modification - Validation failed because a modification is redundant.
 * * Failure_RestrictionAccount_Invalid_Modification - Validation failed because a value is not in the container.
 * * Failure_RestrictionAccount_Modification_Count_Exceeded - Validation failed because the transaction has too many modifications.
 * * Failure_RestrictionAccount_No_Modifications - Validation failed because the transaction has no modifications.
 * * Failure_RestrictionAccount_Values_Count_Exceeded - Validation failed because the resulting account restriction has too many values.
 * * Failure_RestrictionAccount_Invalid_Value - Validation failed because the account restriction value is invalid.
 * * Failure_RestrictionAccount_Address_Interaction_Prohibited - Validation failed because the addresses involved in the transaction are not allowed to interact.
 * * Failure_RestrictionAccount_Mosaic_Transfer_Prohibited - Validation failed because the mosaic transfer is prohibited by the recipient.
 * * Failure_RestrictionAccount_Operation_Type_Prohibited - Validation failed because the operation type is not allowed to be initiated by the signer.
 * * Failure_RestrictionMosaic_Invalid_Restriction_Type - Validation failed because the mosaic restriction type is invalid.
 * * Failure_RestrictionMosaic_Previous_Value_Mismatch - Validation failed because specified previous value does not match current value.
 * * Failure_RestrictionMosaic_Previous_Value_Must_Be_Zero - Validation failed because specified previous value is nonzero.
 * * Failure_RestrictionMosaic_Max_Restrictions_Exceeded - Validation failed because the maximum number of restrictions would be exeeded.
 * * Failure_RestrictionMosaic_Cannot_Delete_Nonexistent_Restriction - Validation failed because nonexistent restriction cannot be deleted.
 * * Failure_RestrictionMosaic_Unknown_Global_Restriction - Validation failed because required global restriction does not exist.
 * * Failure_RestrictionMosaic_Invalid_Global_Restriction - Validation failed because mosaic has invalid global restriction.
 * * Failure_RestrictionMosaic_Account_Unauthorized - Validation failed because account lacks proper permissions to move mosaic.
 * * Failure_Transfer_Message_Too_Large - Validation failed because the message is too large.
 * * Failure_Transfer_Out_Of_Order_Mosaics - Validation failed because mosaics are out of order.
 * * Failure_Chain_Unlinked - Validation failed because a block was received that did not link with the existing chain.
 * * Failure_Chain_Block_Not_Hit - Validation failed because a block was received that is not a hit.
 * * Failure_Chain_Block_Inconsistent_State_Hash - Validation failed because a block was received that has an inconsistent state hash.
 * * Failure_Chain_Block_Inconsistent_Receipts_Hash - Validation failed because a block was received that has an inconsistent receipts hash.
 * * Failure_Chain_Unconfirmed_Cache_Too_Full - Validation failed because the unconfirmed cache is too full.
 * * Failure_Consumer_Empty_Input - Validation failed because the consumer input is empty.
 * * Failure_Consumer_Block_Transactions_Hash_Mismatch - Validation failed because the block transactions hash does not match the calculated value.
 * * Neutral_Consumer_Hash_In_Recency_Cache - Validation failed because an entity hash is present in the recency cache.
 * * Failure_Consumer_Remote_Chain_Too_Many_Blocks - Validation failed because the chain part has too many blocks.
 * * Failure_Consumer_Remote_Chain_Improper_Link - Validation failed because the chain is internally improperly linked.
 * * Failure_Consumer_Remote_Chain_Duplicate_Transactions - Validation failed because the chain part contains duplicate transactions.
 * * Failure_Consumer_Remote_Chain_Unlinked - Validation failed because the chain part does not link to the current chain.
 * * Failure_Consumer_Remote_Chain_Difficulties_Mismatch - Validation failed because the remote chain difficulties do not match the calculated difficulties.
 * * Failure_Consumer_Remote_Chain_Score_Not_Better - Validation failed because the remote chain score is not better.
 * * Failure_Consumer_Remote_Chain_Too_Far_Behind - Validation failed because the remote chain is too far behind.
 * * Failure_Consumer_Remote_Chain_Too_Far_In_Future - Validation failed because the remote chain timestamp is too far in the future.
 * * Failure_Consumer_Batch_Signature_Not_Verifiable - Validation failed because the verification of the signature failed during a batch operation.
 * * Failure_Extension_Partial_Transaction_Cache_Prune - Validation failed because the partial transaction was pruned from the temporal cache.
 * * Failure_Extension_Partial_Transaction_Dependency_Removed - Validation failed because the partial transaction was pruned from the temporal cache due to its dependency being removed.
 * * Failure_Extension_Read_Rate_Limit_Exceeded - Validation failed because socket read rate limit was exceeded.
 * @export
 * @enum {string}
 */
var TransactionStatusEnum;
(function (TransactionStatusEnum) {
    TransactionStatusEnum["Success"] = "Success";
    TransactionStatusEnum["Neutral"] = "Neutral";
    TransactionStatusEnum["Failure"] = "Failure";
    TransactionStatusEnum["FailureCorePastDeadline"] = "Failure_Core_Past_Deadline";
    TransactionStatusEnum["FailureCoreFutureDeadline"] = "Failure_Core_Future_Deadline";
    TransactionStatusEnum["FailureCoreInsufficientBalance"] = "Failure_Core_Insufficient_Balance";
    TransactionStatusEnum["FailureCoreTooManyTransactions"] = "Failure_Core_Too_Many_Transactions";
    TransactionStatusEnum["FailureCoreNemesisAccountSignedAfterNemesisBlock"] = "Failure_Core_Nemesis_Account_Signed_After_Nemesis_Block";
    TransactionStatusEnum["FailureCoreWrongNetwork"] = "Failure_Core_Wrong_Network";
    TransactionStatusEnum["FailureCoreInvalidAddress"] = "Failure_Core_Invalid_Address";
    TransactionStatusEnum["FailureCoreInvalidVersion"] = "Failure_Core_Invalid_Version";
    TransactionStatusEnum["FailureCoreInvalidTransactionFee"] = "Failure_Core_Invalid_Transaction_Fee";
    TransactionStatusEnum["FailureCoreBlockHarvesterIneligible"] = "Failure_Core_Block_Harvester_Ineligible";
    TransactionStatusEnum["FailureCoreZeroAddress"] = "Failure_Core_Zero_Address";
    TransactionStatusEnum["FailureCoreZeroPublicKey"] = "Failure_Core_Zero_Public_Key";
    TransactionStatusEnum["FailureCoreNonzeroInternalPadding"] = "Failure_Core_Nonzero_Internal_Padding";
    TransactionStatusEnum["FailureCoreAddressCollision"] = "Failure_Core_Address_Collision";
    TransactionStatusEnum["FailureCoreInvalidLinkAction"] = "Failure_Core_Invalid_Link_Action";
    TransactionStatusEnum["FailureCoreLinkAlreadyExists"] = "Failure_Core_Link_Already_Exists";
    TransactionStatusEnum["FailureCoreInconsistentUnlinkData"] = "Failure_Core_Inconsistent_Unlink_Data";
    TransactionStatusEnum["FailureCoreInvalidLinkRange"] = "Failure_Core_Invalid_Link_Range";
    TransactionStatusEnum["FailureCoreTooManyLinks"] = "Failure_Core_Too_Many_Links";
    TransactionStatusEnum["FailureHashAlreadyExists"] = "Failure_Hash_Already_Exists";
    TransactionStatusEnum["FailureSignatureNotVerifiable"] = "Failure_Signature_Not_Verifiable";
    TransactionStatusEnum["FailureAccountLinkLinkAlreadyExists"] = "Failure_AccountLink_Link_Already_Exists";
    TransactionStatusEnum["FailureAccountLinkInconsistentUnlinkData"] = "Failure_AccountLink_Inconsistent_Unlink_Data";
    TransactionStatusEnum["FailureAccountLinkUnknownLink"] = "Failure_AccountLink_Unknown_Link";
    TransactionStatusEnum["FailureAccountLinkRemoteAccountIneligible"] = "Failure_AccountLink_Remote_Account_Ineligible";
    TransactionStatusEnum["FailureAccountLinkRemoteAccountSignerProhibited"] = "Failure_AccountLink_Remote_Account_Signer_Prohibited";
    TransactionStatusEnum["FailureAccountLinkRemoteAccountParticipantProhibited"] = "Failure_AccountLink_Remote_Account_Participant_Prohibited";
    TransactionStatusEnum["FailureAggregateTooManyTransactions"] = "Failure_Aggregate_Too_Many_Transactions";
    TransactionStatusEnum["FailureAggregateNoTransactions"] = "Failure_Aggregate_No_Transactions";
    TransactionStatusEnum["FailureAggregateTooManyCosignatures"] = "Failure_Aggregate_Too_Many_Cosignatures";
    TransactionStatusEnum["FailureAggregateRedundantCosignatures"] = "Failure_Aggregate_Redundant_Cosignatures";
    TransactionStatusEnum["FailureAggregateIneligibleCosignatories"] = "Failure_Aggregate_Ineligible_Cosignatories";
    TransactionStatusEnum["FailureAggregateMissingCosignatures"] = "Failure_Aggregate_Missing_Cosignatures";
    TransactionStatusEnum["FailureAggregateTransactionsHashMismatch"] = "Failure_Aggregate_Transactions_Hash_Mismatch";
    TransactionStatusEnum["FailureLockHashInvalidMosaicId"] = "Failure_LockHash_Invalid_Mosaic_Id";
    TransactionStatusEnum["FailureLockHashInvalidMosaicAmount"] = "Failure_LockHash_Invalid_Mosaic_Amount";
    TransactionStatusEnum["FailureLockHashHashAlreadyExists"] = "Failure_LockHash_Hash_Already_Exists";
    TransactionStatusEnum["FailureLockHashUnknownHash"] = "Failure_LockHash_Unknown_Hash";
    TransactionStatusEnum["FailureLockHashInactiveHash"] = "Failure_LockHash_Inactive_Hash";
    TransactionStatusEnum["FailureLockHashInvalidDuration"] = "Failure_LockHash_Invalid_Duration";
    TransactionStatusEnum["FailureLockSecretInvalidHashAlgorithm"] = "Failure_LockSecret_Invalid_Hash_Algorithm";
    TransactionStatusEnum["FailureLockSecretHashAlreadyExists"] = "Failure_LockSecret_Hash_Already_Exists";
    TransactionStatusEnum["FailureLockSecretProofSizeOutOfBounds"] = "Failure_LockSecret_Proof_Size_Out_Of_Bounds";
    TransactionStatusEnum["FailureLockSecretSecretMismatch"] = "Failure_LockSecret_Secret_Mismatch";
    TransactionStatusEnum["FailureLockSecretUnknownCompositeKey"] = "Failure_LockSecret_Unknown_Composite_Key";
    TransactionStatusEnum["FailureLockSecretInactiveSecret"] = "Failure_LockSecret_Inactive_Secret";
    TransactionStatusEnum["FailureLockSecretHashAlgorithmMismatch"] = "Failure_LockSecret_Hash_Algorithm_Mismatch";
    TransactionStatusEnum["FailureLockSecretInvalidDuration"] = "Failure_LockSecret_Invalid_Duration";
    TransactionStatusEnum["FailureMetadataValueTooSmall"] = "Failure_Metadata_Value_Too_Small";
    TransactionStatusEnum["FailureMetadataValueTooLarge"] = "Failure_Metadata_Value_Too_Large";
    TransactionStatusEnum["FailureMetadataValueSizeDeltaTooLarge"] = "Failure_Metadata_Value_Size_Delta_Too_Large";
    TransactionStatusEnum["FailureMetadataValueSizeDeltaMismatch"] = "Failure_Metadata_Value_Size_Delta_Mismatch";
    TransactionStatusEnum["FailureMetadataValueChangeIrreversible"] = "Failure_Metadata_Value_Change_Irreversible";
    TransactionStatusEnum["FailureMosaicInvalidDuration"] = "Failure_Mosaic_Invalid_Duration";
    TransactionStatusEnum["FailureMosaicInvalidName"] = "Failure_Mosaic_Invalid_Name";
    TransactionStatusEnum["FailureMosaicNameIdMismatch"] = "Failure_Mosaic_Name_Id_Mismatch";
    TransactionStatusEnum["FailureMosaicExpired"] = "Failure_Mosaic_Expired";
    TransactionStatusEnum["FailureMosaicOwnerConflict"] = "Failure_Mosaic_Owner_Conflict";
    TransactionStatusEnum["FailureMosaicIdMismatch"] = "Failure_Mosaic_Id_Mismatch";
    TransactionStatusEnum["FailureMosaicParentIdConflict"] = "Failure_Mosaic_Parent_Id_Conflict";
    TransactionStatusEnum["FailureMosaicInvalidProperty"] = "Failure_Mosaic_Invalid_Property";
    TransactionStatusEnum["FailureMosaicInvalidFlags"] = "Failure_Mosaic_Invalid_Flags";
    TransactionStatusEnum["FailureMosaicInvalidDivisibility"] = "Failure_Mosaic_Invalid_Divisibility";
    TransactionStatusEnum["FailureMosaicInvalidSupplyChangeAction"] = "Failure_Mosaic_Invalid_Supply_Change_Action";
    TransactionStatusEnum["FailureMosaicInvalidSupplyChangeAmount"] = "Failure_Mosaic_Invalid_Supply_Change_Amount";
    TransactionStatusEnum["FailureMosaicInvalidId"] = "Failure_Mosaic_Invalid_Id";
    TransactionStatusEnum["FailureMosaicModificationDisallowed"] = "Failure_Mosaic_Modification_Disallowed";
    TransactionStatusEnum["FailureMosaicModificationNoChanges"] = "Failure_Mosaic_Modification_No_Changes";
    TransactionStatusEnum["FailureMosaicSupplyImmutable"] = "Failure_Mosaic_Supply_Immutable";
    TransactionStatusEnum["FailureMosaicSupplyNegative"] = "Failure_Mosaic_Supply_Negative";
    TransactionStatusEnum["FailureMosaicSupplyExceeded"] = "Failure_Mosaic_Supply_Exceeded";
    TransactionStatusEnum["FailureMosaicNonTransferable"] = "Failure_Mosaic_Non_Transferable";
    TransactionStatusEnum["FailureMosaicMaxMosaicsExceeded"] = "Failure_Mosaic_Max_Mosaics_Exceeded";
    TransactionStatusEnum["FailureMosaicRequiredPropertyFlagUnset"] = "Failure_Mosaic_Required_Property_Flag_Unset";
    TransactionStatusEnum["FailureMultisigAccountInBothSets"] = "Failure_Multisig_Account_In_Both_Sets";
    TransactionStatusEnum["FailureMultisigMultipleDeletes"] = "Failure_Multisig_Multiple_Deletes";
    TransactionStatusEnum["FailureMultisigRedundantModification"] = "Failure_Multisig_Redundant_Modification";
    TransactionStatusEnum["FailureMultisigUnknownMultisigAccount"] = "Failure_Multisig_Unknown_Multisig_Account";
    TransactionStatusEnum["FailureMultisigNotACosignatory"] = "Failure_Multisig_Not_A_Cosignatory";
    TransactionStatusEnum["FailureMultisigAlreadyACosignatory"] = "Failure_Multisig_Already_A_Cosignatory";
    TransactionStatusEnum["FailureMultisigMinSettingOutOfRange"] = "Failure_Multisig_Min_Setting_Out_Of_Range";
    TransactionStatusEnum["FailureMultisigMinSettingLargerThanNumCosignatories"] = "Failure_Multisig_Min_Setting_Larger_Than_Num_Cosignatories";
    TransactionStatusEnum["FailureMultisigInvalidModificationAction"] = "Failure_Multisig_Invalid_Modification_Action";
    TransactionStatusEnum["FailureMultisigMaxCosignedAccounts"] = "Failure_Multisig_Max_Cosigned_Accounts";
    TransactionStatusEnum["FailureMultisigMaxCosignatories"] = "Failure_Multisig_Max_Cosignatories";
    TransactionStatusEnum["FailureMultisigLoop"] = "Failure_Multisig_Loop";
    TransactionStatusEnum["FailureMultisigMaxMultisigDepth"] = "Failure_Multisig_Max_Multisig_Depth";
    TransactionStatusEnum["FailureMultisigOperationProhibitedByAccount"] = "Failure_Multisig_Operation_Prohibited_By_Account";
    TransactionStatusEnum["FailureNamespaceInvalidDuration"] = "Failure_Namespace_Invalid_Duration";
    TransactionStatusEnum["FailureNamespaceInvalidName"] = "Failure_Namespace_Invalid_Name";
    TransactionStatusEnum["FailureNamespaceNameIdMismatch"] = "Failure_Namespace_Name_Id_Mismatch";
    TransactionStatusEnum["FailureNamespaceExpired"] = "Failure_Namespace_Expired";
    TransactionStatusEnum["FailureNamespaceOwnerConflict"] = "Failure_Namespace_Owner_Conflict";
    TransactionStatusEnum["FailureNamespaceIdMismatch"] = "Failure_Namespace_Id_Mismatch";
    TransactionStatusEnum["FailureNamespaceInvalidRegistrationType"] = "Failure_Namespace_Invalid_Registration_Type";
    TransactionStatusEnum["FailureNamespaceRootNameReserved"] = "Failure_Namespace_Root_Name_Reserved";
    TransactionStatusEnum["FailureNamespaceTooDeep"] = "Failure_Namespace_Too_Deep";
    TransactionStatusEnum["FailureNamespaceUnknownParent"] = "Failure_Namespace_Unknown_Parent";
    TransactionStatusEnum["FailureNamespaceAlreadyExists"] = "Failure_Namespace_Already_Exists";
    TransactionStatusEnum["FailureNamespaceAlreadyActive"] = "Failure_Namespace_Already_Active";
    TransactionStatusEnum["FailureNamespaceEternalAfterNemesisBlock"] = "Failure_Namespace_Eternal_After_Nemesis_Block";
    TransactionStatusEnum["FailureNamespaceMaxChildrenExceeded"] = "Failure_Namespace_Max_Children_Exceeded";
    TransactionStatusEnum["FailureNamespaceAliasInvalidAction"] = "Failure_Namespace_Alias_Invalid_Action";
    TransactionStatusEnum["FailureNamespaceUnknown"] = "Failure_Namespace_Unknown";
    TransactionStatusEnum["FailureNamespaceAliasAlreadyExists"] = "Failure_Namespace_Alias_Already_Exists";
    TransactionStatusEnum["FailureNamespaceUnknownAlias"] = "Failure_Namespace_Unknown_Alias";
    TransactionStatusEnum["FailureNamespaceAliasInconsistentUnlinkType"] = "Failure_Namespace_Alias_Inconsistent_Unlink_Type";
    TransactionStatusEnum["FailureNamespaceAliasInconsistentUnlinkData"] = "Failure_Namespace_Alias_Inconsistent_Unlink_Data";
    TransactionStatusEnum["FailureNamespaceAliasInvalidAddress"] = "Failure_Namespace_Alias_Invalid_Address";
    TransactionStatusEnum["FailureRestrictionAccountInvalidRestrictionFlags"] = "Failure_RestrictionAccount_Invalid_Restriction_Flags";
    TransactionStatusEnum["FailureRestrictionAccountInvalidModificationAction"] = "Failure_RestrictionAccount_Invalid_Modification_Action";
    TransactionStatusEnum["FailureRestrictionAccountInvalidModificationAddress"] = "Failure_RestrictionAccount_Invalid_Modification_Address";
    TransactionStatusEnum["FailureRestrictionAccountModificationOperationTypeIncompatible"] = "Failure_RestrictionAccount_Modification_Operation_Type_Incompatible";
    TransactionStatusEnum["FailureRestrictionAccountRedundantModification"] = "Failure_RestrictionAccount_Redundant_Modification";
    TransactionStatusEnum["FailureRestrictionAccountInvalidModification"] = "Failure_RestrictionAccount_Invalid_Modification";
    TransactionStatusEnum["FailureRestrictionAccountModificationCountExceeded"] = "Failure_RestrictionAccount_Modification_Count_Exceeded";
    TransactionStatusEnum["FailureRestrictionAccountNoModifications"] = "Failure_RestrictionAccount_No_Modifications";
    TransactionStatusEnum["FailureRestrictionAccountValuesCountExceeded"] = "Failure_RestrictionAccount_Values_Count_Exceeded";
    TransactionStatusEnum["FailureRestrictionAccountInvalidValue"] = "Failure_RestrictionAccount_Invalid_Value";
    TransactionStatusEnum["FailureRestrictionAccountAddressInteractionProhibited"] = "Failure_RestrictionAccount_Address_Interaction_Prohibited";
    TransactionStatusEnum["FailureRestrictionAccountMosaicTransferProhibited"] = "Failure_RestrictionAccount_Mosaic_Transfer_Prohibited";
    TransactionStatusEnum["FailureRestrictionAccountOperationTypeProhibited"] = "Failure_RestrictionAccount_Operation_Type_Prohibited";
    TransactionStatusEnum["FailureRestrictionMosaicInvalidRestrictionType"] = "Failure_RestrictionMosaic_Invalid_Restriction_Type";
    TransactionStatusEnum["FailureRestrictionMosaicPreviousValueMismatch"] = "Failure_RestrictionMosaic_Previous_Value_Mismatch";
    TransactionStatusEnum["FailureRestrictionMosaicPreviousValueMustBeZero"] = "Failure_RestrictionMosaic_Previous_Value_Must_Be_Zero";
    TransactionStatusEnum["FailureRestrictionMosaicMaxRestrictionsExceeded"] = "Failure_RestrictionMosaic_Max_Restrictions_Exceeded";
    TransactionStatusEnum["FailureRestrictionMosaicCannotDeleteNonexistentRestriction"] = "Failure_RestrictionMosaic_Cannot_Delete_Nonexistent_Restriction";
    TransactionStatusEnum["FailureRestrictionMosaicUnknownGlobalRestriction"] = "Failure_RestrictionMosaic_Unknown_Global_Restriction";
    TransactionStatusEnum["FailureRestrictionMosaicInvalidGlobalRestriction"] = "Failure_RestrictionMosaic_Invalid_Global_Restriction";
    TransactionStatusEnum["FailureRestrictionMosaicAccountUnauthorized"] = "Failure_RestrictionMosaic_Account_Unauthorized";
    TransactionStatusEnum["FailureTransferMessageTooLarge"] = "Failure_Transfer_Message_Too_Large";
    TransactionStatusEnum["FailureTransferOutOfOrderMosaics"] = "Failure_Transfer_Out_Of_Order_Mosaics";
    TransactionStatusEnum["FailureChainUnlinked"] = "Failure_Chain_Unlinked";
    TransactionStatusEnum["FailureChainBlockNotHit"] = "Failure_Chain_Block_Not_Hit";
    TransactionStatusEnum["FailureChainBlockInconsistentStateHash"] = "Failure_Chain_Block_Inconsistent_State_Hash";
    TransactionStatusEnum["FailureChainBlockInconsistentReceiptsHash"] = "Failure_Chain_Block_Inconsistent_Receipts_Hash";
    TransactionStatusEnum["FailureChainUnconfirmedCacheTooFull"] = "Failure_Chain_Unconfirmed_Cache_Too_Full";
    TransactionStatusEnum["FailureConsumerEmptyInput"] = "Failure_Consumer_Empty_Input";
    TransactionStatusEnum["FailureConsumerBlockTransactionsHashMismatch"] = "Failure_Consumer_Block_Transactions_Hash_Mismatch";
    TransactionStatusEnum["NeutralConsumerHashInRecencyCache"] = "Neutral_Consumer_Hash_In_Recency_Cache";
    TransactionStatusEnum["FailureConsumerRemoteChainTooManyBlocks"] = "Failure_Consumer_Remote_Chain_Too_Many_Blocks";
    TransactionStatusEnum["FailureConsumerRemoteChainImproperLink"] = "Failure_Consumer_Remote_Chain_Improper_Link";
    TransactionStatusEnum["FailureConsumerRemoteChainDuplicateTransactions"] = "Failure_Consumer_Remote_Chain_Duplicate_Transactions";
    TransactionStatusEnum["FailureConsumerRemoteChainUnlinked"] = "Failure_Consumer_Remote_Chain_Unlinked";
    TransactionStatusEnum["FailureConsumerRemoteChainDifficultiesMismatch"] = "Failure_Consumer_Remote_Chain_Difficulties_Mismatch";
    TransactionStatusEnum["FailureConsumerRemoteChainScoreNotBetter"] = "Failure_Consumer_Remote_Chain_Score_Not_Better";
    TransactionStatusEnum["FailureConsumerRemoteChainTooFarBehind"] = "Failure_Consumer_Remote_Chain_Too_Far_Behind";
    TransactionStatusEnum["FailureConsumerRemoteChainTooFarInFuture"] = "Failure_Consumer_Remote_Chain_Too_Far_In_Future";
    TransactionStatusEnum["FailureConsumerBatchSignatureNotVerifiable"] = "Failure_Consumer_Batch_Signature_Not_Verifiable";
    TransactionStatusEnum["FailureExtensionPartialTransactionCachePrune"] = "Failure_Extension_Partial_Transaction_Cache_Prune";
    TransactionStatusEnum["FailureExtensionPartialTransactionDependencyRemoved"] = "Failure_Extension_Partial_Transaction_Dependency_Removed";
    TransactionStatusEnum["FailureExtensionReadRateLimitExceeded"] = "Failure_Extension_Read_Rate_Limit_Exceeded";
})(TransactionStatusEnum = exports.TransactionStatusEnum || (exports.TransactionStatusEnum = {}));
function TransactionStatusEnumFromJSON(json) {
    return TransactionStatusEnumFromJSONTyped(json, false);
}
exports.TransactionStatusEnumFromJSON = TransactionStatusEnumFromJSON;
function TransactionStatusEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.TransactionStatusEnumFromJSONTyped = TransactionStatusEnumFromJSONTyped;
function TransactionStatusEnumToJSON(value) {
    return value;
}
exports.TransactionStatusEnumToJSON = TransactionStatusEnumToJSON;

},{}],1145:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionTypeEnumToJSON = exports.TransactionTypeEnumFromJSONTyped = exports.TransactionTypeEnumFromJSON = exports.TransactionTypeEnum = void 0;
/**
 * Type of transaction:
 * * 0x414C (16716 decimal) - AccountKeyLinkTransaction.
 * * 0x4243 (16963 decimal) - VrfKeyLinkTransaction.
 * * 0x4143 (16707 decimal) - VotingKeyLinkTransaction.
 * * 0x424C (16972 decimal) - NodeKeyLinkTransaction.
 * * 0x4141 (16705 decimal) - AggregateCompleteTransaction.
 * * 0x4241 (16961 decimal) - AggregateBondedTransaction.
 * * 0x414D (16717 decimal) - MosaicDefinitionTransaction.
 * * 0x424D (16973 decimal) - MosaicSupplyChangeTransaction.
 * * 0x414E (16718 decimal) - NamespaceRegistrationTransaction.
 * * 0x424E (16974 decimal) - AddressAliasTransaction.
 * * 0x434E (17230 decimal) - MosaicAliasTransaction.
 * * 0x4144 (16708 decimal) - AccountMetadataTransaction.
 * * 0x4244 (16964 decimal) - MosaicMetadataTransaction.
 * * 0x4344 (17220 decimal) - NamespaceMetadataTransaction.
 * * 0x4155 (16725 decimal) - MultisigAccountModificationTransaction.
 * * 0x4148 (16712 decimal) - HashLockTransaction.
 * * 0x4152 (16722 decimal) - SecretLockTransaction.
 * * 0x4252 (16978 decimal) - SecretProofTransaction.
 * * 0x4150 (16720 decimal) - AccountAddressRestrictionTransaction.
 * * 0x4250 (16976 decimal) - AccountMosaicRestrictionTransaction.
 * * 0x4350 (17232 decimal) - AccountOperationRestrictionTransaction.
 * * 0x4151 (16721 decimal) - MosaicGlobalRestrictionTransaction.
 * * 0x4251 (16977 decimal) - MosaicAddressRestrictionTransaction.
 * * 0x4154 (16724 decimal) - TransferTransaction.
 * @export
 * @enum {string}
 */
var TransactionTypeEnum;
(function (TransactionTypeEnum) {
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16716"] = 16716] = "NUMBER_16716";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16963"] = 16963] = "NUMBER_16963";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16707"] = 16707] = "NUMBER_16707";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16972"] = 16972] = "NUMBER_16972";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16705"] = 16705] = "NUMBER_16705";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16961"] = 16961] = "NUMBER_16961";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16717"] = 16717] = "NUMBER_16717";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16973"] = 16973] = "NUMBER_16973";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16718"] = 16718] = "NUMBER_16718";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16974"] = 16974] = "NUMBER_16974";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_17230"] = 17230] = "NUMBER_17230";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16708"] = 16708] = "NUMBER_16708";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16964"] = 16964] = "NUMBER_16964";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_17220"] = 17220] = "NUMBER_17220";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16725"] = 16725] = "NUMBER_16725";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16712"] = 16712] = "NUMBER_16712";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16722"] = 16722] = "NUMBER_16722";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16978"] = 16978] = "NUMBER_16978";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16720"] = 16720] = "NUMBER_16720";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16976"] = 16976] = "NUMBER_16976";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_17232"] = 17232] = "NUMBER_17232";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16721"] = 16721] = "NUMBER_16721";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16977"] = 16977] = "NUMBER_16977";
    TransactionTypeEnum[TransactionTypeEnum["NUMBER_16724"] = 16724] = "NUMBER_16724";
})(TransactionTypeEnum = exports.TransactionTypeEnum || (exports.TransactionTypeEnum = {}));
function TransactionTypeEnumFromJSON(json) {
    return TransactionTypeEnumFromJSONTyped(json, false);
}
exports.TransactionTypeEnumFromJSON = TransactionTypeEnumFromJSON;
function TransactionTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.TransactionTypeEnumFromJSONTyped = TransactionTypeEnumFromJSONTyped;
function TransactionTypeEnumToJSON(value) {
    return value;
}
exports.TransactionTypeEnumToJSON = TransactionTypeEnumToJSON;

},{}],1146:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferNetworkPropertiesDTOToJSON = exports.TransferNetworkPropertiesDTOFromJSONTyped = exports.TransferNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function TransferNetworkPropertiesDTOFromJSON(json) {
    return TransferNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.TransferNetworkPropertiesDTOFromJSON = TransferNetworkPropertiesDTOFromJSON;
function TransferNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'maxMessageSize': !runtime_1.exists(json, 'maxMessageSize') ? undefined : json['maxMessageSize'],
    };
}
exports.TransferNetworkPropertiesDTOFromJSONTyped = TransferNetworkPropertiesDTOFromJSONTyped;
function TransferNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'maxMessageSize': value.maxMessageSize,
    };
}
exports.TransferNetworkPropertiesDTOToJSON = TransferNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],1147:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferTransactionBodyDTOToJSON = exports.TransferTransactionBodyDTOFromJSONTyped = exports.TransferTransactionBodyDTOFromJSON = void 0;
function TransferTransactionBodyDTOFromJSON(json) {
    return TransferTransactionBodyDTOFromJSONTyped(json, false);
}
exports.TransferTransactionBodyDTOFromJSON = TransferTransactionBodyDTOFromJSON;
function TransferTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'recipientAddress': json['recipientAddress'],
        'mosaics': json['mosaics'],
        'message': json['message'],
    };
}
exports.TransferTransactionBodyDTOFromJSONTyped = TransferTransactionBodyDTOFromJSONTyped;
function TransferTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'recipientAddress': value.recipientAddress,
        'mosaics': value.mosaics,
        'message': value.message,
    };
}
exports.TransferTransactionBodyDTOToJSON = TransferTransactionBodyDTOToJSON;

},{}],1148:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferTransactionDTOToJSON = exports.TransferTransactionDTOFromJSONTyped = exports.TransferTransactionDTOFromJSON = void 0;
function TransferTransactionDTOFromJSON(json) {
    return TransferTransactionDTOFromJSONTyped(json, false);
}
exports.TransferTransactionDTOFromJSON = TransferTransactionDTOFromJSON;
function TransferTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'recipientAddress': json['recipientAddress'],
        'mosaics': json['mosaics'],
        'message': json['message'],
    };
}
exports.TransferTransactionDTOFromJSONTyped = TransferTransactionDTOFromJSONTyped;
function TransferTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'recipientAddress': value.recipientAddress,
        'mosaics': value.mosaics,
        'message': value.message,
    };
}
exports.TransferTransactionDTOToJSON = TransferTransactionDTOToJSON;

},{}],1149:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnresolvedMosaicToJSON = exports.UnresolvedMosaicFromJSONTyped = exports.UnresolvedMosaicFromJSON = void 0;
function UnresolvedMosaicFromJSON(json) {
    return UnresolvedMosaicFromJSONTyped(json, false);
}
exports.UnresolvedMosaicFromJSON = UnresolvedMosaicFromJSON;
function UnresolvedMosaicFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'id': json['id'],
        'amount': json['amount'],
    };
}
exports.UnresolvedMosaicFromJSONTyped = UnresolvedMosaicFromJSONTyped;
function UnresolvedMosaicToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'amount': value.amount,
    };
}
exports.UnresolvedMosaicToJSON = UnresolvedMosaicToJSON;

},{}],1150:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerifiableEntityDTOToJSON = exports.VerifiableEntityDTOFromJSONTyped = exports.VerifiableEntityDTOFromJSON = void 0;
function VerifiableEntityDTOFromJSON(json) {
    return VerifiableEntityDTOFromJSONTyped(json, false);
}
exports.VerifiableEntityDTOFromJSON = VerifiableEntityDTOFromJSON;
function VerifiableEntityDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'signature': json['signature'],
    };
}
exports.VerifiableEntityDTOFromJSONTyped = VerifiableEntityDTOFromJSONTyped;
function VerifiableEntityDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'signature': value.signature,
    };
}
exports.VerifiableEntityDTOToJSON = VerifiableEntityDTOToJSON;

},{}],1151:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VotingKeyLinkNetworkPropertiesDTOToJSON = exports.VotingKeyLinkNetworkPropertiesDTOFromJSONTyped = exports.VotingKeyLinkNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function VotingKeyLinkNetworkPropertiesDTOFromJSON(json) {
    return VotingKeyLinkNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.VotingKeyLinkNetworkPropertiesDTOFromJSON = VotingKeyLinkNetworkPropertiesDTOFromJSON;
function VotingKeyLinkNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'dummy': !runtime_1.exists(json, 'dummy') ? undefined : json['dummy'],
    };
}
exports.VotingKeyLinkNetworkPropertiesDTOFromJSONTyped = VotingKeyLinkNetworkPropertiesDTOFromJSONTyped;
function VotingKeyLinkNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'dummy': value.dummy,
    };
}
exports.VotingKeyLinkNetworkPropertiesDTOToJSON = VotingKeyLinkNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],1152:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VotingKeyLinkTransactionBodyDTOToJSON = exports.VotingKeyLinkTransactionBodyDTOFromJSONTyped = exports.VotingKeyLinkTransactionBodyDTOFromJSON = void 0;
function VotingKeyLinkTransactionBodyDTOFromJSON(json) {
    return VotingKeyLinkTransactionBodyDTOFromJSONTyped(json, false);
}
exports.VotingKeyLinkTransactionBodyDTOFromJSON = VotingKeyLinkTransactionBodyDTOFromJSON;
function VotingKeyLinkTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'linkedPublicKey': json['linkedPublicKey'],
        'startPoint': json['startPoint'],
        'endPoint': json['endPoint'],
        'linkAction': json['linkAction'],
    };
}
exports.VotingKeyLinkTransactionBodyDTOFromJSONTyped = VotingKeyLinkTransactionBodyDTOFromJSONTyped;
function VotingKeyLinkTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'linkedPublicKey': value.linkedPublicKey,
        'startPoint': value.startPoint,
        'endPoint': value.endPoint,
        'linkAction': value.linkAction,
    };
}
exports.VotingKeyLinkTransactionBodyDTOToJSON = VotingKeyLinkTransactionBodyDTOToJSON;

},{}],1153:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VotingKeyLinkTransactionDTOToJSON = exports.VotingKeyLinkTransactionDTOFromJSONTyped = exports.VotingKeyLinkTransactionDTOFromJSON = void 0;
function VotingKeyLinkTransactionDTOFromJSON(json) {
    return VotingKeyLinkTransactionDTOFromJSONTyped(json, false);
}
exports.VotingKeyLinkTransactionDTOFromJSON = VotingKeyLinkTransactionDTOFromJSON;
function VotingKeyLinkTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'linkedPublicKey': json['linkedPublicKey'],
        'startPoint': json['startPoint'],
        'endPoint': json['endPoint'],
        'linkAction': json['linkAction'],
    };
}
exports.VotingKeyLinkTransactionDTOFromJSONTyped = VotingKeyLinkTransactionDTOFromJSONTyped;
function VotingKeyLinkTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'linkedPublicKey': value.linkedPublicKey,
        'startPoint': value.startPoint,
        'endPoint': value.endPoint,
        'linkAction': value.linkAction,
    };
}
exports.VotingKeyLinkTransactionDTOToJSON = VotingKeyLinkTransactionDTOToJSON;

},{}],1154:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VrfKeyLinkNetworkPropertiesDTOToJSON = exports.VrfKeyLinkNetworkPropertiesDTOFromJSONTyped = exports.VrfKeyLinkNetworkPropertiesDTOFromJSON = void 0;
const runtime_1 = require("../runtime");
function VrfKeyLinkNetworkPropertiesDTOFromJSON(json) {
    return VrfKeyLinkNetworkPropertiesDTOFromJSONTyped(json, false);
}
exports.VrfKeyLinkNetworkPropertiesDTOFromJSON = VrfKeyLinkNetworkPropertiesDTOFromJSON;
function VrfKeyLinkNetworkPropertiesDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'dummy': !runtime_1.exists(json, 'dummy') ? undefined : json['dummy'],
    };
}
exports.VrfKeyLinkNetworkPropertiesDTOFromJSONTyped = VrfKeyLinkNetworkPropertiesDTOFromJSONTyped;
function VrfKeyLinkNetworkPropertiesDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'dummy': value.dummy,
    };
}
exports.VrfKeyLinkNetworkPropertiesDTOToJSON = VrfKeyLinkNetworkPropertiesDTOToJSON;

},{"../runtime":1158}],1155:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VrfKeyLinkTransactionBodyDTOToJSON = exports.VrfKeyLinkTransactionBodyDTOFromJSONTyped = exports.VrfKeyLinkTransactionBodyDTOFromJSON = void 0;
function VrfKeyLinkTransactionBodyDTOFromJSON(json) {
    return VrfKeyLinkTransactionBodyDTOFromJSONTyped(json, false);
}
exports.VrfKeyLinkTransactionBodyDTOFromJSON = VrfKeyLinkTransactionBodyDTOFromJSON;
function VrfKeyLinkTransactionBodyDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'linkedPublicKey': json['linkedPublicKey'],
        'linkAction': json['linkAction'],
    };
}
exports.VrfKeyLinkTransactionBodyDTOFromJSONTyped = VrfKeyLinkTransactionBodyDTOFromJSONTyped;
function VrfKeyLinkTransactionBodyDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'linkedPublicKey': value.linkedPublicKey,
        'linkAction': value.linkAction,
    };
}
exports.VrfKeyLinkTransactionBodyDTOToJSON = VrfKeyLinkTransactionBodyDTOToJSON;

},{}],1156:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VrfKeyLinkTransactionDTOToJSON = exports.VrfKeyLinkTransactionDTOFromJSONTyped = exports.VrfKeyLinkTransactionDTOFromJSON = void 0;
function VrfKeyLinkTransactionDTOFromJSON(json) {
    return VrfKeyLinkTransactionDTOFromJSONTyped(json, false);
}
exports.VrfKeyLinkTransactionDTOFromJSON = VrfKeyLinkTransactionDTOFromJSON;
function VrfKeyLinkTransactionDTOFromJSONTyped(json, ignoreDiscriminator) {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        'size': json['size'],
        'signature': json['signature'],
        'signerPublicKey': json['signerPublicKey'],
        'version': json['version'],
        'network': json['network'],
        'type': json['type'],
        'maxFee': json['maxFee'],
        'deadline': json['deadline'],
        'linkedPublicKey': json['linkedPublicKey'],
        'linkAction': json['linkAction'],
    };
}
exports.VrfKeyLinkTransactionDTOFromJSONTyped = VrfKeyLinkTransactionDTOFromJSONTyped;
function VrfKeyLinkTransactionDTOToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'size': value.size,
        'signature': value.signature,
        'signerPublicKey': value.signerPublicKey,
        'version': value.version,
        'network': value.network,
        'type': value.type,
        'maxFee': value.maxFee,
        'deadline': value.deadline,
        'linkedPublicKey': value.linkedPublicKey,
        'linkAction': value.linkAction,
    };
}
exports.VrfKeyLinkTransactionDTOToJSON = VrfKeyLinkTransactionDTOToJSON;

},{}],1157:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./AccountAddressRestrictionTransactionBodyDTO"), exports);
__exportStar(require("./AccountAddressRestrictionTransactionDTO"), exports);
__exportStar(require("./AccountDTO"), exports);
__exportStar(require("./AccountIds"), exports);
__exportStar(require("./AccountInfoDTO"), exports);
__exportStar(require("./AccountKeyLinkNetworkPropertiesDTO"), exports);
__exportStar(require("./AccountKeyLinkTransactionBodyDTO"), exports);
__exportStar(require("./AccountKeyLinkTransactionDTO"), exports);
__exportStar(require("./AccountKeyTypeFlagsEnum"), exports);
__exportStar(require("./AccountLinkPublicKeyDTO"), exports);
__exportStar(require("./AccountLinkVotingKeyDTO"), exports);
__exportStar(require("./AccountLinkVotingKeysDTO"), exports);
__exportStar(require("./AccountMetadataTransactionBodyDTO"), exports);
__exportStar(require("./AccountMetadataTransactionDTO"), exports);
__exportStar(require("./AccountMosaicRestrictionTransactionBodyDTO"), exports);
__exportStar(require("./AccountMosaicRestrictionTransactionDTO"), exports);
__exportStar(require("./AccountNamesDTO"), exports);
__exportStar(require("./AccountOperationRestrictionTransactionBodyDTO"), exports);
__exportStar(require("./AccountOperationRestrictionTransactionDTO"), exports);
__exportStar(require("./AccountOrderByEnum"), exports);
__exportStar(require("./AccountPage"), exports);
__exportStar(require("./AccountRestrictionDTO"), exports);
__exportStar(require("./AccountRestrictionFlagsEnum"), exports);
__exportStar(require("./AccountRestrictionNetworkPropertiesDTO"), exports);
__exportStar(require("./AccountRestrictionsDTO"), exports);
__exportStar(require("./AccountRestrictionsInfoDTO"), exports);
__exportStar(require("./AccountTypeEnum"), exports);
__exportStar(require("./AccountsNamesDTO"), exports);
__exportStar(require("./ActivityBucketDTO"), exports);
__exportStar(require("./AddressAliasTransactionBodyDTO"), exports);
__exportStar(require("./AddressAliasTransactionDTO"), exports);
__exportStar(require("./Addresses"), exports);
__exportStar(require("./AggregateNetworkPropertiesDTO"), exports);
__exportStar(require("./AggregateTransactionBodyDTO"), exports);
__exportStar(require("./AggregateTransactionBodyExtendedDTO"), exports);
__exportStar(require("./AggregateTransactionDTO"), exports);
__exportStar(require("./AggregateTransactionExtendedDTO"), exports);
__exportStar(require("./AliasActionEnum"), exports);
__exportStar(require("./AliasDTO"), exports);
__exportStar(require("./AliasTypeEnum"), exports);
__exportStar(require("./AnnounceTransactionInfoDTO"), exports);
__exportStar(require("./BalanceChangeReceiptDTO"), exports);
__exportStar(require("./BalanceChangeReceiptDTOAllOf"), exports);
__exportStar(require("./BalanceTransferReceiptDTO"), exports);
__exportStar(require("./BalanceTransferReceiptDTOAllOf"), exports);
__exportStar(require("./BlockDTO"), exports);
__exportStar(require("./BlockDTOAllOf"), exports);
__exportStar(require("./BlockInfoDTO"), exports);
__exportStar(require("./BlockMetaDTO"), exports);
__exportStar(require("./BlockOrderByEnum"), exports);
__exportStar(require("./BlockPage"), exports);
__exportStar(require("./ChainPropertiesDTO"), exports);
__exportStar(require("./ChainScoreDTO"), exports);
__exportStar(require("./CommunicationTimestampsDTO"), exports);
__exportStar(require("./Cosignature"), exports);
__exportStar(require("./CosignatureDTO"), exports);
__exportStar(require("./CosignatureDTOAllOf"), exports);
__exportStar(require("./EmbeddedAccountAddressRestrictionTransactionDTO"), exports);
__exportStar(require("./EmbeddedAccountKeyLinkTransactionDTO"), exports);
__exportStar(require("./EmbeddedAccountMetadataTransactionDTO"), exports);
__exportStar(require("./EmbeddedAccountMosaicRestrictionTransactionDTO"), exports);
__exportStar(require("./EmbeddedAccountOperationRestrictionTransactionDTO"), exports);
__exportStar(require("./EmbeddedAddressAliasTransactionDTO"), exports);
__exportStar(require("./EmbeddedHashLockTransactionDTO"), exports);
__exportStar(require("./EmbeddedMosaicAddressRestrictionTransactionDTO"), exports);
__exportStar(require("./EmbeddedMosaicAliasTransactionDTO"), exports);
__exportStar(require("./EmbeddedMosaicDefinitionTransactionDTO"), exports);
__exportStar(require("./EmbeddedMosaicGlobalRestrictionTransactionDTO"), exports);
__exportStar(require("./EmbeddedMosaicMetadataTransactionDTO"), exports);
__exportStar(require("./EmbeddedMosaicSupplyChangeTransactionDTO"), exports);
__exportStar(require("./EmbeddedMultisigAccountModificationTransactionDTO"), exports);
__exportStar(require("./EmbeddedNamespaceMetadataTransactionDTO"), exports);
__exportStar(require("./EmbeddedNamespaceRegistrationTransactionDTO"), exports);
__exportStar(require("./EmbeddedNodeKeyLinkTransactionDTO"), exports);
__exportStar(require("./EmbeddedSecretLockTransactionDTO"), exports);
__exportStar(require("./EmbeddedSecretProofTransactionDTO"), exports);
__exportStar(require("./EmbeddedTransactionBodyDTO"), exports);
__exportStar(require("./EmbeddedTransactionDTO"), exports);
__exportStar(require("./EmbeddedTransactionInfoDTO"), exports);
__exportStar(require("./EmbeddedTransactionMetaDTO"), exports);
__exportStar(require("./EmbeddedTransferTransactionDTO"), exports);
__exportStar(require("./EmbeddedVotingKeyLinkTransactionDTO"), exports);
__exportStar(require("./EmbeddedVrfKeyLinkTransactionDTO"), exports);
__exportStar(require("./EntityDTO"), exports);
__exportStar(require("./HashLockNetworkPropertiesDTO"), exports);
__exportStar(require("./HashLockTransactionBodyDTO"), exports);
__exportStar(require("./HashLockTransactionDTO"), exports);
__exportStar(require("./HeightInfoDTO"), exports);
__exportStar(require("./InflationReceiptDTO"), exports);
__exportStar(require("./InflationReceiptDTOAllOf"), exports);
__exportStar(require("./LinkActionEnum"), exports);
__exportStar(require("./LockHashAlgorithmEnum"), exports);
__exportStar(require("./MerklePathItemDTO"), exports);
__exportStar(require("./MerkleProofInfoDTO"), exports);
__exportStar(require("./MessageDTO"), exports);
__exportStar(require("./MessageTypeEnum"), exports);
__exportStar(require("./MetadataEntryDTO"), exports);
__exportStar(require("./MetadataInfoDTO"), exports);
__exportStar(require("./MetadataNetworkPropertiesDTO"), exports);
__exportStar(require("./MetadataPage"), exports);
__exportStar(require("./MetadataTypeEnum"), exports);
__exportStar(require("./ModelError"), exports);
__exportStar(require("./Mosaic"), exports);
__exportStar(require("./MosaicAddressRestrictionDTO"), exports);
__exportStar(require("./MosaicAddressRestrictionEntryDTO"), exports);
__exportStar(require("./MosaicAddressRestrictionEntryWrapperDTO"), exports);
__exportStar(require("./MosaicAddressRestrictionTransactionBodyDTO"), exports);
__exportStar(require("./MosaicAddressRestrictionTransactionDTO"), exports);
__exportStar(require("./MosaicAliasTransactionBodyDTO"), exports);
__exportStar(require("./MosaicAliasTransactionDTO"), exports);
__exportStar(require("./MosaicDTO"), exports);
__exportStar(require("./MosaicDefinitionTransactionBodyDTO"), exports);
__exportStar(require("./MosaicDefinitionTransactionDTO"), exports);
__exportStar(require("./MosaicExpiryReceiptDTO"), exports);
__exportStar(require("./MosaicExpiryReceiptDTOAllOf"), exports);
__exportStar(require("./MosaicGlobalRestrictionDTO"), exports);
__exportStar(require("./MosaicGlobalRestrictionEntryDTO"), exports);
__exportStar(require("./MosaicGlobalRestrictionEntryRestrictionDTO"), exports);
__exportStar(require("./MosaicGlobalRestrictionEntryWrapperDTO"), exports);
__exportStar(require("./MosaicGlobalRestrictionTransactionBodyDTO"), exports);
__exportStar(require("./MosaicGlobalRestrictionTransactionDTO"), exports);
__exportStar(require("./MosaicIds"), exports);
__exportStar(require("./MosaicInfoDTO"), exports);
__exportStar(require("./MosaicMetadataTransactionBodyDTO"), exports);
__exportStar(require("./MosaicMetadataTransactionDTO"), exports);
__exportStar(require("./MosaicNamesDTO"), exports);
__exportStar(require("./MosaicNetworkPropertiesDTO"), exports);
__exportStar(require("./MosaicPage"), exports);
__exportStar(require("./MosaicRestrictionEntryTypeEnum"), exports);
__exportStar(require("./MosaicRestrictionNetworkPropertiesDTO"), exports);
__exportStar(require("./MosaicRestrictionTypeEnum"), exports);
__exportStar(require("./MosaicSupplyChangeActionEnum"), exports);
__exportStar(require("./MosaicSupplyChangeTransactionBodyDTO"), exports);
__exportStar(require("./MosaicSupplyChangeTransactionDTO"), exports);
__exportStar(require("./MosaicsNamesDTO"), exports);
__exportStar(require("./MultisigAccountGraphInfoDTO"), exports);
__exportStar(require("./MultisigAccountInfoDTO"), exports);
__exportStar(require("./MultisigAccountModificationTransactionBodyDTO"), exports);
__exportStar(require("./MultisigAccountModificationTransactionDTO"), exports);
__exportStar(require("./MultisigDTO"), exports);
__exportStar(require("./MultisigNetworkPropertiesDTO"), exports);
__exportStar(require("./NamespaceDTO"), exports);
__exportStar(require("./NamespaceExpiryReceiptDTO"), exports);
__exportStar(require("./NamespaceExpiryReceiptDTOAllOf"), exports);
__exportStar(require("./NamespaceIds"), exports);
__exportStar(require("./NamespaceInfoDTO"), exports);
__exportStar(require("./NamespaceMetaDTO"), exports);
__exportStar(require("./NamespaceMetadataTransactionBodyDTO"), exports);
__exportStar(require("./NamespaceMetadataTransactionDTO"), exports);
__exportStar(require("./NamespaceNameDTO"), exports);
__exportStar(require("./NamespaceNetworkPropertiesDTO"), exports);
__exportStar(require("./NamespacePage"), exports);
__exportStar(require("./NamespaceRegistrationTransactionBodyDTO"), exports);
__exportStar(require("./NamespaceRegistrationTransactionDTO"), exports);
__exportStar(require("./NamespaceRegistrationTypeEnum"), exports);
__exportStar(require("./NetworkConfigurationDTO"), exports);
__exportStar(require("./NetworkPropertiesDTO"), exports);
__exportStar(require("./NetworkTypeDTO"), exports);
__exportStar(require("./NetworkTypeEnum"), exports);
__exportStar(require("./NodeHealthDTO"), exports);
__exportStar(require("./NodeHealthInfoDTO"), exports);
__exportStar(require("./NodeIdentityEqualityStrategy"), exports);
__exportStar(require("./NodeInfoDTO"), exports);
__exportStar(require("./NodeKeyLinkNetworkPropertiesDTO"), exports);
__exportStar(require("./NodeKeyLinkTransactionBodyDTO"), exports);
__exportStar(require("./NodeKeyLinkTransactionDTO"), exports);
__exportStar(require("./NodeStatusEnum"), exports);
__exportStar(require("./NodeTimeDTO"), exports);
__exportStar(require("./Order"), exports);
__exportStar(require("./Pagination"), exports);
__exportStar(require("./PluginsPropertiesDTO"), exports);
__exportStar(require("./PositionEnum"), exports);
__exportStar(require("./ReceiptDTO"), exports);
__exportStar(require("./ReceiptTypeEnum"), exports);
__exportStar(require("./RentalFeesDTO"), exports);
__exportStar(require("./ResolutionEntryDTO"), exports);
__exportStar(require("./ResolutionStatementDTO"), exports);
__exportStar(require("./ResolutionStatementInfoDTO"), exports);
__exportStar(require("./ResolutionStatementPage"), exports);
__exportStar(require("./RolesTypeEnum"), exports);
__exportStar(require("./SecretLockNetworkPropertiesDTO"), exports);
__exportStar(require("./SecretLockTransactionBodyDTO"), exports);
__exportStar(require("./SecretLockTransactionDTO"), exports);
__exportStar(require("./SecretProofTransactionBodyDTO"), exports);
__exportStar(require("./SecretProofTransactionDTO"), exports);
__exportStar(require("./ServerDTO"), exports);
__exportStar(require("./ServerInfoDTO"), exports);
__exportStar(require("./SizePrefixedEntityDTO"), exports);
__exportStar(require("./SourceDTO"), exports);
__exportStar(require("./StorageInfoDTO"), exports);
__exportStar(require("./SupplementalPublicKeysDTO"), exports);
__exportStar(require("./TransactionBodyDTO"), exports);
__exportStar(require("./TransactionDTO"), exports);
__exportStar(require("./TransactionFeesDTO"), exports);
__exportStar(require("./TransactionGroupEnum"), exports);
__exportStar(require("./TransactionHashes"), exports);
__exportStar(require("./TransactionIds"), exports);
__exportStar(require("./TransactionInfoDTO"), exports);
__exportStar(require("./TransactionMetaDTO"), exports);
__exportStar(require("./TransactionPage"), exports);
__exportStar(require("./TransactionPayload"), exports);
__exportStar(require("./TransactionStatementDTO"), exports);
__exportStar(require("./TransactionStatementInfoDTO"), exports);
__exportStar(require("./TransactionStatementPage"), exports);
__exportStar(require("./TransactionStatusDTO"), exports);
__exportStar(require("./TransactionStatusEnum"), exports);
__exportStar(require("./TransactionTypeEnum"), exports);
__exportStar(require("./TransferNetworkPropertiesDTO"), exports);
__exportStar(require("./TransferTransactionBodyDTO"), exports);
__exportStar(require("./TransferTransactionDTO"), exports);
__exportStar(require("./UnresolvedMosaic"), exports);
__exportStar(require("./VerifiableEntityDTO"), exports);
__exportStar(require("./VotingKeyLinkNetworkPropertiesDTO"), exports);
__exportStar(require("./VotingKeyLinkTransactionBodyDTO"), exports);
__exportStar(require("./VotingKeyLinkTransactionDTO"), exports);
__exportStar(require("./VrfKeyLinkNetworkPropertiesDTO"), exports);
__exportStar(require("./VrfKeyLinkTransactionBodyDTO"), exports);
__exportStar(require("./VrfKeyLinkTransactionDTO"), exports);

},{"./AccountAddressRestrictionTransactionBodyDTO":939,"./AccountAddressRestrictionTransactionDTO":940,"./AccountDTO":941,"./AccountIds":942,"./AccountInfoDTO":943,"./AccountKeyLinkNetworkPropertiesDTO":944,"./AccountKeyLinkTransactionBodyDTO":945,"./AccountKeyLinkTransactionDTO":946,"./AccountKeyTypeFlagsEnum":947,"./AccountLinkPublicKeyDTO":948,"./AccountLinkVotingKeyDTO":949,"./AccountLinkVotingKeysDTO":950,"./AccountMetadataTransactionBodyDTO":951,"./AccountMetadataTransactionDTO":952,"./AccountMosaicRestrictionTransactionBodyDTO":953,"./AccountMosaicRestrictionTransactionDTO":954,"./AccountNamesDTO":955,"./AccountOperationRestrictionTransactionBodyDTO":956,"./AccountOperationRestrictionTransactionDTO":957,"./AccountOrderByEnum":958,"./AccountPage":959,"./AccountRestrictionDTO":960,"./AccountRestrictionFlagsEnum":961,"./AccountRestrictionNetworkPropertiesDTO":962,"./AccountRestrictionsDTO":963,"./AccountRestrictionsInfoDTO":964,"./AccountTypeEnum":965,"./AccountsNamesDTO":966,"./ActivityBucketDTO":967,"./AddressAliasTransactionBodyDTO":968,"./AddressAliasTransactionDTO":969,"./Addresses":970,"./AggregateNetworkPropertiesDTO":971,"./AggregateTransactionBodyDTO":972,"./AggregateTransactionBodyExtendedDTO":973,"./AggregateTransactionDTO":974,"./AggregateTransactionExtendedDTO":975,"./AliasActionEnum":976,"./AliasDTO":977,"./AliasTypeEnum":978,"./AnnounceTransactionInfoDTO":979,"./BalanceChangeReceiptDTO":980,"./BalanceChangeReceiptDTOAllOf":981,"./BalanceTransferReceiptDTO":982,"./BalanceTransferReceiptDTOAllOf":983,"./BlockDTO":984,"./BlockDTOAllOf":985,"./BlockInfoDTO":986,"./BlockMetaDTO":987,"./BlockOrderByEnum":988,"./BlockPage":989,"./ChainPropertiesDTO":990,"./ChainScoreDTO":991,"./CommunicationTimestampsDTO":992,"./Cosignature":993,"./CosignatureDTO":994,"./CosignatureDTOAllOf":995,"./EmbeddedAccountAddressRestrictionTransactionDTO":996,"./EmbeddedAccountKeyLinkTransactionDTO":997,"./EmbeddedAccountMetadataTransactionDTO":998,"./EmbeddedAccountMosaicRestrictionTransactionDTO":999,"./EmbeddedAccountOperationRestrictionTransactionDTO":1000,"./EmbeddedAddressAliasTransactionDTO":1001,"./EmbeddedHashLockTransactionDTO":1002,"./EmbeddedMosaicAddressRestrictionTransactionDTO":1003,"./EmbeddedMosaicAliasTransactionDTO":1004,"./EmbeddedMosaicDefinitionTransactionDTO":1005,"./EmbeddedMosaicGlobalRestrictionTransactionDTO":1006,"./EmbeddedMosaicMetadataTransactionDTO":1007,"./EmbeddedMosaicSupplyChangeTransactionDTO":1008,"./EmbeddedMultisigAccountModificationTransactionDTO":1009,"./EmbeddedNamespaceMetadataTransactionDTO":1010,"./EmbeddedNamespaceRegistrationTransactionDTO":1011,"./EmbeddedNodeKeyLinkTransactionDTO":1012,"./EmbeddedSecretLockTransactionDTO":1013,"./EmbeddedSecretProofTransactionDTO":1014,"./EmbeddedTransactionBodyDTO":1015,"./EmbeddedTransactionDTO":1016,"./EmbeddedTransactionInfoDTO":1017,"./EmbeddedTransactionMetaDTO":1018,"./EmbeddedTransferTransactionDTO":1019,"./EmbeddedVotingKeyLinkTransactionDTO":1020,"./EmbeddedVrfKeyLinkTransactionDTO":1021,"./EntityDTO":1022,"./HashLockNetworkPropertiesDTO":1023,"./HashLockTransactionBodyDTO":1024,"./HashLockTransactionDTO":1025,"./HeightInfoDTO":1026,"./InflationReceiptDTO":1027,"./InflationReceiptDTOAllOf":1028,"./LinkActionEnum":1029,"./LockHashAlgorithmEnum":1030,"./MerklePathItemDTO":1031,"./MerkleProofInfoDTO":1032,"./MessageDTO":1033,"./MessageTypeEnum":1034,"./MetadataEntryDTO":1035,"./MetadataInfoDTO":1036,"./MetadataNetworkPropertiesDTO":1037,"./MetadataPage":1038,"./MetadataTypeEnum":1039,"./ModelError":1040,"./Mosaic":1041,"./MosaicAddressRestrictionDTO":1042,"./MosaicAddressRestrictionEntryDTO":1043,"./MosaicAddressRestrictionEntryWrapperDTO":1044,"./MosaicAddressRestrictionTransactionBodyDTO":1045,"./MosaicAddressRestrictionTransactionDTO":1046,"./MosaicAliasTransactionBodyDTO":1047,"./MosaicAliasTransactionDTO":1048,"./MosaicDTO":1049,"./MosaicDefinitionTransactionBodyDTO":1050,"./MosaicDefinitionTransactionDTO":1051,"./MosaicExpiryReceiptDTO":1052,"./MosaicExpiryReceiptDTOAllOf":1053,"./MosaicGlobalRestrictionDTO":1054,"./MosaicGlobalRestrictionEntryDTO":1055,"./MosaicGlobalRestrictionEntryRestrictionDTO":1056,"./MosaicGlobalRestrictionEntryWrapperDTO":1057,"./MosaicGlobalRestrictionTransactionBodyDTO":1058,"./MosaicGlobalRestrictionTransactionDTO":1059,"./MosaicIds":1060,"./MosaicInfoDTO":1061,"./MosaicMetadataTransactionBodyDTO":1062,"./MosaicMetadataTransactionDTO":1063,"./MosaicNamesDTO":1064,"./MosaicNetworkPropertiesDTO":1065,"./MosaicPage":1066,"./MosaicRestrictionEntryTypeEnum":1067,"./MosaicRestrictionNetworkPropertiesDTO":1068,"./MosaicRestrictionTypeEnum":1069,"./MosaicSupplyChangeActionEnum":1070,"./MosaicSupplyChangeTransactionBodyDTO":1071,"./MosaicSupplyChangeTransactionDTO":1072,"./MosaicsNamesDTO":1073,"./MultisigAccountGraphInfoDTO":1074,"./MultisigAccountInfoDTO":1075,"./MultisigAccountModificationTransactionBodyDTO":1076,"./MultisigAccountModificationTransactionDTO":1077,"./MultisigDTO":1078,"./MultisigNetworkPropertiesDTO":1079,"./NamespaceDTO":1080,"./NamespaceExpiryReceiptDTO":1081,"./NamespaceExpiryReceiptDTOAllOf":1082,"./NamespaceIds":1083,"./NamespaceInfoDTO":1084,"./NamespaceMetaDTO":1085,"./NamespaceMetadataTransactionBodyDTO":1086,"./NamespaceMetadataTransactionDTO":1087,"./NamespaceNameDTO":1088,"./NamespaceNetworkPropertiesDTO":1089,"./NamespacePage":1090,"./NamespaceRegistrationTransactionBodyDTO":1091,"./NamespaceRegistrationTransactionDTO":1092,"./NamespaceRegistrationTypeEnum":1093,"./NetworkConfigurationDTO":1094,"./NetworkPropertiesDTO":1095,"./NetworkTypeDTO":1096,"./NetworkTypeEnum":1097,"./NodeHealthDTO":1098,"./NodeHealthInfoDTO":1099,"./NodeIdentityEqualityStrategy":1100,"./NodeInfoDTO":1101,"./NodeKeyLinkNetworkPropertiesDTO":1102,"./NodeKeyLinkTransactionBodyDTO":1103,"./NodeKeyLinkTransactionDTO":1104,"./NodeStatusEnum":1105,"./NodeTimeDTO":1106,"./Order":1107,"./Pagination":1108,"./PluginsPropertiesDTO":1109,"./PositionEnum":1110,"./ReceiptDTO":1111,"./ReceiptTypeEnum":1112,"./RentalFeesDTO":1113,"./ResolutionEntryDTO":1114,"./ResolutionStatementDTO":1115,"./ResolutionStatementInfoDTO":1116,"./ResolutionStatementPage":1117,"./RolesTypeEnum":1118,"./SecretLockNetworkPropertiesDTO":1119,"./SecretLockTransactionBodyDTO":1120,"./SecretLockTransactionDTO":1121,"./SecretProofTransactionBodyDTO":1122,"./SecretProofTransactionDTO":1123,"./ServerDTO":1124,"./ServerInfoDTO":1125,"./SizePrefixedEntityDTO":1126,"./SourceDTO":1127,"./StorageInfoDTO":1128,"./SupplementalPublicKeysDTO":1129,"./TransactionBodyDTO":1130,"./TransactionDTO":1131,"./TransactionFeesDTO":1132,"./TransactionGroupEnum":1133,"./TransactionHashes":1134,"./TransactionIds":1135,"./TransactionInfoDTO":1136,"./TransactionMetaDTO":1137,"./TransactionPage":1138,"./TransactionPayload":1139,"./TransactionStatementDTO":1140,"./TransactionStatementInfoDTO":1141,"./TransactionStatementPage":1142,"./TransactionStatusDTO":1143,"./TransactionStatusEnum":1144,"./TransactionTypeEnum":1145,"./TransferNetworkPropertiesDTO":1146,"./TransferTransactionBodyDTO":1147,"./TransferTransactionDTO":1148,"./UnresolvedMosaic":1149,"./VerifiableEntityDTO":1150,"./VotingKeyLinkNetworkPropertiesDTO":1151,"./VotingKeyLinkTransactionBodyDTO":1152,"./VotingKeyLinkTransactionDTO":1153,"./VrfKeyLinkNetworkPropertiesDTO":1154,"./VrfKeyLinkTransactionBodyDTO":1155,"./VrfKeyLinkTransactionDTO":1156}],1158:[function(require,module,exports){
"use strict";
/* tslint:disable */
/* eslint-disable */
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest 1.2.0
 *
 * The version of the OpenAPI document: 0.9.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.Configuration = exports.COLLECTION_FORMATS = exports.RequiredError = exports.BaseAPI = exports.BASE_PATH = void 0;
exports.BASE_PATH = "http://localhost:3000".replace(/\/+$/, "");
const isBlob = (value) => typeof Blob !== 'undefined' && value instanceof Blob;
/**
 * This is the base class for all generated API classes.
 */
class BaseAPI {
    constructor(configuration = new Configuration()) {
        this.configuration = configuration;
        this.fetchApi = (url, init) => __awaiter(this, void 0, void 0, function* () {
            let fetchParams = { url, init };
            for (const middleware of this.middleware) {
                if (middleware.pre) {
                    fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;
                }
            }
            let response = yield this.configuration.fetchApi(fetchParams.url, fetchParams.init);
            for (const middleware of this.middleware) {
                if (middleware.post) {
                    response = (yield middleware.post({
                        fetch: this.fetchApi,
                        url,
                        init,
                        response: response.clone(),
                    })) || response;
                }
            }
            return response;
        });
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre) => ({ pre }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post) => ({ post }));
        return this.withMiddleware(...middlewares);
    }
    request(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const { url, init } = this.createFetchParams(context);
            const response = yield this.fetchApi(url, init);
            if (response.status >= 200 && response.status < 300) {
                return response;
            }
            throw response;
        });
    }
    createFetchParams(context) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }
        const body = ((typeof FormData !== "undefined" && context.body instanceof FormData) || context.body instanceof URLSearchParams || isBlob(context.body))
            ? context.body
            : JSON.stringify(context.body);
        const headers = Object.assign({}, this.configuration.headers, context.headers);
        const init = {
            method: context.method,
            headers: headers,
            body,
            credentials: this.configuration.credentials
        };
        return { url, init };
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
    clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}
exports.BaseAPI = BaseAPI;
;
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
class Configuration {
    constructor(configuration = {}) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
    }
    get fetchApi() {
        return this.configuration.fetchApi || window.fetch.bind(window);
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : () => apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : () => accessToken;
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
}
exports.Configuration = Configuration;
function exists(json, key) {
    const value = json[key];
    return value !== null && value !== undefined;
}
exports.exists = exists;
function querystring(params, prefix = '') {
    return Object.keys(params)
        .map((key) => {
        const fullKey = prefix + (prefix.length ? `[${key}]` : key);
        const value = params[key];
        if (value instanceof Array) {
            const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))
                .join(`&${encodeURIComponent(fullKey)}=`);
            return `${encodeURIComponent(fullKey)}=${multiValue}`;
        }
        if (value instanceof Object) {
            return querystring(value, fullKey);
        }
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
    })
        .filter(part => part.length > 0)
        .join('&');
}
exports.querystring = querystring;
function mapValues(data, fn) {
    return Object.keys(data).reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: fn(data[key]) })), {});
}
exports.mapValues = mapValues;
function canConsumeForm(consumes) {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
exports.canConsumeForm = canConsumeForm;
class JSONApiResponse {
    constructor(raw, transformer = (jsonValue) => jsonValue) {
        this.raw = raw;
        this.transformer = transformer;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.transformer(yield this.raw.json());
        });
    }
}
exports.JSONApiResponse = JSONApiResponse;
class VoidApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return undefined;
        });
    }
}
exports.VoidApiResponse = VoidApiResponse;
class BlobApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.raw.blob();
        });
    }
    ;
}
exports.BlobApiResponse = BlobApiResponse;
class TextApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.raw.text();
        });
    }
    ;
}
exports.TextApiResponse = TextApiResponse;

},{}],1159:[function(require,module,exports){
/*! https://mths.be/utf8js v3.0.0 by @mathias */
;(function(root) {

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	root.version = '3.0.0';
	root.encode = utf8encode;
	root.decode = utf8decode;

}(typeof exports === 'undefined' ? this.utf8 = {} : exports));

},{}],1160:[function(require,module,exports){
(function(nacl) {
'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = Math.floor((x[j] + 128) / 256);
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  return n;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES,

  gf: gf,
  D: D,
  L: L,
  pack25519: pack25519,
  unpack25519: unpack25519,
  M: M,
  A: A,
  S: S,
  Z: Z,
  pow2523: pow2523,
  add: add,
  set25519: set25519,
  modL: modL,
  scalarmult: scalarmult,
  scalarbase: scalarbase,
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var i = 0; i < arguments.length; i++) {
    if (!(arguments[i] instanceof Uint8Array))
      throw new TypeError('unexpected type, use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (typeof require !== 'undefined') {
    // Node.js.
    crypto = require('crypto');
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})(typeof module !== 'undefined' && module.exports ? module.exports : (self.nacl = self.nacl || {}));

},{"crypto":18}],1161:[function(require,module,exports){
'use strict';

module.exports = function() {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};

},{}],"/node_modules/buffer":[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,require("buffer").Buffer)
},{"base64-js":156,"buffer":47,"ieee754":344}],"/node_modules/catbuffer-typescript":[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./AmountDto"), exports);
__exportStar(require("./BlockDurationDto"), exports);
__exportStar(require("./BlockFeeMultiplierDto"), exports);
__exportStar(require("./DifficultyDto"), exports);
__exportStar(require("./HeightDto"), exports);
__exportStar(require("./ImportanceDto"), exports);
__exportStar(require("./ImportanceHeightDto"), exports);
__exportStar(require("./UnresolvedMosaicIdDto"), exports);
__exportStar(require("./MosaicIdDto"), exports);
__exportStar(require("./TimestampDto"), exports);
__exportStar(require("./UnresolvedAddressDto"), exports);
__exportStar(require("./AddressDto"), exports);
__exportStar(require("./Hash256Dto"), exports);
__exportStar(require("./Hash512Dto"), exports);
__exportStar(require("./KeyDto"), exports);
__exportStar(require("./VotingKeyDto"), exports);
__exportStar(require("./SignatureDto"), exports);
__exportStar(require("./MosaicBuilder"), exports);
__exportStar(require("./UnresolvedMosaicBuilder"), exports);
__exportStar(require("./ProofGammaDto"), exports);
__exportStar(require("./ProofVerificationHashDto"), exports);
__exportStar(require("./ProofScalarDto"), exports);
__exportStar(require("./VrfProofBuilder"), exports);
__exportStar(require("./BlockHeaderBuilder"), exports);
__exportStar(require("./ReceiptBuilder"), exports);
__exportStar(require("./BalanceTransferReceiptBuilder"), exports);
__exportStar(require("./BalanceChangeReceiptBuilder"), exports);
__exportStar(require("./InflationReceiptBuilder"), exports);
__exportStar(require("./MosaicExpiryReceiptBuilder"), exports);
__exportStar(require("./NamespaceIdDto"), exports);
__exportStar(require("./NamespaceExpiryReceiptBuilder"), exports);
__exportStar(require("./ReceiptSourceBuilder"), exports);
__exportStar(require("./AddressResolutionEntryBuilder"), exports);
__exportStar(require("./MosaicResolutionEntryBuilder"), exports);
__exportStar(require("./MosaicResolutionStatementBuilder"), exports);
__exportStar(require("./AddressResolutionStatementBuilder"), exports);
__exportStar(require("./ImportanceSnapshotBuilder"), exports);
__exportStar(require("./HeightActivityBucketBuilder"), exports);
__exportStar(require("./HeightActivityBucketsBuilder"), exports);
__exportStar(require("./AccountStateBuilder"), exports);
__exportStar(require("./HashLockInfoBuilder"), exports);
__exportStar(require("./ScopedMetadataKeyDto"), exports);
__exportStar(require("./MetadataValueBuilder"), exports);
__exportStar(require("./MetadataEntryBuilder"), exports);
__exportStar(require("./MosaicNonceDto"), exports);
__exportStar(require("./MosaicPropertiesBuilder"), exports);
__exportStar(require("./MosaicDefinitionBuilder"), exports);
__exportStar(require("./MosaicEntryBuilder"), exports);
__exportStar(require("./MultisigEntryBuilder"), exports);
__exportStar(require("./TransactionBuilder"), exports);
__exportStar(require("./EmbeddedTransactionBuilder"), exports);
__exportStar(require("./MosaicDefinitionTransactionBodyBuilder"), exports);
__exportStar(require("./MosaicDefinitionTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMosaicDefinitionTransactionBuilder"), exports);
__exportStar(require("./NamespaceLifetimeBuilder"), exports);
__exportStar(require("./NamespaceAliasBuilder"), exports);
__exportStar(require("./NamespacePathBuilder"), exports);
__exportStar(require("./RootNamespaceHistoryBuilder"), exports);
__exportStar(require("./AccountRestrictionAddressValueBuilder"), exports);
__exportStar(require("./AccountRestrictionMosaicValueBuilder"), exports);
__exportStar(require("./AccountRestrictionTransactionTypeValueBuilder"), exports);
__exportStar(require("./AccountRestrictionsInfoBuilder"), exports);
__exportStar(require("./AccountRestrictionsBuilder"), exports);
__exportStar(require("./MosaicRestrictionKeyDto"), exports);
__exportStar(require("./AddressKeyValueBuilder"), exports);
__exportStar(require("./AddressKeyValueSetBuilder"), exports);
__exportStar(require("./RestrictionRuleBuilder"), exports);
__exportStar(require("./GlobalKeyValueBuilder"), exports);
__exportStar(require("./GlobalKeyValueSetBuilder"), exports);
__exportStar(require("./MosaicAddressRestrictionEntryBuilder"), exports);
__exportStar(require("./MosaicGlobalRestrictionEntryBuilder"), exports);
__exportStar(require("./MosaicRestrictionEntryBuilder"), exports);
__exportStar(require("./SecretLockInfoBuilder"), exports);
__exportStar(require("./AccountKeyLinkTransactionBodyBuilder"), exports);
__exportStar(require("./AccountKeyLinkTransactionBuilder"), exports);
__exportStar(require("./EmbeddedAccountKeyLinkTransactionBuilder"), exports);
__exportStar(require("./NodeKeyLinkTransactionBodyBuilder"), exports);
__exportStar(require("./NodeKeyLinkTransactionBuilder"), exports);
__exportStar(require("./EmbeddedNodeKeyLinkTransactionBuilder"), exports);
__exportStar(require("./CosignatureBuilder"), exports);
__exportStar(require("./DetachedCosignatureBuilder"), exports);
__exportStar(require("./AggregateTransactionBodyBuilder"), exports);
__exportStar(require("./AggregateCompleteTransactionBuilder"), exports);
__exportStar(require("./AggregateBondedTransactionBuilder"), exports);
__exportStar(require("./VotingKeyLinkTransactionBodyBuilder"), exports);
__exportStar(require("./VotingKeyLinkTransactionBuilder"), exports);
__exportStar(require("./EmbeddedVotingKeyLinkTransactionBuilder"), exports);
__exportStar(require("./VrfKeyLinkTransactionBodyBuilder"), exports);
__exportStar(require("./VrfKeyLinkTransactionBuilder"), exports);
__exportStar(require("./EmbeddedVrfKeyLinkTransactionBuilder"), exports);
__exportStar(require("./HashLockTransactionBodyBuilder"), exports);
__exportStar(require("./HashLockTransactionBuilder"), exports);
__exportStar(require("./EmbeddedHashLockTransactionBuilder"), exports);
__exportStar(require("./SecretLockTransactionBodyBuilder"), exports);
__exportStar(require("./SecretLockTransactionBuilder"), exports);
__exportStar(require("./EmbeddedSecretLockTransactionBuilder"), exports);
__exportStar(require("./SecretProofTransactionBodyBuilder"), exports);
__exportStar(require("./SecretProofTransactionBuilder"), exports);
__exportStar(require("./EmbeddedSecretProofTransactionBuilder"), exports);
__exportStar(require("./AccountMetadataTransactionBodyBuilder"), exports);
__exportStar(require("./AccountMetadataTransactionBuilder"), exports);
__exportStar(require("./EmbeddedAccountMetadataTransactionBuilder"), exports);
__exportStar(require("./MosaicMetadataTransactionBodyBuilder"), exports);
__exportStar(require("./MosaicMetadataTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMosaicMetadataTransactionBuilder"), exports);
__exportStar(require("./NamespaceMetadataTransactionBodyBuilder"), exports);
__exportStar(require("./NamespaceMetadataTransactionBuilder"), exports);
__exportStar(require("./EmbeddedNamespaceMetadataTransactionBuilder"), exports);
__exportStar(require("./MosaicSupplyChangeTransactionBodyBuilder"), exports);
__exportStar(require("./MosaicSupplyChangeTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMosaicSupplyChangeTransactionBuilder"), exports);
__exportStar(require("./MultisigAccountModificationTransactionBodyBuilder"), exports);
__exportStar(require("./MultisigAccountModificationTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMultisigAccountModificationTransactionBuilder"), exports);
__exportStar(require("./AddressAliasTransactionBodyBuilder"), exports);
__exportStar(require("./AddressAliasTransactionBuilder"), exports);
__exportStar(require("./EmbeddedAddressAliasTransactionBuilder"), exports);
__exportStar(require("./MosaicAliasTransactionBodyBuilder"), exports);
__exportStar(require("./MosaicAliasTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMosaicAliasTransactionBuilder"), exports);
__exportStar(require("./NamespaceRegistrationTransactionBodyBuilder"), exports);
__exportStar(require("./NamespaceRegistrationTransactionBuilder"), exports);
__exportStar(require("./EmbeddedNamespaceRegistrationTransactionBuilder"), exports);
__exportStar(require("./AccountAddressRestrictionTransactionBodyBuilder"), exports);
__exportStar(require("./AccountAddressRestrictionTransactionBuilder"), exports);
__exportStar(require("./EmbeddedAccountAddressRestrictionTransactionBuilder"), exports);
__exportStar(require("./AccountMosaicRestrictionTransactionBodyBuilder"), exports);
__exportStar(require("./AccountMosaicRestrictionTransactionBuilder"), exports);
__exportStar(require("./EmbeddedAccountMosaicRestrictionTransactionBuilder"), exports);
__exportStar(require("./AccountOperationRestrictionTransactionBodyBuilder"), exports);
__exportStar(require("./AccountOperationRestrictionTransactionBuilder"), exports);
__exportStar(require("./EmbeddedAccountOperationRestrictionTransactionBuilder"), exports);
__exportStar(require("./MosaicAddressRestrictionTransactionBodyBuilder"), exports);
__exportStar(require("./MosaicAddressRestrictionTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMosaicAddressRestrictionTransactionBuilder"), exports);
__exportStar(require("./MosaicGlobalRestrictionTransactionBodyBuilder"), exports);
__exportStar(require("./MosaicGlobalRestrictionTransactionBuilder"), exports);
__exportStar(require("./EmbeddedMosaicGlobalRestrictionTransactionBuilder"), exports);
__exportStar(require("./TransferTransactionBodyBuilder"), exports);
__exportStar(require("./TransferTransactionBuilder"), exports);
__exportStar(require("./EmbeddedTransferTransactionBuilder"), exports);
__exportStar(require("./EmbeddedTransactionHelper"), exports);
__exportStar(require("./TransactionHelper"), exports);
__exportStar(require("./GeneratorUtils"), exports);

},{"./AccountAddressRestrictionTransactionBodyBuilder":157,"./AccountAddressRestrictionTransactionBuilder":158,"./AccountKeyLinkTransactionBodyBuilder":160,"./AccountKeyLinkTransactionBuilder":161,"./AccountMetadataTransactionBodyBuilder":162,"./AccountMetadataTransactionBuilder":163,"./AccountMosaicRestrictionTransactionBodyBuilder":164,"./AccountMosaicRestrictionTransactionBuilder":165,"./AccountOperationRestrictionTransactionBodyBuilder":166,"./AccountOperationRestrictionTransactionBuilder":167,"./AccountRestrictionAddressValueBuilder":168,"./AccountRestrictionMosaicValueBuilder":170,"./AccountRestrictionTransactionTypeValueBuilder":171,"./AccountRestrictionsBuilder":172,"./AccountRestrictionsInfoBuilder":173,"./AccountStateBuilder":174,"./AddressAliasTransactionBodyBuilder":176,"./AddressAliasTransactionBuilder":177,"./AddressDto":178,"./AddressKeyValueBuilder":179,"./AddressKeyValueSetBuilder":180,"./AddressResolutionEntryBuilder":181,"./AddressResolutionStatementBuilder":182,"./AggregateBondedTransactionBuilder":183,"./AggregateCompleteTransactionBuilder":184,"./AggregateTransactionBodyBuilder":185,"./AmountDto":186,"./BalanceChangeReceiptBuilder":187,"./BalanceTransferReceiptBuilder":188,"./BlockDurationDto":189,"./BlockFeeMultiplierDto":190,"./BlockHeaderBuilder":191,"./CosignatureBuilder":192,"./DetachedCosignatureBuilder":193,"./DifficultyDto":194,"./EmbeddedAccountAddressRestrictionTransactionBuilder":195,"./EmbeddedAccountKeyLinkTransactionBuilder":196,"./EmbeddedAccountMetadataTransactionBuilder":197,"./EmbeddedAccountMosaicRestrictionTransactionBuilder":198,"./EmbeddedAccountOperationRestrictionTransactionBuilder":199,"./EmbeddedAddressAliasTransactionBuilder":200,"./EmbeddedHashLockTransactionBuilder":201,"./EmbeddedMosaicAddressRestrictionTransactionBuilder":202,"./EmbeddedMosaicAliasTransactionBuilder":203,"./EmbeddedMosaicDefinitionTransactionBuilder":204,"./EmbeddedMosaicGlobalRestrictionTransactionBuilder":205,"./EmbeddedMosaicMetadataTransactionBuilder":206,"./EmbeddedMosaicSupplyChangeTransactionBuilder":207,"./EmbeddedMultisigAccountModificationTransactionBuilder":208,"./EmbeddedNamespaceMetadataTransactionBuilder":209,"./EmbeddedNamespaceRegistrationTransactionBuilder":210,"./EmbeddedNodeKeyLinkTransactionBuilder":211,"./EmbeddedSecretLockTransactionBuilder":212,"./EmbeddedSecretProofTransactionBuilder":213,"./EmbeddedTransactionBuilder":214,"./EmbeddedTransactionHelper":215,"./EmbeddedTransferTransactionBuilder":216,"./EmbeddedVotingKeyLinkTransactionBuilder":217,"./EmbeddedVrfKeyLinkTransactionBuilder":218,"./GeneratorUtils":220,"./GlobalKeyValueBuilder":221,"./GlobalKeyValueSetBuilder":222,"./Hash256Dto":223,"./Hash512Dto":224,"./HashLockInfoBuilder":225,"./HashLockTransactionBodyBuilder":226,"./HashLockTransactionBuilder":227,"./HeightActivityBucketBuilder":228,"./HeightActivityBucketsBuilder":229,"./HeightDto":230,"./ImportanceDto":231,"./ImportanceHeightDto":232,"./ImportanceSnapshotBuilder":233,"./InflationReceiptBuilder":234,"./KeyDto":235,"./MetadataEntryBuilder":236,"./MetadataValueBuilder":237,"./MosaicAddressRestrictionEntryBuilder":238,"./MosaicAddressRestrictionTransactionBodyBuilder":239,"./MosaicAddressRestrictionTransactionBuilder":240,"./MosaicAliasTransactionBodyBuilder":241,"./MosaicAliasTransactionBuilder":242,"./MosaicBuilder":243,"./MosaicDefinitionBuilder":244,"./MosaicDefinitionTransactionBodyBuilder":245,"./MosaicDefinitionTransactionBuilder":246,"./MosaicEntryBuilder":247,"./MosaicExpiryReceiptBuilder":248,"./MosaicGlobalRestrictionEntryBuilder":249,"./MosaicGlobalRestrictionTransactionBodyBuilder":250,"./MosaicGlobalRestrictionTransactionBuilder":251,"./MosaicIdDto":252,"./MosaicMetadataTransactionBodyBuilder":253,"./MosaicMetadataTransactionBuilder":254,"./MosaicNonceDto":255,"./MosaicPropertiesBuilder":256,"./MosaicResolutionEntryBuilder":257,"./MosaicResolutionStatementBuilder":258,"./MosaicRestrictionEntryBuilder":259,"./MosaicRestrictionKeyDto":261,"./MosaicSupplyChangeTransactionBodyBuilder":262,"./MosaicSupplyChangeTransactionBuilder":263,"./MultisigAccountModificationTransactionBodyBuilder":264,"./MultisigAccountModificationTransactionBuilder":265,"./MultisigEntryBuilder":266,"./NamespaceAliasBuilder":267,"./NamespaceExpiryReceiptBuilder":269,"./NamespaceIdDto":270,"./NamespaceLifetimeBuilder":271,"./NamespaceMetadataTransactionBodyBuilder":272,"./NamespaceMetadataTransactionBuilder":273,"./NamespacePathBuilder":274,"./NamespaceRegistrationTransactionBodyBuilder":275,"./NamespaceRegistrationTransactionBuilder":276,"./NodeKeyLinkTransactionBodyBuilder":278,"./NodeKeyLinkTransactionBuilder":279,"./ProofGammaDto":280,"./ProofScalarDto":281,"./ProofVerificationHashDto":282,"./ReceiptBuilder":283,"./ReceiptSourceBuilder":284,"./RestrictionRuleBuilder":285,"./RootNamespaceHistoryBuilder":286,"./ScopedMetadataKeyDto":287,"./SecretLockInfoBuilder":288,"./SecretLockTransactionBodyBuilder":289,"./SecretLockTransactionBuilder":290,"./SecretProofTransactionBodyBuilder":291,"./SecretProofTransactionBuilder":292,"./SignatureDto":293,"./TimestampDto":294,"./TransactionBuilder":295,"./TransactionHelper":296,"./TransferTransactionBodyBuilder":297,"./TransferTransactionBuilder":298,"./UnresolvedAddressDto":299,"./UnresolvedMosaicBuilder":300,"./UnresolvedMosaicIdDto":301,"./VotingKeyDto":302,"./VotingKeyLinkTransactionBodyBuilder":303,"./VotingKeyLinkTransactionBuilder":304,"./VrfKeyLinkTransactionBodyBuilder":305,"./VrfKeyLinkTransactionBuilder":306,"./VrfProofBuilder":307}],"/node_modules/js-sha3":[function(require,module,exports){
(function (process,global){
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA3_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  var CSHAKE_BYTEPAD = {
    '128': 168,
    '256': 136
  };

  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };

  var createCshakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits, n, s) {
      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    };
  };

  var createKmacOutputMethod = function (bits, padding, outputType) {
    return function (key, message, outputBits, s) {
      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    };
  };

  var createOutputMethods = function (method, createMethod, bits, padding) {
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createMethod(bits, padding, type);
    }
    return method;
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    return createOutputMethods(method, createOutputMethod, bits, padding);
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  };

  var createCshakeMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createCshakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits, n, s) {
      if (!n && !s) {
        return methods['shake' + bits].create(outputBits);
      } else {
        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
      }
    };
    method.update = function (message, outputBits, n, s) {
      return method.create(outputBits, n, s).update(message);
    };
    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  };

  var createKmacMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createKmacOutputMethod(bits, padding, 'hex');
    method.create = function (key, outputBits, s) {
      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    };
    method.update = function (key, message, outputBits, s) {
      return method.create(key, outputBits, s).update(message);
    };
    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  };

  var algorithms = [
    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
  ];

  var methods = {}, methodNames = [];

  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits = algorithm.bits;
    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name + '_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
      if (algorithm.name !== 'sha3') {
        var newMethodName = algorithm.name + bits[j];
        methodNames.push(newMethodName);
        methods[newMethodName] = methods[methodName];
      }
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.finalized = false;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }

  Keccak.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
      blockCount = this.blockCount, index = 0, s = this.s, i, code;

    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.encode = function (x, right) {
    var o = x & 255, n = 1;
    var bytes = [o];
    x = x >> 8;
    o = x & 255;
    while (o > 0) {
      bytes.unshift(o);
      x = x >> 8;
      o = x & 255;
      ++n;
    }
    if (right) {
      bytes.push(n);
    } else {
      bytes.unshift(n);
    }
    this.update(bytes);
    return bytes.length;
  };

  Keccak.prototype.encodeString = function (str) {
    var notString, type = typeof str;
    if (type !== 'string') {
      if (type === 'object') {
        if (str === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
          str = new Uint8Array(str);
        } else if (!Array.isArray(str)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var bytes = 0, length = str.length;
    if (notString) {
      bytes = length;
    } else {
      for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);
        if (code < 0x80) {
          bytes += 1;
        } else if (code < 0x800) {
          bytes += 2;
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes += 3;
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
          bytes += 4;
        }
      }
    }
    bytes += this.encode(bytes * 8);
    this.update(str);
    return bytes;
  };

  Keccak.prototype.bytepad = function (strs, w) {
    var bytes = this.encode(w);
    for (var i = 0; i < strs.length; ++i) {
      bytes += this.encodeString(strs[i]);
    }
    var paddingBytes = w - bytes % w;
    var zeros = [];
    zeros.length = paddingBytes;
    this.update(zeros);
    return this;
  };

  Keccak.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  function Kmac(bits, padding, outputBits) {
    Keccak.call(this, bits, padding, outputBits);
  }

  Kmac.prototype = new Keccak();

  Kmac.prototype.finalize = function () {
    this.encode(this.outputBits, true);
    return Keccak.prototype.finalize.call(this);
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };

  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }
    if (AMD) {
      define(function () {
        return methods;
      });
    }
  }
})();

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":117}],"/node_modules/jsbn":[function(require,module,exports){
(function(){

    // Copyright (c) 2005  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Basic JavaScript BN library - subset useful for RSA encryption.

    // Bits per digit
    var dbits;

    // JavaScript engine analysis
    var canary = 0xdeadbeefcafe;
    var j_lm = ((canary&0xffffff)==0xefcafe);

    // (public) Constructor
    function BigInteger(a,b,c) {
      if(a != null)
        if("number" == typeof a) this.fromNumber(a,b,c);
        else if(b == null && "string" != typeof a) this.fromString(a,256);
        else this.fromString(a,b);
    }

    // return new, unset BigInteger
    function nbi() { return new BigInteger(null); }

    // am: Compute w_j += (x*this_i), propagate carries,
    // c is initial carry, returns final carry.
    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
    // We need to select the fastest one that works in this environment.

    // am1: use a single mult and divide to get the high bits,
    // max digit bits should be 26 because
    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
    function am1(i,x,w,j,c,n) {
      while(--n >= 0) {
        var v = x*this[i++]+w[j]+c;
        c = Math.floor(v/0x4000000);
        w[j++] = v&0x3ffffff;
      }
      return c;
    }
    // am2 avoids a big mult-and-extract completely.
    // Max digit bits should be <= 30 because we do bitwise ops
    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
    function am2(i,x,w,j,c,n) {
      var xl = x&0x7fff, xh = x>>15;
      while(--n >= 0) {
        var l = this[i]&0x7fff;
        var h = this[i++]>>15;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
        w[j++] = l&0x3fffffff;
      }
      return c;
    }
    // Alternately, set max digit bits to 28 since some
    // browsers slow down when dealing with 32-bit numbers.
    function am3(i,x,w,j,c,n) {
      var xl = x&0x3fff, xh = x>>14;
      while(--n >= 0) {
        var l = this[i]&0x3fff;
        var h = this[i++]>>14;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x3fff)<<14)+w[j]+c;
        c = (l>>28)+(m>>14)+xh*h;
        w[j++] = l&0xfffffff;
      }
      return c;
    }
    var inBrowser = typeof navigator !== "undefined";
    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
      BigInteger.prototype.am = am2;
      dbits = 30;
    }
    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {
      BigInteger.prototype.am = am1;
      dbits = 26;
    }
    else { // Mozilla/Netscape seems to prefer am3
      BigInteger.prototype.am = am3;
      dbits = 28;
    }

    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = ((1<<dbits)-1);
    BigInteger.prototype.DV = (1<<dbits);

    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2,BI_FP);
    BigInteger.prototype.F1 = BI_FP-dbits;
    BigInteger.prototype.F2 = 2*dbits-BI_FP;

    // Digit conversions
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr,vv;
    rr = "0".charCodeAt(0);
    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

    function int2char(n) { return BI_RM.charAt(n); }
    function intAt(s,i) {
      var c = BI_RC[s.charCodeAt(i)];
      return (c==null)?-1:c;
    }

    // (protected) copy this to r
    function bnpCopyTo(r) {
      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }

    // (protected) set from integer value x, -DV <= x < DV
    function bnpFromInt(x) {
      this.t = 1;
      this.s = (x<0)?-1:0;
      if(x > 0) this[0] = x;
      else if(x < -1) this[0] = x+this.DV;
      else this.t = 0;
    }

    // return bigint initialized to value
    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

    // (protected) set from string and radix
    function bnpFromString(s,b) {
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 256) k = 8; // byte array
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else { this.fromRadix(s,b); return; }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while(--i >= 0) {
        var x = (k==8)?s[i]&0xff:intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-") mi = true;
          continue;
        }
        mi = false;
        if(sh == 0)
          this[this.t++] = x;
        else if(sh+k > this.DB) {
          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
          this[this.t++] = (x>>(this.DB-sh));
        }
        else
          this[this.t-1] |= x<<sh;
        sh += k;
        if(sh >= this.DB) sh -= this.DB;
      }
      if(k == 8 && (s[0]&0x80) != 0) {
        this.s = -1;
        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
      }
      this.clamp();
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) clamp off excess high words
    function bnpClamp() {
      var c = this.s&this.DM;
      while(this.t > 0 && this[this.t-1] == c) --this.t;
    }

    // (public) return string representation in given radix
    function bnToString(b) {
      if(this.s < 0) return "-"+this.negate().toString(b);
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else return this.toRadix(b);
      var km = (1<<k)-1, d, m = false, r = "", i = this.t;
      var p = this.DB-(i*this.DB)%k;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
        while(i >= 0) {
          if(p < k) {
            d = (this[i]&((1<<p)-1))<<(k-p);
            d |= this[--i]>>(p+=this.DB-k);
          }
          else {
            d = (this[i]>>(p-=k))&km;
            if(p <= 0) { p += this.DB; --i; }
          }
          if(d > 0) m = true;
          if(m) r += int2char(d);
        }
      }
      return m?r:"0";
    }

    // (public) -this
    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

    // (public) |this|
    function bnAbs() { return (this.s<0)?this.negate():this; }

    // (public) return + if this > a, - if this < a, 0 if equal
    function bnCompareTo(a) {
      var r = this.s-a.s;
      if(r != 0) return r;
      var i = this.t;
      r = i-a.t;
      if(r != 0) return (this.s<0)?-r:r;
      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
      return 0;
    }

    // returns bit length of the integer x
    function nbits(x) {
      var r = 1, t;
      if((t=x>>>16) != 0) { x = t; r += 16; }
      if((t=x>>8) != 0) { x = t; r += 8; }
      if((t=x>>4) != 0) { x = t; r += 4; }
      if((t=x>>2) != 0) { x = t; r += 2; }
      if((t=x>>1) != 0) { x = t; r += 1; }
      return r;
    }

    // (public) return the number of bits in "this"
    function bnBitLength() {
      if(this.t <= 0) return 0;
      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
    }

    // (protected) r = this << n*DB
    function bnpDLShiftTo(n,r) {
      var i;
      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
      for(i = n-1; i >= 0; --i) r[i] = 0;
      r.t = this.t+n;
      r.s = this.s;
    }

    // (protected) r = this >> n*DB
    function bnpDRShiftTo(n,r) {
      for(var i = n; i < this.t; ++i) r[i-n] = this[i];
      r.t = Math.max(this.t-n,0);
      r.s = this.s;
    }

    // (protected) r = this << n
    function bnpLShiftTo(n,r) {
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<cbs)-1;
      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
      for(i = this.t-1; i >= 0; --i) {
        r[i+ds+1] = (this[i]>>cbs)|c;
        c = (this[i]&bm)<<bs;
      }
      for(i = ds-1; i >= 0; --i) r[i] = 0;
      r[ds] = c;
      r.t = this.t+ds+1;
      r.s = this.s;
      r.clamp();
    }

    // (protected) r = this >> n
    function bnpRShiftTo(n,r) {
      r.s = this.s;
      var ds = Math.floor(n/this.DB);
      if(ds >= this.t) { r.t = 0; return; }
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<bs)-1;
      r[0] = this[ds]>>bs;
      for(var i = ds+1; i < this.t; ++i) {
        r[i-ds-1] |= (this[i]&bm)<<cbs;
        r[i-ds] = this[i]>>bs;
      }
      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
      r.t = this.t-ds;
      r.clamp();
    }

    // (protected) r = this - a
    function bnpSubTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]-a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c -= a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c -= a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = (c<0)?-1:0;
      if(c < -1) r[i++] = this.DV+c;
      else if(c > 0) r[i++] = c;
      r.t = i;
      r.clamp();
    }

    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    function bnpMultiplyTo(a,r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i+y.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
      r.s = 0;
      r.clamp();
      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
    }

    // (protected) r = this^2, r != this (HAC 14.16)
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2*x.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < x.t-1; ++i) {
        var c = x.am(i,x[i],r,2*i,0,1);
        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
          r[i+x.t] -= x.DV;
          r[i+x.t+1] = 1;
        }
      }
      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
      r.s = 0;
      r.clamp();
    }

    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    function bnpDivRemTo(m,q,r) {
      var pm = m.abs();
      if(pm.t <= 0) return;
      var pt = this.abs();
      if(pt.t < pm.t) {
        if(q != null) q.fromInt(0);
        if(r != null) this.copyTo(r);
        return;
      }
      if(r == null) r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus
      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
      else { pm.copyTo(y); pt.copyTo(r); }
      var ys = y.t;
      var y0 = y[ys-1];
      if(y0 == 0) return;
      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
      var i = r.t, j = i-ys, t = (q==null)?nbi():q;
      y.dlShiftTo(j,t);
      if(r.compareTo(t) >= 0) {
        r[r.t++] = 1;
        r.subTo(t,r);
      }
      BigInteger.ONE.dlShiftTo(ys,t);
      t.subTo(y,y);  // "negative" y so we can replace sub with am later
      while(y.t < ys) y[y.t++] = 0;
      while(--j >= 0) {
        // Estimate quotient digit
        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out
          y.dlShiftTo(j,t);
          r.subTo(t,r);
          while(r[i] < --qd) r.subTo(t,r);
        }
      }
      if(q != null) {
        r.drShiftTo(ys,q);
        if(ts != ms) BigInteger.ZERO.subTo(q,q);
      }
      r.t = ys;
      r.clamp();
      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder
      if(ts < 0) BigInteger.ZERO.subTo(r,r);
    }

    // (public) this mod a
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a,null,r);
      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
      return r;
    }

    // Modular reduction using "classic" algorithm
    function Classic(m) { this.m = m; }
    function cConvert(x) {
      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
      else return x;
    }
    function cRevert(x) { return x; }
    function cReduce(x) { x.divRemTo(this.m,null,x); }
    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;

    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    function bnpInvDigit() {
      if(this.t < 1) return 0;
      var x = this[0];
      if((x&1) == 0) return 0;
      var y = x&3;       // y == 1/x mod 2^2
      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4
      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8
      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16
      // last step - calculate inverse mod DV directly;
      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits
      // we really want the negative inverse, and -DV < y < DV
      return (y>0)?this.DV-y:-y;
    }

    // Montgomery reduction
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp&0x7fff;
      this.mph = this.mp>>15;
      this.um = (1<<(m.DB-15))-1;
      this.mt2 = 2*m.t;
    }

    // xR mod m
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t,r);
      r.divRemTo(this.m,null,r);
      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
      return r;
    }

    // x/R mod m
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }

    // x = x/R mod m (HAC 14.32)
    function montReduce(x) {
      while(x.t <= this.mt2) // pad x so am has enough room later
        x[x.t++] = 0;
      for(var i = 0; i < this.m.t; ++i) {
        // faster way of calculating u0 = x[i]*mp mod DV
        var j = x[i]&0x7fff;
        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
        // use am to combine the multiply-shift-add into one call
        j = i+this.m.t;
        x[j] += this.m.am(0,u0,x,i,0,this.m.t);
        // propagate carry
        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
      }
      x.clamp();
      x.drShiftTo(this.m.t,x);
      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = "x^2/R mod m"; x != r
    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = "xy/R mod m"; x,y != r
    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;

    // (protected) true iff this is even
    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    function bnpExp(e,z) {
      if(e > 0xffffffff || e < 1) return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
      g.copyTo(r);
      while(--i >= 0) {
        z.sqrTo(r,r2);
        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
        else { var t = r; r = r2; r2 = t; }
      }
      return z.revert(r);
    }

    // (public) this^e % m, 0 <= e < 2^32
    function bnModPowInt(e,m) {
      var z;
      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
      return this.exp(e,z);
    }

    // protected
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;

    // public
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;

    // "constants"
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);

    // Copyright (c) 2005-2009  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Extended JavaScript BN functions, required for RSA private ops.

    // Version 1.1: new BigInteger("0", 10) returns "proper" zero
    // Version 1.2: square() API, isProbablePrime fix

    // (public)
    function bnClone() { var r = nbi(); this.copyTo(r); return r; }

    // (public) return value as integer
    function bnIntValue() {
      if(this.s < 0) {
        if(this.t == 1) return this[0]-this.DV;
        else if(this.t == 0) return -1;
      }
      else if(this.t == 1) return this[0];
      else if(this.t == 0) return 0;
      // assumes 16 < DB < 32
      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
    }

    // (public) return value as byte
    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }

    // (public) return value as short (assumes DB>=16)
    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }

    // (protected) return x s.t. r^x < DV
    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

    // (public) 0 if this == 0, 1 if this > 0
    function bnSigNum() {
      if(this.s < 0) return -1;
      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
      else return 1;
    }

    // (protected) convert to radix string
    function bnpToRadix(b) {
      if(b == null) b = 10;
      if(this.signum() == 0 || b < 2 || b > 36) return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b,cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d,y,z);
      while(y.signum() > 0) {
        r = (a+z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d,y,z);
      }
      return z.intValue().toString(b) + r;
    }

    // (protected) convert from radix string
    function bnpFromRadix(s,b) {
      this.fromInt(0);
      if(b == null) b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
      for(var i = 0; i < s.length; ++i) {
        var x = intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
          continue;
        }
        w = b*w+x;
        if(++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w,0);
          j = 0;
          w = 0;
        }
      }
      if(j > 0) {
        this.dMultiply(Math.pow(b,j));
        this.dAddOffset(w,0);
      }
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) alternate constructor
    function bnpFromNumber(a,b,c) {
      if("number" == typeof b) {
        // new BigInteger(int,int,RNG)
        if(a < 2) this.fromInt(1);
        else {
          this.fromNumber(a,c);
          if(!this.testBit(a-1))	// force MSB set
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
          if(this.isEven()) this.dAddOffset(1,0); // force odd
          while(!this.isProbablePrime(b)) {
            this.dAddOffset(2,0);
            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
          }
        }
      }
      else {
        // new BigInteger(int,RNG)
        var x = new Array(), t = a&7;
        x.length = (a>>3)+1;
        b.nextBytes(x);
        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
        this.fromString(x,256);
      }
    }

    // (public) convert to bigendian byte array
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB-(i*this.DB)%8, d, k = 0;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
          r[k++] = d|(this.s<<(this.DB-p));
        while(i >= 0) {
          if(p < 8) {
            d = (this[i]&((1<<p)-1))<<(8-p);
            d |= this[--i]>>(p+=this.DB-8);
          }
          else {
            d = (this[i]>>(p-=8))&0xff;
            if(p <= 0) { p += this.DB; --i; }
          }
          if((d&0x80) != 0) d |= -256;
          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
          if(k > 0 || d != this.s) r[k++] = d;
        }
      }
      return r;
    }

    function bnEquals(a) { return(this.compareTo(a)==0); }
    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

    // (protected) r = this op a (bitwise)
    function bnpBitwiseTo(a,op,r) {
      var i, f, m = Math.min(a.t,this.t);
      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
      if(a.t < this.t) {
        f = a.s&this.DM;
        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
        r.t = this.t;
      }
      else {
        f = this.s&this.DM;
        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
        r.t = a.t;
      }
      r.s = op(this.s,a.s);
      r.clamp();
    }

    // (public) this & a
    function op_and(x,y) { return x&y; }
    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

    // (public) this | a
    function op_or(x,y) { return x|y; }
    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

    // (public) this ^ a
    function op_xor(x,y) { return x^y; }
    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

    // (public) this & ~a
    function op_andnot(x,y) { return x&~y; }
    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

    // (public) ~this
    function bnNot() {
      var r = nbi();
      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }

    // (public) this << n
    function bnShiftLeft(n) {
      var r = nbi();
      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
      return r;
    }

    // (public) this >> n
    function bnShiftRight(n) {
      var r = nbi();
      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
      return r;
    }

    // return index of lowest 1-bit in x, x < 2^31
    function lbit(x) {
      if(x == 0) return -1;
      var r = 0;
      if((x&0xffff) == 0) { x >>= 16; r += 16; }
      if((x&0xff) == 0) { x >>= 8; r += 8; }
      if((x&0xf) == 0) { x >>= 4; r += 4; }
      if((x&3) == 0) { x >>= 2; r += 2; }
      if((x&1) == 0) ++r;
      return r;
    }

    // (public) returns index of lowest 1-bit (or -1 if none)
    function bnGetLowestSetBit() {
      for(var i = 0; i < this.t; ++i)
        if(this[i] != 0) return i*this.DB+lbit(this[i]);
      if(this.s < 0) return this.t*this.DB;
      return -1;
    }

    // return number of 1 bits in x
    function cbit(x) {
      var r = 0;
      while(x != 0) { x &= x-1; ++r; }
      return r;
    }

    // (public) return number of set bits
    function bnBitCount() {
      var r = 0, x = this.s&this.DM;
      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
      return r;
    }

    // (public) true iff nth bit is set
    function bnTestBit(n) {
      var j = Math.floor(n/this.DB);
      if(j >= this.t) return(this.s!=0);
      return((this[j]&(1<<(n%this.DB)))!=0);
    }

    // (protected) this op (1<<n)
    function bnpChangeBit(n,op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r,op,r);
      return r;
    }

    // (public) this | (1<<n)
    function bnSetBit(n) { return this.changeBit(n,op_or); }

    // (public) this & ~(1<<n)
    function bnClearBit(n) { return this.changeBit(n,op_andnot); }

    // (public) this ^ (1<<n)
    function bnFlipBit(n) { return this.changeBit(n,op_xor); }

    // (protected) r = this + a
    function bnpAddTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]+a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c += a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c += a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = (c<0)?-1:0;
      if(c > 0) r[i++] = c;
      else if(c < -1) r[i++] = this.DV+c;
      r.t = i;
      r.clamp();
    }

    // (public) this + a
    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

    // (public) this - a
    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

    // (public) this * a
    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

    // (public) this^2
    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

    // (public) this / a
    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

    // (public) this % a
    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

    // (public) [this/a,this%a]
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a,q,r);
      return new Array(q,r);
    }

    // (protected) this *= n, this >= 0, 1 < n < DV
    function bnpDMultiply(n) {
      this[this.t] = this.am(0,n-1,this,0,0,this.t);
      ++this.t;
      this.clamp();
    }

    // (protected) this += n << w words, this >= 0
    function bnpDAddOffset(n,w) {
      if(n == 0) return;
      while(this.t <= w) this[this.t++] = 0;
      this[w] += n;
      while(this[w] >= this.DV) {
        this[w] -= this.DV;
        if(++w >= this.t) this[this.t++] = 0;
        ++this[w];
      }
    }

    // A "null" reducer
    function NullExp() {}
    function nNop(x) { return x; }
    function nMulTo(x,y,r) { x.multiplyTo(y,r); }
    function nSqrTo(x,r) { x.squareTo(r); }

    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;

    // (public) this^e
    function bnPow(e) { return this.exp(e,new NullExp()); }

    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    function bnpMultiplyLowerTo(a,n,r) {
      var i = Math.min(this.t+a.t,n);
      r.s = 0; // assumes a,this >= 0
      r.t = i;
      while(i > 0) r[--i] = 0;
      var j;
      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
      r.clamp();
    }

    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    function bnpMultiplyUpperTo(a,n,r) {
      --n;
      var i = r.t = this.t+a.t-n;
      r.s = 0; // assumes a,this >= 0
      while(--i >= 0) r[i] = 0;
      for(i = Math.max(n-this.t,0); i < a.t; ++i)
        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
      r.clamp();
      r.drShiftTo(1,r);
    }

    // Barrett modular reduction
    function Barrett(m) {
      // setup Barrett
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }

    function barrettConvert(x) {
      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
      else if(x.compareTo(this.m) < 0) return x;
      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
    }

    function barrettRevert(x) { return x; }

    // x = x mod m (HAC 14.42)
    function barrettReduce(x) {
      x.drShiftTo(this.m.t-1,this.r2);
      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
      x.subTo(this.r2,x);
      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = x^2 mod m; x != r
    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = x*y mod m; x,y != r
    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;

    // (public) this^e % m (HAC 14.85)
    function bnModPow(e,m) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if(i <= 0) return r;
      else if(i < 18) k = 1;
      else if(i < 48) k = 3;
      else if(i < 144) k = 4;
      else if(i < 768) k = 5;
      else k = 6;
      if(i < 8)
        z = new Classic(m);
      else if(m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);

      // precomputation
      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
      g[1] = z.convert(this);
      if(k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1],g2);
        while(n <= km) {
          g[n] = nbi();
          z.mulTo(g2,g[n-2],g[n]);
          n += 2;
        }
      }

      var j = e.t-1, w, is1 = true, r2 = nbi(), t;
      i = nbits(e[j])-1;
      while(j >= 0) {
        if(i >= k1) w = (e[j]>>(i-k1))&km;
        else {
          w = (e[j]&((1<<(i+1))-1))<<(k1-i);
          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
        }

        n = k;
        while((w&1) == 0) { w >>= 1; --n; }
        if((i -= n) < 0) { i += this.DB; --j; }
        if(is1) {	// ret == 1, don't bother squaring or multiplying it
          g[w].copyTo(r);
          is1 = false;
        }
        else {
          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
          z.mulTo(r2,g[w],r);
        }

        while(j >= 0 && (e[j]&(1<<i)) == 0) {
          z.sqrTo(r,r2); t = r; r = r2; r2 = t;
          if(--i < 0) { i = this.DB-1; --j; }
        }
      }
      return z.revert(r);
    }

    // (public) gcd(this,a) (HAC 14.54)
    function bnGCD(a) {
      var x = (this.s<0)?this.negate():this.clone();
      var y = (a.s<0)?a.negate():a.clone();
      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if(g < 0) return x;
      if(i < g) g = i;
      if(g > 0) {
        x.rShiftTo(g,x);
        y.rShiftTo(g,y);
      }
      while(x.signum() > 0) {
        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
        if(x.compareTo(y) >= 0) {
          x.subTo(y,x);
          x.rShiftTo(1,x);
        }
        else {
          y.subTo(x,y);
          y.rShiftTo(1,y);
        }
      }
      if(g > 0) y.lShiftTo(g,y);
      return y;
    }

    // (protected) this % n, n < 2^26
    function bnpModInt(n) {
      if(n <= 0) return 0;
      var d = this.DV%n, r = (this.s<0)?n-1:0;
      if(this.t > 0)
        if(d == 0) r = this[0]%n;
        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
      return r;
    }

    // (public) 1/this % m (HAC 14.61)
    function bnModInverse(m) {
      var ac = m.isEven();
      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while(u.signum() != 0) {
        while(u.isEven()) {
          u.rShiftTo(1,u);
          if(ac) {
            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
            a.rShiftTo(1,a);
          }
          else if(!b.isEven()) b.subTo(m,b);
          b.rShiftTo(1,b);
        }
        while(v.isEven()) {
          v.rShiftTo(1,v);
          if(ac) {
            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
            c.rShiftTo(1,c);
          }
          else if(!d.isEven()) d.subTo(m,d);
          d.rShiftTo(1,d);
        }
        if(u.compareTo(v) >= 0) {
          u.subTo(v,u);
          if(ac) a.subTo(c,a);
          b.subTo(d,b);
        }
        else {
          v.subTo(u,v);
          if(ac) c.subTo(a,c);
          d.subTo(b,d);
        }
      }
      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if(d.compareTo(m) >= 0) return d.subtract(m);
      if(d.signum() < 0) d.addTo(m,d); else return d;
      if(d.signum() < 0) return d.add(m); else return d;
    }

    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
    var lplim = (1<<26)/lowprimes[lowprimes.length-1];

    // (public) test primality with certainty >= 1-.5^t
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
        for(i = 0; i < lowprimes.length; ++i)
          if(x[0] == lowprimes[i]) return true;
        return false;
      }
      if(x.isEven()) return false;
      i = 1;
      while(i < lowprimes.length) {
        var m = lowprimes[i], j = i+1;
        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
        m = x.modInt(m);
        while(i < j) if(m%lowprimes[i++] == 0) return false;
      }
      return x.millerRabin(t);
    }

    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if(k <= 0) return false;
      var r = n1.shiftRight(k);
      t = (t+1)>>1;
      if(t > lowprimes.length) t = lowprimes.length;
      var a = nbi();
      for(var i = 0; i < t; ++i) {
        //Pick bases at random, instead of starting at 2
        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
        var y = a.modPow(r,this);
        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while(j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2,this);
            if(y.compareTo(BigInteger.ONE) == 0) return false;
          }
          if(y.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }

    // protected
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;

    // public
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

    // JSBN-specific extension
    BigInteger.prototype.square = bnSquare;

    // Expose the Barrett function
    BigInteger.prototype.Barrett = Barrett

    // BigInteger interfaces not implemented in jsbn:

    // BigInteger(int signum, byte[] magnitude)
    // double doubleValue()
    // float floatValue()
    // int hashCode()
    // long longValue()
    // static BigInteger valueOf(long val)

	// Random number generator - requires a PRNG backend, e.g. prng4.js

	// For best results, put code like
	// <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>
	// in your main HTML document.

	var rng_state;
	var rng_pool;
	var rng_pptr;

	// Mix in a 32-bit integer into the pool
	function rng_seed_int(x) {
	  rng_pool[rng_pptr++] ^= x & 255;
	  rng_pool[rng_pptr++] ^= (x >> 8) & 255;
	  rng_pool[rng_pptr++] ^= (x >> 16) & 255;
	  rng_pool[rng_pptr++] ^= (x >> 24) & 255;
	  if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;
	}

	// Mix in the current time (w/milliseconds) into the pool
	function rng_seed_time() {
	  rng_seed_int(new Date().getTime());
	}

	// Initialize the pool with junk if needed.
	if(rng_pool == null) {
	  rng_pool = new Array();
	  rng_pptr = 0;
	  var t;
	  if(typeof window !== "undefined" && window.crypto) {
		if (window.crypto.getRandomValues) {
		  // Use webcrypto if available
		  var ua = new Uint8Array(32);
		  window.crypto.getRandomValues(ua);
		  for(t = 0; t < 32; ++t)
			rng_pool[rng_pptr++] = ua[t];
		}
		else if(navigator.appName == "Netscape" && navigator.appVersion < "5") {
		  // Extract entropy (256 bits) from NS4 RNG if available
		  var z = window.crypto.random(32);
		  for(t = 0; t < z.length; ++t)
			rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
		}
	  }
	  while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()
		t = Math.floor(65536 * Math.random());
		rng_pool[rng_pptr++] = t >>> 8;
		rng_pool[rng_pptr++] = t & 255;
	  }
	  rng_pptr = 0;
	  rng_seed_time();
	  //rng_seed_int(window.screenX);
	  //rng_seed_int(window.screenY);
	}

	function rng_get_byte() {
	  if(rng_state == null) {
		rng_seed_time();
		rng_state = prng_newstate();
		rng_state.init(rng_pool);
		for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
		  rng_pool[rng_pptr] = 0;
		rng_pptr = 0;
		//rng_pool = null;
	  }
	  // TODO: allow reseeding after first request
	  return rng_state.next();
	}

	function rng_get_bytes(ba) {
	  var i;
	  for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
	}

	function SecureRandom() {}

	SecureRandom.prototype.nextBytes = rng_get_bytes;

	// prng4.js - uses Arcfour as a PRNG

	function Arcfour() {
	  this.i = 0;
	  this.j = 0;
	  this.S = new Array();
	}

	// Initialize arcfour context from key, an array of ints, each from [0..255]
	function ARC4init(key) {
	  var i, j, t;
	  for(i = 0; i < 256; ++i)
		this.S[i] = i;
	  j = 0;
	  for(i = 0; i < 256; ++i) {
		j = (j + this.S[i] + key[i % key.length]) & 255;
		t = this.S[i];
		this.S[i] = this.S[j];
		this.S[j] = t;
	  }
	  this.i = 0;
	  this.j = 0;
	}

	function ARC4next() {
	  var t;
	  this.i = (this.i + 1) & 255;
	  this.j = (this.j + this.S[this.i]) & 255;
	  t = this.S[this.i];
	  this.S[this.i] = this.S[this.j];
	  this.S[this.j] = t;
	  return this.S[(t + this.S[this.i]) & 255];
	}

	Arcfour.prototype.init = ARC4init;
	Arcfour.prototype.next = ARC4next;

	// Plug in your RNG constructor here
	function prng_newstate() {
	  return new Arcfour();
	}

	// Pool size must be a multiple of 4 and greater than 32.
	// An array of bytes the size of the pool will be passed to init()
	var rng_psize = 256;

  BigInteger.SecureRandom = SecureRandom;
  BigInteger.BigInteger = BigInteger;
  if (typeof exports !== 'undefined') {
    exports = module.exports = BigInteger;
  } else {
    this.BigInteger = BigInteger;
    this.SecureRandom = SecureRandom;
  }

}).call(this);

},{}],"/node_modules/rxjs/operators":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var audit_1 = require("../internal/operators/audit");
exports.audit = audit_1.audit;
var auditTime_1 = require("../internal/operators/auditTime");
exports.auditTime = auditTime_1.auditTime;
var buffer_1 = require("../internal/operators/buffer");
exports.buffer = buffer_1.buffer;
var bufferCount_1 = require("../internal/operators/bufferCount");
exports.bufferCount = bufferCount_1.bufferCount;
var bufferTime_1 = require("../internal/operators/bufferTime");
exports.bufferTime = bufferTime_1.bufferTime;
var bufferToggle_1 = require("../internal/operators/bufferToggle");
exports.bufferToggle = bufferToggle_1.bufferToggle;
var bufferWhen_1 = require("../internal/operators/bufferWhen");
exports.bufferWhen = bufferWhen_1.bufferWhen;
var catchError_1 = require("../internal/operators/catchError");
exports.catchError = catchError_1.catchError;
var combineAll_1 = require("../internal/operators/combineAll");
exports.combineAll = combineAll_1.combineAll;
var combineLatest_1 = require("../internal/operators/combineLatest");
exports.combineLatest = combineLatest_1.combineLatest;
var concat_1 = require("../internal/operators/concat");
exports.concat = concat_1.concat;
var concatAll_1 = require("../internal/operators/concatAll");
exports.concatAll = concatAll_1.concatAll;
var concatMap_1 = require("../internal/operators/concatMap");
exports.concatMap = concatMap_1.concatMap;
var concatMapTo_1 = require("../internal/operators/concatMapTo");
exports.concatMapTo = concatMapTo_1.concatMapTo;
var count_1 = require("../internal/operators/count");
exports.count = count_1.count;
var debounce_1 = require("../internal/operators/debounce");
exports.debounce = debounce_1.debounce;
var debounceTime_1 = require("../internal/operators/debounceTime");
exports.debounceTime = debounceTime_1.debounceTime;
var defaultIfEmpty_1 = require("../internal/operators/defaultIfEmpty");
exports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;
var delay_1 = require("../internal/operators/delay");
exports.delay = delay_1.delay;
var delayWhen_1 = require("../internal/operators/delayWhen");
exports.delayWhen = delayWhen_1.delayWhen;
var dematerialize_1 = require("../internal/operators/dematerialize");
exports.dematerialize = dematerialize_1.dematerialize;
var distinct_1 = require("../internal/operators/distinct");
exports.distinct = distinct_1.distinct;
var distinctUntilChanged_1 = require("../internal/operators/distinctUntilChanged");
exports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
var distinctUntilKeyChanged_1 = require("../internal/operators/distinctUntilKeyChanged");
exports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;
var elementAt_1 = require("../internal/operators/elementAt");
exports.elementAt = elementAt_1.elementAt;
var endWith_1 = require("../internal/operators/endWith");
exports.endWith = endWith_1.endWith;
var every_1 = require("../internal/operators/every");
exports.every = every_1.every;
var exhaust_1 = require("../internal/operators/exhaust");
exports.exhaust = exhaust_1.exhaust;
var exhaustMap_1 = require("../internal/operators/exhaustMap");
exports.exhaustMap = exhaustMap_1.exhaustMap;
var expand_1 = require("../internal/operators/expand");
exports.expand = expand_1.expand;
var filter_1 = require("../internal/operators/filter");
exports.filter = filter_1.filter;
var finalize_1 = require("../internal/operators/finalize");
exports.finalize = finalize_1.finalize;
var find_1 = require("../internal/operators/find");
exports.find = find_1.find;
var findIndex_1 = require("../internal/operators/findIndex");
exports.findIndex = findIndex_1.findIndex;
var first_1 = require("../internal/operators/first");
exports.first = first_1.first;
var groupBy_1 = require("../internal/operators/groupBy");
exports.groupBy = groupBy_1.groupBy;
var ignoreElements_1 = require("../internal/operators/ignoreElements");
exports.ignoreElements = ignoreElements_1.ignoreElements;
var isEmpty_1 = require("../internal/operators/isEmpty");
exports.isEmpty = isEmpty_1.isEmpty;
var last_1 = require("../internal/operators/last");
exports.last = last_1.last;
var map_1 = require("../internal/operators/map");
exports.map = map_1.map;
var mapTo_1 = require("../internal/operators/mapTo");
exports.mapTo = mapTo_1.mapTo;
var materialize_1 = require("../internal/operators/materialize");
exports.materialize = materialize_1.materialize;
var max_1 = require("../internal/operators/max");
exports.max = max_1.max;
var merge_1 = require("../internal/operators/merge");
exports.merge = merge_1.merge;
var mergeAll_1 = require("../internal/operators/mergeAll");
exports.mergeAll = mergeAll_1.mergeAll;
var mergeMap_1 = require("../internal/operators/mergeMap");
exports.mergeMap = mergeMap_1.mergeMap;
var mergeMap_2 = require("../internal/operators/mergeMap");
exports.flatMap = mergeMap_2.mergeMap;
var mergeMapTo_1 = require("../internal/operators/mergeMapTo");
exports.mergeMapTo = mergeMapTo_1.mergeMapTo;
var mergeScan_1 = require("../internal/operators/mergeScan");
exports.mergeScan = mergeScan_1.mergeScan;
var min_1 = require("../internal/operators/min");
exports.min = min_1.min;
var multicast_1 = require("../internal/operators/multicast");
exports.multicast = multicast_1.multicast;
var observeOn_1 = require("../internal/operators/observeOn");
exports.observeOn = observeOn_1.observeOn;
var onErrorResumeNext_1 = require("../internal/operators/onErrorResumeNext");
exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
var pairwise_1 = require("../internal/operators/pairwise");
exports.pairwise = pairwise_1.pairwise;
var partition_1 = require("../internal/operators/partition");
exports.partition = partition_1.partition;
var pluck_1 = require("../internal/operators/pluck");
exports.pluck = pluck_1.pluck;
var publish_1 = require("../internal/operators/publish");
exports.publish = publish_1.publish;
var publishBehavior_1 = require("../internal/operators/publishBehavior");
exports.publishBehavior = publishBehavior_1.publishBehavior;
var publishLast_1 = require("../internal/operators/publishLast");
exports.publishLast = publishLast_1.publishLast;
var publishReplay_1 = require("../internal/operators/publishReplay");
exports.publishReplay = publishReplay_1.publishReplay;
var race_1 = require("../internal/operators/race");
exports.race = race_1.race;
var reduce_1 = require("../internal/operators/reduce");
exports.reduce = reduce_1.reduce;
var repeat_1 = require("../internal/operators/repeat");
exports.repeat = repeat_1.repeat;
var repeatWhen_1 = require("../internal/operators/repeatWhen");
exports.repeatWhen = repeatWhen_1.repeatWhen;
var retry_1 = require("../internal/operators/retry");
exports.retry = retry_1.retry;
var retryWhen_1 = require("../internal/operators/retryWhen");
exports.retryWhen = retryWhen_1.retryWhen;
var refCount_1 = require("../internal/operators/refCount");
exports.refCount = refCount_1.refCount;
var sample_1 = require("../internal/operators/sample");
exports.sample = sample_1.sample;
var sampleTime_1 = require("../internal/operators/sampleTime");
exports.sampleTime = sampleTime_1.sampleTime;
var scan_1 = require("../internal/operators/scan");
exports.scan = scan_1.scan;
var sequenceEqual_1 = require("../internal/operators/sequenceEqual");
exports.sequenceEqual = sequenceEqual_1.sequenceEqual;
var share_1 = require("../internal/operators/share");
exports.share = share_1.share;
var shareReplay_1 = require("../internal/operators/shareReplay");
exports.shareReplay = shareReplay_1.shareReplay;
var single_1 = require("../internal/operators/single");
exports.single = single_1.single;
var skip_1 = require("../internal/operators/skip");
exports.skip = skip_1.skip;
var skipLast_1 = require("../internal/operators/skipLast");
exports.skipLast = skipLast_1.skipLast;
var skipUntil_1 = require("../internal/operators/skipUntil");
exports.skipUntil = skipUntil_1.skipUntil;
var skipWhile_1 = require("../internal/operators/skipWhile");
exports.skipWhile = skipWhile_1.skipWhile;
var startWith_1 = require("../internal/operators/startWith");
exports.startWith = startWith_1.startWith;
var subscribeOn_1 = require("../internal/operators/subscribeOn");
exports.subscribeOn = subscribeOn_1.subscribeOn;
var switchAll_1 = require("../internal/operators/switchAll");
exports.switchAll = switchAll_1.switchAll;
var switchMap_1 = require("../internal/operators/switchMap");
exports.switchMap = switchMap_1.switchMap;
var switchMapTo_1 = require("../internal/operators/switchMapTo");
exports.switchMapTo = switchMapTo_1.switchMapTo;
var take_1 = require("../internal/operators/take");
exports.take = take_1.take;
var takeLast_1 = require("../internal/operators/takeLast");
exports.takeLast = takeLast_1.takeLast;
var takeUntil_1 = require("../internal/operators/takeUntil");
exports.takeUntil = takeUntil_1.takeUntil;
var takeWhile_1 = require("../internal/operators/takeWhile");
exports.takeWhile = takeWhile_1.takeWhile;
var tap_1 = require("../internal/operators/tap");
exports.tap = tap_1.tap;
var throttle_1 = require("../internal/operators/throttle");
exports.throttle = throttle_1.throttle;
var throttleTime_1 = require("../internal/operators/throttleTime");
exports.throttleTime = throttleTime_1.throttleTime;
var throwIfEmpty_1 = require("../internal/operators/throwIfEmpty");
exports.throwIfEmpty = throwIfEmpty_1.throwIfEmpty;
var timeInterval_1 = require("../internal/operators/timeInterval");
exports.timeInterval = timeInterval_1.timeInterval;
var timeout_1 = require("../internal/operators/timeout");
exports.timeout = timeout_1.timeout;
var timeoutWith_1 = require("../internal/operators/timeoutWith");
exports.timeoutWith = timeoutWith_1.timeoutWith;
var timestamp_1 = require("../internal/operators/timestamp");
exports.timestamp = timestamp_1.timestamp;
var toArray_1 = require("../internal/operators/toArray");
exports.toArray = toArray_1.toArray;
var window_1 = require("../internal/operators/window");
exports.window = window_1.window;
var windowCount_1 = require("../internal/operators/windowCount");
exports.windowCount = windowCount_1.windowCount;
var windowTime_1 = require("../internal/operators/windowTime");
exports.windowTime = windowTime_1.windowTime;
var windowToggle_1 = require("../internal/operators/windowToggle");
exports.windowToggle = windowToggle_1.windowToggle;
var windowWhen_1 = require("../internal/operators/windowWhen");
exports.windowWhen = windowWhen_1.windowWhen;
var withLatestFrom_1 = require("../internal/operators/withLatestFrom");
exports.withLatestFrom = withLatestFrom_1.withLatestFrom;
var zip_1 = require("../internal/operators/zip");
exports.zip = zip_1.zip;
var zipAll_1 = require("../internal/operators/zipAll");
exports.zipAll = zipAll_1.zipAll;

},{"../internal/operators/audit":394,"../internal/operators/auditTime":395,"../internal/operators/buffer":396,"../internal/operators/bufferCount":397,"../internal/operators/bufferTime":398,"../internal/operators/bufferToggle":399,"../internal/operators/bufferWhen":400,"../internal/operators/catchError":401,"../internal/operators/combineAll":402,"../internal/operators/combineLatest":403,"../internal/operators/concat":404,"../internal/operators/concatAll":405,"../internal/operators/concatMap":406,"../internal/operators/concatMapTo":407,"../internal/operators/count":408,"../internal/operators/debounce":409,"../internal/operators/debounceTime":410,"../internal/operators/defaultIfEmpty":411,"../internal/operators/delay":412,"../internal/operators/delayWhen":413,"../internal/operators/dematerialize":414,"../internal/operators/distinct":415,"../internal/operators/distinctUntilChanged":416,"../internal/operators/distinctUntilKeyChanged":417,"../internal/operators/elementAt":418,"../internal/operators/endWith":419,"../internal/operators/every":420,"../internal/operators/exhaust":421,"../internal/operators/exhaustMap":422,"../internal/operators/expand":423,"../internal/operators/filter":424,"../internal/operators/finalize":425,"../internal/operators/find":426,"../internal/operators/findIndex":427,"../internal/operators/first":428,"../internal/operators/groupBy":429,"../internal/operators/ignoreElements":430,"../internal/operators/isEmpty":431,"../internal/operators/last":432,"../internal/operators/map":433,"../internal/operators/mapTo":434,"../internal/operators/materialize":435,"../internal/operators/max":436,"../internal/operators/merge":437,"../internal/operators/mergeAll":438,"../internal/operators/mergeMap":439,"../internal/operators/mergeMapTo":440,"../internal/operators/mergeScan":441,"../internal/operators/min":442,"../internal/operators/multicast":443,"../internal/operators/observeOn":444,"../internal/operators/onErrorResumeNext":445,"../internal/operators/pairwise":446,"../internal/operators/partition":447,"../internal/operators/pluck":448,"../internal/operators/publish":449,"../internal/operators/publishBehavior":450,"../internal/operators/publishLast":451,"../internal/operators/publishReplay":452,"../internal/operators/race":453,"../internal/operators/reduce":454,"../internal/operators/refCount":455,"../internal/operators/repeat":456,"../internal/operators/repeatWhen":457,"../internal/operators/retry":458,"../internal/operators/retryWhen":459,"../internal/operators/sample":460,"../internal/operators/sampleTime":461,"../internal/operators/scan":462,"../internal/operators/sequenceEqual":463,"../internal/operators/share":464,"../internal/operators/shareReplay":465,"../internal/operators/single":466,"../internal/operators/skip":467,"../internal/operators/skipLast":468,"../internal/operators/skipUntil":469,"../internal/operators/skipWhile":470,"../internal/operators/startWith":471,"../internal/operators/subscribeOn":472,"../internal/operators/switchAll":473,"../internal/operators/switchMap":474,"../internal/operators/switchMapTo":475,"../internal/operators/take":476,"../internal/operators/takeLast":477,"../internal/operators/takeUntil":478,"../internal/operators/takeWhile":479,"../internal/operators/tap":480,"../internal/operators/throttle":481,"../internal/operators/throttleTime":482,"../internal/operators/throwIfEmpty":483,"../internal/operators/timeInterval":484,"../internal/operators/timeout":485,"../internal/operators/timeoutWith":486,"../internal/operators/timestamp":487,"../internal/operators/toArray":488,"../internal/operators/window":489,"../internal/operators/windowCount":490,"../internal/operators/windowTime":491,"../internal/operators/windowToggle":492,"../internal/operators/windowWhen":493,"../internal/operators/withLatestFrom":494,"../internal/operators/zip":495,"../internal/operators/zipAll":496}],"/node_modules/rxjs":[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("./internal/Observable");
exports.Observable = Observable_1.Observable;
var ConnectableObservable_1 = require("./internal/observable/ConnectableObservable");
exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;
var groupBy_1 = require("./internal/operators/groupBy");
exports.GroupedObservable = groupBy_1.GroupedObservable;
var observable_1 = require("./internal/symbol/observable");
exports.observable = observable_1.observable;
var Subject_1 = require("./internal/Subject");
exports.Subject = Subject_1.Subject;
var BehaviorSubject_1 = require("./internal/BehaviorSubject");
exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;
var ReplaySubject_1 = require("./internal/ReplaySubject");
exports.ReplaySubject = ReplaySubject_1.ReplaySubject;
var AsyncSubject_1 = require("./internal/AsyncSubject");
exports.AsyncSubject = AsyncSubject_1.AsyncSubject;
var asap_1 = require("./internal/scheduler/asap");
exports.asapScheduler = asap_1.asap;
var async_1 = require("./internal/scheduler/async");
exports.asyncScheduler = async_1.async;
var queue_1 = require("./internal/scheduler/queue");
exports.queueScheduler = queue_1.queue;
var animationFrame_1 = require("./internal/scheduler/animationFrame");
exports.animationFrameScheduler = animationFrame_1.animationFrame;
var VirtualTimeScheduler_1 = require("./internal/scheduler/VirtualTimeScheduler");
exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;
exports.VirtualAction = VirtualTimeScheduler_1.VirtualAction;
var Scheduler_1 = require("./internal/Scheduler");
exports.Scheduler = Scheduler_1.Scheduler;
var Subscription_1 = require("./internal/Subscription");
exports.Subscription = Subscription_1.Subscription;
var Subscriber_1 = require("./internal/Subscriber");
exports.Subscriber = Subscriber_1.Subscriber;
var Notification_1 = require("./internal/Notification");
exports.Notification = Notification_1.Notification;
exports.NotificationKind = Notification_1.NotificationKind;
var pipe_1 = require("./internal/util/pipe");
exports.pipe = pipe_1.pipe;
var noop_1 = require("./internal/util/noop");
exports.noop = noop_1.noop;
var identity_1 = require("./internal/util/identity");
exports.identity = identity_1.identity;
var isObservable_1 = require("./internal/util/isObservable");
exports.isObservable = isObservable_1.isObservable;
var ArgumentOutOfRangeError_1 = require("./internal/util/ArgumentOutOfRangeError");
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
var EmptyError_1 = require("./internal/util/EmptyError");
exports.EmptyError = EmptyError_1.EmptyError;
var ObjectUnsubscribedError_1 = require("./internal/util/ObjectUnsubscribedError");
exports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;
var UnsubscriptionError_1 = require("./internal/util/UnsubscriptionError");
exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;
var TimeoutError_1 = require("./internal/util/TimeoutError");
exports.TimeoutError = TimeoutError_1.TimeoutError;
var bindCallback_1 = require("./internal/observable/bindCallback");
exports.bindCallback = bindCallback_1.bindCallback;
var bindNodeCallback_1 = require("./internal/observable/bindNodeCallback");
exports.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;
var combineLatest_1 = require("./internal/observable/combineLatest");
exports.combineLatest = combineLatest_1.combineLatest;
var concat_1 = require("./internal/observable/concat");
exports.concat = concat_1.concat;
var defer_1 = require("./internal/observable/defer");
exports.defer = defer_1.defer;
var empty_1 = require("./internal/observable/empty");
exports.empty = empty_1.empty;
var forkJoin_1 = require("./internal/observable/forkJoin");
exports.forkJoin = forkJoin_1.forkJoin;
var from_1 = require("./internal/observable/from");
exports.from = from_1.from;
var fromEvent_1 = require("./internal/observable/fromEvent");
exports.fromEvent = fromEvent_1.fromEvent;
var fromEventPattern_1 = require("./internal/observable/fromEventPattern");
exports.fromEventPattern = fromEventPattern_1.fromEventPattern;
var generate_1 = require("./internal/observable/generate");
exports.generate = generate_1.generate;
var iif_1 = require("./internal/observable/iif");
exports.iif = iif_1.iif;
var interval_1 = require("./internal/observable/interval");
exports.interval = interval_1.interval;
var merge_1 = require("./internal/observable/merge");
exports.merge = merge_1.merge;
var never_1 = require("./internal/observable/never");
exports.never = never_1.never;
var of_1 = require("./internal/observable/of");
exports.of = of_1.of;
var onErrorResumeNext_1 = require("./internal/observable/onErrorResumeNext");
exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
var pairs_1 = require("./internal/observable/pairs");
exports.pairs = pairs_1.pairs;
var partition_1 = require("./internal/observable/partition");
exports.partition = partition_1.partition;
var race_1 = require("./internal/observable/race");
exports.race = race_1.race;
var range_1 = require("./internal/observable/range");
exports.range = range_1.range;
var throwError_1 = require("./internal/observable/throwError");
exports.throwError = throwError_1.throwError;
var timer_1 = require("./internal/observable/timer");
exports.timer = timer_1.timer;
var using_1 = require("./internal/observable/using");
exports.using = using_1.using;
var zip_1 = require("./internal/observable/zip");
exports.zip = zip_1.zip;
var scheduled_1 = require("./internal/scheduled/scheduled");
exports.scheduled = scheduled_1.scheduled;
var empty_2 = require("./internal/observable/empty");
exports.EMPTY = empty_2.EMPTY;
var never_2 = require("./internal/observable/never");
exports.NEVER = never_2.NEVER;
var config_1 = require("./internal/config");
exports.config = config_1.config;

},{"./internal/AsyncSubject":352,"./internal/BehaviorSubject":353,"./internal/Notification":355,"./internal/Observable":356,"./internal/ReplaySubject":359,"./internal/Scheduler":360,"./internal/Subject":361,"./internal/Subscriber":363,"./internal/Subscription":364,"./internal/config":365,"./internal/observable/ConnectableObservable":366,"./internal/observable/bindCallback":368,"./internal/observable/bindNodeCallback":369,"./internal/observable/combineLatest":370,"./internal/observable/concat":371,"./internal/observable/defer":372,"./internal/observable/empty":373,"./internal/observable/forkJoin":374,"./internal/observable/from":375,"./internal/observable/fromEvent":377,"./internal/observable/fromEventPattern":378,"./internal/observable/generate":379,"./internal/observable/iif":380,"./internal/observable/interval":381,"./internal/observable/merge":382,"./internal/observable/never":383,"./internal/observable/of":384,"./internal/observable/onErrorResumeNext":385,"./internal/observable/pairs":386,"./internal/observable/partition":387,"./internal/observable/race":388,"./internal/observable/range":389,"./internal/observable/throwError":390,"./internal/observable/timer":391,"./internal/observable/using":392,"./internal/observable/zip":393,"./internal/operators/groupBy":429,"./internal/scheduled/scheduled":501,"./internal/scheduler/VirtualTimeScheduler":511,"./internal/scheduler/animationFrame":512,"./internal/scheduler/asap":513,"./internal/scheduler/async":514,"./internal/scheduler/queue":515,"./internal/symbol/observable":517,"./internal/util/ArgumentOutOfRangeError":519,"./internal/util/EmptyError":520,"./internal/util/ObjectUnsubscribedError":522,"./internal/util/TimeoutError":523,"./internal/util/UnsubscriptionError":524,"./internal/util/identity":527,"./internal/util/isObservable":536,"./internal/util/noop":539,"./internal/util/pipe":541}],"/node_modules/symbol-sdk":[function(require,module,exports){
"use strict";
/*
 * Copyright 2018 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./src/infrastructure/infrastructure"));
__export(require("./src/model/model"));
__export(require("./src/service/service"));
__export(require("./src/core/utils/utility"));
__export(require("./src/core/format"));
__export(require("./src/core/crypto"));

},{"./src/core/crypto":555,"./src/core/format":565,"./src/core/utils/utility":570,"./src/infrastructure/infrastructure":591,"./src/model/model":639,"./src/service/service":768}]},{},[]);
